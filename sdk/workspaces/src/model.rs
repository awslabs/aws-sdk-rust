// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Describes a rule for an IP access control group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IpRuleItem {
    /// <p>The IP address range, in CIDR notation.</p>
    #[doc(hidden)]
    pub ip_rule: std::option::Option<std::string::String>,
    /// <p>The description.</p>
    #[doc(hidden)]
    pub rule_desc: std::option::Option<std::string::String>,
}
impl IpRuleItem {
    /// <p>The IP address range, in CIDR notation.</p>
    pub fn ip_rule(&self) -> std::option::Option<&str> {
        self.ip_rule.as_deref()
    }
    /// <p>The description.</p>
    pub fn rule_desc(&self) -> std::option::Option<&str> {
        self.rule_desc.as_deref()
    }
}
/// See [`IpRuleItem`](crate::model::IpRuleItem).
pub mod ip_rule_item {

    /// A builder for [`IpRuleItem`](crate::model::IpRuleItem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) ip_rule: std::option::Option<std::string::String>,
        pub(crate) rule_desc: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The IP address range, in CIDR notation.</p>
        pub fn ip_rule(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_rule = Some(input.into());
            self
        }
        /// <p>The IP address range, in CIDR notation.</p>
        pub fn set_ip_rule(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_rule = input;
            self
        }
        /// <p>The description.</p>
        pub fn rule_desc(mut self, input: impl Into<std::string::String>) -> Self {
            self.rule_desc = Some(input.into());
            self
        }
        /// <p>The description.</p>
        pub fn set_rule_desc(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.rule_desc = input;
            self
        }
        /// Consumes the builder and constructs a [`IpRuleItem`](crate::model::IpRuleItem).
        pub fn build(self) -> crate::model::IpRuleItem {
            crate::model::IpRuleItem {
                ip_rule: self.ip_rule,
                rule_desc: self.rule_desc,
            }
        }
    }
}
impl IpRuleItem {
    /// Creates a new builder-style object to manufacture [`IpRuleItem`](crate::model::IpRuleItem).
    pub fn builder() -> crate::model::ip_rule_item::Builder {
        crate::model::ip_rule_item::Builder::default()
    }
}

/// <p>Describes the permissions for a connection alias. Connection aliases are used for cross-Region redirection. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html"> Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionAliasPermission {
    /// <p>The identifier of the Amazon Web Services account that the connection alias is shared with.</p>
    #[doc(hidden)]
    pub shared_account_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether the specified Amazon Web Services account is allowed to associate the connection alias with a directory.</p>
    #[doc(hidden)]
    pub allow_association: std::option::Option<bool>,
}
impl ConnectionAliasPermission {
    /// <p>The identifier of the Amazon Web Services account that the connection alias is shared with.</p>
    pub fn shared_account_id(&self) -> std::option::Option<&str> {
        self.shared_account_id.as_deref()
    }
    /// <p>Indicates whether the specified Amazon Web Services account is allowed to associate the connection alias with a directory.</p>
    pub fn allow_association(&self) -> std::option::Option<bool> {
        self.allow_association
    }
}
/// See [`ConnectionAliasPermission`](crate::model::ConnectionAliasPermission).
pub mod connection_alias_permission {

    /// A builder for [`ConnectionAliasPermission`](crate::model::ConnectionAliasPermission).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) shared_account_id: std::option::Option<std::string::String>,
        pub(crate) allow_association: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Web Services account that the connection alias is shared with.</p>
        pub fn shared_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_account_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Web Services account that the connection alias is shared with.</p>
        pub fn set_shared_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.shared_account_id = input;
            self
        }
        /// <p>Indicates whether the specified Amazon Web Services account is allowed to associate the connection alias with a directory.</p>
        pub fn allow_association(mut self, input: bool) -> Self {
            self.allow_association = Some(input);
            self
        }
        /// <p>Indicates whether the specified Amazon Web Services account is allowed to associate the connection alias with a directory.</p>
        pub fn set_allow_association(mut self, input: std::option::Option<bool>) -> Self {
            self.allow_association = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionAliasPermission`](crate::model::ConnectionAliasPermission).
        pub fn build(self) -> crate::model::ConnectionAliasPermission {
            crate::model::ConnectionAliasPermission {
                shared_account_id: self.shared_account_id,
                allow_association: self.allow_association,
            }
        }
    }
}
impl ConnectionAliasPermission {
    /// Creates a new builder-style object to manufacture [`ConnectionAliasPermission`](crate::model::ConnectionAliasPermission).
    pub fn builder() -> crate::model::connection_alias_permission::Builder {
        crate::model::connection_alias_permission::Builder::default()
    }
}

/// <p>Describes a WorkSpace that could not be rebooted. (<code>RebootWorkspaces</code>), rebuilt (<code>RebuildWorkspaces</code>), restored (<code>RestoreWorkspace</code>), terminated (<code>TerminateWorkspaces</code>), started (<code>StartWorkspaces</code>), or stopped (<code>StopWorkspaces</code>).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedWorkspaceChangeRequest {
    /// <p>The identifier of the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
    /// <p>The error code that is returned if the WorkSpace cannot be rebooted.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The text of the error message that is returned if the WorkSpace cannot be rebooted.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl FailedWorkspaceChangeRequest {
    /// <p>The identifier of the WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
    /// <p>The error code that is returned if the WorkSpace cannot be rebooted.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The text of the error message that is returned if the WorkSpace cannot be rebooted.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`FailedWorkspaceChangeRequest`](crate::model::FailedWorkspaceChangeRequest).
pub mod failed_workspace_change_request {

    /// A builder for [`FailedWorkspaceChangeRequest`](crate::model::FailedWorkspaceChangeRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// <p>The error code that is returned if the WorkSpace cannot be rebooted.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code that is returned if the WorkSpace cannot be rebooted.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The text of the error message that is returned if the WorkSpace cannot be rebooted.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The text of the error message that is returned if the WorkSpace cannot be rebooted.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedWorkspaceChangeRequest`](crate::model::FailedWorkspaceChangeRequest).
        pub fn build(self) -> crate::model::FailedWorkspaceChangeRequest {
            crate::model::FailedWorkspaceChangeRequest {
                workspace_id: self.workspace_id,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl FailedWorkspaceChangeRequest {
    /// Creates a new builder-style object to manufacture [`FailedWorkspaceChangeRequest`](crate::model::FailedWorkspaceChangeRequest).
    pub fn builder() -> crate::model::failed_workspace_change_request::Builder {
        crate::model::failed_workspace_change_request::Builder::default()
    }
}

/// <p>Describes the information used to terminate a WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TerminateRequest {
    /// <p>The identifier of the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
}
impl TerminateRequest {
    /// <p>The identifier of the WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
}
/// See [`TerminateRequest`](crate::model::TerminateRequest).
pub mod terminate_request {

    /// A builder for [`TerminateRequest`](crate::model::TerminateRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`TerminateRequest`](crate::model::TerminateRequest).
        pub fn build(self) -> crate::model::TerminateRequest {
            crate::model::TerminateRequest {
                workspace_id: self.workspace_id,
            }
        }
    }
}
impl TerminateRequest {
    /// Creates a new builder-style object to manufacture [`TerminateRequest`](crate::model::TerminateRequest).
    pub fn builder() -> crate::model::terminate_request::Builder {
        crate::model::terminate_request::Builder::default()
    }
}

/// <p>Describes the information used to stop a WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StopRequest {
    /// <p>The identifier of the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
}
impl StopRequest {
    /// <p>The identifier of the WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
}
/// See [`StopRequest`](crate::model::StopRequest).
pub mod stop_request {

    /// A builder for [`StopRequest`](crate::model::StopRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StopRequest`](crate::model::StopRequest).
        pub fn build(self) -> crate::model::StopRequest {
            crate::model::StopRequest {
                workspace_id: self.workspace_id,
            }
        }
    }
}
impl StopRequest {
    /// Creates a new builder-style object to manufacture [`StopRequest`](crate::model::StopRequest).
    pub fn builder() -> crate::model::stop_request::Builder {
        crate::model::stop_request::Builder::default()
    }
}

/// <p>Information used to start a WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StartRequest {
    /// <p>The identifier of the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
}
impl StartRequest {
    /// <p>The identifier of the WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
}
/// See [`StartRequest`](crate::model::StartRequest).
pub mod start_request {

    /// A builder for [`StartRequest`](crate::model::StartRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`StartRequest`](crate::model::StartRequest).
        pub fn build(self) -> crate::model::StartRequest {
            crate::model::StartRequest {
                workspace_id: self.workspace_id,
            }
        }
    }
}
impl StartRequest {
    /// Creates a new builder-style object to manufacture [`StartRequest`](crate::model::StartRequest).
    pub fn builder() -> crate::model::start_request::Builder {
        crate::model::start_request::Builder::default()
    }
}

/// <p>Describes a tag.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Tag {
    /// <p>The key of the tag.</p>
    #[doc(hidden)]
    pub key: std::option::Option<std::string::String>,
    /// <p>The value of the tag.</p>
    #[doc(hidden)]
    pub value: std::option::Option<std::string::String>,
}
impl Tag {
    /// <p>The key of the tag.</p>
    pub fn key(&self) -> std::option::Option<&str> {
        self.key.as_deref()
    }
    /// <p>The value of the tag.</p>
    pub fn value(&self) -> std::option::Option<&str> {
        self.value.as_deref()
    }
}
/// See [`Tag`](crate::model::Tag).
pub mod tag {

    /// A builder for [`Tag`](crate::model::Tag).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) key: std::option::Option<std::string::String>,
        pub(crate) value: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The key of the tag.</p>
        pub fn key(mut self, input: impl Into<std::string::String>) -> Self {
            self.key = Some(input.into());
            self
        }
        /// <p>The key of the tag.</p>
        pub fn set_key(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.key = input;
            self
        }
        /// <p>The value of the tag.</p>
        pub fn value(mut self, input: impl Into<std::string::String>) -> Self {
            self.value = Some(input.into());
            self
        }
        /// <p>The value of the tag.</p>
        pub fn set_value(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.value = input;
            self
        }
        /// Consumes the builder and constructs a [`Tag`](crate::model::Tag).
        pub fn build(self) -> crate::model::Tag {
            crate::model::Tag {
                key: self.key,
                value: self.value,
            }
        }
    }
}
impl Tag {
    /// Creates a new builder-style object to manufacture [`Tag`](crate::model::Tag).
    pub fn builder() -> crate::model::tag::Builder {
        crate::model::tag::Builder::default()
    }
}

/// When writing a match expression against `Tenancy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let tenancy = unimplemented!();
/// match tenancy {
///     Tenancy::Dedicated => { /* ... */ },
///     Tenancy::Shared => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `tenancy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Tenancy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Tenancy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Tenancy::NewFeature` is defined.
/// Specifically, when `tenancy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Tenancy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Tenancy {
    #[allow(missing_docs)] // documentation missing in model
    Dedicated,
    #[allow(missing_docs)] // documentation missing in model
    Shared,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Tenancy {
    fn from(s: &str) -> Self {
        match s {
            "DEDICATED" => Tenancy::Dedicated,
            "SHARED" => Tenancy::Shared,
            other => Tenancy::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Tenancy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Tenancy::from(s))
    }
}
impl Tenancy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Tenancy::Dedicated => "DEDICATED",
            Tenancy::Shared => "SHARED",
            Tenancy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEDICATED", "SHARED"]
    }
}
impl AsRef<str> for Tenancy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the information used to rebuild a WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RebuildRequest {
    /// <p>The identifier of the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
}
impl RebuildRequest {
    /// <p>The identifier of the WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
}
/// See [`RebuildRequest`](crate::model::RebuildRequest).
pub mod rebuild_request {

    /// A builder for [`RebuildRequest`](crate::model::RebuildRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RebuildRequest`](crate::model::RebuildRequest).
        pub fn build(self) -> crate::model::RebuildRequest {
            crate::model::RebuildRequest {
                workspace_id: self.workspace_id,
            }
        }
    }
}
impl RebuildRequest {
    /// Creates a new builder-style object to manufacture [`RebuildRequest`](crate::model::RebuildRequest).
    pub fn builder() -> crate::model::rebuild_request::Builder {
        crate::model::rebuild_request::Builder::default()
    }
}

/// <p>Describes the information used to reboot a WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RebootRequest {
    /// <p>The identifier of the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
}
impl RebootRequest {
    /// <p>The identifier of the WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
}
/// See [`RebootRequest`](crate::model::RebootRequest).
pub mod reboot_request {

    /// A builder for [`RebootRequest`](crate::model::RebootRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`RebootRequest`](crate::model::RebootRequest).
        pub fn build(self) -> crate::model::RebootRequest {
            crate::model::RebootRequest {
                workspace_id: self.workspace_id,
            }
        }
    }
}
impl RebootRequest {
    /// Creates a new builder-style object to manufacture [`RebootRequest`](crate::model::RebootRequest).
    pub fn builder() -> crate::model::reboot_request::Builder {
        crate::model::reboot_request::Builder::default()
    }
}

/// When writing a match expression against `TargetWorkspaceState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let targetworkspacestate = unimplemented!();
/// match targetworkspacestate {
///     TargetWorkspaceState::AdminMaintenance => { /* ... */ },
///     TargetWorkspaceState::Available => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `targetworkspacestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `TargetWorkspaceState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `TargetWorkspaceState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `TargetWorkspaceState::NewFeature` is defined.
/// Specifically, when `targetworkspacestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `TargetWorkspaceState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum TargetWorkspaceState {
    #[allow(missing_docs)] // documentation missing in model
    AdminMaintenance,
    #[allow(missing_docs)] // documentation missing in model
    Available,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for TargetWorkspaceState {
    fn from(s: &str) -> Self {
        match s {
            "ADMIN_MAINTENANCE" => TargetWorkspaceState::AdminMaintenance,
            "AVAILABLE" => TargetWorkspaceState::Available,
            other => {
                TargetWorkspaceState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for TargetWorkspaceState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(TargetWorkspaceState::from(s))
    }
}
impl TargetWorkspaceState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            TargetWorkspaceState::AdminMaintenance => "ADMIN_MAINTENANCE",
            TargetWorkspaceState::Available => "AVAILABLE",
            TargetWorkspaceState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ADMIN_MAINTENANCE", "AVAILABLE"]
    }
}
impl AsRef<str> for TargetWorkspaceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceProperties {
    /// <p>The running mode. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html">Manage the WorkSpace Running Mode</a>.</p> <note>
    /// <p>The <code>MANUAL</code> value is only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use this value. For more information, see <a href="http://aws.amazon.com/workspaces/core/">Amazon WorkSpaces Core</a>.</p>
    /// </note>
    #[doc(hidden)]
    pub running_mode: std::option::Option<crate::model::RunningMode>,
    /// <p>The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.</p>
    #[doc(hidden)]
    pub running_mode_auto_stop_timeout_in_minutes: std::option::Option<i32>,
    /// <p>The size of the root volume. For important information about how to modify the size of the root and user volumes, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
    #[doc(hidden)]
    pub root_volume_size_gib: std::option::Option<i32>,
    /// <p>The size of the user storage. For important information about how to modify the size of the root and user volumes, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
    #[doc(hidden)]
    pub user_volume_size_gib: std::option::Option<i32>,
    /// <p>The compute type. For more information, see <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces Bundles</a>.</p>
    #[doc(hidden)]
    pub compute_type_name: std::option::Option<crate::model::Compute>,
    /// <p>The protocol. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-protocols.html"> Protocols for Amazon WorkSpaces</a>.</p> <note>
    /// <ul>
    /// <li> <p>Only available for WorkSpaces created with PCoIP bundles.</p> </li>
    /// <li> <p>The <code>Protocols</code> property is case sensitive. Ensure you use <code>PCOIP</code> or <code>WSP</code>.</p> </li>
    /// <li> <p>Unavailable for Windows 7 WorkSpaces and WorkSpaces using GPU-based bundles (Graphics, GraphicsPro, Graphics.g4dn, and GraphicsPro.g4dn).</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub protocols: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
}
impl WorkspaceProperties {
    /// <p>The running mode. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html">Manage the WorkSpace Running Mode</a>.</p> <note>
    /// <p>The <code>MANUAL</code> value is only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use this value. For more information, see <a href="http://aws.amazon.com/workspaces/core/">Amazon WorkSpaces Core</a>.</p>
    /// </note>
    pub fn running_mode(&self) -> std::option::Option<&crate::model::RunningMode> {
        self.running_mode.as_ref()
    }
    /// <p>The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.</p>
    pub fn running_mode_auto_stop_timeout_in_minutes(&self) -> std::option::Option<i32> {
        self.running_mode_auto_stop_timeout_in_minutes
    }
    /// <p>The size of the root volume. For important information about how to modify the size of the root and user volumes, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
    pub fn root_volume_size_gib(&self) -> std::option::Option<i32> {
        self.root_volume_size_gib
    }
    /// <p>The size of the user storage. For important information about how to modify the size of the root and user volumes, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
    pub fn user_volume_size_gib(&self) -> std::option::Option<i32> {
        self.user_volume_size_gib
    }
    /// <p>The compute type. For more information, see <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces Bundles</a>.</p>
    pub fn compute_type_name(&self) -> std::option::Option<&crate::model::Compute> {
        self.compute_type_name.as_ref()
    }
    /// <p>The protocol. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-protocols.html"> Protocols for Amazon WorkSpaces</a>.</p> <note>
    /// <ul>
    /// <li> <p>Only available for WorkSpaces created with PCoIP bundles.</p> </li>
    /// <li> <p>The <code>Protocols</code> property is case sensitive. Ensure you use <code>PCOIP</code> or <code>WSP</code>.</p> </li>
    /// <li> <p>Unavailable for Windows 7 WorkSpaces and WorkSpaces using GPU-based bundles (Graphics, GraphicsPro, Graphics.g4dn, and GraphicsPro.g4dn).</p> </li>
    /// </ul>
    /// </note>
    pub fn protocols(&self) -> std::option::Option<&[crate::model::Protocol]> {
        self.protocols.as_deref()
    }
}
/// See [`WorkspaceProperties`](crate::model::WorkspaceProperties).
pub mod workspace_properties {

    /// A builder for [`WorkspaceProperties`](crate::model::WorkspaceProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) running_mode: std::option::Option<crate::model::RunningMode>,
        pub(crate) running_mode_auto_stop_timeout_in_minutes: std::option::Option<i32>,
        pub(crate) root_volume_size_gib: std::option::Option<i32>,
        pub(crate) user_volume_size_gib: std::option::Option<i32>,
        pub(crate) compute_type_name: std::option::Option<crate::model::Compute>,
        pub(crate) protocols: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
    }
    impl Builder {
        /// <p>The running mode. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html">Manage the WorkSpace Running Mode</a>.</p> <note>
        /// <p>The <code>MANUAL</code> value is only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use this value. For more information, see <a href="http://aws.amazon.com/workspaces/core/">Amazon WorkSpaces Core</a>.</p>
        /// </note>
        pub fn running_mode(mut self, input: crate::model::RunningMode) -> Self {
            self.running_mode = Some(input);
            self
        }
        /// <p>The running mode. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/running-mode.html">Manage the WorkSpace Running Mode</a>.</p> <note>
        /// <p>The <code>MANUAL</code> value is only supported by Amazon WorkSpaces Core. Contact your account team to be allow-listed to use this value. For more information, see <a href="http://aws.amazon.com/workspaces/core/">Amazon WorkSpaces Core</a>.</p>
        /// </note>
        pub fn set_running_mode(
            mut self,
            input: std::option::Option<crate::model::RunningMode>,
        ) -> Self {
            self.running_mode = input;
            self
        }
        /// <p>The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.</p>
        pub fn running_mode_auto_stop_timeout_in_minutes(mut self, input: i32) -> Self {
            self.running_mode_auto_stop_timeout_in_minutes = Some(input);
            self
        }
        /// <p>The time after a user logs off when WorkSpaces are automatically stopped. Configured in 60-minute intervals.</p>
        pub fn set_running_mode_auto_stop_timeout_in_minutes(
            mut self,
            input: std::option::Option<i32>,
        ) -> Self {
            self.running_mode_auto_stop_timeout_in_minutes = input;
            self
        }
        /// <p>The size of the root volume. For important information about how to modify the size of the root and user volumes, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
        pub fn root_volume_size_gib(mut self, input: i32) -> Self {
            self.root_volume_size_gib = Some(input);
            self
        }
        /// <p>The size of the root volume. For important information about how to modify the size of the root and user volumes, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
        pub fn set_root_volume_size_gib(mut self, input: std::option::Option<i32>) -> Self {
            self.root_volume_size_gib = input;
            self
        }
        /// <p>The size of the user storage. For important information about how to modify the size of the root and user volumes, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
        pub fn user_volume_size_gib(mut self, input: i32) -> Self {
            self.user_volume_size_gib = Some(input);
            self
        }
        /// <p>The size of the user storage. For important information about how to modify the size of the root and user volumes, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">Modify a WorkSpace</a>.</p>
        pub fn set_user_volume_size_gib(mut self, input: std::option::Option<i32>) -> Self {
            self.user_volume_size_gib = input;
            self
        }
        /// <p>The compute type. For more information, see <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces Bundles</a>.</p>
        pub fn compute_type_name(mut self, input: crate::model::Compute) -> Self {
            self.compute_type_name = Some(input);
            self
        }
        /// <p>The compute type. For more information, see <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces Bundles</a>.</p>
        pub fn set_compute_type_name(
            mut self,
            input: std::option::Option<crate::model::Compute>,
        ) -> Self {
            self.compute_type_name = input;
            self
        }
        /// Appends an item to `protocols`.
        ///
        /// To override the contents of this collection use [`set_protocols`](Self::set_protocols).
        ///
        /// <p>The protocol. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-protocols.html"> Protocols for Amazon WorkSpaces</a>.</p> <note>
        /// <ul>
        /// <li> <p>Only available for WorkSpaces created with PCoIP bundles.</p> </li>
        /// <li> <p>The <code>Protocols</code> property is case sensitive. Ensure you use <code>PCOIP</code> or <code>WSP</code>.</p> </li>
        /// <li> <p>Unavailable for Windows 7 WorkSpaces and WorkSpaces using GPU-based bundles (Graphics, GraphicsPro, Graphics.g4dn, and GraphicsPro.g4dn).</p> </li>
        /// </ul>
        /// </note>
        pub fn protocols(mut self, input: crate::model::Protocol) -> Self {
            let mut v = self.protocols.unwrap_or_default();
            v.push(input);
            self.protocols = Some(v);
            self
        }
        /// <p>The protocol. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-protocols.html"> Protocols for Amazon WorkSpaces</a>.</p> <note>
        /// <ul>
        /// <li> <p>Only available for WorkSpaces created with PCoIP bundles.</p> </li>
        /// <li> <p>The <code>Protocols</code> property is case sensitive. Ensure you use <code>PCOIP</code> or <code>WSP</code>.</p> </li>
        /// <li> <p>Unavailable for Windows 7 WorkSpaces and WorkSpaces using GPU-based bundles (Graphics, GraphicsPro, Graphics.g4dn, and GraphicsPro.g4dn).</p> </li>
        /// </ul>
        /// </note>
        pub fn set_protocols(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Protocol>>,
        ) -> Self {
            self.protocols = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspaceProperties`](crate::model::WorkspaceProperties).
        pub fn build(self) -> crate::model::WorkspaceProperties {
            crate::model::WorkspaceProperties {
                running_mode: self.running_mode,
                running_mode_auto_stop_timeout_in_minutes: self
                    .running_mode_auto_stop_timeout_in_minutes,
                root_volume_size_gib: self.root_volume_size_gib,
                user_volume_size_gib: self.user_volume_size_gib,
                compute_type_name: self.compute_type_name,
                protocols: self.protocols,
            }
        }
    }
}
impl WorkspaceProperties {
    /// Creates a new builder-style object to manufacture [`WorkspaceProperties`](crate::model::WorkspaceProperties).
    pub fn builder() -> crate::model::workspace_properties::Builder {
        crate::model::workspace_properties::Builder::default()
    }
}

/// When writing a match expression against `Protocol`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let protocol = unimplemented!();
/// match protocol {
///     Protocol::Pcoip => { /* ... */ },
///     Protocol::Wsp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `protocol` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Protocol::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Protocol::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Protocol::NewFeature` is defined.
/// Specifically, when `protocol` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Protocol::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Protocol {
    #[allow(missing_docs)] // documentation missing in model
    Pcoip,
    #[allow(missing_docs)] // documentation missing in model
    Wsp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Protocol {
    fn from(s: &str) -> Self {
        match s {
            "PCOIP" => Protocol::Pcoip,
            "WSP" => Protocol::Wsp,
            other => Protocol::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Protocol {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Protocol::from(s))
    }
}
impl Protocol {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Protocol::Pcoip => "PCOIP",
            Protocol::Wsp => "WSP",
            Protocol::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PCOIP", "WSP"]
    }
}
impl AsRef<str> for Protocol {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Compute`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let compute = unimplemented!();
/// match compute {
///     Compute::Graphics => { /* ... */ },
///     Compute::Graphicspro => { /* ... */ },
///     Compute::GraphicsproG4Dn => { /* ... */ },
///     Compute::GraphicsG4Dn => { /* ... */ },
///     Compute::Performance => { /* ... */ },
///     Compute::Power => { /* ... */ },
///     Compute::Powerpro => { /* ... */ },
///     Compute::Standard => { /* ... */ },
///     Compute::Value => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `compute` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Compute::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Compute::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Compute::NewFeature` is defined.
/// Specifically, when `compute` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Compute::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Compute {
    #[allow(missing_docs)] // documentation missing in model
    Graphics,
    #[allow(missing_docs)] // documentation missing in model
    Graphicspro,
    #[allow(missing_docs)] // documentation missing in model
    GraphicsproG4Dn,
    #[allow(missing_docs)] // documentation missing in model
    GraphicsG4Dn,
    #[allow(missing_docs)] // documentation missing in model
    Performance,
    #[allow(missing_docs)] // documentation missing in model
    Power,
    #[allow(missing_docs)] // documentation missing in model
    Powerpro,
    #[allow(missing_docs)] // documentation missing in model
    Standard,
    #[allow(missing_docs)] // documentation missing in model
    Value,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Compute {
    fn from(s: &str) -> Self {
        match s {
            "GRAPHICS" => Compute::Graphics,
            "GRAPHICSPRO" => Compute::Graphicspro,
            "GRAPHICSPRO_G4DN" => Compute::GraphicsproG4Dn,
            "GRAPHICS_G4DN" => Compute::GraphicsG4Dn,
            "PERFORMANCE" => Compute::Performance,
            "POWER" => Compute::Power,
            "POWERPRO" => Compute::Powerpro,
            "STANDARD" => Compute::Standard,
            "VALUE" => Compute::Value,
            other => Compute::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Compute {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Compute::from(s))
    }
}
impl Compute {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Compute::Graphics => "GRAPHICS",
            Compute::Graphicspro => "GRAPHICSPRO",
            Compute::GraphicsproG4Dn => "GRAPHICSPRO_G4DN",
            Compute::GraphicsG4Dn => "GRAPHICS_G4DN",
            Compute::Performance => "PERFORMANCE",
            Compute::Power => "POWER",
            Compute::Powerpro => "POWERPRO",
            Compute::Standard => "STANDARD",
            Compute::Value => "VALUE",
            Compute::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "GRAPHICS",
            "GRAPHICSPRO",
            "GRAPHICSPRO_G4DN",
            "GRAPHICS_G4DN",
            "PERFORMANCE",
            "POWER",
            "POWERPRO",
            "STANDARD",
            "VALUE",
        ]
    }
}
impl AsRef<str> for Compute {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `RunningMode`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let runningmode = unimplemented!();
/// match runningmode {
///     RunningMode::AlwaysOn => { /* ... */ },
///     RunningMode::AutoStop => { /* ... */ },
///     RunningMode::Manual => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `runningmode` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `RunningMode::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `RunningMode::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `RunningMode::NewFeature` is defined.
/// Specifically, when `runningmode` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `RunningMode::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum RunningMode {
    #[allow(missing_docs)] // documentation missing in model
    AlwaysOn,
    #[allow(missing_docs)] // documentation missing in model
    AutoStop,
    #[allow(missing_docs)] // documentation missing in model
    Manual,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for RunningMode {
    fn from(s: &str) -> Self {
        match s {
            "ALWAYS_ON" => RunningMode::AlwaysOn,
            "AUTO_STOP" => RunningMode::AutoStop,
            "MANUAL" => RunningMode::Manual,
            other => RunningMode::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for RunningMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(RunningMode::from(s))
    }
}
impl RunningMode {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            RunningMode::AlwaysOn => "ALWAYS_ON",
            RunningMode::AutoStop => "AUTO_STOP",
            RunningMode::Manual => "MANUAL",
            RunningMode::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALWAYS_ON", "AUTO_STOP", "MANUAL"]
    }
}
impl AsRef<str> for RunningMode {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the default properties that are used for creating WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html">Update Directory Details for Your WorkSpaces</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceCreationProperties {
    /// <p>Indicates whether Amazon WorkDocs is enabled for your WorkSpaces.</p> <note>
    /// <p>If WorkDocs is already enabled for a WorkSpaces directory and you disable it, new WorkSpaces launched in the directory will not have WorkDocs enabled. However, WorkDocs remains enabled for any existing WorkSpaces, unless you either disable users' access to WorkDocs or you delete the WorkDocs site. To disable users' access to WorkDocs, see <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/inactive-user.html">Disabling Users</a> in the <i>Amazon WorkDocs Administration Guide</i>. To delete a WorkDocs site, see <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/manage-sites.html">Deleting a Site</a> in the <i>Amazon WorkDocs Administration Guide</i>.</p>
    /// <p>If you enable WorkDocs on a directory that already has existing WorkSpaces, the existing WorkSpaces and any new WorkSpaces that are launched in the directory will have WorkDocs enabled.</p>
    /// </note>
    #[doc(hidden)]
    pub enable_work_docs: std::option::Option<bool>,
    /// <p>Indicates whether internet access is enabled for your WorkSpaces.</p>
    #[doc(hidden)]
    pub enable_internet_access: std::option::Option<bool>,
    /// <p>The default organizational unit (OU) for your WorkSpaces directories. This string must be the full Lightweight Directory Access Protocol (LDAP) distinguished name for the target domain and OU. It must be in the form <code>"OU=<i>value</i>,DC=<i>value</i>,DC=<i>value</i>"</code>, where <i>value</i> is any string of characters, and the number of domain components (DCs) is two or more. For example, <code>OU=WorkSpaces_machines,DC=machines,DC=example,DC=com</code>. </p> <important>
    /// <ul>
    /// <li> <p>To avoid errors, certain characters in the distinguished name must be escaped. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/ldap/distinguished-names"> Distinguished Names</a> in the Microsoft documentation.</p> </li>
    /// <li> <p>The API doesn't validate whether the OU exists.</p> </li>
    /// </ul>
    /// </important>
    #[doc(hidden)]
    pub default_ou: std::option::Option<std::string::String>,
    /// <p>The identifier of your custom security group.</p>
    #[doc(hidden)]
    pub custom_security_group_id: std::option::Option<std::string::String>,
    /// <p>Indicates whether users are local administrators of their WorkSpaces.</p>
    #[doc(hidden)]
    pub user_enabled_as_local_administrator: std::option::Option<bool>,
    /// <p>Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace Maintenance</a>. </p>
    #[doc(hidden)]
    pub enable_maintenance_mode: std::option::Option<bool>,
}
impl WorkspaceCreationProperties {
    /// <p>Indicates whether Amazon WorkDocs is enabled for your WorkSpaces.</p> <note>
    /// <p>If WorkDocs is already enabled for a WorkSpaces directory and you disable it, new WorkSpaces launched in the directory will not have WorkDocs enabled. However, WorkDocs remains enabled for any existing WorkSpaces, unless you either disable users' access to WorkDocs or you delete the WorkDocs site. To disable users' access to WorkDocs, see <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/inactive-user.html">Disabling Users</a> in the <i>Amazon WorkDocs Administration Guide</i>. To delete a WorkDocs site, see <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/manage-sites.html">Deleting a Site</a> in the <i>Amazon WorkDocs Administration Guide</i>.</p>
    /// <p>If you enable WorkDocs on a directory that already has existing WorkSpaces, the existing WorkSpaces and any new WorkSpaces that are launched in the directory will have WorkDocs enabled.</p>
    /// </note>
    pub fn enable_work_docs(&self) -> std::option::Option<bool> {
        self.enable_work_docs
    }
    /// <p>Indicates whether internet access is enabled for your WorkSpaces.</p>
    pub fn enable_internet_access(&self) -> std::option::Option<bool> {
        self.enable_internet_access
    }
    /// <p>The default organizational unit (OU) for your WorkSpaces directories. This string must be the full Lightweight Directory Access Protocol (LDAP) distinguished name for the target domain and OU. It must be in the form <code>"OU=<i>value</i>,DC=<i>value</i>,DC=<i>value</i>"</code>, where <i>value</i> is any string of characters, and the number of domain components (DCs) is two or more. For example, <code>OU=WorkSpaces_machines,DC=machines,DC=example,DC=com</code>. </p> <important>
    /// <ul>
    /// <li> <p>To avoid errors, certain characters in the distinguished name must be escaped. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/ldap/distinguished-names"> Distinguished Names</a> in the Microsoft documentation.</p> </li>
    /// <li> <p>The API doesn't validate whether the OU exists.</p> </li>
    /// </ul>
    /// </important>
    pub fn default_ou(&self) -> std::option::Option<&str> {
        self.default_ou.as_deref()
    }
    /// <p>The identifier of your custom security group.</p>
    pub fn custom_security_group_id(&self) -> std::option::Option<&str> {
        self.custom_security_group_id.as_deref()
    }
    /// <p>Indicates whether users are local administrators of their WorkSpaces.</p>
    pub fn user_enabled_as_local_administrator(&self) -> std::option::Option<bool> {
        self.user_enabled_as_local_administrator
    }
    /// <p>Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace Maintenance</a>. </p>
    pub fn enable_maintenance_mode(&self) -> std::option::Option<bool> {
        self.enable_maintenance_mode
    }
}
/// See [`WorkspaceCreationProperties`](crate::model::WorkspaceCreationProperties).
pub mod workspace_creation_properties {

    /// A builder for [`WorkspaceCreationProperties`](crate::model::WorkspaceCreationProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_work_docs: std::option::Option<bool>,
        pub(crate) enable_internet_access: std::option::Option<bool>,
        pub(crate) default_ou: std::option::Option<std::string::String>,
        pub(crate) custom_security_group_id: std::option::Option<std::string::String>,
        pub(crate) user_enabled_as_local_administrator: std::option::Option<bool>,
        pub(crate) enable_maintenance_mode: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Indicates whether Amazon WorkDocs is enabled for your WorkSpaces.</p> <note>
        /// <p>If WorkDocs is already enabled for a WorkSpaces directory and you disable it, new WorkSpaces launched in the directory will not have WorkDocs enabled. However, WorkDocs remains enabled for any existing WorkSpaces, unless you either disable users' access to WorkDocs or you delete the WorkDocs site. To disable users' access to WorkDocs, see <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/inactive-user.html">Disabling Users</a> in the <i>Amazon WorkDocs Administration Guide</i>. To delete a WorkDocs site, see <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/manage-sites.html">Deleting a Site</a> in the <i>Amazon WorkDocs Administration Guide</i>.</p>
        /// <p>If you enable WorkDocs on a directory that already has existing WorkSpaces, the existing WorkSpaces and any new WorkSpaces that are launched in the directory will have WorkDocs enabled.</p>
        /// </note>
        pub fn enable_work_docs(mut self, input: bool) -> Self {
            self.enable_work_docs = Some(input);
            self
        }
        /// <p>Indicates whether Amazon WorkDocs is enabled for your WorkSpaces.</p> <note>
        /// <p>If WorkDocs is already enabled for a WorkSpaces directory and you disable it, new WorkSpaces launched in the directory will not have WorkDocs enabled. However, WorkDocs remains enabled for any existing WorkSpaces, unless you either disable users' access to WorkDocs or you delete the WorkDocs site. To disable users' access to WorkDocs, see <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/inactive-user.html">Disabling Users</a> in the <i>Amazon WorkDocs Administration Guide</i>. To delete a WorkDocs site, see <a href="https://docs.aws.amazon.com/workdocs/latest/adminguide/manage-sites.html">Deleting a Site</a> in the <i>Amazon WorkDocs Administration Guide</i>.</p>
        /// <p>If you enable WorkDocs on a directory that already has existing WorkSpaces, the existing WorkSpaces and any new WorkSpaces that are launched in the directory will have WorkDocs enabled.</p>
        /// </note>
        pub fn set_enable_work_docs(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_work_docs = input;
            self
        }
        /// <p>Indicates whether internet access is enabled for your WorkSpaces.</p>
        pub fn enable_internet_access(mut self, input: bool) -> Self {
            self.enable_internet_access = Some(input);
            self
        }
        /// <p>Indicates whether internet access is enabled for your WorkSpaces.</p>
        pub fn set_enable_internet_access(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_internet_access = input;
            self
        }
        /// <p>The default organizational unit (OU) for your WorkSpaces directories. This string must be the full Lightweight Directory Access Protocol (LDAP) distinguished name for the target domain and OU. It must be in the form <code>"OU=<i>value</i>,DC=<i>value</i>,DC=<i>value</i>"</code>, where <i>value</i> is any string of characters, and the number of domain components (DCs) is two or more. For example, <code>OU=WorkSpaces_machines,DC=machines,DC=example,DC=com</code>. </p> <important>
        /// <ul>
        /// <li> <p>To avoid errors, certain characters in the distinguished name must be escaped. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/ldap/distinguished-names"> Distinguished Names</a> in the Microsoft documentation.</p> </li>
        /// <li> <p>The API doesn't validate whether the OU exists.</p> </li>
        /// </ul>
        /// </important>
        pub fn default_ou(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_ou = Some(input.into());
            self
        }
        /// <p>The default organizational unit (OU) for your WorkSpaces directories. This string must be the full Lightweight Directory Access Protocol (LDAP) distinguished name for the target domain and OU. It must be in the form <code>"OU=<i>value</i>,DC=<i>value</i>,DC=<i>value</i>"</code>, where <i>value</i> is any string of characters, and the number of domain components (DCs) is two or more. For example, <code>OU=WorkSpaces_machines,DC=machines,DC=example,DC=com</code>. </p> <important>
        /// <ul>
        /// <li> <p>To avoid errors, certain characters in the distinguished name must be escaped. For more information, see <a href="https://docs.microsoft.com/previous-versions/windows/desktop/ldap/distinguished-names"> Distinguished Names</a> in the Microsoft documentation.</p> </li>
        /// <li> <p>The API doesn't validate whether the OU exists.</p> </li>
        /// </ul>
        /// </important>
        pub fn set_default_ou(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.default_ou = input;
            self
        }
        /// <p>The identifier of your custom security group.</p>
        pub fn custom_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_security_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of your custom security group.</p>
        pub fn set_custom_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_security_group_id = input;
            self
        }
        /// <p>Indicates whether users are local administrators of their WorkSpaces.</p>
        pub fn user_enabled_as_local_administrator(mut self, input: bool) -> Self {
            self.user_enabled_as_local_administrator = Some(input);
            self
        }
        /// <p>Indicates whether users are local administrators of their WorkSpaces.</p>
        pub fn set_user_enabled_as_local_administrator(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.user_enabled_as_local_administrator = input;
            self
        }
        /// <p>Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace Maintenance</a>. </p>
        pub fn enable_maintenance_mode(mut self, input: bool) -> Self {
            self.enable_maintenance_mode = Some(input);
            self
        }
        /// <p>Indicates whether maintenance mode is enabled for your WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace Maintenance</a>. </p>
        pub fn set_enable_maintenance_mode(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_maintenance_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspaceCreationProperties`](crate::model::WorkspaceCreationProperties).
        pub fn build(self) -> crate::model::WorkspaceCreationProperties {
            crate::model::WorkspaceCreationProperties {
                enable_work_docs: self.enable_work_docs,
                enable_internet_access: self.enable_internet_access,
                default_ou: self.default_ou,
                custom_security_group_id: self.custom_security_group_id,
                user_enabled_as_local_administrator: self.user_enabled_as_local_administrator,
                enable_maintenance_mode: self.enable_maintenance_mode,
            }
        }
    }
}
impl WorkspaceCreationProperties {
    /// Creates a new builder-style object to manufacture [`WorkspaceCreationProperties`](crate::model::WorkspaceCreationProperties).
    pub fn builder() -> crate::model::workspace_creation_properties::Builder {
        crate::model::workspace_creation_properties::Builder::default()
    }
}

/// <p>The device types and operating systems that can be used to access a WorkSpace. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-network-requirements.html">Amazon WorkSpaces Client Network Requirements</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceAccessProperties {
    /// <p>Indicates whether users can use Windows clients to access their WorkSpaces.</p>
    #[doc(hidden)]
    pub device_type_windows: std::option::Option<crate::model::AccessPropertyValue>,
    /// <p>Indicates whether users can use macOS clients to access their WorkSpaces.</p>
    #[doc(hidden)]
    pub device_type_osx: std::option::Option<crate::model::AccessPropertyValue>,
    /// <p>Indicates whether users can access their WorkSpaces through a web browser.</p>
    #[doc(hidden)]
    pub device_type_web: std::option::Option<crate::model::AccessPropertyValue>,
    /// <p>Indicates whether users can use iOS devices to access their WorkSpaces.</p>
    #[doc(hidden)]
    pub device_type_ios: std::option::Option<crate::model::AccessPropertyValue>,
    /// <p>Indicates whether users can use Android and Android-compatible Chrome OS devices to access their WorkSpaces.</p>
    #[doc(hidden)]
    pub device_type_android: std::option::Option<crate::model::AccessPropertyValue>,
    /// <p>Indicates whether users can use Chromebooks to access their WorkSpaces.</p>
    #[doc(hidden)]
    pub device_type_chrome_os: std::option::Option<crate::model::AccessPropertyValue>,
    /// <p>Indicates whether users can use zero client devices to access their WorkSpaces.</p>
    #[doc(hidden)]
    pub device_type_zero_client: std::option::Option<crate::model::AccessPropertyValue>,
    /// <p>Indicates whether users can use Linux clients to access their WorkSpaces.</p>
    #[doc(hidden)]
    pub device_type_linux: std::option::Option<crate::model::AccessPropertyValue>,
}
impl WorkspaceAccessProperties {
    /// <p>Indicates whether users can use Windows clients to access their WorkSpaces.</p>
    pub fn device_type_windows(&self) -> std::option::Option<&crate::model::AccessPropertyValue> {
        self.device_type_windows.as_ref()
    }
    /// <p>Indicates whether users can use macOS clients to access their WorkSpaces.</p>
    pub fn device_type_osx(&self) -> std::option::Option<&crate::model::AccessPropertyValue> {
        self.device_type_osx.as_ref()
    }
    /// <p>Indicates whether users can access their WorkSpaces through a web browser.</p>
    pub fn device_type_web(&self) -> std::option::Option<&crate::model::AccessPropertyValue> {
        self.device_type_web.as_ref()
    }
    /// <p>Indicates whether users can use iOS devices to access their WorkSpaces.</p>
    pub fn device_type_ios(&self) -> std::option::Option<&crate::model::AccessPropertyValue> {
        self.device_type_ios.as_ref()
    }
    /// <p>Indicates whether users can use Android and Android-compatible Chrome OS devices to access their WorkSpaces.</p>
    pub fn device_type_android(&self) -> std::option::Option<&crate::model::AccessPropertyValue> {
        self.device_type_android.as_ref()
    }
    /// <p>Indicates whether users can use Chromebooks to access their WorkSpaces.</p>
    pub fn device_type_chrome_os(&self) -> std::option::Option<&crate::model::AccessPropertyValue> {
        self.device_type_chrome_os.as_ref()
    }
    /// <p>Indicates whether users can use zero client devices to access their WorkSpaces.</p>
    pub fn device_type_zero_client(
        &self,
    ) -> std::option::Option<&crate::model::AccessPropertyValue> {
        self.device_type_zero_client.as_ref()
    }
    /// <p>Indicates whether users can use Linux clients to access their WorkSpaces.</p>
    pub fn device_type_linux(&self) -> std::option::Option<&crate::model::AccessPropertyValue> {
        self.device_type_linux.as_ref()
    }
}
/// See [`WorkspaceAccessProperties`](crate::model::WorkspaceAccessProperties).
pub mod workspace_access_properties {

    /// A builder for [`WorkspaceAccessProperties`](crate::model::WorkspaceAccessProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) device_type_windows: std::option::Option<crate::model::AccessPropertyValue>,
        pub(crate) device_type_osx: std::option::Option<crate::model::AccessPropertyValue>,
        pub(crate) device_type_web: std::option::Option<crate::model::AccessPropertyValue>,
        pub(crate) device_type_ios: std::option::Option<crate::model::AccessPropertyValue>,
        pub(crate) device_type_android: std::option::Option<crate::model::AccessPropertyValue>,
        pub(crate) device_type_chrome_os: std::option::Option<crate::model::AccessPropertyValue>,
        pub(crate) device_type_zero_client: std::option::Option<crate::model::AccessPropertyValue>,
        pub(crate) device_type_linux: std::option::Option<crate::model::AccessPropertyValue>,
    }
    impl Builder {
        /// <p>Indicates whether users can use Windows clients to access their WorkSpaces.</p>
        pub fn device_type_windows(mut self, input: crate::model::AccessPropertyValue) -> Self {
            self.device_type_windows = Some(input);
            self
        }
        /// <p>Indicates whether users can use Windows clients to access their WorkSpaces.</p>
        pub fn set_device_type_windows(
            mut self,
            input: std::option::Option<crate::model::AccessPropertyValue>,
        ) -> Self {
            self.device_type_windows = input;
            self
        }
        /// <p>Indicates whether users can use macOS clients to access their WorkSpaces.</p>
        pub fn device_type_osx(mut self, input: crate::model::AccessPropertyValue) -> Self {
            self.device_type_osx = Some(input);
            self
        }
        /// <p>Indicates whether users can use macOS clients to access their WorkSpaces.</p>
        pub fn set_device_type_osx(
            mut self,
            input: std::option::Option<crate::model::AccessPropertyValue>,
        ) -> Self {
            self.device_type_osx = input;
            self
        }
        /// <p>Indicates whether users can access their WorkSpaces through a web browser.</p>
        pub fn device_type_web(mut self, input: crate::model::AccessPropertyValue) -> Self {
            self.device_type_web = Some(input);
            self
        }
        /// <p>Indicates whether users can access their WorkSpaces through a web browser.</p>
        pub fn set_device_type_web(
            mut self,
            input: std::option::Option<crate::model::AccessPropertyValue>,
        ) -> Self {
            self.device_type_web = input;
            self
        }
        /// <p>Indicates whether users can use iOS devices to access their WorkSpaces.</p>
        pub fn device_type_ios(mut self, input: crate::model::AccessPropertyValue) -> Self {
            self.device_type_ios = Some(input);
            self
        }
        /// <p>Indicates whether users can use iOS devices to access their WorkSpaces.</p>
        pub fn set_device_type_ios(
            mut self,
            input: std::option::Option<crate::model::AccessPropertyValue>,
        ) -> Self {
            self.device_type_ios = input;
            self
        }
        /// <p>Indicates whether users can use Android and Android-compatible Chrome OS devices to access their WorkSpaces.</p>
        pub fn device_type_android(mut self, input: crate::model::AccessPropertyValue) -> Self {
            self.device_type_android = Some(input);
            self
        }
        /// <p>Indicates whether users can use Android and Android-compatible Chrome OS devices to access their WorkSpaces.</p>
        pub fn set_device_type_android(
            mut self,
            input: std::option::Option<crate::model::AccessPropertyValue>,
        ) -> Self {
            self.device_type_android = input;
            self
        }
        /// <p>Indicates whether users can use Chromebooks to access their WorkSpaces.</p>
        pub fn device_type_chrome_os(mut self, input: crate::model::AccessPropertyValue) -> Self {
            self.device_type_chrome_os = Some(input);
            self
        }
        /// <p>Indicates whether users can use Chromebooks to access their WorkSpaces.</p>
        pub fn set_device_type_chrome_os(
            mut self,
            input: std::option::Option<crate::model::AccessPropertyValue>,
        ) -> Self {
            self.device_type_chrome_os = input;
            self
        }
        /// <p>Indicates whether users can use zero client devices to access their WorkSpaces.</p>
        pub fn device_type_zero_client(mut self, input: crate::model::AccessPropertyValue) -> Self {
            self.device_type_zero_client = Some(input);
            self
        }
        /// <p>Indicates whether users can use zero client devices to access their WorkSpaces.</p>
        pub fn set_device_type_zero_client(
            mut self,
            input: std::option::Option<crate::model::AccessPropertyValue>,
        ) -> Self {
            self.device_type_zero_client = input;
            self
        }
        /// <p>Indicates whether users can use Linux clients to access their WorkSpaces.</p>
        pub fn device_type_linux(mut self, input: crate::model::AccessPropertyValue) -> Self {
            self.device_type_linux = Some(input);
            self
        }
        /// <p>Indicates whether users can use Linux clients to access their WorkSpaces.</p>
        pub fn set_device_type_linux(
            mut self,
            input: std::option::Option<crate::model::AccessPropertyValue>,
        ) -> Self {
            self.device_type_linux = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspaceAccessProperties`](crate::model::WorkspaceAccessProperties).
        pub fn build(self) -> crate::model::WorkspaceAccessProperties {
            crate::model::WorkspaceAccessProperties {
                device_type_windows: self.device_type_windows,
                device_type_osx: self.device_type_osx,
                device_type_web: self.device_type_web,
                device_type_ios: self.device_type_ios,
                device_type_android: self.device_type_android,
                device_type_chrome_os: self.device_type_chrome_os,
                device_type_zero_client: self.device_type_zero_client,
                device_type_linux: self.device_type_linux,
            }
        }
    }
}
impl WorkspaceAccessProperties {
    /// Creates a new builder-style object to manufacture [`WorkspaceAccessProperties`](crate::model::WorkspaceAccessProperties).
    pub fn builder() -> crate::model::workspace_access_properties::Builder {
        crate::model::workspace_access_properties::Builder::default()
    }
}

/// When writing a match expression against `AccessPropertyValue`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let accesspropertyvalue = unimplemented!();
/// match accesspropertyvalue {
///     AccessPropertyValue::Allow => { /* ... */ },
///     AccessPropertyValue::Deny => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `accesspropertyvalue` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AccessPropertyValue::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AccessPropertyValue::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AccessPropertyValue::NewFeature` is defined.
/// Specifically, when `accesspropertyvalue` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AccessPropertyValue::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AccessPropertyValue {
    #[allow(missing_docs)] // documentation missing in model
    Allow,
    #[allow(missing_docs)] // documentation missing in model
    Deny,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AccessPropertyValue {
    fn from(s: &str) -> Self {
        match s {
            "ALLOW" => AccessPropertyValue::Allow,
            "DENY" => AccessPropertyValue::Deny,
            other => {
                AccessPropertyValue::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AccessPropertyValue {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AccessPropertyValue::from(s))
    }
}
impl AccessPropertyValue {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AccessPropertyValue::Allow => "ALLOW",
            AccessPropertyValue::Deny => "DENY",
            AccessPropertyValue::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ALLOW", "DENY"]
    }
}
impl AsRef<str> for AccessPropertyValue {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the self-service permissions for a directory. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/enable-user-self-service-workspace-management.html">Enable Self-Service WorkSpace Management Capabilities for Your Users</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SelfservicePermissions {
    /// <p>Specifies whether users can restart their WorkSpace.</p>
    #[doc(hidden)]
    pub restart_workspace: std::option::Option<crate::model::ReconnectEnum>,
    /// <p>Specifies whether users can increase the volume size of the drives on their WorkSpace.</p>
    #[doc(hidden)]
    pub increase_volume_size: std::option::Option<crate::model::ReconnectEnum>,
    /// <p>Specifies whether users can change the compute type (bundle) for their WorkSpace.</p>
    #[doc(hidden)]
    pub change_compute_type: std::option::Option<crate::model::ReconnectEnum>,
    /// <p>Specifies whether users can switch the running mode of their WorkSpace.</p>
    #[doc(hidden)]
    pub switch_running_mode: std::option::Option<crate::model::ReconnectEnum>,
    /// <p>Specifies whether users can rebuild the operating system of a WorkSpace to its original state.</p>
    #[doc(hidden)]
    pub rebuild_workspace: std::option::Option<crate::model::ReconnectEnum>,
}
impl SelfservicePermissions {
    /// <p>Specifies whether users can restart their WorkSpace.</p>
    pub fn restart_workspace(&self) -> std::option::Option<&crate::model::ReconnectEnum> {
        self.restart_workspace.as_ref()
    }
    /// <p>Specifies whether users can increase the volume size of the drives on their WorkSpace.</p>
    pub fn increase_volume_size(&self) -> std::option::Option<&crate::model::ReconnectEnum> {
        self.increase_volume_size.as_ref()
    }
    /// <p>Specifies whether users can change the compute type (bundle) for their WorkSpace.</p>
    pub fn change_compute_type(&self) -> std::option::Option<&crate::model::ReconnectEnum> {
        self.change_compute_type.as_ref()
    }
    /// <p>Specifies whether users can switch the running mode of their WorkSpace.</p>
    pub fn switch_running_mode(&self) -> std::option::Option<&crate::model::ReconnectEnum> {
        self.switch_running_mode.as_ref()
    }
    /// <p>Specifies whether users can rebuild the operating system of a WorkSpace to its original state.</p>
    pub fn rebuild_workspace(&self) -> std::option::Option<&crate::model::ReconnectEnum> {
        self.rebuild_workspace.as_ref()
    }
}
/// See [`SelfservicePermissions`](crate::model::SelfservicePermissions).
pub mod selfservice_permissions {

    /// A builder for [`SelfservicePermissions`](crate::model::SelfservicePermissions).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) restart_workspace: std::option::Option<crate::model::ReconnectEnum>,
        pub(crate) increase_volume_size: std::option::Option<crate::model::ReconnectEnum>,
        pub(crate) change_compute_type: std::option::Option<crate::model::ReconnectEnum>,
        pub(crate) switch_running_mode: std::option::Option<crate::model::ReconnectEnum>,
        pub(crate) rebuild_workspace: std::option::Option<crate::model::ReconnectEnum>,
    }
    impl Builder {
        /// <p>Specifies whether users can restart their WorkSpace.</p>
        pub fn restart_workspace(mut self, input: crate::model::ReconnectEnum) -> Self {
            self.restart_workspace = Some(input);
            self
        }
        /// <p>Specifies whether users can restart their WorkSpace.</p>
        pub fn set_restart_workspace(
            mut self,
            input: std::option::Option<crate::model::ReconnectEnum>,
        ) -> Self {
            self.restart_workspace = input;
            self
        }
        /// <p>Specifies whether users can increase the volume size of the drives on their WorkSpace.</p>
        pub fn increase_volume_size(mut self, input: crate::model::ReconnectEnum) -> Self {
            self.increase_volume_size = Some(input);
            self
        }
        /// <p>Specifies whether users can increase the volume size of the drives on their WorkSpace.</p>
        pub fn set_increase_volume_size(
            mut self,
            input: std::option::Option<crate::model::ReconnectEnum>,
        ) -> Self {
            self.increase_volume_size = input;
            self
        }
        /// <p>Specifies whether users can change the compute type (bundle) for their WorkSpace.</p>
        pub fn change_compute_type(mut self, input: crate::model::ReconnectEnum) -> Self {
            self.change_compute_type = Some(input);
            self
        }
        /// <p>Specifies whether users can change the compute type (bundle) for their WorkSpace.</p>
        pub fn set_change_compute_type(
            mut self,
            input: std::option::Option<crate::model::ReconnectEnum>,
        ) -> Self {
            self.change_compute_type = input;
            self
        }
        /// <p>Specifies whether users can switch the running mode of their WorkSpace.</p>
        pub fn switch_running_mode(mut self, input: crate::model::ReconnectEnum) -> Self {
            self.switch_running_mode = Some(input);
            self
        }
        /// <p>Specifies whether users can switch the running mode of their WorkSpace.</p>
        pub fn set_switch_running_mode(
            mut self,
            input: std::option::Option<crate::model::ReconnectEnum>,
        ) -> Self {
            self.switch_running_mode = input;
            self
        }
        /// <p>Specifies whether users can rebuild the operating system of a WorkSpace to its original state.</p>
        pub fn rebuild_workspace(mut self, input: crate::model::ReconnectEnum) -> Self {
            self.rebuild_workspace = Some(input);
            self
        }
        /// <p>Specifies whether users can rebuild the operating system of a WorkSpace to its original state.</p>
        pub fn set_rebuild_workspace(
            mut self,
            input: std::option::Option<crate::model::ReconnectEnum>,
        ) -> Self {
            self.rebuild_workspace = input;
            self
        }
        /// Consumes the builder and constructs a [`SelfservicePermissions`](crate::model::SelfservicePermissions).
        pub fn build(self) -> crate::model::SelfservicePermissions {
            crate::model::SelfservicePermissions {
                restart_workspace: self.restart_workspace,
                increase_volume_size: self.increase_volume_size,
                change_compute_type: self.change_compute_type,
                switch_running_mode: self.switch_running_mode,
                rebuild_workspace: self.rebuild_workspace,
            }
        }
    }
}
impl SelfservicePermissions {
    /// Creates a new builder-style object to manufacture [`SelfservicePermissions`](crate::model::SelfservicePermissions).
    pub fn builder() -> crate::model::selfservice_permissions::Builder {
        crate::model::selfservice_permissions::Builder::default()
    }
}

/// When writing a match expression against `ReconnectEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let reconnectenum = unimplemented!();
/// match reconnectenum {
///     ReconnectEnum::Disabled => { /* ... */ },
///     ReconnectEnum::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `reconnectenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ReconnectEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ReconnectEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ReconnectEnum::NewFeature` is defined.
/// Specifically, when `reconnectenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ReconnectEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ReconnectEnum {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ReconnectEnum {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => ReconnectEnum::Disabled,
            "ENABLED" => ReconnectEnum::Enabled,
            other => ReconnectEnum::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ReconnectEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ReconnectEnum::from(s))
    }
}
impl ReconnectEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ReconnectEnum::Disabled => "DISABLED",
            ReconnectEnum::Enabled => "ENABLED",
            ReconnectEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for ReconnectEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DeletableSamlProperty`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deletablesamlproperty = unimplemented!();
/// match deletablesamlproperty {
///     DeletableSamlProperty::SamlPropertiesRelayStateParameterName => { /* ... */ },
///     DeletableSamlProperty::SamlPropertiesUserAccessUrl => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deletablesamlproperty` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeletableSamlProperty::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeletableSamlProperty::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeletableSamlProperty::NewFeature` is defined.
/// Specifically, when `deletablesamlproperty` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeletableSamlProperty::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeletableSamlProperty {
    #[allow(missing_docs)] // documentation missing in model
    SamlPropertiesRelayStateParameterName,
    #[allow(missing_docs)] // documentation missing in model
    SamlPropertiesUserAccessUrl,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeletableSamlProperty {
    fn from(s: &str) -> Self {
        match s {
            "SAML_PROPERTIES_RELAY_STATE_PARAMETER_NAME" => {
                DeletableSamlProperty::SamlPropertiesRelayStateParameterName
            }
            "SAML_PROPERTIES_USER_ACCESS_URL" => DeletableSamlProperty::SamlPropertiesUserAccessUrl,
            other => {
                DeletableSamlProperty::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for DeletableSamlProperty {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeletableSamlProperty::from(s))
    }
}
impl DeletableSamlProperty {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DeletableSamlProperty::SamlPropertiesRelayStateParameterName => {
                "SAML_PROPERTIES_RELAY_STATE_PARAMETER_NAME"
            }
            DeletableSamlProperty::SamlPropertiesUserAccessUrl => "SAML_PROPERTIES_USER_ACCESS_URL",
            DeletableSamlProperty::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "SAML_PROPERTIES_RELAY_STATE_PARAMETER_NAME",
            "SAML_PROPERTIES_USER_ACCESS_URL",
        ]
    }
}
impl AsRef<str> for DeletableSamlProperty {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SamlProperties {
    /// <p>Indicates the status of SAML 2.0 authentication. These statuses include the following.</p>
    /// <ul>
    /// <li> <p>If the setting is <code>DISABLED</code>, end users will be directed to login with their directory credentials.</p> </li>
    /// <li> <p>If the setting is <code>ENABLED</code>, end users will be directed to login via the user access URL. Users attempting to connect to WorkSpaces from a client application that does not support SAML 2.0 authentication will not be able to connect.</p> </li>
    /// <li> <p>If the setting is <code>ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK</code>, end users will be directed to login via the user access URL on supported client applications, but will not prevent clients that do not support SAML 2.0 authentication from connecting as if SAML 2.0 authentication was disabled.</p> </li>
    /// </ul>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::SamlStatusEnum>,
    /// <p>The SAML 2.0 identity provider (IdP) user access URL is the URL a user would navigate to in their web browser in order to federate from the IdP and directly access the application, without any SAML 2.0 service provider (SP) bindings.</p>
    #[doc(hidden)]
    pub user_access_url: std::option::Option<std::string::String>,
    /// <p>The relay state parameter name supported by the SAML 2.0 identity provider (IdP). When the end user is redirected to the user access URL from the WorkSpaces client application, this relay state parameter name is appended as a query parameter to the URL along with the relay state endpoint to return the user to the client application session.</p>
    /// <p>To use SAML 2.0 authentication with WorkSpaces, the IdP must support IdP-initiated deep linking for the relay state URL. Consult your IdP documentation for more information.</p>
    #[doc(hidden)]
    pub relay_state_parameter_name: std::option::Option<std::string::String>,
}
impl SamlProperties {
    /// <p>Indicates the status of SAML 2.0 authentication. These statuses include the following.</p>
    /// <ul>
    /// <li> <p>If the setting is <code>DISABLED</code>, end users will be directed to login with their directory credentials.</p> </li>
    /// <li> <p>If the setting is <code>ENABLED</code>, end users will be directed to login via the user access URL. Users attempting to connect to WorkSpaces from a client application that does not support SAML 2.0 authentication will not be able to connect.</p> </li>
    /// <li> <p>If the setting is <code>ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK</code>, end users will be directed to login via the user access URL on supported client applications, but will not prevent clients that do not support SAML 2.0 authentication from connecting as if SAML 2.0 authentication was disabled.</p> </li>
    /// </ul>
    pub fn status(&self) -> std::option::Option<&crate::model::SamlStatusEnum> {
        self.status.as_ref()
    }
    /// <p>The SAML 2.0 identity provider (IdP) user access URL is the URL a user would navigate to in their web browser in order to federate from the IdP and directly access the application, without any SAML 2.0 service provider (SP) bindings.</p>
    pub fn user_access_url(&self) -> std::option::Option<&str> {
        self.user_access_url.as_deref()
    }
    /// <p>The relay state parameter name supported by the SAML 2.0 identity provider (IdP). When the end user is redirected to the user access URL from the WorkSpaces client application, this relay state parameter name is appended as a query parameter to the URL along with the relay state endpoint to return the user to the client application session.</p>
    /// <p>To use SAML 2.0 authentication with WorkSpaces, the IdP must support IdP-initiated deep linking for the relay state URL. Consult your IdP documentation for more information.</p>
    pub fn relay_state_parameter_name(&self) -> std::option::Option<&str> {
        self.relay_state_parameter_name.as_deref()
    }
}
/// See [`SamlProperties`](crate::model::SamlProperties).
pub mod saml_properties {

    /// A builder for [`SamlProperties`](crate::model::SamlProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::SamlStatusEnum>,
        pub(crate) user_access_url: std::option::Option<std::string::String>,
        pub(crate) relay_state_parameter_name: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates the status of SAML 2.0 authentication. These statuses include the following.</p>
        /// <ul>
        /// <li> <p>If the setting is <code>DISABLED</code>, end users will be directed to login with their directory credentials.</p> </li>
        /// <li> <p>If the setting is <code>ENABLED</code>, end users will be directed to login via the user access URL. Users attempting to connect to WorkSpaces from a client application that does not support SAML 2.0 authentication will not be able to connect.</p> </li>
        /// <li> <p>If the setting is <code>ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK</code>, end users will be directed to login via the user access URL on supported client applications, but will not prevent clients that do not support SAML 2.0 authentication from connecting as if SAML 2.0 authentication was disabled.</p> </li>
        /// </ul>
        pub fn status(mut self, input: crate::model::SamlStatusEnum) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>Indicates the status of SAML 2.0 authentication. These statuses include the following.</p>
        /// <ul>
        /// <li> <p>If the setting is <code>DISABLED</code>, end users will be directed to login with their directory credentials.</p> </li>
        /// <li> <p>If the setting is <code>ENABLED</code>, end users will be directed to login via the user access URL. Users attempting to connect to WorkSpaces from a client application that does not support SAML 2.0 authentication will not be able to connect.</p> </li>
        /// <li> <p>If the setting is <code>ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK</code>, end users will be directed to login via the user access URL on supported client applications, but will not prevent clients that do not support SAML 2.0 authentication from connecting as if SAML 2.0 authentication was disabled.</p> </li>
        /// </ul>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::SamlStatusEnum>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The SAML 2.0 identity provider (IdP) user access URL is the URL a user would navigate to in their web browser in order to federate from the IdP and directly access the application, without any SAML 2.0 service provider (SP) bindings.</p>
        pub fn user_access_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_access_url = Some(input.into());
            self
        }
        /// <p>The SAML 2.0 identity provider (IdP) user access URL is the URL a user would navigate to in their web browser in order to federate from the IdP and directly access the application, without any SAML 2.0 service provider (SP) bindings.</p>
        pub fn set_user_access_url(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.user_access_url = input;
            self
        }
        /// <p>The relay state parameter name supported by the SAML 2.0 identity provider (IdP). When the end user is redirected to the user access URL from the WorkSpaces client application, this relay state parameter name is appended as a query parameter to the URL along with the relay state endpoint to return the user to the client application session.</p>
        /// <p>To use SAML 2.0 authentication with WorkSpaces, the IdP must support IdP-initiated deep linking for the relay state URL. Consult your IdP documentation for more information.</p>
        pub fn relay_state_parameter_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.relay_state_parameter_name = Some(input.into());
            self
        }
        /// <p>The relay state parameter name supported by the SAML 2.0 identity provider (IdP). When the end user is redirected to the user access URL from the WorkSpaces client application, this relay state parameter name is appended as a query parameter to the URL along with the relay state endpoint to return the user to the client application session.</p>
        /// <p>To use SAML 2.0 authentication with WorkSpaces, the IdP must support IdP-initiated deep linking for the relay state URL. Consult your IdP documentation for more information.</p>
        pub fn set_relay_state_parameter_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.relay_state_parameter_name = input;
            self
        }
        /// Consumes the builder and constructs a [`SamlProperties`](crate::model::SamlProperties).
        pub fn build(self) -> crate::model::SamlProperties {
            crate::model::SamlProperties {
                status: self.status,
                user_access_url: self.user_access_url,
                relay_state_parameter_name: self.relay_state_parameter_name,
            }
        }
    }
}
impl SamlProperties {
    /// Creates a new builder-style object to manufacture [`SamlProperties`](crate::model::SamlProperties).
    pub fn builder() -> crate::model::saml_properties::Builder {
        crate::model::saml_properties::Builder::default()
    }
}

/// When writing a match expression against `SamlStatusEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let samlstatusenum = unimplemented!();
/// match samlstatusenum {
///     SamlStatusEnum::Disabled => { /* ... */ },
///     SamlStatusEnum::Enabled => { /* ... */ },
///     SamlStatusEnum::EnabledWithDirectoryLoginFallback => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `samlstatusenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `SamlStatusEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `SamlStatusEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `SamlStatusEnum::NewFeature` is defined.
/// Specifically, when `samlstatusenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `SamlStatusEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum SamlStatusEnum {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    #[allow(missing_docs)] // documentation missing in model
    EnabledWithDirectoryLoginFallback,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for SamlStatusEnum {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => SamlStatusEnum::Disabled,
            "ENABLED" => SamlStatusEnum::Enabled,
            "ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK" => {
                SamlStatusEnum::EnabledWithDirectoryLoginFallback
            }
            other => SamlStatusEnum::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for SamlStatusEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(SamlStatusEnum::from(s))
    }
}
impl SamlStatusEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            SamlStatusEnum::Disabled => "DISABLED",
            SamlStatusEnum::Enabled => "ENABLED",
            SamlStatusEnum::EnabledWithDirectoryLoginFallback => {
                "ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK"
            }
            SamlStatusEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DISABLED",
            "ENABLED",
            "ENABLED_WITH_DIRECTORY_LOGIN_FALLBACK",
        ]
    }
}
impl AsRef<str> for SamlStatusEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an Amazon WorkSpaces client.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClientProperties {
    /// <p>Specifies whether users can cache their credentials on the Amazon WorkSpaces client. When enabled, users can choose to reconnect to their WorkSpaces without re-entering their credentials. </p>
    #[doc(hidden)]
    pub reconnect_enabled: std::option::Option<crate::model::ReconnectEnum>,
    /// <p>Specifies whether users can upload diagnostic log files of Amazon WorkSpaces client directly to WorkSpaces to troubleshoot issues when using the WorkSpaces client. When enabled, the log files will be sent to WorkSpaces automatically and will be applied to all users in the specified directory.</p>
    #[doc(hidden)]
    pub log_upload_enabled: std::option::Option<crate::model::LogUploadEnum>,
}
impl ClientProperties {
    /// <p>Specifies whether users can cache their credentials on the Amazon WorkSpaces client. When enabled, users can choose to reconnect to their WorkSpaces without re-entering their credentials. </p>
    pub fn reconnect_enabled(&self) -> std::option::Option<&crate::model::ReconnectEnum> {
        self.reconnect_enabled.as_ref()
    }
    /// <p>Specifies whether users can upload diagnostic log files of Amazon WorkSpaces client directly to WorkSpaces to troubleshoot issues when using the WorkSpaces client. When enabled, the log files will be sent to WorkSpaces automatically and will be applied to all users in the specified directory.</p>
    pub fn log_upload_enabled(&self) -> std::option::Option<&crate::model::LogUploadEnum> {
        self.log_upload_enabled.as_ref()
    }
}
/// See [`ClientProperties`](crate::model::ClientProperties).
pub mod client_properties {

    /// A builder for [`ClientProperties`](crate::model::ClientProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) reconnect_enabled: std::option::Option<crate::model::ReconnectEnum>,
        pub(crate) log_upload_enabled: std::option::Option<crate::model::LogUploadEnum>,
    }
    impl Builder {
        /// <p>Specifies whether users can cache their credentials on the Amazon WorkSpaces client. When enabled, users can choose to reconnect to their WorkSpaces without re-entering their credentials. </p>
        pub fn reconnect_enabled(mut self, input: crate::model::ReconnectEnum) -> Self {
            self.reconnect_enabled = Some(input);
            self
        }
        /// <p>Specifies whether users can cache their credentials on the Amazon WorkSpaces client. When enabled, users can choose to reconnect to their WorkSpaces without re-entering their credentials. </p>
        pub fn set_reconnect_enabled(
            mut self,
            input: std::option::Option<crate::model::ReconnectEnum>,
        ) -> Self {
            self.reconnect_enabled = input;
            self
        }
        /// <p>Specifies whether users can upload diagnostic log files of Amazon WorkSpaces client directly to WorkSpaces to troubleshoot issues when using the WorkSpaces client. When enabled, the log files will be sent to WorkSpaces automatically and will be applied to all users in the specified directory.</p>
        pub fn log_upload_enabled(mut self, input: crate::model::LogUploadEnum) -> Self {
            self.log_upload_enabled = Some(input);
            self
        }
        /// <p>Specifies whether users can upload diagnostic log files of Amazon WorkSpaces client directly to WorkSpaces to troubleshoot issues when using the WorkSpaces client. When enabled, the log files will be sent to WorkSpaces automatically and will be applied to all users in the specified directory.</p>
        pub fn set_log_upload_enabled(
            mut self,
            input: std::option::Option<crate::model::LogUploadEnum>,
        ) -> Self {
            self.log_upload_enabled = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientProperties`](crate::model::ClientProperties).
        pub fn build(self) -> crate::model::ClientProperties {
            crate::model::ClientProperties {
                reconnect_enabled: self.reconnect_enabled,
                log_upload_enabled: self.log_upload_enabled,
            }
        }
    }
}
impl ClientProperties {
    /// Creates a new builder-style object to manufacture [`ClientProperties`](crate::model::ClientProperties).
    pub fn builder() -> crate::model::client_properties::Builder {
        crate::model::client_properties::Builder::default()
    }
}

/// When writing a match expression against `LogUploadEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let loguploadenum = unimplemented!();
/// match loguploadenum {
///     LogUploadEnum::Disabled => { /* ... */ },
///     LogUploadEnum::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `loguploadenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `LogUploadEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `LogUploadEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `LogUploadEnum::NewFeature` is defined.
/// Specifically, when `loguploadenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `LogUploadEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum LogUploadEnum {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for LogUploadEnum {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => LogUploadEnum::Disabled,
            "ENABLED" => LogUploadEnum::Enabled,
            other => LogUploadEnum::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for LogUploadEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(LogUploadEnum::from(s))
    }
}
impl LogUploadEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            LogUploadEnum::Disabled => "DISABLED",
            LogUploadEnum::Enabled => "ENABLED",
            LogUploadEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for LogUploadEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DeletableCertificateBasedAuthProperty`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let deletablecertificatebasedauthproperty = unimplemented!();
/// match deletablecertificatebasedauthproperty {
///     DeletableCertificateBasedAuthProperty::CertificateBasedAuthPropertiesCertificateAuthorityArn => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `deletablecertificatebasedauthproperty` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DeletableCertificateBasedAuthProperty::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DeletableCertificateBasedAuthProperty::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DeletableCertificateBasedAuthProperty::NewFeature` is defined.
/// Specifically, when `deletablecertificatebasedauthproperty` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DeletableCertificateBasedAuthProperty::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DeletableCertificateBasedAuthProperty {
    #[allow(missing_docs)] // documentation missing in model
    CertificateBasedAuthPropertiesCertificateAuthorityArn,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DeletableCertificateBasedAuthProperty {
    fn from(s: &str) -> Self {
        match s {
                        "CERTIFICATE_BASED_AUTH_PROPERTIES_CERTIFICATE_AUTHORITY_ARN" => DeletableCertificateBasedAuthProperty::CertificateBasedAuthPropertiesCertificateAuthorityArn,
other => DeletableCertificateBasedAuthProperty::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
                    }
    }
}
impl std::str::FromStr for DeletableCertificateBasedAuthProperty {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DeletableCertificateBasedAuthProperty::from(s))
    }
}
impl DeletableCertificateBasedAuthProperty {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
    DeletableCertificateBasedAuthProperty::CertificateBasedAuthPropertiesCertificateAuthorityArn => "CERTIFICATE_BASED_AUTH_PROPERTIES_CERTIFICATE_AUTHORITY_ARN",
    DeletableCertificateBasedAuthProperty::Unknown(value) => value.as_str()
}
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CERTIFICATE_BASED_AUTH_PROPERTIES_CERTIFICATE_AUTHORITY_ARN"]
    }
}
impl AsRef<str> for DeletableCertificateBasedAuthProperty {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the properties of the certificate-based authentication you want to use with your WorkSpaces.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CertificateBasedAuthProperties {
    /// <p>The status of the certificate-based authentication properties.</p>
    #[doc(hidden)]
    pub status: std::option::Option<crate::model::CertificateBasedAuthStatusEnum>,
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager Private CA resource.</p>
    #[doc(hidden)]
    pub certificate_authority_arn: std::option::Option<std::string::String>,
}
impl CertificateBasedAuthProperties {
    /// <p>The status of the certificate-based authentication properties.</p>
    pub fn status(&self) -> std::option::Option<&crate::model::CertificateBasedAuthStatusEnum> {
        self.status.as_ref()
    }
    /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager Private CA resource.</p>
    pub fn certificate_authority_arn(&self) -> std::option::Option<&str> {
        self.certificate_authority_arn.as_deref()
    }
}
/// See [`CertificateBasedAuthProperties`](crate::model::CertificateBasedAuthProperties).
pub mod certificate_based_auth_properties {

    /// A builder for [`CertificateBasedAuthProperties`](crate::model::CertificateBasedAuthProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) status: std::option::Option<crate::model::CertificateBasedAuthStatusEnum>,
        pub(crate) certificate_authority_arn: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The status of the certificate-based authentication properties.</p>
        pub fn status(mut self, input: crate::model::CertificateBasedAuthStatusEnum) -> Self {
            self.status = Some(input);
            self
        }
        /// <p>The status of the certificate-based authentication properties.</p>
        pub fn set_status(
            mut self,
            input: std::option::Option<crate::model::CertificateBasedAuthStatusEnum>,
        ) -> Self {
            self.status = input;
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager Private CA resource.</p>
        pub fn certificate_authority_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.certificate_authority_arn = Some(input.into());
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the Amazon Web Services Certificate Manager Private CA resource.</p>
        pub fn set_certificate_authority_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.certificate_authority_arn = input;
            self
        }
        /// Consumes the builder and constructs a [`CertificateBasedAuthProperties`](crate::model::CertificateBasedAuthProperties).
        pub fn build(self) -> crate::model::CertificateBasedAuthProperties {
            crate::model::CertificateBasedAuthProperties {
                status: self.status,
                certificate_authority_arn: self.certificate_authority_arn,
            }
        }
    }
}
impl CertificateBasedAuthProperties {
    /// Creates a new builder-style object to manufacture [`CertificateBasedAuthProperties`](crate::model::CertificateBasedAuthProperties).
    pub fn builder() -> crate::model::certificate_based_auth_properties::Builder {
        crate::model::certificate_based_auth_properties::Builder::default()
    }
}

/// When writing a match expression against `CertificateBasedAuthStatusEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let certificatebasedauthstatusenum = unimplemented!();
/// match certificatebasedauthstatusenum {
///     CertificateBasedAuthStatusEnum::Disabled => { /* ... */ },
///     CertificateBasedAuthStatusEnum::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `certificatebasedauthstatusenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `CertificateBasedAuthStatusEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `CertificateBasedAuthStatusEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `CertificateBasedAuthStatusEnum::NewFeature` is defined.
/// Specifically, when `certificatebasedauthstatusenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `CertificateBasedAuthStatusEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum CertificateBasedAuthStatusEnum {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for CertificateBasedAuthStatusEnum {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => CertificateBasedAuthStatusEnum::Disabled,
            "ENABLED" => CertificateBasedAuthStatusEnum::Enabled,
            other => CertificateBasedAuthStatusEnum::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for CertificateBasedAuthStatusEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(CertificateBasedAuthStatusEnum::from(s))
    }
}
impl CertificateBasedAuthStatusEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            CertificateBasedAuthStatusEnum::Disabled => "DISABLED",
            CertificateBasedAuthStatusEnum::Enabled => "ENABLED",
            CertificateBasedAuthStatusEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for CertificateBasedAuthStatusEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DedicatedTenancySupportEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dedicatedtenancysupportenum = unimplemented!();
/// match dedicatedtenancysupportenum {
///     DedicatedTenancySupportEnum::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dedicatedtenancysupportenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DedicatedTenancySupportEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DedicatedTenancySupportEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DedicatedTenancySupportEnum::NewFeature` is defined.
/// Specifically, when `dedicatedtenancysupportenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DedicatedTenancySupportEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DedicatedTenancySupportEnum {
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DedicatedTenancySupportEnum {
    fn from(s: &str) -> Self {
        match s {
            "ENABLED" => DedicatedTenancySupportEnum::Enabled,
            other => DedicatedTenancySupportEnum::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DedicatedTenancySupportEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DedicatedTenancySupportEnum::from(s))
    }
}
impl DedicatedTenancySupportEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DedicatedTenancySupportEnum::Enabled => "ENABLED",
            DedicatedTenancySupportEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["ENABLED"]
    }
}
impl AsRef<str> for DedicatedTenancySupportEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `Application`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let application = unimplemented!();
/// match application {
///     Application::MicrosoftOffice2016 => { /* ... */ },
///     Application::MicrosoftOffice2019 => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `application` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `Application::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `Application::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `Application::NewFeature` is defined.
/// Specifically, when `application` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `Application::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum Application {
    #[allow(missing_docs)] // documentation missing in model
    MicrosoftOffice2016,
    #[allow(missing_docs)] // documentation missing in model
    MicrosoftOffice2019,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for Application {
    fn from(s: &str) -> Self {
        match s {
            "Microsoft_Office_2016" => Application::MicrosoftOffice2016,
            "Microsoft_Office_2019" => Application::MicrosoftOffice2019,
            other => Application::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for Application {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(Application::from(s))
    }
}
impl Application {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            Application::MicrosoftOffice2016 => "Microsoft_Office_2016",
            Application::MicrosoftOffice2019 => "Microsoft_Office_2019",
            Application::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["Microsoft_Office_2016", "Microsoft_Office_2019"]
    }
}
impl AsRef<str> for Application {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WorkspaceImageIngestionProcess`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workspaceimageingestionprocess = unimplemented!();
/// match workspaceimageingestionprocess {
///     WorkspaceImageIngestionProcess::ByolGraphics => { /* ... */ },
///     WorkspaceImageIngestionProcess::ByolGraphicspro => { /* ... */ },
///     WorkspaceImageIngestionProcess::ByolGraphicsG4Dn => { /* ... */ },
///     WorkspaceImageIngestionProcess::ByolGraphicsG4DnByop => { /* ... */ },
///     WorkspaceImageIngestionProcess::ByolRegular => { /* ... */ },
///     WorkspaceImageIngestionProcess::ByolRegularByop => { /* ... */ },
///     WorkspaceImageIngestionProcess::ByolRegularWsp => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workspaceimageingestionprocess` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkspaceImageIngestionProcess::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkspaceImageIngestionProcess::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkspaceImageIngestionProcess::NewFeature` is defined.
/// Specifically, when `workspaceimageingestionprocess` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkspaceImageIngestionProcess::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkspaceImageIngestionProcess {
    #[allow(missing_docs)] // documentation missing in model
    ByolGraphics,
    #[allow(missing_docs)] // documentation missing in model
    ByolGraphicspro,
    #[allow(missing_docs)] // documentation missing in model
    ByolGraphicsG4Dn,
    #[allow(missing_docs)] // documentation missing in model
    ByolGraphicsG4DnByop,
    #[allow(missing_docs)] // documentation missing in model
    ByolRegular,
    #[allow(missing_docs)] // documentation missing in model
    ByolRegularByop,
    #[allow(missing_docs)] // documentation missing in model
    ByolRegularWsp,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkspaceImageIngestionProcess {
    fn from(s: &str) -> Self {
        match s {
            "BYOL_GRAPHICS" => WorkspaceImageIngestionProcess::ByolGraphics,
            "BYOL_GRAPHICSPRO" => WorkspaceImageIngestionProcess::ByolGraphicspro,
            "BYOL_GRAPHICS_G4DN" => WorkspaceImageIngestionProcess::ByolGraphicsG4Dn,
            "BYOL_GRAPHICS_G4DN_BYOP" => WorkspaceImageIngestionProcess::ByolGraphicsG4DnByop,
            "BYOL_REGULAR" => WorkspaceImageIngestionProcess::ByolRegular,
            "BYOL_REGULAR_BYOP" => WorkspaceImageIngestionProcess::ByolRegularByop,
            "BYOL_REGULAR_WSP" => WorkspaceImageIngestionProcess::ByolRegularWsp,
            other => WorkspaceImageIngestionProcess::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for WorkspaceImageIngestionProcess {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkspaceImageIngestionProcess::from(s))
    }
}
impl WorkspaceImageIngestionProcess {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkspaceImageIngestionProcess::ByolGraphics => "BYOL_GRAPHICS",
            WorkspaceImageIngestionProcess::ByolGraphicspro => "BYOL_GRAPHICSPRO",
            WorkspaceImageIngestionProcess::ByolGraphicsG4Dn => "BYOL_GRAPHICS_G4DN",
            WorkspaceImageIngestionProcess::ByolGraphicsG4DnByop => "BYOL_GRAPHICS_G4DN_BYOP",
            WorkspaceImageIngestionProcess::ByolRegular => "BYOL_REGULAR",
            WorkspaceImageIngestionProcess::ByolRegularByop => "BYOL_REGULAR_BYOP",
            WorkspaceImageIngestionProcess::ByolRegularWsp => "BYOL_REGULAR_WSP",
            WorkspaceImageIngestionProcess::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "BYOL_GRAPHICS",
            "BYOL_GRAPHICSPRO",
            "BYOL_GRAPHICS_G4DN",
            "BYOL_GRAPHICS_G4DN_BYOP",
            "BYOL_REGULAR",
            "BYOL_REGULAR_BYOP",
            "BYOL_REGULAR_WSP",
        ]
    }
}
impl AsRef<str> for WorkspaceImageIngestionProcess {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Returns default client branding attributes that were imported. These attributes display on the client login screen.</p> <important>
/// <p>Client branding attributes are public facing. Ensure that you don't include sensitive information.</p>
/// </important>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultClientBrandingAttributes {
    /// <p>The logo. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
    #[doc(hidden)]
    pub logo_url: std::option::Option<std::string::String>,
    /// <p>The support email. The company's customer support email address.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub support_email: std::option::Option<std::string::String>,
    /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive.You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub support_link: std::option::Option<std::string::String>,
    /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
    #[doc(hidden)]
    pub forgot_password_link: std::option::Option<std::string::String>,
    /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
    #[doc(hidden)]
    pub login_message:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DefaultClientBrandingAttributes {
    /// <p>The logo. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
    pub fn logo_url(&self) -> std::option::Option<&str> {
        self.logo_url.as_deref()
    }
    /// <p>The support email. The company's customer support email address.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    pub fn support_email(&self) -> std::option::Option<&str> {
        self.support_email.as_deref()
    }
    /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive.You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    pub fn support_link(&self) -> std::option::Option<&str> {
        self.support_link.as_deref()
    }
    /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
    pub fn forgot_password_link(&self) -> std::option::Option<&str> {
        self.forgot_password_link.as_deref()
    }
    /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
    pub fn login_message(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.login_message.as_ref()
    }
}
/// See [`DefaultClientBrandingAttributes`](crate::model::DefaultClientBrandingAttributes).
pub mod default_client_branding_attributes {

    /// A builder for [`DefaultClientBrandingAttributes`](crate::model::DefaultClientBrandingAttributes).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logo_url: std::option::Option<std::string::String>,
        pub(crate) support_email: std::option::Option<std::string::String>,
        pub(crate) support_link: std::option::Option<std::string::String>,
        pub(crate) forgot_password_link: std::option::Option<std::string::String>,
        pub(crate) login_message: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The logo. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
        pub fn logo_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.logo_url = Some(input.into());
            self
        }
        /// <p>The logo. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
        pub fn set_logo_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logo_url = input;
            self
        }
        /// <p>The support email. The company's customer support email address.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn support_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_email = Some(input.into());
            self
        }
        /// <p>The support email. The company's customer support email address.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn set_support_email(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.support_email = input;
            self
        }
        /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive.You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn support_link(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_link = Some(input.into());
            self
        }
        /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive.You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn set_support_link(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.support_link = input;
            self
        }
        /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
        pub fn forgot_password_link(mut self, input: impl Into<std::string::String>) -> Self {
            self.forgot_password_link = Some(input.into());
            self
        }
        /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
        pub fn set_forgot_password_link(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.forgot_password_link = input;
            self
        }
        /// Adds a key-value pair to `login_message`.
        ///
        /// To override the contents of this collection use [`set_login_message`](Self::set_login_message).
        ///
        /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
        pub fn login_message(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.login_message.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.login_message = Some(hash_map);
            self
        }
        /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
        pub fn set_login_message(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.login_message = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultClientBrandingAttributes`](crate::model::DefaultClientBrandingAttributes).
        pub fn build(self) -> crate::model::DefaultClientBrandingAttributes {
            crate::model::DefaultClientBrandingAttributes {
                logo_url: self.logo_url,
                support_email: self.support_email,
                support_link: self.support_link,
                forgot_password_link: self.forgot_password_link,
                login_message: self.login_message,
            }
        }
    }
}
impl DefaultClientBrandingAttributes {
    /// Creates a new builder-style object to manufacture [`DefaultClientBrandingAttributes`](crate::model::DefaultClientBrandingAttributes).
    pub fn builder() -> crate::model::default_client_branding_attributes::Builder {
        crate::model::default_client_branding_attributes::Builder::default()
    }
}

/// <p>The client branding attributes for iOS device types. These attributes are displayed on the iOS client login screen only.</p> <important>
/// <p>Client branding attributes are public facing. Ensure you do not include sensitive information.</p>
/// </important>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IosClientBrandingAttributes {
    /// <p>The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
    #[doc(hidden)]
    pub logo_url: std::option::Option<std::string::String>,
    /// <p>The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
    /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
    /// </note>
    #[doc(hidden)]
    pub logo2x_url: std::option::Option<std::string::String>,
    /// <p>The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x).The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
    /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
    /// </note>
    #[doc(hidden)]
    pub logo3x_url: std::option::Option<std::string::String>,
    /// <p>The support email. The company's customer support email address.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub support_email: std::option::Option<std::string::String>,
    /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub support_link: std::option::Option<std::string::String>,
    /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
    #[doc(hidden)]
    pub forgot_password_link: std::option::Option<std::string::String>,
    /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
    #[doc(hidden)]
    pub login_message:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl IosClientBrandingAttributes {
    /// <p>The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
    pub fn logo_url(&self) -> std::option::Option<&str> {
        self.logo_url.as_deref()
    }
    /// <p>The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
    /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
    /// </note>
    pub fn logo2x_url(&self) -> std::option::Option<&str> {
        self.logo2x_url.as_deref()
    }
    /// <p>The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x).The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
    /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
    /// </note>
    pub fn logo3x_url(&self) -> std::option::Option<&str> {
        self.logo3x_url.as_deref()
    }
    /// <p>The support email. The company's customer support email address.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    pub fn support_email(&self) -> std::option::Option<&str> {
        self.support_email.as_deref()
    }
    /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    pub fn support_link(&self) -> std::option::Option<&str> {
        self.support_link.as_deref()
    }
    /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
    pub fn forgot_password_link(&self) -> std::option::Option<&str> {
        self.forgot_password_link.as_deref()
    }
    /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
    pub fn login_message(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.login_message.as_ref()
    }
}
/// See [`IosClientBrandingAttributes`](crate::model::IosClientBrandingAttributes).
pub mod ios_client_branding_attributes {

    /// A builder for [`IosClientBrandingAttributes`](crate::model::IosClientBrandingAttributes).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logo_url: std::option::Option<std::string::String>,
        pub(crate) logo2x_url: std::option::Option<std::string::String>,
        pub(crate) logo3x_url: std::option::Option<std::string::String>,
        pub(crate) support_email: std::option::Option<std::string::String>,
        pub(crate) support_link: std::option::Option<std::string::String>,
        pub(crate) forgot_password_link: std::option::Option<std::string::String>,
        pub(crate) login_message: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
        pub fn logo_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.logo_url = Some(input.into());
            self
        }
        /// <p>The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
        pub fn set_logo_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logo_url = input;
            self
        }
        /// <p>The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
        /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
        /// </note>
        pub fn logo2x_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.logo2x_url = Some(input.into());
            self
        }
        /// <p>The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
        /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
        /// </note>
        pub fn set_logo2x_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logo2x_url = input;
            self
        }
        /// <p>The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x).The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
        /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
        /// </note>
        pub fn logo3x_url(mut self, input: impl Into<std::string::String>) -> Self {
            self.logo3x_url = Some(input.into());
            self
        }
        /// <p>The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x).The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
        /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
        /// </note>
        pub fn set_logo3x_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.logo3x_url = input;
            self
        }
        /// <p>The support email. The company's customer support email address.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn support_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_email = Some(input.into());
            self
        }
        /// <p>The support email. The company's customer support email address.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn set_support_email(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.support_email = input;
            self
        }
        /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn support_link(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_link = Some(input.into());
            self
        }
        /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn set_support_link(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.support_link = input;
            self
        }
        /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
        pub fn forgot_password_link(mut self, input: impl Into<std::string::String>) -> Self {
            self.forgot_password_link = Some(input.into());
            self
        }
        /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
        pub fn set_forgot_password_link(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.forgot_password_link = input;
            self
        }
        /// Adds a key-value pair to `login_message`.
        ///
        /// To override the contents of this collection use [`set_login_message`](Self::set_login_message).
        ///
        /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
        pub fn login_message(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.login_message.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.login_message = Some(hash_map);
            self
        }
        /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
        pub fn set_login_message(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.login_message = input;
            self
        }
        /// Consumes the builder and constructs a [`IosClientBrandingAttributes`](crate::model::IosClientBrandingAttributes).
        pub fn build(self) -> crate::model::IosClientBrandingAttributes {
            crate::model::IosClientBrandingAttributes {
                logo_url: self.logo_url,
                logo2x_url: self.logo2x_url,
                logo3x_url: self.logo3x_url,
                support_email: self.support_email,
                support_link: self.support_link,
                forgot_password_link: self.forgot_password_link,
                login_message: self.login_message,
            }
        }
    }
}
impl IosClientBrandingAttributes {
    /// Creates a new builder-style object to manufacture [`IosClientBrandingAttributes`](crate::model::IosClientBrandingAttributes).
    pub fn builder() -> crate::model::ios_client_branding_attributes::Builder {
        crate::model::ios_client_branding_attributes::Builder::default()
    }
}

/// <p>The default client branding attributes to be imported. These attributes display on the client login screen.</p> <important>
/// <p>Client branding attributes are public facing. Ensure that you do not include sensitive information.</p>
/// </important>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultImportClientBrandingAttributes {
    /// <p>The logo. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
    #[doc(hidden)]
    pub logo: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The support email. The company's customer support email address.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub support_email: std::option::Option<std::string::String>,
    /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub support_link: std::option::Option<std::string::String>,
    /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
    #[doc(hidden)]
    pub forgot_password_link: std::option::Option<std::string::String>,
    /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
    #[doc(hidden)]
    pub login_message:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl DefaultImportClientBrandingAttributes {
    /// <p>The logo. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
    pub fn logo(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.logo.as_ref()
    }
    /// <p>The support email. The company's customer support email address.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    pub fn support_email(&self) -> std::option::Option<&str> {
        self.support_email.as_deref()
    }
    /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    pub fn support_link(&self) -> std::option::Option<&str> {
        self.support_link.as_deref()
    }
    /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
    pub fn forgot_password_link(&self) -> std::option::Option<&str> {
        self.forgot_password_link.as_deref()
    }
    /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
    pub fn login_message(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.login_message.as_ref()
    }
}
/// See [`DefaultImportClientBrandingAttributes`](crate::model::DefaultImportClientBrandingAttributes).
pub mod default_import_client_branding_attributes {

    /// A builder for [`DefaultImportClientBrandingAttributes`](crate::model::DefaultImportClientBrandingAttributes).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logo: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) support_email: std::option::Option<std::string::String>,
        pub(crate) support_link: std::option::Option<std::string::String>,
        pub(crate) forgot_password_link: std::option::Option<std::string::String>,
        pub(crate) login_message: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The logo. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
        pub fn logo(mut self, input: aws_smithy_types::Blob) -> Self {
            self.logo = Some(input);
            self
        }
        /// <p>The logo. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
        pub fn set_logo(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.logo = input;
            self
        }
        /// <p>The support email. The company's customer support email address.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn support_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_email = Some(input.into());
            self
        }
        /// <p>The support email. The company's customer support email address.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn set_support_email(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.support_email = input;
            self
        }
        /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn support_link(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_link = Some(input.into());
            self
        }
        /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn set_support_link(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.support_link = input;
            self
        }
        /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
        pub fn forgot_password_link(mut self, input: impl Into<std::string::String>) -> Self {
            self.forgot_password_link = Some(input.into());
            self
        }
        /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
        pub fn set_forgot_password_link(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.forgot_password_link = input;
            self
        }
        /// Adds a key-value pair to `login_message`.
        ///
        /// To override the contents of this collection use [`set_login_message`](Self::set_login_message).
        ///
        /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
        pub fn login_message(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.login_message.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.login_message = Some(hash_map);
            self
        }
        /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
        pub fn set_login_message(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.login_message = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultImportClientBrandingAttributes`](crate::model::DefaultImportClientBrandingAttributes).
        pub fn build(self) -> crate::model::DefaultImportClientBrandingAttributes {
            crate::model::DefaultImportClientBrandingAttributes {
                logo: self.logo,
                support_email: self.support_email,
                support_link: self.support_link,
                forgot_password_link: self.forgot_password_link,
                login_message: self.login_message,
            }
        }
    }
}
impl DefaultImportClientBrandingAttributes {
    /// Creates a new builder-style object to manufacture [`DefaultImportClientBrandingAttributes`](crate::model::DefaultImportClientBrandingAttributes).
    pub fn builder() -> crate::model::default_import_client_branding_attributes::Builder {
        crate::model::default_import_client_branding_attributes::Builder::default()
    }
}

/// <p>The client branding attributes to import for iOS device types. These attributes are displayed on the iOS client login screen.</p> <important>
/// <p>Client branding attributes are public facing. Ensure you do not include sensitive information.</p>
/// </important>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IosImportClientBrandingAttributes {
    /// <p>The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
    #[doc(hidden)]
    pub logo: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
    /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
    /// </note>
    #[doc(hidden)]
    pub logo2x: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
    /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
    /// </note>
    #[doc(hidden)]
    pub logo3x: std::option::Option<aws_smithy_types::Blob>,
    /// <p>The support email. The company's customer support email address.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub support_email: std::option::Option<std::string::String>,
    /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    #[doc(hidden)]
    pub support_link: std::option::Option<std::string::String>,
    /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
    #[doc(hidden)]
    pub forgot_password_link: std::option::Option<std::string::String>,
    /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
    #[doc(hidden)]
    pub login_message:
        std::option::Option<std::collections::HashMap<std::string::String, std::string::String>>,
}
impl IosImportClientBrandingAttributes {
    /// <p>The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
    pub fn logo(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.logo.as_ref()
    }
    /// <p>The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
    /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
    /// </note>
    pub fn logo2x(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.logo2x.as_ref()
    }
    /// <p>The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
    /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
    /// </note>
    pub fn logo3x(&self) -> std::option::Option<&aws_smithy_types::Blob> {
        self.logo3x.as_ref()
    }
    /// <p>The support email. The company's customer support email address.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    pub fn support_email(&self) -> std::option::Option<&str> {
        self.support_email.as_deref()
    }
    /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
    /// <ul>
    /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
    /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
    /// </ul>
    /// </note>
    pub fn support_link(&self) -> std::option::Option<&str> {
        self.support_link.as_deref()
    }
    /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
    pub fn forgot_password_link(&self) -> std::option::Option<&str> {
        self.forgot_password_link.as_deref()
    }
    /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
    pub fn login_message(
        &self,
    ) -> std::option::Option<&std::collections::HashMap<std::string::String, std::string::String>>
    {
        self.login_message.as_ref()
    }
}
/// See [`IosImportClientBrandingAttributes`](crate::model::IosImportClientBrandingAttributes).
pub mod ios_import_client_branding_attributes {

    /// A builder for [`IosImportClientBrandingAttributes`](crate::model::IosImportClientBrandingAttributes).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) logo: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) logo2x: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) logo3x: std::option::Option<aws_smithy_types::Blob>,
        pub(crate) support_email: std::option::Option<std::string::String>,
        pub(crate) support_link: std::option::Option<std::string::String>,
        pub(crate) forgot_password_link: std::option::Option<std::string::String>,
        pub(crate) login_message: std::option::Option<
            std::collections::HashMap<std::string::String, std::string::String>,
        >,
    }
    impl Builder {
        /// <p>The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
        pub fn logo(mut self, input: aws_smithy_types::Blob) -> Self {
            self.logo = Some(input);
            self
        }
        /// <p>The logo. This is the standard-resolution display that has a 1:1 pixel density (or @1x), where one pixel is equal to one point. The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p>
        pub fn set_logo(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.logo = input;
            self
        }
        /// <p>The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
        /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
        /// </note>
        pub fn logo2x(mut self, input: aws_smithy_types::Blob) -> Self {
            self.logo2x = Some(input);
            self
        }
        /// <p>The @2x version of the logo. This is the higher resolution display that offers a scale factor of 2.0 (or @2x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
        /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
        /// </note>
        pub fn set_logo2x(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.logo2x = input;
            self
        }
        /// <p>The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
        /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
        /// </note>
        pub fn logo3x(mut self, input: aws_smithy_types::Blob) -> Self {
            self.logo3x = Some(input);
            self
        }
        /// <p>The @3x version of the logo. This is the higher resolution display that offers a scale factor of 3.0 (or @3x). The only image format accepted is a binary data object that is converted from a <code>.png</code> file.</p> <note>
        /// <p> For more information about iOS image size and resolution, see <a href="https://developer.apple.com/design/human-interface-guidelines/ios/icons-and-images/image-size-and-resolution/">Image Size and Resolution </a> in the <i>Apple Human Interface Guidelines</i>.</p>
        /// </note>
        pub fn set_logo3x(mut self, input: std::option::Option<aws_smithy_types::Blob>) -> Self {
            self.logo3x = input;
            self
        }
        /// <p>The support email. The company's customer support email address.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn support_email(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_email = Some(input.into());
            self
        }
        /// <p>The support email. The company's customer support email address.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default email is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn set_support_email(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.support_email = input;
            self
        }
        /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn support_link(mut self, input: impl Into<std::string::String>) -> Self {
            self.support_link = Some(input.into());
            self
        }
        /// <p>The support link. The link for the company's customer support page for their WorkSpace.</p> <note>
        /// <ul>
        /// <li> <p>In each platform type, the <code>SupportEmail</code> and <code>SupportLink</code> parameters are mutually exclusive. You can specify one parameter for each platform type, but not both.</p> </li>
        /// <li> <p>The default support link is <code>workspaces-feedback@amazon.com</code>.</p> </li>
        /// </ul>
        /// </note>
        pub fn set_support_link(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.support_link = input;
            self
        }
        /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
        pub fn forgot_password_link(mut self, input: impl Into<std::string::String>) -> Self {
            self.forgot_password_link = Some(input.into());
            self
        }
        /// <p>The forgotten password link. This is the web address that users can go to if they forget the password for their WorkSpace.</p>
        pub fn set_forgot_password_link(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.forgot_password_link = input;
            self
        }
        /// Adds a key-value pair to `login_message`.
        ///
        /// To override the contents of this collection use [`set_login_message`](Self::set_login_message).
        ///
        /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
        pub fn login_message(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            let mut hash_map = self.login_message.unwrap_or_default();
            hash_map.insert(k.into(), v.into());
            self.login_message = Some(hash_map);
            self
        }
        /// <p>The login message. Specified as a key value pair, in which the key is a locale and the value is the localized message for that locale. The only key supported is <code>en_US</code>. The HTML tags supported include the following: <code>a, b, blockquote, br, cite, code, dd, dl, dt, div, em, i, li, ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>.</p>
        pub fn set_login_message(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.login_message = input;
            self
        }
        /// Consumes the builder and constructs a [`IosImportClientBrandingAttributes`](crate::model::IosImportClientBrandingAttributes).
        pub fn build(self) -> crate::model::IosImportClientBrandingAttributes {
            crate::model::IosImportClientBrandingAttributes {
                logo: self.logo,
                logo2x: self.logo2x,
                logo3x: self.logo3x,
                support_email: self.support_email,
                support_link: self.support_link,
                forgot_password_link: self.forgot_password_link,
                login_message: self.login_message,
            }
        }
    }
}
impl IosImportClientBrandingAttributes {
    /// Creates a new builder-style object to manufacture [`IosImportClientBrandingAttributes`](crate::model::IosImportClientBrandingAttributes).
    pub fn builder() -> crate::model::ios_import_client_branding_attributes::Builder {
        crate::model::ios_import_client_branding_attributes::Builder::default()
    }
}

/// <p>Describes a snapshot.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Snapshot {
    /// <p>The time when the snapshot was created.</p>
    #[doc(hidden)]
    pub snapshot_time: std::option::Option<aws_smithy_types::DateTime>,
}
impl Snapshot {
    /// <p>The time when the snapshot was created.</p>
    pub fn snapshot_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.snapshot_time.as_ref()
    }
}
/// See [`Snapshot`](crate::model::Snapshot).
pub mod snapshot {

    /// A builder for [`Snapshot`](crate::model::Snapshot).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) snapshot_time: std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The time when the snapshot was created.</p>
        pub fn snapshot_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.snapshot_time = Some(input);
            self
        }
        /// <p>The time when the snapshot was created.</p>
        pub fn set_snapshot_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.snapshot_time = input;
            self
        }
        /// Consumes the builder and constructs a [`Snapshot`](crate::model::Snapshot).
        pub fn build(self) -> crate::model::Snapshot {
            crate::model::Snapshot {
                snapshot_time: self.snapshot_time,
            }
        }
    }
}
impl Snapshot {
    /// Creates a new builder-style object to manufacture [`Snapshot`](crate::model::Snapshot).
    pub fn builder() -> crate::model::snapshot::Builder {
        crate::model::snapshot::Builder::default()
    }
}

/// <p>Describes the connection status of a WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceConnectionStatus {
    /// <p>The identifier of the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
    /// <p>The connection state of the WorkSpace. The connection state is unknown if the WorkSpace is stopped.</p>
    #[doc(hidden)]
    pub connection_state: std::option::Option<crate::model::ConnectionState>,
    /// <p>The timestamp of the connection status check.</p>
    #[doc(hidden)]
    pub connection_state_check_timestamp: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The timestamp of the last known user connection.</p>
    #[doc(hidden)]
    pub last_known_user_connection_timestamp: std::option::Option<aws_smithy_types::DateTime>,
}
impl WorkspaceConnectionStatus {
    /// <p>The identifier of the WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
    /// <p>The connection state of the WorkSpace. The connection state is unknown if the WorkSpace is stopped.</p>
    pub fn connection_state(&self) -> std::option::Option<&crate::model::ConnectionState> {
        self.connection_state.as_ref()
    }
    /// <p>The timestamp of the connection status check.</p>
    pub fn connection_state_check_timestamp(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.connection_state_check_timestamp.as_ref()
    }
    /// <p>The timestamp of the last known user connection.</p>
    pub fn last_known_user_connection_timestamp(
        &self,
    ) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_known_user_connection_timestamp.as_ref()
    }
}
/// See [`WorkspaceConnectionStatus`](crate::model::WorkspaceConnectionStatus).
pub mod workspace_connection_status {

    /// A builder for [`WorkspaceConnectionStatus`](crate::model::WorkspaceConnectionStatus).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
        pub(crate) connection_state: std::option::Option<crate::model::ConnectionState>,
        pub(crate) connection_state_check_timestamp:
            std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) last_known_user_connection_timestamp:
            std::option::Option<aws_smithy_types::DateTime>,
    }
    impl Builder {
        /// <p>The identifier of the WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// <p>The connection state of the WorkSpace. The connection state is unknown if the WorkSpace is stopped.</p>
        pub fn connection_state(mut self, input: crate::model::ConnectionState) -> Self {
            self.connection_state = Some(input);
            self
        }
        /// <p>The connection state of the WorkSpace. The connection state is unknown if the WorkSpace is stopped.</p>
        pub fn set_connection_state(
            mut self,
            input: std::option::Option<crate::model::ConnectionState>,
        ) -> Self {
            self.connection_state = input;
            self
        }
        /// <p>The timestamp of the connection status check.</p>
        pub fn connection_state_check_timestamp(
            mut self,
            input: aws_smithy_types::DateTime,
        ) -> Self {
            self.connection_state_check_timestamp = Some(input);
            self
        }
        /// <p>The timestamp of the connection status check.</p>
        pub fn set_connection_state_check_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.connection_state_check_timestamp = input;
            self
        }
        /// <p>The timestamp of the last known user connection.</p>
        pub fn last_known_user_connection_timestamp(
            mut self,
            input: aws_smithy_types::DateTime,
        ) -> Self {
            self.last_known_user_connection_timestamp = Some(input);
            self
        }
        /// <p>The timestamp of the last known user connection.</p>
        pub fn set_last_known_user_connection_timestamp(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_known_user_connection_timestamp = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspaceConnectionStatus`](crate::model::WorkspaceConnectionStatus).
        pub fn build(self) -> crate::model::WorkspaceConnectionStatus {
            crate::model::WorkspaceConnectionStatus {
                workspace_id: self.workspace_id,
                connection_state: self.connection_state,
                connection_state_check_timestamp: self.connection_state_check_timestamp,
                last_known_user_connection_timestamp: self.last_known_user_connection_timestamp,
            }
        }
    }
}
impl WorkspaceConnectionStatus {
    /// Creates a new builder-style object to manufacture [`WorkspaceConnectionStatus`](crate::model::WorkspaceConnectionStatus).
    pub fn builder() -> crate::model::workspace_connection_status::Builder {
        crate::model::workspace_connection_status::Builder::default()
    }
}

/// When writing a match expression against `ConnectionState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let connectionstate = unimplemented!();
/// match connectionstate {
///     ConnectionState::Connected => { /* ... */ },
///     ConnectionState::Disconnected => { /* ... */ },
///     ConnectionState::UnknownValue => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectionstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectionState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectionState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectionState::NewFeature` is defined.
/// Specifically, when `connectionstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectionState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
/// _Note: `ConnectionState::Unknown` has been renamed to `::UnknownValue`._
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectionState {
    #[allow(missing_docs)] // documentation missing in model
    Connected,
    #[allow(missing_docs)] // documentation missing in model
    Disconnected,
    /// _Note: `::Unknown` has been renamed to `::UnknownValue`._
    UnknownValue,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConnectionState {
    fn from(s: &str) -> Self {
        match s {
            "CONNECTED" => ConnectionState::Connected,
            "DISCONNECTED" => ConnectionState::Disconnected,
            "UNKNOWN" => ConnectionState::UnknownValue,
            other => ConnectionState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ConnectionState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectionState::from(s))
    }
}
impl ConnectionState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionState::Connected => "CONNECTED",
            ConnectionState::Disconnected => "DISCONNECTED",
            ConnectionState::UnknownValue => "UNKNOWN",
            ConnectionState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CONNECTED", "DISCONNECTED", "UNKNOWN"]
    }
}
impl AsRef<str> for ConnectionState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct Workspace {
    /// <p>The identifier of the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the Directory Service directory for the WorkSpace.</p>
    #[doc(hidden)]
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The user for the WorkSpace.</p>
    #[doc(hidden)]
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The IP address of the WorkSpace.</p>
    #[doc(hidden)]
    pub ip_address: std::option::Option<std::string::String>,
    /// <p>The operational state of the WorkSpace.</p> <note>
    /// <p>After a WorkSpace is terminated, the <code>TERMINATED</code> state is returned only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html"> DescribeWorkSpaces</a>. If the WorkSpace ID isn't returned, then the WorkSpace has been successfully terminated.</p>
    /// </note>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::WorkspaceState>,
    /// <p>The identifier of the bundle used to create the WorkSpace.</p>
    #[doc(hidden)]
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the subnet for the WorkSpace.</p>
    #[doc(hidden)]
    pub subnet_id: std::option::Option<std::string::String>,
    /// <p>The text of the error message that is returned if the WorkSpace cannot be created.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The name of the WorkSpace, as seen by the operating system. The format of this name varies. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/launch-workspaces-tutorials.html"> Launch a WorkSpace</a>. </p>
    #[doc(hidden)]
    pub computer_name: std::option::Option<std::string::String>,
    /// <p>The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.</p>
    #[doc(hidden)]
    pub volume_encryption_key: std::option::Option<std::string::String>,
    /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
    #[doc(hidden)]
    pub user_volume_encryption_enabled: std::option::Option<bool>,
    /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
    #[doc(hidden)]
    pub root_volume_encryption_enabled: std::option::Option<bool>,
    /// <p>The properties of the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_properties: std::option::Option<crate::model::WorkspaceProperties>,
    /// <p>The modification states of the WorkSpace.</p>
    #[doc(hidden)]
    pub modification_states: std::option::Option<std::vec::Vec<crate::model::ModificationState>>,
    /// <p>The Standby WorkSpace or Primary WorkSpace related to the specified WorkSpace.</p>
    #[doc(hidden)]
    pub related_workspaces:
        std::option::Option<std::vec::Vec<crate::model::RelatedWorkspaceProperties>>,
}
impl Workspace {
    /// <p>The identifier of the WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
    /// <p>The identifier of the Directory Service directory for the WorkSpace.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>The user for the WorkSpace.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
    /// <p>The IP address of the WorkSpace.</p>
    pub fn ip_address(&self) -> std::option::Option<&str> {
        self.ip_address.as_deref()
    }
    /// <p>The operational state of the WorkSpace.</p> <note>
    /// <p>After a WorkSpace is terminated, the <code>TERMINATED</code> state is returned only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html"> DescribeWorkSpaces</a>. If the WorkSpace ID isn't returned, then the WorkSpace has been successfully terminated.</p>
    /// </note>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkspaceState> {
        self.state.as_ref()
    }
    /// <p>The identifier of the bundle used to create the WorkSpace.</p>
    pub fn bundle_id(&self) -> std::option::Option<&str> {
        self.bundle_id.as_deref()
    }
    /// <p>The identifier of the subnet for the WorkSpace.</p>
    pub fn subnet_id(&self) -> std::option::Option<&str> {
        self.subnet_id.as_deref()
    }
    /// <p>The text of the error message that is returned if the WorkSpace cannot be created.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The name of the WorkSpace, as seen by the operating system. The format of this name varies. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/launch-workspaces-tutorials.html"> Launch a WorkSpace</a>. </p>
    pub fn computer_name(&self) -> std::option::Option<&str> {
        self.computer_name.as_deref()
    }
    /// <p>The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.</p>
    pub fn volume_encryption_key(&self) -> std::option::Option<&str> {
        self.volume_encryption_key.as_deref()
    }
    /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
    pub fn user_volume_encryption_enabled(&self) -> std::option::Option<bool> {
        self.user_volume_encryption_enabled
    }
    /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
    pub fn root_volume_encryption_enabled(&self) -> std::option::Option<bool> {
        self.root_volume_encryption_enabled
    }
    /// <p>The properties of the WorkSpace.</p>
    pub fn workspace_properties(&self) -> std::option::Option<&crate::model::WorkspaceProperties> {
        self.workspace_properties.as_ref()
    }
    /// <p>The modification states of the WorkSpace.</p>
    pub fn modification_states(&self) -> std::option::Option<&[crate::model::ModificationState]> {
        self.modification_states.as_deref()
    }
    /// <p>The Standby WorkSpace or Primary WorkSpace related to the specified WorkSpace.</p>
    pub fn related_workspaces(
        &self,
    ) -> std::option::Option<&[crate::model::RelatedWorkspaceProperties]> {
        self.related_workspaces.as_deref()
    }
}
/// See [`Workspace`](crate::model::Workspace).
pub mod workspace {

    /// A builder for [`Workspace`](crate::model::Workspace).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) ip_address: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::WorkspaceState>,
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) subnet_id: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) computer_name: std::option::Option<std::string::String>,
        pub(crate) volume_encryption_key: std::option::Option<std::string::String>,
        pub(crate) user_volume_encryption_enabled: std::option::Option<bool>,
        pub(crate) root_volume_encryption_enabled: std::option::Option<bool>,
        pub(crate) workspace_properties: std::option::Option<crate::model::WorkspaceProperties>,
        pub(crate) modification_states:
            std::option::Option<std::vec::Vec<crate::model::ModificationState>>,
        pub(crate) related_workspaces:
            std::option::Option<std::vec::Vec<crate::model::RelatedWorkspaceProperties>>,
    }
    impl Builder {
        /// <p>The identifier of the WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// <p>The identifier of the Directory Service directory for the WorkSpace.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Directory Service directory for the WorkSpace.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The user for the WorkSpace.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>The user for the WorkSpace.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// <p>The IP address of the WorkSpace.</p>
        pub fn ip_address(mut self, input: impl Into<std::string::String>) -> Self {
            self.ip_address = Some(input.into());
            self
        }
        /// <p>The IP address of the WorkSpace.</p>
        pub fn set_ip_address(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.ip_address = input;
            self
        }
        /// <p>The operational state of the WorkSpace.</p> <note>
        /// <p>After a WorkSpace is terminated, the <code>TERMINATED</code> state is returned only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html"> DescribeWorkSpaces</a>. If the WorkSpace ID isn't returned, then the WorkSpace has been successfully terminated.</p>
        /// </note>
        pub fn state(mut self, input: crate::model::WorkspaceState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The operational state of the WorkSpace.</p> <note>
        /// <p>After a WorkSpace is terminated, the <code>TERMINATED</code> state is returned only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html"> DescribeWorkSpaces</a>. If the WorkSpace ID isn't returned, then the WorkSpace has been successfully terminated.</p>
        /// </note>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkspaceState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The identifier of the bundle used to create the WorkSpace.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The identifier of the bundle used to create the WorkSpace.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>The identifier of the subnet for the WorkSpace.</p>
        pub fn subnet_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.subnet_id = Some(input.into());
            self
        }
        /// <p>The identifier of the subnet for the WorkSpace.</p>
        pub fn set_subnet_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.subnet_id = input;
            self
        }
        /// <p>The text of the error message that is returned if the WorkSpace cannot be created.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The text of the error message that is returned if the WorkSpace cannot be created.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The name of the WorkSpace, as seen by the operating system. The format of this name varies. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/launch-workspaces-tutorials.html"> Launch a WorkSpace</a>. </p>
        pub fn computer_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.computer_name = Some(input.into());
            self
        }
        /// <p>The name of the WorkSpace, as seen by the operating system. The format of this name varies. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/launch-workspaces-tutorials.html"> Launch a WorkSpace</a>. </p>
        pub fn set_computer_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.computer_name = input;
            self
        }
        /// <p>The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.</p>
        pub fn volume_encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_encryption_key = Some(input.into());
            self
        }
        /// <p>The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.</p>
        pub fn set_volume_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_encryption_key = input;
            self
        }
        /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
        pub fn user_volume_encryption_enabled(mut self, input: bool) -> Self {
            self.user_volume_encryption_enabled = Some(input);
            self
        }
        /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
        pub fn set_user_volume_encryption_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.user_volume_encryption_enabled = input;
            self
        }
        /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
        pub fn root_volume_encryption_enabled(mut self, input: bool) -> Self {
            self.root_volume_encryption_enabled = Some(input);
            self
        }
        /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
        pub fn set_root_volume_encryption_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.root_volume_encryption_enabled = input;
            self
        }
        /// <p>The properties of the WorkSpace.</p>
        pub fn workspace_properties(mut self, input: crate::model::WorkspaceProperties) -> Self {
            self.workspace_properties = Some(input);
            self
        }
        /// <p>The properties of the WorkSpace.</p>
        pub fn set_workspace_properties(
            mut self,
            input: std::option::Option<crate::model::WorkspaceProperties>,
        ) -> Self {
            self.workspace_properties = input;
            self
        }
        /// Appends an item to `modification_states`.
        ///
        /// To override the contents of this collection use [`set_modification_states`](Self::set_modification_states).
        ///
        /// <p>The modification states of the WorkSpace.</p>
        pub fn modification_states(mut self, input: crate::model::ModificationState) -> Self {
            let mut v = self.modification_states.unwrap_or_default();
            v.push(input);
            self.modification_states = Some(v);
            self
        }
        /// <p>The modification states of the WorkSpace.</p>
        pub fn set_modification_states(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ModificationState>>,
        ) -> Self {
            self.modification_states = input;
            self
        }
        /// Appends an item to `related_workspaces`.
        ///
        /// To override the contents of this collection use [`set_related_workspaces`](Self::set_related_workspaces).
        ///
        /// <p>The Standby WorkSpace or Primary WorkSpace related to the specified WorkSpace.</p>
        pub fn related_workspaces(
            mut self,
            input: crate::model::RelatedWorkspaceProperties,
        ) -> Self {
            let mut v = self.related_workspaces.unwrap_or_default();
            v.push(input);
            self.related_workspaces = Some(v);
            self
        }
        /// <p>The Standby WorkSpace or Primary WorkSpace related to the specified WorkSpace.</p>
        pub fn set_related_workspaces(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RelatedWorkspaceProperties>>,
        ) -> Self {
            self.related_workspaces = input;
            self
        }
        /// Consumes the builder and constructs a [`Workspace`](crate::model::Workspace).
        pub fn build(self) -> crate::model::Workspace {
            crate::model::Workspace {
                workspace_id: self.workspace_id,
                directory_id: self.directory_id,
                user_name: self.user_name,
                ip_address: self.ip_address,
                state: self.state,
                bundle_id: self.bundle_id,
                subnet_id: self.subnet_id,
                error_message: self.error_message,
                error_code: self.error_code,
                computer_name: self.computer_name,
                volume_encryption_key: self.volume_encryption_key,
                user_volume_encryption_enabled: self.user_volume_encryption_enabled,
                root_volume_encryption_enabled: self.root_volume_encryption_enabled,
                workspace_properties: self.workspace_properties,
                modification_states: self.modification_states,
                related_workspaces: self.related_workspaces,
            }
        }
    }
}
impl Workspace {
    /// Creates a new builder-style object to manufacture [`Workspace`](crate::model::Workspace).
    pub fn builder() -> crate::model::workspace::Builder {
        crate::model::workspace::Builder::default()
    }
}

/// <p>Describes the related WorkSpace. The related WorkSpace could be a Standby WorkSpace or Primary WorkSpace related to the specified WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RelatedWorkspaceProperties {
    /// <p>The identifier of the related WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
    /// <p>The Region of the related WorkSpace.</p>
    #[doc(hidden)]
    pub region: std::option::Option<std::string::String>,
    /// <p>Indicates the state of the WorkSpace.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::WorkspaceState>,
    /// <p>Indicates the type of WorkSpace.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::StandbyWorkspaceRelationshipType>,
}
impl RelatedWorkspaceProperties {
    /// <p>The identifier of the related WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
    /// <p>The Region of the related WorkSpace.</p>
    pub fn region(&self) -> std::option::Option<&str> {
        self.region.as_deref()
    }
    /// <p>Indicates the state of the WorkSpace.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkspaceState> {
        self.state.as_ref()
    }
    /// <p>Indicates the type of WorkSpace.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::StandbyWorkspaceRelationshipType> {
        self.r#type.as_ref()
    }
}
/// See [`RelatedWorkspaceProperties`](crate::model::RelatedWorkspaceProperties).
pub mod related_workspace_properties {

    /// A builder for [`RelatedWorkspaceProperties`](crate::model::RelatedWorkspaceProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_id: std::option::Option<std::string::String>,
        pub(crate) region: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::WorkspaceState>,
        pub(crate) r#type: std::option::Option<crate::model::StandbyWorkspaceRelationshipType>,
    }
    impl Builder {
        /// <p>The identifier of the related WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the related WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// <p>The Region of the related WorkSpace.</p>
        pub fn region(mut self, input: impl Into<std::string::String>) -> Self {
            self.region = Some(input.into());
            self
        }
        /// <p>The Region of the related WorkSpace.</p>
        pub fn set_region(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.region = input;
            self
        }
        /// <p>Indicates the state of the WorkSpace.</p>
        pub fn state(mut self, input: crate::model::WorkspaceState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>Indicates the state of the WorkSpace.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkspaceState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Indicates the type of WorkSpace.</p>
        pub fn r#type(mut self, input: crate::model::StandbyWorkspaceRelationshipType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>Indicates the type of WorkSpace.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::StandbyWorkspaceRelationshipType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`RelatedWorkspaceProperties`](crate::model::RelatedWorkspaceProperties).
        pub fn build(self) -> crate::model::RelatedWorkspaceProperties {
            crate::model::RelatedWorkspaceProperties {
                workspace_id: self.workspace_id,
                region: self.region,
                state: self.state,
                r#type: self.r#type,
            }
        }
    }
}
impl RelatedWorkspaceProperties {
    /// Creates a new builder-style object to manufacture [`RelatedWorkspaceProperties`](crate::model::RelatedWorkspaceProperties).
    pub fn builder() -> crate::model::related_workspace_properties::Builder {
        crate::model::related_workspace_properties::Builder::default()
    }
}

/// When writing a match expression against `StandbyWorkspaceRelationshipType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let standbyworkspacerelationshiptype = unimplemented!();
/// match standbyworkspacerelationshiptype {
///     StandbyWorkspaceRelationshipType::Primary => { /* ... */ },
///     StandbyWorkspaceRelationshipType::Standby => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `standbyworkspacerelationshiptype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `StandbyWorkspaceRelationshipType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `StandbyWorkspaceRelationshipType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `StandbyWorkspaceRelationshipType::NewFeature` is defined.
/// Specifically, when `standbyworkspacerelationshiptype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `StandbyWorkspaceRelationshipType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum StandbyWorkspaceRelationshipType {
    #[allow(missing_docs)] // documentation missing in model
    Primary,
    #[allow(missing_docs)] // documentation missing in model
    Standby,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for StandbyWorkspaceRelationshipType {
    fn from(s: &str) -> Self {
        match s {
            "PRIMARY" => StandbyWorkspaceRelationshipType::Primary,
            "STANDBY" => StandbyWorkspaceRelationshipType::Standby,
            other => StandbyWorkspaceRelationshipType::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for StandbyWorkspaceRelationshipType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(StandbyWorkspaceRelationshipType::from(s))
    }
}
impl StandbyWorkspaceRelationshipType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            StandbyWorkspaceRelationshipType::Primary => "PRIMARY",
            StandbyWorkspaceRelationshipType::Standby => "STANDBY",
            StandbyWorkspaceRelationshipType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["PRIMARY", "STANDBY"]
    }
}
impl AsRef<str> for StandbyWorkspaceRelationshipType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WorkspaceState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workspacestate = unimplemented!();
/// match workspacestate {
///     WorkspaceState::AdminMaintenance => { /* ... */ },
///     WorkspaceState::Available => { /* ... */ },
///     WorkspaceState::Error => { /* ... */ },
///     WorkspaceState::Impaired => { /* ... */ },
///     WorkspaceState::Maintenance => { /* ... */ },
///     WorkspaceState::Pending => { /* ... */ },
///     WorkspaceState::Rebooting => { /* ... */ },
///     WorkspaceState::Rebuilding => { /* ... */ },
///     WorkspaceState::Restoring => { /* ... */ },
///     WorkspaceState::Starting => { /* ... */ },
///     WorkspaceState::Stopped => { /* ... */ },
///     WorkspaceState::Stopping => { /* ... */ },
///     WorkspaceState::Suspended => { /* ... */ },
///     WorkspaceState::Terminated => { /* ... */ },
///     WorkspaceState::Terminating => { /* ... */ },
///     WorkspaceState::Unhealthy => { /* ... */ },
///     WorkspaceState::Updating => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workspacestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkspaceState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkspaceState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkspaceState::NewFeature` is defined.
/// Specifically, when `workspacestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkspaceState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkspaceState {
    #[allow(missing_docs)] // documentation missing in model
    AdminMaintenance,
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Impaired,
    #[allow(missing_docs)] // documentation missing in model
    Maintenance,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    #[allow(missing_docs)] // documentation missing in model
    Rebooting,
    #[allow(missing_docs)] // documentation missing in model
    Rebuilding,
    #[allow(missing_docs)] // documentation missing in model
    Restoring,
    #[allow(missing_docs)] // documentation missing in model
    Starting,
    #[allow(missing_docs)] // documentation missing in model
    Stopped,
    #[allow(missing_docs)] // documentation missing in model
    Stopping,
    #[allow(missing_docs)] // documentation missing in model
    Suspended,
    #[allow(missing_docs)] // documentation missing in model
    Terminated,
    #[allow(missing_docs)] // documentation missing in model
    Terminating,
    #[allow(missing_docs)] // documentation missing in model
    Unhealthy,
    #[allow(missing_docs)] // documentation missing in model
    Updating,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkspaceState {
    fn from(s: &str) -> Self {
        match s {
            "ADMIN_MAINTENANCE" => WorkspaceState::AdminMaintenance,
            "AVAILABLE" => WorkspaceState::Available,
            "ERROR" => WorkspaceState::Error,
            "IMPAIRED" => WorkspaceState::Impaired,
            "MAINTENANCE" => WorkspaceState::Maintenance,
            "PENDING" => WorkspaceState::Pending,
            "REBOOTING" => WorkspaceState::Rebooting,
            "REBUILDING" => WorkspaceState::Rebuilding,
            "RESTORING" => WorkspaceState::Restoring,
            "STARTING" => WorkspaceState::Starting,
            "STOPPED" => WorkspaceState::Stopped,
            "STOPPING" => WorkspaceState::Stopping,
            "SUSPENDED" => WorkspaceState::Suspended,
            "TERMINATED" => WorkspaceState::Terminated,
            "TERMINATING" => WorkspaceState::Terminating,
            "UNHEALTHY" => WorkspaceState::Unhealthy,
            "UPDATING" => WorkspaceState::Updating,
            other => WorkspaceState::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for WorkspaceState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkspaceState::from(s))
    }
}
impl WorkspaceState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkspaceState::AdminMaintenance => "ADMIN_MAINTENANCE",
            WorkspaceState::Available => "AVAILABLE",
            WorkspaceState::Error => "ERROR",
            WorkspaceState::Impaired => "IMPAIRED",
            WorkspaceState::Maintenance => "MAINTENANCE",
            WorkspaceState::Pending => "PENDING",
            WorkspaceState::Rebooting => "REBOOTING",
            WorkspaceState::Rebuilding => "REBUILDING",
            WorkspaceState::Restoring => "RESTORING",
            WorkspaceState::Starting => "STARTING",
            WorkspaceState::Stopped => "STOPPED",
            WorkspaceState::Stopping => "STOPPING",
            WorkspaceState::Suspended => "SUSPENDED",
            WorkspaceState::Terminated => "TERMINATED",
            WorkspaceState::Terminating => "TERMINATING",
            WorkspaceState::Unhealthy => "UNHEALTHY",
            WorkspaceState::Updating => "UPDATING",
            WorkspaceState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ADMIN_MAINTENANCE",
            "AVAILABLE",
            "ERROR",
            "IMPAIRED",
            "MAINTENANCE",
            "PENDING",
            "REBOOTING",
            "REBUILDING",
            "RESTORING",
            "STARTING",
            "STOPPED",
            "STOPPING",
            "SUSPENDED",
            "TERMINATED",
            "TERMINATING",
            "UNHEALTHY",
            "UPDATING",
        ]
    }
}
impl AsRef<str> for WorkspaceState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a WorkSpace modification.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ModificationState {
    /// <p>The resource.</p>
    #[doc(hidden)]
    pub resource: std::option::Option<crate::model::ModificationResourceEnum>,
    /// <p>The modification state.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ModificationStateEnum>,
}
impl ModificationState {
    /// <p>The resource.</p>
    pub fn resource(&self) -> std::option::Option<&crate::model::ModificationResourceEnum> {
        self.resource.as_ref()
    }
    /// <p>The modification state.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ModificationStateEnum> {
        self.state.as_ref()
    }
}
/// See [`ModificationState`](crate::model::ModificationState).
pub mod modification_state {

    /// A builder for [`ModificationState`](crate::model::ModificationState).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource: std::option::Option<crate::model::ModificationResourceEnum>,
        pub(crate) state: std::option::Option<crate::model::ModificationStateEnum>,
    }
    impl Builder {
        /// <p>The resource.</p>
        pub fn resource(mut self, input: crate::model::ModificationResourceEnum) -> Self {
            self.resource = Some(input);
            self
        }
        /// <p>The resource.</p>
        pub fn set_resource(
            mut self,
            input: std::option::Option<crate::model::ModificationResourceEnum>,
        ) -> Self {
            self.resource = input;
            self
        }
        /// <p>The modification state.</p>
        pub fn state(mut self, input: crate::model::ModificationStateEnum) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The modification state.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ModificationStateEnum>,
        ) -> Self {
            self.state = input;
            self
        }
        /// Consumes the builder and constructs a [`ModificationState`](crate::model::ModificationState).
        pub fn build(self) -> crate::model::ModificationState {
            crate::model::ModificationState {
                resource: self.resource,
                state: self.state,
            }
        }
    }
}
impl ModificationState {
    /// Creates a new builder-style object to manufacture [`ModificationState`](crate::model::ModificationState).
    pub fn builder() -> crate::model::modification_state::Builder {
        crate::model::modification_state::Builder::default()
    }
}

/// When writing a match expression against `ModificationStateEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modificationstateenum = unimplemented!();
/// match modificationstateenum {
///     ModificationStateEnum::UpdateInitiated => { /* ... */ },
///     ModificationStateEnum::UpdateInProgress => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modificationstateenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModificationStateEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModificationStateEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModificationStateEnum::NewFeature` is defined.
/// Specifically, when `modificationstateenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModificationStateEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModificationStateEnum {
    #[allow(missing_docs)] // documentation missing in model
    UpdateInitiated,
    #[allow(missing_docs)] // documentation missing in model
    UpdateInProgress,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModificationStateEnum {
    fn from(s: &str) -> Self {
        match s {
            "UPDATE_INITIATED" => ModificationStateEnum::UpdateInitiated,
            "UPDATE_IN_PROGRESS" => ModificationStateEnum::UpdateInProgress,
            other => {
                ModificationStateEnum::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ModificationStateEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModificationStateEnum::from(s))
    }
}
impl ModificationStateEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModificationStateEnum::UpdateInitiated => "UPDATE_INITIATED",
            ModificationStateEnum::UpdateInProgress => "UPDATE_IN_PROGRESS",
            ModificationStateEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["UPDATE_INITIATED", "UPDATE_IN_PROGRESS"]
    }
}
impl AsRef<str> for ModificationStateEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ModificationResourceEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let modificationresourceenum = unimplemented!();
/// match modificationresourceenum {
///     ModificationResourceEnum::ComputeType => { /* ... */ },
///     ModificationResourceEnum::RootVolume => { /* ... */ },
///     ModificationResourceEnum::UserVolume => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `modificationresourceenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ModificationResourceEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ModificationResourceEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ModificationResourceEnum::NewFeature` is defined.
/// Specifically, when `modificationresourceenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ModificationResourceEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ModificationResourceEnum {
    #[allow(missing_docs)] // documentation missing in model
    ComputeType,
    #[allow(missing_docs)] // documentation missing in model
    RootVolume,
    #[allow(missing_docs)] // documentation missing in model
    UserVolume,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ModificationResourceEnum {
    fn from(s: &str) -> Self {
        match s {
            "COMPUTE_TYPE" => ModificationResourceEnum::ComputeType,
            "ROOT_VOLUME" => ModificationResourceEnum::RootVolume,
            "USER_VOLUME" => ModificationResourceEnum::UserVolume,
            other => ModificationResourceEnum::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for ModificationResourceEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ModificationResourceEnum::from(s))
    }
}
impl ModificationResourceEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ModificationResourceEnum::ComputeType => "COMPUTE_TYPE",
            ModificationResourceEnum::RootVolume => "ROOT_VOLUME",
            ModificationResourceEnum::UserVolume => "USER_VOLUME",
            ModificationResourceEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPUTE_TYPE", "ROOT_VOLUME", "USER_VOLUME"]
    }
}
impl AsRef<str> for ModificationResourceEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a WorkSpace image.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceImage {
    /// <p>The identifier of the image.</p>
    #[doc(hidden)]
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The name of the image.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The description of the image.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The operating system that the image is running. </p>
    #[doc(hidden)]
    pub operating_system: std::option::Option<crate::model::OperatingSystem>,
    /// <p>The status of the image.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::WorkspaceImageState>,
    /// <p>Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to <code>DEDICATED</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows Desktop Images</a>.</p>
    #[doc(hidden)]
    pub required_tenancy: std::option::Option<crate::model::WorkspaceImageRequiredTenancy>,
    /// <p>The error code that is returned for the image.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The text of the error message that is returned for the image.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
    /// <p>The date when the image was created. If the image has been shared, the Amazon Web Services account that the image has been shared with sees the original creation date of the image.</p>
    #[doc(hidden)]
    pub created: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The identifier of the Amazon Web Services account that owns the image.</p>
    #[doc(hidden)]
    pub owner_account_id: std::option::Option<std::string::String>,
    /// <p>The updates (if any) that are available for the specified image.</p>
    #[doc(hidden)]
    pub updates: std::option::Option<crate::model::UpdateResult>,
}
impl WorkspaceImage {
    /// <p>The identifier of the image.</p>
    pub fn image_id(&self) -> std::option::Option<&str> {
        self.image_id.as_deref()
    }
    /// <p>The name of the image.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The description of the image.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The operating system that the image is running. </p>
    pub fn operating_system(&self) -> std::option::Option<&crate::model::OperatingSystem> {
        self.operating_system.as_ref()
    }
    /// <p>The status of the image.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkspaceImageState> {
        self.state.as_ref()
    }
    /// <p>Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to <code>DEDICATED</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows Desktop Images</a>.</p>
    pub fn required_tenancy(
        &self,
    ) -> std::option::Option<&crate::model::WorkspaceImageRequiredTenancy> {
        self.required_tenancy.as_ref()
    }
    /// <p>The error code that is returned for the image.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The text of the error message that is returned for the image.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
    /// <p>The date when the image was created. If the image has been shared, the Amazon Web Services account that the image has been shared with sees the original creation date of the image.</p>
    pub fn created(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.created.as_ref()
    }
    /// <p>The identifier of the Amazon Web Services account that owns the image.</p>
    pub fn owner_account_id(&self) -> std::option::Option<&str> {
        self.owner_account_id.as_deref()
    }
    /// <p>The updates (if any) that are available for the specified image.</p>
    pub fn updates(&self) -> std::option::Option<&crate::model::UpdateResult> {
        self.updates.as_ref()
    }
}
/// See [`WorkspaceImage`](crate::model::WorkspaceImage).
pub mod workspace_image {

    /// A builder for [`WorkspaceImage`](crate::model::WorkspaceImage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) operating_system: std::option::Option<crate::model::OperatingSystem>,
        pub(crate) state: std::option::Option<crate::model::WorkspaceImageState>,
        pub(crate) required_tenancy:
            std::option::Option<crate::model::WorkspaceImageRequiredTenancy>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
        pub(crate) created: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) owner_account_id: std::option::Option<std::string::String>,
        pub(crate) updates: std::option::Option<crate::model::UpdateResult>,
    }
    impl Builder {
        /// <p>The identifier of the image.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        /// <p>The identifier of the image.</p>
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The name of the image.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the image.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The description of the image.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the image.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The operating system that the image is running. </p>
        pub fn operating_system(mut self, input: crate::model::OperatingSystem) -> Self {
            self.operating_system = Some(input);
            self
        }
        /// <p>The operating system that the image is running. </p>
        pub fn set_operating_system(
            mut self,
            input: std::option::Option<crate::model::OperatingSystem>,
        ) -> Self {
            self.operating_system = input;
            self
        }
        /// <p>The status of the image.</p>
        pub fn state(mut self, input: crate::model::WorkspaceImageState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The status of the image.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkspaceImageState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to <code>DEDICATED</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows Desktop Images</a>.</p>
        pub fn required_tenancy(
            mut self,
            input: crate::model::WorkspaceImageRequiredTenancy,
        ) -> Self {
            self.required_tenancy = Some(input);
            self
        }
        /// <p>Specifies whether the image is running on dedicated hardware. When Bring Your Own License (BYOL) is enabled, this value is set to <code>DEDICATED</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows Desktop Images</a>.</p>
        pub fn set_required_tenancy(
            mut self,
            input: std::option::Option<crate::model::WorkspaceImageRequiredTenancy>,
        ) -> Self {
            self.required_tenancy = input;
            self
        }
        /// <p>The error code that is returned for the image.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code that is returned for the image.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The text of the error message that is returned for the image.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The text of the error message that is returned for the image.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// <p>The date when the image was created. If the image has been shared, the Amazon Web Services account that the image has been shared with sees the original creation date of the image.</p>
        pub fn created(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.created = Some(input);
            self
        }
        /// <p>The date when the image was created. If the image has been shared, the Amazon Web Services account that the image has been shared with sees the original creation date of the image.</p>
        pub fn set_created(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.created = input;
            self
        }
        /// <p>The identifier of the Amazon Web Services account that owns the image.</p>
        pub fn owner_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Web Services account that owns the image.</p>
        pub fn set_owner_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.owner_account_id = input;
            self
        }
        /// <p>The updates (if any) that are available for the specified image.</p>
        pub fn updates(mut self, input: crate::model::UpdateResult) -> Self {
            self.updates = Some(input);
            self
        }
        /// <p>The updates (if any) that are available for the specified image.</p>
        pub fn set_updates(
            mut self,
            input: std::option::Option<crate::model::UpdateResult>,
        ) -> Self {
            self.updates = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspaceImage`](crate::model::WorkspaceImage).
        pub fn build(self) -> crate::model::WorkspaceImage {
            crate::model::WorkspaceImage {
                image_id: self.image_id,
                name: self.name,
                description: self.description,
                operating_system: self.operating_system,
                state: self.state,
                required_tenancy: self.required_tenancy,
                error_code: self.error_code,
                error_message: self.error_message,
                created: self.created,
                owner_account_id: self.owner_account_id,
                updates: self.updates,
            }
        }
    }
}
impl WorkspaceImage {
    /// Creates a new builder-style object to manufacture [`WorkspaceImage`](crate::model::WorkspaceImage).
    pub fn builder() -> crate::model::workspace_image::Builder {
        crate::model::workspace_image::Builder::default()
    }
}

/// <p>Describes whether a WorkSpace image needs to be updated with the latest drivers and other components required by Amazon WorkSpaces.</p> <note>
/// <p>Only Windows 10 WorkSpace images can be programmatically updated at this time.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UpdateResult {
    /// <p>Indicates whether updated drivers or other components are available for the specified WorkSpace image.</p>
    #[doc(hidden)]
    pub update_available: std::option::Option<bool>,
    /// <p>A description of whether updates for the WorkSpace image are pending or available.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
}
impl UpdateResult {
    /// <p>Indicates whether updated drivers or other components are available for the specified WorkSpace image.</p>
    pub fn update_available(&self) -> std::option::Option<bool> {
        self.update_available
    }
    /// <p>A description of whether updates for the WorkSpace image are pending or available.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
}
/// See [`UpdateResult`](crate::model::UpdateResult).
pub mod update_result {

    /// A builder for [`UpdateResult`](crate::model::UpdateResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) update_available: std::option::Option<bool>,
        pub(crate) description: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Indicates whether updated drivers or other components are available for the specified WorkSpace image.</p>
        pub fn update_available(mut self, input: bool) -> Self {
            self.update_available = Some(input);
            self
        }
        /// <p>Indicates whether updated drivers or other components are available for the specified WorkSpace image.</p>
        pub fn set_update_available(mut self, input: std::option::Option<bool>) -> Self {
            self.update_available = input;
            self
        }
        /// <p>A description of whether updates for the WorkSpace image are pending or available.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>A description of whether updates for the WorkSpace image are pending or available.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// Consumes the builder and constructs a [`UpdateResult`](crate::model::UpdateResult).
        pub fn build(self) -> crate::model::UpdateResult {
            crate::model::UpdateResult {
                update_available: self.update_available,
                description: self.description,
            }
        }
    }
}
impl UpdateResult {
    /// Creates a new builder-style object to manufacture [`UpdateResult`](crate::model::UpdateResult).
    pub fn builder() -> crate::model::update_result::Builder {
        crate::model::update_result::Builder::default()
    }
}

/// When writing a match expression against `WorkspaceImageRequiredTenancy`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workspaceimagerequiredtenancy = unimplemented!();
/// match workspaceimagerequiredtenancy {
///     WorkspaceImageRequiredTenancy::Dedicated => { /* ... */ },
///     WorkspaceImageRequiredTenancy::Default => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workspaceimagerequiredtenancy` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkspaceImageRequiredTenancy::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkspaceImageRequiredTenancy::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkspaceImageRequiredTenancy::NewFeature` is defined.
/// Specifically, when `workspaceimagerequiredtenancy` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkspaceImageRequiredTenancy::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkspaceImageRequiredTenancy {
    #[allow(missing_docs)] // documentation missing in model
    Dedicated,
    #[allow(missing_docs)] // documentation missing in model
    Default,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkspaceImageRequiredTenancy {
    fn from(s: &str) -> Self {
        match s {
            "DEDICATED" => WorkspaceImageRequiredTenancy::Dedicated,
            "DEFAULT" => WorkspaceImageRequiredTenancy::Default,
            other => WorkspaceImageRequiredTenancy::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for WorkspaceImageRequiredTenancy {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkspaceImageRequiredTenancy::from(s))
    }
}
impl WorkspaceImageRequiredTenancy {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkspaceImageRequiredTenancy::Dedicated => "DEDICATED",
            WorkspaceImageRequiredTenancy::Default => "DEFAULT",
            WorkspaceImageRequiredTenancy::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DEDICATED", "DEFAULT"]
    }
}
impl AsRef<str> for WorkspaceImageRequiredTenancy {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WorkspaceImageState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workspaceimagestate = unimplemented!();
/// match workspaceimagestate {
///     WorkspaceImageState::Available => { /* ... */ },
///     WorkspaceImageState::Error => { /* ... */ },
///     WorkspaceImageState::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workspaceimagestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkspaceImageState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkspaceImageState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkspaceImageState::NewFeature` is defined.
/// Specifically, when `workspaceimagestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkspaceImageState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkspaceImageState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkspaceImageState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => WorkspaceImageState::Available,
            "ERROR" => WorkspaceImageState::Error,
            "PENDING" => WorkspaceImageState::Pending,
            other => {
                WorkspaceImageState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WorkspaceImageState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkspaceImageState::from(s))
    }
}
impl WorkspaceImageState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkspaceImageState::Available => "AVAILABLE",
            WorkspaceImageState::Error => "ERROR",
            WorkspaceImageState::Pending => "PENDING",
            WorkspaceImageState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "ERROR", "PENDING"]
    }
}
impl AsRef<str> for WorkspaceImageState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>The operating system that the image is running.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OperatingSystem {
    /// <p>The operating system.</p>
    #[doc(hidden)]
    pub r#type: std::option::Option<crate::model::OperatingSystemType>,
}
impl OperatingSystem {
    /// <p>The operating system.</p>
    pub fn r#type(&self) -> std::option::Option<&crate::model::OperatingSystemType> {
        self.r#type.as_ref()
    }
}
/// See [`OperatingSystem`](crate::model::OperatingSystem).
pub mod operating_system {

    /// A builder for [`OperatingSystem`](crate::model::OperatingSystem).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) r#type: std::option::Option<crate::model::OperatingSystemType>,
    }
    impl Builder {
        /// <p>The operating system.</p>
        pub fn r#type(mut self, input: crate::model::OperatingSystemType) -> Self {
            self.r#type = Some(input);
            self
        }
        /// <p>The operating system.</p>
        pub fn set_type(
            mut self,
            input: std::option::Option<crate::model::OperatingSystemType>,
        ) -> Self {
            self.r#type = input;
            self
        }
        /// Consumes the builder and constructs a [`OperatingSystem`](crate::model::OperatingSystem).
        pub fn build(self) -> crate::model::OperatingSystem {
            crate::model::OperatingSystem {
                r#type: self.r#type,
            }
        }
    }
}
impl OperatingSystem {
    /// Creates a new builder-style object to manufacture [`OperatingSystem`](crate::model::OperatingSystem).
    pub fn builder() -> crate::model::operating_system::Builder {
        crate::model::operating_system::Builder::default()
    }
}

/// When writing a match expression against `OperatingSystemType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let operatingsystemtype = unimplemented!();
/// match operatingsystemtype {
///     OperatingSystemType::Linux => { /* ... */ },
///     OperatingSystemType::Windows => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `operatingsystemtype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `OperatingSystemType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `OperatingSystemType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `OperatingSystemType::NewFeature` is defined.
/// Specifically, when `operatingsystemtype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `OperatingSystemType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum OperatingSystemType {
    #[allow(missing_docs)] // documentation missing in model
    Linux,
    #[allow(missing_docs)] // documentation missing in model
    Windows,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for OperatingSystemType {
    fn from(s: &str) -> Self {
        match s {
            "LINUX" => OperatingSystemType::Linux,
            "WINDOWS" => OperatingSystemType::Windows,
            other => {
                OperatingSystemType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for OperatingSystemType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(OperatingSystemType::from(s))
    }
}
impl OperatingSystemType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            OperatingSystemType::Linux => "LINUX",
            OperatingSystemType::Windows => "WINDOWS",
            OperatingSystemType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["LINUX", "WINDOWS"]
    }
}
impl AsRef<str> for OperatingSystemType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ImageType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let imagetype = unimplemented!();
/// match imagetype {
///     ImageType::Owned => { /* ... */ },
///     ImageType::Shared => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `imagetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ImageType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ImageType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ImageType::NewFeature` is defined.
/// Specifically, when `imagetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ImageType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ImageType {
    #[allow(missing_docs)] // documentation missing in model
    Owned,
    #[allow(missing_docs)] // documentation missing in model
    Shared,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ImageType {
    fn from(s: &str) -> Self {
        match s {
            "OWNED" => ImageType::Owned,
            "SHARED" => ImageType::Shared,
            other => ImageType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ImageType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ImageType::from(s))
    }
}
impl ImageType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ImageType::Owned => "OWNED",
            ImageType::Shared => "SHARED",
            ImageType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["OWNED", "SHARED"]
    }
}
impl AsRef<str> for ImageType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the Amazon Web Services accounts that have been granted permission to use a shared image. For more information about sharing images, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/share-custom-image.html"> Share or Unshare a Custom WorkSpaces Image</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ImagePermission {
    /// <p>The identifier of the Amazon Web Services account that an image has been shared with.</p>
    #[doc(hidden)]
    pub shared_account_id: std::option::Option<std::string::String>,
}
impl ImagePermission {
    /// <p>The identifier of the Amazon Web Services account that an image has been shared with.</p>
    pub fn shared_account_id(&self) -> std::option::Option<&str> {
        self.shared_account_id.as_deref()
    }
}
/// See [`ImagePermission`](crate::model::ImagePermission).
pub mod image_permission {

    /// A builder for [`ImagePermission`](crate::model::ImagePermission).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) shared_account_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The identifier of the Amazon Web Services account that an image has been shared with.</p>
        pub fn shared_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.shared_account_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Web Services account that an image has been shared with.</p>
        pub fn set_shared_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.shared_account_id = input;
            self
        }
        /// Consumes the builder and constructs a [`ImagePermission`](crate::model::ImagePermission).
        pub fn build(self) -> crate::model::ImagePermission {
            crate::model::ImagePermission {
                shared_account_id: self.shared_account_id,
            }
        }
    }
}
impl ImagePermission {
    /// Creates a new builder-style object to manufacture [`ImagePermission`](crate::model::ImagePermission).
    pub fn builder() -> crate::model::image_permission::Builder {
        crate::model::image_permission::Builder::default()
    }
}

/// <p>Describes a directory that is used with Amazon WorkSpaces.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceDirectory {
    /// <p>The directory identifier.</p>
    #[doc(hidden)]
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The directory alias.</p>
    #[doc(hidden)]
    pub alias: std::option::Option<std::string::String>,
    /// <p>The name of the directory.</p>
    #[doc(hidden)]
    pub directory_name: std::option::Option<std::string::String>,
    /// <p>The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.</p>
    #[doc(hidden)]
    pub registration_code: std::option::Option<std::string::String>,
    /// <p>The identifiers of the subnets used with the directory.</p>
    #[doc(hidden)]
    pub subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The IP addresses of the DNS servers for the directory.</p>
    #[doc(hidden)]
    pub dns_ip_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The user name for the service account.</p>
    #[doc(hidden)]
    pub customer_user_name: std::option::Option<std::string::String>,
    /// <p>The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.</p>
    #[doc(hidden)]
    pub iam_role_id: std::option::Option<std::string::String>,
    /// <p>The directory type.</p>
    #[doc(hidden)]
    pub directory_type: std::option::Option<crate::model::WorkspaceDirectoryType>,
    /// <p>The identifier of the security group that is assigned to new WorkSpaces.</p>
    #[doc(hidden)]
    pub workspace_security_group_id: std::option::Option<std::string::String>,
    /// <p>The state of the directory's registration with Amazon WorkSpaces. After a directory is deregistered, the <code>DEREGISTERED</code> state is returned very briefly before the directory metadata is cleaned up, so this state is rarely returned. To confirm that a directory is deregistered, check for the directory ID by using <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceDirectories.html"> DescribeWorkspaceDirectories</a>. If the directory ID isn't returned, then the directory has been successfully deregistered.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::WorkspaceDirectoryState>,
    /// <p>The default creation properties for all WorkSpaces in the directory.</p>
    #[doc(hidden)]
    pub workspace_creation_properties:
        std::option::Option<crate::model::DefaultWorkspaceCreationProperties>,
    /// <p>The identifiers of the IP access control groups associated with the directory.</p>
    #[doc(hidden)]
    pub ip_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
    /// <p>The devices and operating systems that users can use to access WorkSpaces.</p>
    #[doc(hidden)]
    pub workspace_access_properties: std::option::Option<crate::model::WorkspaceAccessProperties>,
    /// <p>Specifies whether the directory is dedicated or shared. To use Bring Your Own License (BYOL), this value must be set to <code>DEDICATED</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows Desktop Images</a>.</p>
    #[doc(hidden)]
    pub tenancy: std::option::Option<crate::model::Tenancy>,
    /// <p>The default self-service permissions for WorkSpaces in the directory.</p>
    #[doc(hidden)]
    pub selfservice_permissions: std::option::Option<crate::model::SelfservicePermissions>,
    /// <p>Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.</p>
    #[doc(hidden)]
    pub saml_properties: std::option::Option<crate::model::SamlProperties>,
    /// <p>The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory for WorkSpaces login.</p>
    #[doc(hidden)]
    pub certificate_based_auth_properties:
        std::option::Option<crate::model::CertificateBasedAuthProperties>,
}
impl WorkspaceDirectory {
    /// <p>The directory identifier.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>The directory alias.</p>
    pub fn alias(&self) -> std::option::Option<&str> {
        self.alias.as_deref()
    }
    /// <p>The name of the directory.</p>
    pub fn directory_name(&self) -> std::option::Option<&str> {
        self.directory_name.as_deref()
    }
    /// <p>The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.</p>
    pub fn registration_code(&self) -> std::option::Option<&str> {
        self.registration_code.as_deref()
    }
    /// <p>The identifiers of the subnets used with the directory.</p>
    pub fn subnet_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.subnet_ids.as_deref()
    }
    /// <p>The IP addresses of the DNS servers for the directory.</p>
    pub fn dns_ip_addresses(&self) -> std::option::Option<&[std::string::String]> {
        self.dns_ip_addresses.as_deref()
    }
    /// <p>The user name for the service account.</p>
    pub fn customer_user_name(&self) -> std::option::Option<&str> {
        self.customer_user_name.as_deref()
    }
    /// <p>The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.</p>
    pub fn iam_role_id(&self) -> std::option::Option<&str> {
        self.iam_role_id.as_deref()
    }
    /// <p>The directory type.</p>
    pub fn directory_type(&self) -> std::option::Option<&crate::model::WorkspaceDirectoryType> {
        self.directory_type.as_ref()
    }
    /// <p>The identifier of the security group that is assigned to new WorkSpaces.</p>
    pub fn workspace_security_group_id(&self) -> std::option::Option<&str> {
        self.workspace_security_group_id.as_deref()
    }
    /// <p>The state of the directory's registration with Amazon WorkSpaces. After a directory is deregistered, the <code>DEREGISTERED</code> state is returned very briefly before the directory metadata is cleaned up, so this state is rarely returned. To confirm that a directory is deregistered, check for the directory ID by using <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceDirectories.html"> DescribeWorkspaceDirectories</a>. If the directory ID isn't returned, then the directory has been successfully deregistered.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkspaceDirectoryState> {
        self.state.as_ref()
    }
    /// <p>The default creation properties for all WorkSpaces in the directory.</p>
    pub fn workspace_creation_properties(
        &self,
    ) -> std::option::Option<&crate::model::DefaultWorkspaceCreationProperties> {
        self.workspace_creation_properties.as_ref()
    }
    /// <p>The identifiers of the IP access control groups associated with the directory.</p>
    pub fn ip_group_ids(&self) -> std::option::Option<&[std::string::String]> {
        self.ip_group_ids.as_deref()
    }
    /// <p>The devices and operating systems that users can use to access WorkSpaces.</p>
    pub fn workspace_access_properties(
        &self,
    ) -> std::option::Option<&crate::model::WorkspaceAccessProperties> {
        self.workspace_access_properties.as_ref()
    }
    /// <p>Specifies whether the directory is dedicated or shared. To use Bring Your Own License (BYOL), this value must be set to <code>DEDICATED</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows Desktop Images</a>.</p>
    pub fn tenancy(&self) -> std::option::Option<&crate::model::Tenancy> {
        self.tenancy.as_ref()
    }
    /// <p>The default self-service permissions for WorkSpaces in the directory.</p>
    pub fn selfservice_permissions(
        &self,
    ) -> std::option::Option<&crate::model::SelfservicePermissions> {
        self.selfservice_permissions.as_ref()
    }
    /// <p>Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.</p>
    pub fn saml_properties(&self) -> std::option::Option<&crate::model::SamlProperties> {
        self.saml_properties.as_ref()
    }
    /// <p>The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory for WorkSpaces login.</p>
    pub fn certificate_based_auth_properties(
        &self,
    ) -> std::option::Option<&crate::model::CertificateBasedAuthProperties> {
        self.certificate_based_auth_properties.as_ref()
    }
}
/// See [`WorkspaceDirectory`](crate::model::WorkspaceDirectory).
pub mod workspace_directory {

    /// A builder for [`WorkspaceDirectory`](crate::model::WorkspaceDirectory).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) alias: std::option::Option<std::string::String>,
        pub(crate) directory_name: std::option::Option<std::string::String>,
        pub(crate) registration_code: std::option::Option<std::string::String>,
        pub(crate) subnet_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) dns_ip_addresses: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) customer_user_name: std::option::Option<std::string::String>,
        pub(crate) iam_role_id: std::option::Option<std::string::String>,
        pub(crate) directory_type: std::option::Option<crate::model::WorkspaceDirectoryType>,
        pub(crate) workspace_security_group_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::WorkspaceDirectoryState>,
        pub(crate) workspace_creation_properties:
            std::option::Option<crate::model::DefaultWorkspaceCreationProperties>,
        pub(crate) ip_group_ids: std::option::Option<std::vec::Vec<std::string::String>>,
        pub(crate) workspace_access_properties:
            std::option::Option<crate::model::WorkspaceAccessProperties>,
        pub(crate) tenancy: std::option::Option<crate::model::Tenancy>,
        pub(crate) selfservice_permissions:
            std::option::Option<crate::model::SelfservicePermissions>,
        pub(crate) saml_properties: std::option::Option<crate::model::SamlProperties>,
        pub(crate) certificate_based_auth_properties:
            std::option::Option<crate::model::CertificateBasedAuthProperties>,
    }
    impl Builder {
        /// <p>The directory identifier.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The directory identifier.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The directory alias.</p>
        pub fn alias(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias = Some(input.into());
            self
        }
        /// <p>The directory alias.</p>
        pub fn set_alias(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias = input;
            self
        }
        /// <p>The name of the directory.</p>
        pub fn directory_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_name = Some(input.into());
            self
        }
        /// <p>The name of the directory.</p>
        pub fn set_directory_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.directory_name = input;
            self
        }
        /// <p>The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.</p>
        pub fn registration_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.registration_code = Some(input.into());
            self
        }
        /// <p>The registration code for the directory. This is the code that users enter in their Amazon WorkSpaces client application to connect to the directory.</p>
        pub fn set_registration_code(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.registration_code = input;
            self
        }
        /// Appends an item to `subnet_ids`.
        ///
        /// To override the contents of this collection use [`set_subnet_ids`](Self::set_subnet_ids).
        ///
        /// <p>The identifiers of the subnets used with the directory.</p>
        pub fn subnet_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.subnet_ids.unwrap_or_default();
            v.push(input.into());
            self.subnet_ids = Some(v);
            self
        }
        /// <p>The identifiers of the subnets used with the directory.</p>
        pub fn set_subnet_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.subnet_ids = input;
            self
        }
        /// Appends an item to `dns_ip_addresses`.
        ///
        /// To override the contents of this collection use [`set_dns_ip_addresses`](Self::set_dns_ip_addresses).
        ///
        /// <p>The IP addresses of the DNS servers for the directory.</p>
        pub fn dns_ip_addresses(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.dns_ip_addresses.unwrap_or_default();
            v.push(input.into());
            self.dns_ip_addresses = Some(v);
            self
        }
        /// <p>The IP addresses of the DNS servers for the directory.</p>
        pub fn set_dns_ip_addresses(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.dns_ip_addresses = input;
            self
        }
        /// <p>The user name for the service account.</p>
        pub fn customer_user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.customer_user_name = Some(input.into());
            self
        }
        /// <p>The user name for the service account.</p>
        pub fn set_customer_user_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.customer_user_name = input;
            self
        }
        /// <p>The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.</p>
        pub fn iam_role_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.iam_role_id = Some(input.into());
            self
        }
        /// <p>The identifier of the IAM role. This is the role that allows Amazon WorkSpaces to make calls to other services, such as Amazon EC2, on your behalf.</p>
        pub fn set_iam_role_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.iam_role_id = input;
            self
        }
        /// <p>The directory type.</p>
        pub fn directory_type(mut self, input: crate::model::WorkspaceDirectoryType) -> Self {
            self.directory_type = Some(input);
            self
        }
        /// <p>The directory type.</p>
        pub fn set_directory_type(
            mut self,
            input: std::option::Option<crate::model::WorkspaceDirectoryType>,
        ) -> Self {
            self.directory_type = input;
            self
        }
        /// <p>The identifier of the security group that is assigned to new WorkSpaces.</p>
        pub fn workspace_security_group_id(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.workspace_security_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the security group that is assigned to new WorkSpaces.</p>
        pub fn set_workspace_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.workspace_security_group_id = input;
            self
        }
        /// <p>The state of the directory's registration with Amazon WorkSpaces. After a directory is deregistered, the <code>DEREGISTERED</code> state is returned very briefly before the directory metadata is cleaned up, so this state is rarely returned. To confirm that a directory is deregistered, check for the directory ID by using <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceDirectories.html"> DescribeWorkspaceDirectories</a>. If the directory ID isn't returned, then the directory has been successfully deregistered.</p>
        pub fn state(mut self, input: crate::model::WorkspaceDirectoryState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the directory's registration with Amazon WorkSpaces. After a directory is deregistered, the <code>DEREGISTERED</code> state is returned very briefly before the directory metadata is cleaned up, so this state is rarely returned. To confirm that a directory is deregistered, check for the directory ID by using <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceDirectories.html"> DescribeWorkspaceDirectories</a>. If the directory ID isn't returned, then the directory has been successfully deregistered.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkspaceDirectoryState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The default creation properties for all WorkSpaces in the directory.</p>
        pub fn workspace_creation_properties(
            mut self,
            input: crate::model::DefaultWorkspaceCreationProperties,
        ) -> Self {
            self.workspace_creation_properties = Some(input);
            self
        }
        /// <p>The default creation properties for all WorkSpaces in the directory.</p>
        pub fn set_workspace_creation_properties(
            mut self,
            input: std::option::Option<crate::model::DefaultWorkspaceCreationProperties>,
        ) -> Self {
            self.workspace_creation_properties = input;
            self
        }
        /// Appends an item to `ip_group_ids`.
        ///
        /// To override the contents of this collection use [`set_ip_group_ids`](Self::set_ip_group_ids).
        ///
        /// <p>The identifiers of the IP access control groups associated with the directory.</p>
        pub fn ip_group_ids(mut self, input: impl Into<std::string::String>) -> Self {
            let mut v = self.ip_group_ids.unwrap_or_default();
            v.push(input.into());
            self.ip_group_ids = Some(v);
            self
        }
        /// <p>The identifiers of the IP access control groups associated with the directory.</p>
        pub fn set_ip_group_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.ip_group_ids = input;
            self
        }
        /// <p>The devices and operating systems that users can use to access WorkSpaces.</p>
        pub fn workspace_access_properties(
            mut self,
            input: crate::model::WorkspaceAccessProperties,
        ) -> Self {
            self.workspace_access_properties = Some(input);
            self
        }
        /// <p>The devices and operating systems that users can use to access WorkSpaces.</p>
        pub fn set_workspace_access_properties(
            mut self,
            input: std::option::Option<crate::model::WorkspaceAccessProperties>,
        ) -> Self {
            self.workspace_access_properties = input;
            self
        }
        /// <p>Specifies whether the directory is dedicated or shared. To use Bring Your Own License (BYOL), this value must be set to <code>DEDICATED</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows Desktop Images</a>.</p>
        pub fn tenancy(mut self, input: crate::model::Tenancy) -> Self {
            self.tenancy = Some(input);
            self
        }
        /// <p>Specifies whether the directory is dedicated or shared. To use Bring Your Own License (BYOL), this value must be set to <code>DEDICATED</code>. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">Bring Your Own Windows Desktop Images</a>.</p>
        pub fn set_tenancy(mut self, input: std::option::Option<crate::model::Tenancy>) -> Self {
            self.tenancy = input;
            self
        }
        /// <p>The default self-service permissions for WorkSpaces in the directory.</p>
        pub fn selfservice_permissions(
            mut self,
            input: crate::model::SelfservicePermissions,
        ) -> Self {
            self.selfservice_permissions = Some(input);
            self
        }
        /// <p>The default self-service permissions for WorkSpaces in the directory.</p>
        pub fn set_selfservice_permissions(
            mut self,
            input: std::option::Option<crate::model::SelfservicePermissions>,
        ) -> Self {
            self.selfservice_permissions = input;
            self
        }
        /// <p>Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.</p>
        pub fn saml_properties(mut self, input: crate::model::SamlProperties) -> Self {
            self.saml_properties = Some(input);
            self
        }
        /// <p>Describes the enablement status, user access URL, and relay state parameter name that are used for configuring federation with an SAML 2.0 identity provider.</p>
        pub fn set_saml_properties(
            mut self,
            input: std::option::Option<crate::model::SamlProperties>,
        ) -> Self {
            self.saml_properties = input;
            self
        }
        /// <p>The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory for WorkSpaces login.</p>
        pub fn certificate_based_auth_properties(
            mut self,
            input: crate::model::CertificateBasedAuthProperties,
        ) -> Self {
            self.certificate_based_auth_properties = Some(input);
            self
        }
        /// <p>The certificate-based authentication properties used to authenticate SAML 2.0 Identity Provider (IdP) user identities to Active Directory for WorkSpaces login.</p>
        pub fn set_certificate_based_auth_properties(
            mut self,
            input: std::option::Option<crate::model::CertificateBasedAuthProperties>,
        ) -> Self {
            self.certificate_based_auth_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspaceDirectory`](crate::model::WorkspaceDirectory).
        pub fn build(self) -> crate::model::WorkspaceDirectory {
            crate::model::WorkspaceDirectory {
                directory_id: self.directory_id,
                alias: self.alias,
                directory_name: self.directory_name,
                registration_code: self.registration_code,
                subnet_ids: self.subnet_ids,
                dns_ip_addresses: self.dns_ip_addresses,
                customer_user_name: self.customer_user_name,
                iam_role_id: self.iam_role_id,
                directory_type: self.directory_type,
                workspace_security_group_id: self.workspace_security_group_id,
                state: self.state,
                workspace_creation_properties: self.workspace_creation_properties,
                ip_group_ids: self.ip_group_ids,
                workspace_access_properties: self.workspace_access_properties,
                tenancy: self.tenancy,
                selfservice_permissions: self.selfservice_permissions,
                saml_properties: self.saml_properties,
                certificate_based_auth_properties: self.certificate_based_auth_properties,
            }
        }
    }
}
impl WorkspaceDirectory {
    /// Creates a new builder-style object to manufacture [`WorkspaceDirectory`](crate::model::WorkspaceDirectory).
    pub fn builder() -> crate::model::workspace_directory::Builder {
        crate::model::workspace_directory::Builder::default()
    }
}

/// <p>Describes the default values that are used to create WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html">Update Directory Details for Your WorkSpaces</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultWorkspaceCreationProperties {
    /// <p>Specifies whether the directory is enabled for Amazon WorkDocs.</p>
    #[doc(hidden)]
    pub enable_work_docs: std::option::Option<bool>,
    /// <p>Specifies whether to automatically assign an Elastic public IP address to WorkSpaces in this directory by default. If enabled, the Elastic public IP address allows outbound internet access from your WorkSpaces when you’re using an internet gateway in the Amazon VPC in which your WorkSpaces are located. If you're using a Network Address Translation (NAT) gateway for outbound internet access from your VPC, or if your WorkSpaces are in public subnets and you manually assign them Elastic IP addresses, you should disable this setting. This setting applies to new WorkSpaces that you launch or to existing WorkSpaces that you rebuild. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html"> Configure a VPC for Amazon WorkSpaces</a>.</p>
    #[doc(hidden)]
    pub enable_internet_access: std::option::Option<bool>,
    /// <p>The organizational unit (OU) in the directory for the WorkSpace machine accounts.</p>
    #[doc(hidden)]
    pub default_ou: std::option::Option<std::string::String>,
    /// <p>The identifier of the default security group to apply to WorkSpaces when they are created. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-security-groups.html"> Security Groups for Your WorkSpaces</a>.</p>
    #[doc(hidden)]
    pub custom_security_group_id: std::option::Option<std::string::String>,
    /// <p>Specifies whether WorkSpace users are local administrators on their WorkSpaces.</p>
    #[doc(hidden)]
    pub user_enabled_as_local_administrator: std::option::Option<bool>,
    /// <p>Specifies whether maintenance mode is enabled for WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace Maintenance</a>.</p>
    #[doc(hidden)]
    pub enable_maintenance_mode: std::option::Option<bool>,
}
impl DefaultWorkspaceCreationProperties {
    /// <p>Specifies whether the directory is enabled for Amazon WorkDocs.</p>
    pub fn enable_work_docs(&self) -> std::option::Option<bool> {
        self.enable_work_docs
    }
    /// <p>Specifies whether to automatically assign an Elastic public IP address to WorkSpaces in this directory by default. If enabled, the Elastic public IP address allows outbound internet access from your WorkSpaces when you’re using an internet gateway in the Amazon VPC in which your WorkSpaces are located. If you're using a Network Address Translation (NAT) gateway for outbound internet access from your VPC, or if your WorkSpaces are in public subnets and you manually assign them Elastic IP addresses, you should disable this setting. This setting applies to new WorkSpaces that you launch or to existing WorkSpaces that you rebuild. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html"> Configure a VPC for Amazon WorkSpaces</a>.</p>
    pub fn enable_internet_access(&self) -> std::option::Option<bool> {
        self.enable_internet_access
    }
    /// <p>The organizational unit (OU) in the directory for the WorkSpace machine accounts.</p>
    pub fn default_ou(&self) -> std::option::Option<&str> {
        self.default_ou.as_deref()
    }
    /// <p>The identifier of the default security group to apply to WorkSpaces when they are created. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-security-groups.html"> Security Groups for Your WorkSpaces</a>.</p>
    pub fn custom_security_group_id(&self) -> std::option::Option<&str> {
        self.custom_security_group_id.as_deref()
    }
    /// <p>Specifies whether WorkSpace users are local administrators on their WorkSpaces.</p>
    pub fn user_enabled_as_local_administrator(&self) -> std::option::Option<bool> {
        self.user_enabled_as_local_administrator
    }
    /// <p>Specifies whether maintenance mode is enabled for WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace Maintenance</a>.</p>
    pub fn enable_maintenance_mode(&self) -> std::option::Option<bool> {
        self.enable_maintenance_mode
    }
}
/// See [`DefaultWorkspaceCreationProperties`](crate::model::DefaultWorkspaceCreationProperties).
pub mod default_workspace_creation_properties {

    /// A builder for [`DefaultWorkspaceCreationProperties`](crate::model::DefaultWorkspaceCreationProperties).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) enable_work_docs: std::option::Option<bool>,
        pub(crate) enable_internet_access: std::option::Option<bool>,
        pub(crate) default_ou: std::option::Option<std::string::String>,
        pub(crate) custom_security_group_id: std::option::Option<std::string::String>,
        pub(crate) user_enabled_as_local_administrator: std::option::Option<bool>,
        pub(crate) enable_maintenance_mode: std::option::Option<bool>,
    }
    impl Builder {
        /// <p>Specifies whether the directory is enabled for Amazon WorkDocs.</p>
        pub fn enable_work_docs(mut self, input: bool) -> Self {
            self.enable_work_docs = Some(input);
            self
        }
        /// <p>Specifies whether the directory is enabled for Amazon WorkDocs.</p>
        pub fn set_enable_work_docs(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_work_docs = input;
            self
        }
        /// <p>Specifies whether to automatically assign an Elastic public IP address to WorkSpaces in this directory by default. If enabled, the Elastic public IP address allows outbound internet access from your WorkSpaces when you’re using an internet gateway in the Amazon VPC in which your WorkSpaces are located. If you're using a Network Address Translation (NAT) gateway for outbound internet access from your VPC, or if your WorkSpaces are in public subnets and you manually assign them Elastic IP addresses, you should disable this setting. This setting applies to new WorkSpaces that you launch or to existing WorkSpaces that you rebuild. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html"> Configure a VPC for Amazon WorkSpaces</a>.</p>
        pub fn enable_internet_access(mut self, input: bool) -> Self {
            self.enable_internet_access = Some(input);
            self
        }
        /// <p>Specifies whether to automatically assign an Elastic public IP address to WorkSpaces in this directory by default. If enabled, the Elastic public IP address allows outbound internet access from your WorkSpaces when you’re using an internet gateway in the Amazon VPC in which your WorkSpaces are located. If you're using a Network Address Translation (NAT) gateway for outbound internet access from your VPC, or if your WorkSpaces are in public subnets and you manually assign them Elastic IP addresses, you should disable this setting. This setting applies to new WorkSpaces that you launch or to existing WorkSpaces that you rebuild. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-vpc.html"> Configure a VPC for Amazon WorkSpaces</a>.</p>
        pub fn set_enable_internet_access(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_internet_access = input;
            self
        }
        /// <p>The organizational unit (OU) in the directory for the WorkSpace machine accounts.</p>
        pub fn default_ou(mut self, input: impl Into<std::string::String>) -> Self {
            self.default_ou = Some(input.into());
            self
        }
        /// <p>The organizational unit (OU) in the directory for the WorkSpace machine accounts.</p>
        pub fn set_default_ou(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.default_ou = input;
            self
        }
        /// <p>The identifier of the default security group to apply to WorkSpaces when they are created. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-security-groups.html"> Security Groups for Your WorkSpaces</a>.</p>
        pub fn custom_security_group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.custom_security_group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the default security group to apply to WorkSpaces when they are created. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/amazon-workspaces-security-groups.html"> Security Groups for Your WorkSpaces</a>.</p>
        pub fn set_custom_security_group_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.custom_security_group_id = input;
            self
        }
        /// <p>Specifies whether WorkSpace users are local administrators on their WorkSpaces.</p>
        pub fn user_enabled_as_local_administrator(mut self, input: bool) -> Self {
            self.user_enabled_as_local_administrator = Some(input);
            self
        }
        /// <p>Specifies whether WorkSpace users are local administrators on their WorkSpaces.</p>
        pub fn set_user_enabled_as_local_administrator(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.user_enabled_as_local_administrator = input;
            self
        }
        /// <p>Specifies whether maintenance mode is enabled for WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace Maintenance</a>.</p>
        pub fn enable_maintenance_mode(mut self, input: bool) -> Self {
            self.enable_maintenance_mode = Some(input);
            self
        }
        /// <p>Specifies whether maintenance mode is enabled for WorkSpaces. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspace-maintenance.html">WorkSpace Maintenance</a>.</p>
        pub fn set_enable_maintenance_mode(mut self, input: std::option::Option<bool>) -> Self {
            self.enable_maintenance_mode = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultWorkspaceCreationProperties`](crate::model::DefaultWorkspaceCreationProperties).
        pub fn build(self) -> crate::model::DefaultWorkspaceCreationProperties {
            crate::model::DefaultWorkspaceCreationProperties {
                enable_work_docs: self.enable_work_docs,
                enable_internet_access: self.enable_internet_access,
                default_ou: self.default_ou,
                custom_security_group_id: self.custom_security_group_id,
                user_enabled_as_local_administrator: self.user_enabled_as_local_administrator,
                enable_maintenance_mode: self.enable_maintenance_mode,
            }
        }
    }
}
impl DefaultWorkspaceCreationProperties {
    /// Creates a new builder-style object to manufacture [`DefaultWorkspaceCreationProperties`](crate::model::DefaultWorkspaceCreationProperties).
    pub fn builder() -> crate::model::default_workspace_creation_properties::Builder {
        crate::model::default_workspace_creation_properties::Builder::default()
    }
}

/// When writing a match expression against `WorkspaceDirectoryState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workspacedirectorystate = unimplemented!();
/// match workspacedirectorystate {
///     WorkspaceDirectoryState::Deregistered => { /* ... */ },
///     WorkspaceDirectoryState::Deregistering => { /* ... */ },
///     WorkspaceDirectoryState::Error => { /* ... */ },
///     WorkspaceDirectoryState::Registered => { /* ... */ },
///     WorkspaceDirectoryState::Registering => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workspacedirectorystate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkspaceDirectoryState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkspaceDirectoryState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkspaceDirectoryState::NewFeature` is defined.
/// Specifically, when `workspacedirectorystate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkspaceDirectoryState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkspaceDirectoryState {
    #[allow(missing_docs)] // documentation missing in model
    Deregistered,
    #[allow(missing_docs)] // documentation missing in model
    Deregistering,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Registered,
    #[allow(missing_docs)] // documentation missing in model
    Registering,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkspaceDirectoryState {
    fn from(s: &str) -> Self {
        match s {
            "DEREGISTERED" => WorkspaceDirectoryState::Deregistered,
            "DEREGISTERING" => WorkspaceDirectoryState::Deregistering,
            "ERROR" => WorkspaceDirectoryState::Error,
            "REGISTERED" => WorkspaceDirectoryState::Registered,
            "REGISTERING" => WorkspaceDirectoryState::Registering,
            other => WorkspaceDirectoryState::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for WorkspaceDirectoryState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkspaceDirectoryState::from(s))
    }
}
impl WorkspaceDirectoryState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkspaceDirectoryState::Deregistered => "DEREGISTERED",
            WorkspaceDirectoryState::Deregistering => "DEREGISTERING",
            WorkspaceDirectoryState::Error => "ERROR",
            WorkspaceDirectoryState::Registered => "REGISTERED",
            WorkspaceDirectoryState::Registering => "REGISTERING",
            WorkspaceDirectoryState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DEREGISTERED",
            "DEREGISTERING",
            "ERROR",
            "REGISTERED",
            "REGISTERING",
        ]
    }
}
impl AsRef<str> for WorkspaceDirectoryState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WorkspaceDirectoryType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workspacedirectorytype = unimplemented!();
/// match workspacedirectorytype {
///     WorkspaceDirectoryType::AdConnector => { /* ... */ },
///     WorkspaceDirectoryType::SimpleAd => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workspacedirectorytype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkspaceDirectoryType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkspaceDirectoryType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkspaceDirectoryType::NewFeature` is defined.
/// Specifically, when `workspacedirectorytype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkspaceDirectoryType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkspaceDirectoryType {
    #[allow(missing_docs)] // documentation missing in model
    AdConnector,
    #[allow(missing_docs)] // documentation missing in model
    SimpleAd,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkspaceDirectoryType {
    fn from(s: &str) -> Self {
        match s {
            "AD_CONNECTOR" => WorkspaceDirectoryType::AdConnector,
            "SIMPLE_AD" => WorkspaceDirectoryType::SimpleAd,
            other => {
                WorkspaceDirectoryType::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WorkspaceDirectoryType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkspaceDirectoryType::from(s))
    }
}
impl WorkspaceDirectoryType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkspaceDirectoryType::AdConnector => "AD_CONNECTOR",
            WorkspaceDirectoryType::SimpleAd => "SIMPLE_AD",
            WorkspaceDirectoryType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AD_CONNECTOR", "SIMPLE_AD"]
    }
}
impl AsRef<str> for WorkspaceDirectoryType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a WorkSpace bundle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceBundle {
    /// <p>The identifier of the bundle.</p>
    #[doc(hidden)]
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>The name of the bundle.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The owner of the bundle. This is the account identifier of the owner, or <code>AMAZON</code> if the bundle is provided by Amazon Web Services.</p>
    #[doc(hidden)]
    pub owner: std::option::Option<std::string::String>,
    /// <p>The description of the bundle.</p>
    #[doc(hidden)]
    pub description: std::option::Option<std::string::String>,
    /// <p>The identifier of the image that was used to create the bundle.</p>
    #[doc(hidden)]
    pub image_id: std::option::Option<std::string::String>,
    /// <p>The size of the root volume.</p>
    #[doc(hidden)]
    pub root_storage: std::option::Option<crate::model::RootStorage>,
    /// <p>The size of the user volume.</p>
    #[doc(hidden)]
    pub user_storage: std::option::Option<crate::model::UserStorage>,
    /// <p>The compute type of the bundle. For more information, see <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces Bundles</a>.</p>
    #[doc(hidden)]
    pub compute_type: std::option::Option<crate::model::ComputeType>,
    /// <p>The last time that the bundle was updated.</p>
    #[doc(hidden)]
    pub last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The time when the bundle was created.</p>
    #[doc(hidden)]
    pub creation_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The state of the WorkSpace bundle.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::WorkspaceBundleState>,
    /// <p>The type of WorkSpace bundle.</p>
    #[doc(hidden)]
    pub bundle_type: std::option::Option<crate::model::BundleType>,
}
impl WorkspaceBundle {
    /// <p>The identifier of the bundle.</p>
    pub fn bundle_id(&self) -> std::option::Option<&str> {
        self.bundle_id.as_deref()
    }
    /// <p>The name of the bundle.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The owner of the bundle. This is the account identifier of the owner, or <code>AMAZON</code> if the bundle is provided by Amazon Web Services.</p>
    pub fn owner(&self) -> std::option::Option<&str> {
        self.owner.as_deref()
    }
    /// <p>The description of the bundle.</p>
    pub fn description(&self) -> std::option::Option<&str> {
        self.description.as_deref()
    }
    /// <p>The identifier of the image that was used to create the bundle.</p>
    pub fn image_id(&self) -> std::option::Option<&str> {
        self.image_id.as_deref()
    }
    /// <p>The size of the root volume.</p>
    pub fn root_storage(&self) -> std::option::Option<&crate::model::RootStorage> {
        self.root_storage.as_ref()
    }
    /// <p>The size of the user volume.</p>
    pub fn user_storage(&self) -> std::option::Option<&crate::model::UserStorage> {
        self.user_storage.as_ref()
    }
    /// <p>The compute type of the bundle. For more information, see <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces Bundles</a>.</p>
    pub fn compute_type(&self) -> std::option::Option<&crate::model::ComputeType> {
        self.compute_type.as_ref()
    }
    /// <p>The last time that the bundle was updated.</p>
    pub fn last_updated_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.last_updated_time.as_ref()
    }
    /// <p>The time when the bundle was created.</p>
    pub fn creation_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.creation_time.as_ref()
    }
    /// <p>The state of the WorkSpace bundle.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkspaceBundleState> {
        self.state.as_ref()
    }
    /// <p>The type of WorkSpace bundle.</p>
    pub fn bundle_type(&self) -> std::option::Option<&crate::model::BundleType> {
        self.bundle_type.as_ref()
    }
}
/// See [`WorkspaceBundle`](crate::model::WorkspaceBundle).
pub mod workspace_bundle {

    /// A builder for [`WorkspaceBundle`](crate::model::WorkspaceBundle).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) owner: std::option::Option<std::string::String>,
        pub(crate) description: std::option::Option<std::string::String>,
        pub(crate) image_id: std::option::Option<std::string::String>,
        pub(crate) root_storage: std::option::Option<crate::model::RootStorage>,
        pub(crate) user_storage: std::option::Option<crate::model::UserStorage>,
        pub(crate) compute_type: std::option::Option<crate::model::ComputeType>,
        pub(crate) last_updated_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) creation_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) state: std::option::Option<crate::model::WorkspaceBundleState>,
        pub(crate) bundle_type: std::option::Option<crate::model::BundleType>,
    }
    impl Builder {
        /// <p>The identifier of the bundle.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The identifier of the bundle.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>The name of the bundle.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the bundle.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The owner of the bundle. This is the account identifier of the owner, or <code>AMAZON</code> if the bundle is provided by Amazon Web Services.</p>
        pub fn owner(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner = Some(input.into());
            self
        }
        /// <p>The owner of the bundle. This is the account identifier of the owner, or <code>AMAZON</code> if the bundle is provided by Amazon Web Services.</p>
        pub fn set_owner(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.owner = input;
            self
        }
        /// <p>The description of the bundle.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.description = Some(input.into());
            self
        }
        /// <p>The description of the bundle.</p>
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.description = input;
            self
        }
        /// <p>The identifier of the image that was used to create the bundle.</p>
        pub fn image_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.image_id = Some(input.into());
            self
        }
        /// <p>The identifier of the image that was used to create the bundle.</p>
        pub fn set_image_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.image_id = input;
            self
        }
        /// <p>The size of the root volume.</p>
        pub fn root_storage(mut self, input: crate::model::RootStorage) -> Self {
            self.root_storage = Some(input);
            self
        }
        /// <p>The size of the root volume.</p>
        pub fn set_root_storage(
            mut self,
            input: std::option::Option<crate::model::RootStorage>,
        ) -> Self {
            self.root_storage = input;
            self
        }
        /// <p>The size of the user volume.</p>
        pub fn user_storage(mut self, input: crate::model::UserStorage) -> Self {
            self.user_storage = Some(input);
            self
        }
        /// <p>The size of the user volume.</p>
        pub fn set_user_storage(
            mut self,
            input: std::option::Option<crate::model::UserStorage>,
        ) -> Self {
            self.user_storage = input;
            self
        }
        /// <p>The compute type of the bundle. For more information, see <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces Bundles</a>.</p>
        pub fn compute_type(mut self, input: crate::model::ComputeType) -> Self {
            self.compute_type = Some(input);
            self
        }
        /// <p>The compute type of the bundle. For more information, see <a href="http://aws.amazon.com/workspaces/details/#Amazon_WorkSpaces_Bundles">Amazon WorkSpaces Bundles</a>.</p>
        pub fn set_compute_type(
            mut self,
            input: std::option::Option<crate::model::ComputeType>,
        ) -> Self {
            self.compute_type = input;
            self
        }
        /// <p>The last time that the bundle was updated.</p>
        pub fn last_updated_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.last_updated_time = Some(input);
            self
        }
        /// <p>The last time that the bundle was updated.</p>
        pub fn set_last_updated_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.last_updated_time = input;
            self
        }
        /// <p>The time when the bundle was created.</p>
        pub fn creation_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.creation_time = Some(input);
            self
        }
        /// <p>The time when the bundle was created.</p>
        pub fn set_creation_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.creation_time = input;
            self
        }
        /// <p>The state of the WorkSpace bundle.</p>
        pub fn state(mut self, input: crate::model::WorkspaceBundleState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The state of the WorkSpace bundle.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkspaceBundleState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The type of WorkSpace bundle.</p>
        pub fn bundle_type(mut self, input: crate::model::BundleType) -> Self {
            self.bundle_type = Some(input);
            self
        }
        /// <p>The type of WorkSpace bundle.</p>
        pub fn set_bundle_type(
            mut self,
            input: std::option::Option<crate::model::BundleType>,
        ) -> Self {
            self.bundle_type = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspaceBundle`](crate::model::WorkspaceBundle).
        pub fn build(self) -> crate::model::WorkspaceBundle {
            crate::model::WorkspaceBundle {
                bundle_id: self.bundle_id,
                name: self.name,
                owner: self.owner,
                description: self.description,
                image_id: self.image_id,
                root_storage: self.root_storage,
                user_storage: self.user_storage,
                compute_type: self.compute_type,
                last_updated_time: self.last_updated_time,
                creation_time: self.creation_time,
                state: self.state,
                bundle_type: self.bundle_type,
            }
        }
    }
}
impl WorkspaceBundle {
    /// Creates a new builder-style object to manufacture [`WorkspaceBundle`](crate::model::WorkspaceBundle).
    pub fn builder() -> crate::model::workspace_bundle::Builder {
        crate::model::workspace_bundle::Builder::default()
    }
}

/// When writing a match expression against `BundleType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let bundletype = unimplemented!();
/// match bundletype {
///     BundleType::Regular => { /* ... */ },
///     BundleType::Standby => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `bundletype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `BundleType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `BundleType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `BundleType::NewFeature` is defined.
/// Specifically, when `bundletype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `BundleType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum BundleType {
    #[allow(missing_docs)] // documentation missing in model
    Regular,
    #[allow(missing_docs)] // documentation missing in model
    Standby,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for BundleType {
    fn from(s: &str) -> Self {
        match s {
            "REGULAR" => BundleType::Regular,
            "STANDBY" => BundleType::Standby,
            other => BundleType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for BundleType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(BundleType::from(s))
    }
}
impl BundleType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            BundleType::Regular => "REGULAR",
            BundleType::Standby => "STANDBY",
            BundleType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["REGULAR", "STANDBY"]
    }
}
impl AsRef<str> for BundleType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `WorkspaceBundleState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let workspacebundlestate = unimplemented!();
/// match workspacebundlestate {
///     WorkspaceBundleState::Available => { /* ... */ },
///     WorkspaceBundleState::Error => { /* ... */ },
///     WorkspaceBundleState::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `workspacebundlestate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `WorkspaceBundleState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `WorkspaceBundleState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `WorkspaceBundleState::NewFeature` is defined.
/// Specifically, when `workspacebundlestate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `WorkspaceBundleState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum WorkspaceBundleState {
    #[allow(missing_docs)] // documentation missing in model
    Available,
    #[allow(missing_docs)] // documentation missing in model
    Error,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for WorkspaceBundleState {
    fn from(s: &str) -> Self {
        match s {
            "AVAILABLE" => WorkspaceBundleState::Available,
            "ERROR" => WorkspaceBundleState::Error,
            "PENDING" => WorkspaceBundleState::Pending,
            other => {
                WorkspaceBundleState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for WorkspaceBundleState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(WorkspaceBundleState::from(s))
    }
}
impl WorkspaceBundleState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            WorkspaceBundleState::Available => "AVAILABLE",
            WorkspaceBundleState::Error => "ERROR",
            WorkspaceBundleState::Pending => "PENDING",
            WorkspaceBundleState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["AVAILABLE", "ERROR", "PENDING"]
    }
}
impl AsRef<str> for WorkspaceBundleState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes the compute type of the bundle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ComputeType {
    /// <p>The compute type.</p>
    #[doc(hidden)]
    pub name: std::option::Option<crate::model::Compute>,
}
impl ComputeType {
    /// <p>The compute type.</p>
    pub fn name(&self) -> std::option::Option<&crate::model::Compute> {
        self.name.as_ref()
    }
}
/// See [`ComputeType`](crate::model::ComputeType).
pub mod compute_type {

    /// A builder for [`ComputeType`](crate::model::ComputeType).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) name: std::option::Option<crate::model::Compute>,
    }
    impl Builder {
        /// <p>The compute type.</p>
        pub fn name(mut self, input: crate::model::Compute) -> Self {
            self.name = Some(input);
            self
        }
        /// <p>The compute type.</p>
        pub fn set_name(mut self, input: std::option::Option<crate::model::Compute>) -> Self {
            self.name = input;
            self
        }
        /// Consumes the builder and constructs a [`ComputeType`](crate::model::ComputeType).
        pub fn build(self) -> crate::model::ComputeType {
            crate::model::ComputeType { name: self.name }
        }
    }
}
impl ComputeType {
    /// Creates a new builder-style object to manufacture [`ComputeType`](crate::model::ComputeType).
    pub fn builder() -> crate::model::compute_type::Builder {
        crate::model::compute_type::Builder::default()
    }
}

/// <p>Describes the user volume for a WorkSpace bundle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct UserStorage {
    /// <p>The size of the user volume.</p>
    #[doc(hidden)]
    pub capacity: std::option::Option<std::string::String>,
}
impl UserStorage {
    /// <p>The size of the user volume.</p>
    pub fn capacity(&self) -> std::option::Option<&str> {
        self.capacity.as_deref()
    }
}
/// See [`UserStorage`](crate::model::UserStorage).
pub mod user_storage {

    /// A builder for [`UserStorage`](crate::model::UserStorage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The size of the user volume.</p>
        pub fn capacity(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity = Some(input.into());
            self
        }
        /// <p>The size of the user volume.</p>
        pub fn set_capacity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.capacity = input;
            self
        }
        /// Consumes the builder and constructs a [`UserStorage`](crate::model::UserStorage).
        pub fn build(self) -> crate::model::UserStorage {
            crate::model::UserStorage {
                capacity: self.capacity,
            }
        }
    }
}
impl UserStorage {
    /// Creates a new builder-style object to manufacture [`UserStorage`](crate::model::UserStorage).
    pub fn builder() -> crate::model::user_storage::Builder {
        crate::model::user_storage::Builder::default()
    }
}

/// <p>Describes the root volume for a WorkSpace bundle.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RootStorage {
    /// <p>The size of the root volume.</p>
    #[doc(hidden)]
    pub capacity: std::option::Option<std::string::String>,
}
impl RootStorage {
    /// <p>The size of the root volume.</p>
    pub fn capacity(&self) -> std::option::Option<&str> {
        self.capacity.as_deref()
    }
}
/// See [`RootStorage`](crate::model::RootStorage).
pub mod root_storage {

    /// A builder for [`RootStorage`](crate::model::RootStorage).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) capacity: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The size of the root volume.</p>
        pub fn capacity(mut self, input: impl Into<std::string::String>) -> Self {
            self.capacity = Some(input.into());
            self
        }
        /// <p>The size of the root volume.</p>
        pub fn set_capacity(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.capacity = input;
            self
        }
        /// Consumes the builder and constructs a [`RootStorage`](crate::model::RootStorage).
        pub fn build(self) -> crate::model::RootStorage {
            crate::model::RootStorage {
                capacity: self.capacity,
            }
        }
    }
}
impl RootStorage {
    /// Creates a new builder-style object to manufacture [`RootStorage`](crate::model::RootStorage).
    pub fn builder() -> crate::model::root_storage::Builder {
        crate::model::root_storage::Builder::default()
    }
}

/// <p>Describes an IP access control group.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspacesIpGroup {
    /// <p>The identifier of the group.</p>
    #[doc(hidden)]
    pub group_id: std::option::Option<std::string::String>,
    /// <p>The name of the group.</p>
    #[doc(hidden)]
    pub group_name: std::option::Option<std::string::String>,
    /// <p>The description of the group.</p>
    #[doc(hidden)]
    pub group_desc: std::option::Option<std::string::String>,
    /// <p>The rules.</p>
    #[doc(hidden)]
    pub user_rules: std::option::Option<std::vec::Vec<crate::model::IpRuleItem>>,
}
impl WorkspacesIpGroup {
    /// <p>The identifier of the group.</p>
    pub fn group_id(&self) -> std::option::Option<&str> {
        self.group_id.as_deref()
    }
    /// <p>The name of the group.</p>
    pub fn group_name(&self) -> std::option::Option<&str> {
        self.group_name.as_deref()
    }
    /// <p>The description of the group.</p>
    pub fn group_desc(&self) -> std::option::Option<&str> {
        self.group_desc.as_deref()
    }
    /// <p>The rules.</p>
    pub fn user_rules(&self) -> std::option::Option<&[crate::model::IpRuleItem]> {
        self.user_rules.as_deref()
    }
}
/// See [`WorkspacesIpGroup`](crate::model::WorkspacesIpGroup).
pub mod workspaces_ip_group {

    /// A builder for [`WorkspacesIpGroup`](crate::model::WorkspacesIpGroup).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) group_id: std::option::Option<std::string::String>,
        pub(crate) group_name: std::option::Option<std::string::String>,
        pub(crate) group_desc: std::option::Option<std::string::String>,
        pub(crate) user_rules: std::option::Option<std::vec::Vec<crate::model::IpRuleItem>>,
    }
    impl Builder {
        /// <p>The identifier of the group.</p>
        pub fn group_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_id = Some(input.into());
            self
        }
        /// <p>The identifier of the group.</p>
        pub fn set_group_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_id = input;
            self
        }
        /// <p>The name of the group.</p>
        pub fn group_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_name = Some(input.into());
            self
        }
        /// <p>The name of the group.</p>
        pub fn set_group_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_name = input;
            self
        }
        /// <p>The description of the group.</p>
        pub fn group_desc(mut self, input: impl Into<std::string::String>) -> Self {
            self.group_desc = Some(input.into());
            self
        }
        /// <p>The description of the group.</p>
        pub fn set_group_desc(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.group_desc = input;
            self
        }
        /// Appends an item to `user_rules`.
        ///
        /// To override the contents of this collection use [`set_user_rules`](Self::set_user_rules).
        ///
        /// <p>The rules.</p>
        pub fn user_rules(mut self, input: crate::model::IpRuleItem) -> Self {
            let mut v = self.user_rules.unwrap_or_default();
            v.push(input);
            self.user_rules = Some(v);
            self
        }
        /// <p>The rules.</p>
        pub fn set_user_rules(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::IpRuleItem>>,
        ) -> Self {
            self.user_rules = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspacesIpGroup`](crate::model::WorkspacesIpGroup).
        pub fn build(self) -> crate::model::WorkspacesIpGroup {
            crate::model::WorkspacesIpGroup {
                group_id: self.group_id,
                group_name: self.group_name,
                group_desc: self.group_desc,
                user_rules: self.user_rules,
            }
        }
    }
}
impl WorkspacesIpGroup {
    /// Creates a new builder-style object to manufacture [`WorkspacesIpGroup`](crate::model::WorkspacesIpGroup).
    pub fn builder() -> crate::model::workspaces_ip_group::Builder {
        crate::model::workspaces_ip_group::Builder::default()
    }
}

/// <p>Describes a connection alias. Connection aliases are used for cross-Region redirection. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html"> Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionAlias {
    /// <p>The connection string specified for the connection alias. The connection string must be in the form of a fully qualified domain name (FQDN), such as <code>www.example.com</code>.</p>
    #[doc(hidden)]
    pub connection_string: std::option::Option<std::string::String>,
    /// <p>The identifier of the connection alias.</p>
    #[doc(hidden)]
    pub alias_id: std::option::Option<std::string::String>,
    /// <p>The current state of the connection alias.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::ConnectionAliasState>,
    /// <p>The identifier of the Amazon Web Services account that owns the connection alias.</p>
    #[doc(hidden)]
    pub owner_account_id: std::option::Option<std::string::String>,
    /// <p>The association status of the connection alias.</p>
    #[doc(hidden)]
    pub associations: std::option::Option<std::vec::Vec<crate::model::ConnectionAliasAssociation>>,
}
impl ConnectionAlias {
    /// <p>The connection string specified for the connection alias. The connection string must be in the form of a fully qualified domain name (FQDN), such as <code>www.example.com</code>.</p>
    pub fn connection_string(&self) -> std::option::Option<&str> {
        self.connection_string.as_deref()
    }
    /// <p>The identifier of the connection alias.</p>
    pub fn alias_id(&self) -> std::option::Option<&str> {
        self.alias_id.as_deref()
    }
    /// <p>The current state of the connection alias.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::ConnectionAliasState> {
        self.state.as_ref()
    }
    /// <p>The identifier of the Amazon Web Services account that owns the connection alias.</p>
    pub fn owner_account_id(&self) -> std::option::Option<&str> {
        self.owner_account_id.as_deref()
    }
    /// <p>The association status of the connection alias.</p>
    pub fn associations(&self) -> std::option::Option<&[crate::model::ConnectionAliasAssociation]> {
        self.associations.as_deref()
    }
}
/// See [`ConnectionAlias`](crate::model::ConnectionAlias).
pub mod connection_alias {

    /// A builder for [`ConnectionAlias`](crate::model::ConnectionAlias).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) connection_string: std::option::Option<std::string::String>,
        pub(crate) alias_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::ConnectionAliasState>,
        pub(crate) owner_account_id: std::option::Option<std::string::String>,
        pub(crate) associations:
            std::option::Option<std::vec::Vec<crate::model::ConnectionAliasAssociation>>,
    }
    impl Builder {
        /// <p>The connection string specified for the connection alias. The connection string must be in the form of a fully qualified domain name (FQDN), such as <code>www.example.com</code>.</p>
        pub fn connection_string(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_string = Some(input.into());
            self
        }
        /// <p>The connection string specified for the connection alias. The connection string must be in the form of a fully qualified domain name (FQDN), such as <code>www.example.com</code>.</p>
        pub fn set_connection_string(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_string = input;
            self
        }
        /// <p>The identifier of the connection alias.</p>
        pub fn alias_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.alias_id = Some(input.into());
            self
        }
        /// <p>The identifier of the connection alias.</p>
        pub fn set_alias_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.alias_id = input;
            self
        }
        /// <p>The current state of the connection alias.</p>
        pub fn state(mut self, input: crate::model::ConnectionAliasState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The current state of the connection alias.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::ConnectionAliasState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The identifier of the Amazon Web Services account that owns the connection alias.</p>
        pub fn owner_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.owner_account_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Web Services account that owns the connection alias.</p>
        pub fn set_owner_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.owner_account_id = input;
            self
        }
        /// Appends an item to `associations`.
        ///
        /// To override the contents of this collection use [`set_associations`](Self::set_associations).
        ///
        /// <p>The association status of the connection alias.</p>
        pub fn associations(mut self, input: crate::model::ConnectionAliasAssociation) -> Self {
            let mut v = self.associations.unwrap_or_default();
            v.push(input);
            self.associations = Some(v);
            self
        }
        /// <p>The association status of the connection alias.</p>
        pub fn set_associations(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::ConnectionAliasAssociation>>,
        ) -> Self {
            self.associations = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionAlias`](crate::model::ConnectionAlias).
        pub fn build(self) -> crate::model::ConnectionAlias {
            crate::model::ConnectionAlias {
                connection_string: self.connection_string,
                alias_id: self.alias_id,
                state: self.state,
                owner_account_id: self.owner_account_id,
                associations: self.associations,
            }
        }
    }
}
impl ConnectionAlias {
    /// Creates a new builder-style object to manufacture [`ConnectionAlias`](crate::model::ConnectionAlias).
    pub fn builder() -> crate::model::connection_alias::Builder {
        crate::model::connection_alias::Builder::default()
    }
}

/// <p>Describes a connection alias association that is used for cross-Region redirection. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html"> Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectionAliasAssociation {
    /// <p>The association status of the connection alias.</p>
    #[doc(hidden)]
    pub association_status: std::option::Option<crate::model::AssociationStatus>,
    /// <p>The identifier of the Amazon Web Services account that associated the connection alias with a directory.</p>
    #[doc(hidden)]
    pub associated_account_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the directory associated with a connection alias.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.</p>
    #[doc(hidden)]
    pub connection_identifier: std::option::Option<std::string::String>,
}
impl ConnectionAliasAssociation {
    /// <p>The association status of the connection alias.</p>
    pub fn association_status(&self) -> std::option::Option<&crate::model::AssociationStatus> {
        self.association_status.as_ref()
    }
    /// <p>The identifier of the Amazon Web Services account that associated the connection alias with a directory.</p>
    pub fn associated_account_id(&self) -> std::option::Option<&str> {
        self.associated_account_id.as_deref()
    }
    /// <p>The identifier of the directory associated with a connection alias.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.</p>
    pub fn connection_identifier(&self) -> std::option::Option<&str> {
        self.connection_identifier.as_deref()
    }
}
/// See [`ConnectionAliasAssociation`](crate::model::ConnectionAliasAssociation).
pub mod connection_alias_association {

    /// A builder for [`ConnectionAliasAssociation`](crate::model::ConnectionAliasAssociation).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) association_status: std::option::Option<crate::model::AssociationStatus>,
        pub(crate) associated_account_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) connection_identifier: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The association status of the connection alias.</p>
        pub fn association_status(mut self, input: crate::model::AssociationStatus) -> Self {
            self.association_status = Some(input);
            self
        }
        /// <p>The association status of the connection alias.</p>
        pub fn set_association_status(
            mut self,
            input: std::option::Option<crate::model::AssociationStatus>,
        ) -> Self {
            self.association_status = input;
            self
        }
        /// <p>The identifier of the Amazon Web Services account that associated the connection alias with a directory.</p>
        pub fn associated_account_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.associated_account_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Amazon Web Services account that associated the connection alias with a directory.</p>
        pub fn set_associated_account_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.associated_account_id = input;
            self
        }
        /// <p>The identifier of the directory associated with a connection alias.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The identifier of the directory associated with a connection alias.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.</p>
        pub fn connection_identifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.connection_identifier = Some(input.into());
            self
        }
        /// <p>The identifier of the connection alias association. You use the connection identifier in the DNS TXT record when you're configuring your DNS routing policies.</p>
        pub fn set_connection_identifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.connection_identifier = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectionAliasAssociation`](crate::model::ConnectionAliasAssociation).
        pub fn build(self) -> crate::model::ConnectionAliasAssociation {
            crate::model::ConnectionAliasAssociation {
                association_status: self.association_status,
                associated_account_id: self.associated_account_id,
                resource_id: self.resource_id,
                connection_identifier: self.connection_identifier,
            }
        }
    }
}
impl ConnectionAliasAssociation {
    /// Creates a new builder-style object to manufacture [`ConnectionAliasAssociation`](crate::model::ConnectionAliasAssociation).
    pub fn builder() -> crate::model::connection_alias_association::Builder {
        crate::model::connection_alias_association::Builder::default()
    }
}

/// When writing a match expression against `AssociationStatus`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let associationstatus = unimplemented!();
/// match associationstatus {
///     AssociationStatus::AssociatedWithOwnerAccount => { /* ... */ },
///     AssociationStatus::AssociatedWithSharedAccount => { /* ... */ },
///     AssociationStatus::NotAssociated => { /* ... */ },
///     AssociationStatus::PendingAssociation => { /* ... */ },
///     AssociationStatus::PendingDisassociation => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `associationstatus` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `AssociationStatus::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `AssociationStatus::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `AssociationStatus::NewFeature` is defined.
/// Specifically, when `associationstatus` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `AssociationStatus::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum AssociationStatus {
    #[allow(missing_docs)] // documentation missing in model
    AssociatedWithOwnerAccount,
    #[allow(missing_docs)] // documentation missing in model
    AssociatedWithSharedAccount,
    #[allow(missing_docs)] // documentation missing in model
    NotAssociated,
    #[allow(missing_docs)] // documentation missing in model
    PendingAssociation,
    #[allow(missing_docs)] // documentation missing in model
    PendingDisassociation,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for AssociationStatus {
    fn from(s: &str) -> Self {
        match s {
            "ASSOCIATED_WITH_OWNER_ACCOUNT" => AssociationStatus::AssociatedWithOwnerAccount,
            "ASSOCIATED_WITH_SHARED_ACCOUNT" => AssociationStatus::AssociatedWithSharedAccount,
            "NOT_ASSOCIATED" => AssociationStatus::NotAssociated,
            "PENDING_ASSOCIATION" => AssociationStatus::PendingAssociation,
            "PENDING_DISASSOCIATION" => AssociationStatus::PendingDisassociation,
            other => {
                AssociationStatus::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for AssociationStatus {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(AssociationStatus::from(s))
    }
}
impl AssociationStatus {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            AssociationStatus::AssociatedWithOwnerAccount => "ASSOCIATED_WITH_OWNER_ACCOUNT",
            AssociationStatus::AssociatedWithSharedAccount => "ASSOCIATED_WITH_SHARED_ACCOUNT",
            AssociationStatus::NotAssociated => "NOT_ASSOCIATED",
            AssociationStatus::PendingAssociation => "PENDING_ASSOCIATION",
            AssociationStatus::PendingDisassociation => "PENDING_DISASSOCIATION",
            AssociationStatus::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "ASSOCIATED_WITH_OWNER_ACCOUNT",
            "ASSOCIATED_WITH_SHARED_ACCOUNT",
            "NOT_ASSOCIATED",
            "PENDING_ASSOCIATION",
            "PENDING_DISASSOCIATION",
        ]
    }
}
impl AsRef<str> for AssociationStatus {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ConnectionAliasState`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let connectionaliasstate = unimplemented!();
/// match connectionaliasstate {
///     ConnectionAliasState::Created => { /* ... */ },
///     ConnectionAliasState::Creating => { /* ... */ },
///     ConnectionAliasState::Deleting => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `connectionaliasstate` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ConnectionAliasState::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ConnectionAliasState::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ConnectionAliasState::NewFeature` is defined.
/// Specifically, when `connectionaliasstate` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ConnectionAliasState::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ConnectionAliasState {
    #[allow(missing_docs)] // documentation missing in model
    Created,
    #[allow(missing_docs)] // documentation missing in model
    Creating,
    #[allow(missing_docs)] // documentation missing in model
    Deleting,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ConnectionAliasState {
    fn from(s: &str) -> Self {
        match s {
            "CREATED" => ConnectionAliasState::Created,
            "CREATING" => ConnectionAliasState::Creating,
            "DELETING" => ConnectionAliasState::Deleting,
            other => {
                ConnectionAliasState::Unknown(crate::types::UnknownVariantValue(other.to_owned()))
            }
        }
    }
}
impl std::str::FromStr for ConnectionAliasState {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ConnectionAliasState::from(s))
    }
}
impl ConnectionAliasState {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ConnectionAliasState::Created => "CREATED",
            ConnectionAliasState::Creating => "CREATING",
            ConnectionAliasState::Deleting => "DELETING",
            ConnectionAliasState::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["CREATED", "CREATING", "DELETING"]
    }
}
impl AsRef<str> for ConnectionAliasState {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes an Amazon Connect client add-in.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConnectClientAddIn {
    /// <p>The client add-in identifier.</p>
    #[doc(hidden)]
    pub add_in_id: std::option::Option<std::string::String>,
    /// <p>The directory identifier for which the client add-in is configured.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>The name of the client add in.</p>
    #[doc(hidden)]
    pub name: std::option::Option<std::string::String>,
    /// <p>The endpoint URL of the client add-in.</p>
    #[doc(hidden)]
    pub url: std::option::Option<std::string::String>,
}
impl ConnectClientAddIn {
    /// <p>The client add-in identifier.</p>
    pub fn add_in_id(&self) -> std::option::Option<&str> {
        self.add_in_id.as_deref()
    }
    /// <p>The directory identifier for which the client add-in is configured.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>The name of the client add in.</p>
    pub fn name(&self) -> std::option::Option<&str> {
        self.name.as_deref()
    }
    /// <p>The endpoint URL of the client add-in.</p>
    pub fn url(&self) -> std::option::Option<&str> {
        self.url.as_deref()
    }
}
/// See [`ConnectClientAddIn`](crate::model::ConnectClientAddIn).
pub mod connect_client_add_in {

    /// A builder for [`ConnectClientAddIn`](crate::model::ConnectClientAddIn).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) add_in_id: std::option::Option<std::string::String>,
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) name: std::option::Option<std::string::String>,
        pub(crate) url: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The client add-in identifier.</p>
        pub fn add_in_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.add_in_id = Some(input.into());
            self
        }
        /// <p>The client add-in identifier.</p>
        pub fn set_add_in_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.add_in_id = input;
            self
        }
        /// <p>The directory identifier for which the client add-in is configured.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The directory identifier for which the client add-in is configured.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>The name of the client add in.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.name = Some(input.into());
            self
        }
        /// <p>The name of the client add in.</p>
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.name = input;
            self
        }
        /// <p>The endpoint URL of the client add-in.</p>
        pub fn url(mut self, input: impl Into<std::string::String>) -> Self {
            self.url = Some(input.into());
            self
        }
        /// <p>The endpoint URL of the client add-in.</p>
        pub fn set_url(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.url = input;
            self
        }
        /// Consumes the builder and constructs a [`ConnectClientAddIn`](crate::model::ConnectClientAddIn).
        pub fn build(self) -> crate::model::ConnectClientAddIn {
            crate::model::ConnectClientAddIn {
                add_in_id: self.add_in_id,
                resource_id: self.resource_id,
                name: self.name,
                url: self.url,
            }
        }
    }
}
impl ConnectClientAddIn {
    /// Creates a new builder-style object to manufacture [`ConnectClientAddIn`](crate::model::ConnectClientAddIn).
    pub fn builder() -> crate::model::connect_client_add_in::Builder {
        crate::model::connect_client_add_in::Builder::default()
    }
}

/// <p>Information about the Amazon WorkSpaces client.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClientPropertiesResult {
    /// <p>The resource identifier, in the form of a directory ID.</p>
    #[doc(hidden)]
    pub resource_id: std::option::Option<std::string::String>,
    /// <p>Information about the Amazon WorkSpaces client.</p>
    #[doc(hidden)]
    pub client_properties: std::option::Option<crate::model::ClientProperties>,
}
impl ClientPropertiesResult {
    /// <p>The resource identifier, in the form of a directory ID.</p>
    pub fn resource_id(&self) -> std::option::Option<&str> {
        self.resource_id.as_deref()
    }
    /// <p>Information about the Amazon WorkSpaces client.</p>
    pub fn client_properties(&self) -> std::option::Option<&crate::model::ClientProperties> {
        self.client_properties.as_ref()
    }
}
/// See [`ClientPropertiesResult`](crate::model::ClientPropertiesResult).
pub mod client_properties_result {

    /// A builder for [`ClientPropertiesResult`](crate::model::ClientPropertiesResult).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) resource_id: std::option::Option<std::string::String>,
        pub(crate) client_properties: std::option::Option<crate::model::ClientProperties>,
    }
    impl Builder {
        /// <p>The resource identifier, in the form of a directory ID.</p>
        pub fn resource_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.resource_id = Some(input.into());
            self
        }
        /// <p>The resource identifier, in the form of a directory ID.</p>
        pub fn set_resource_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.resource_id = input;
            self
        }
        /// <p>Information about the Amazon WorkSpaces client.</p>
        pub fn client_properties(mut self, input: crate::model::ClientProperties) -> Self {
            self.client_properties = Some(input);
            self
        }
        /// <p>Information about the Amazon WorkSpaces client.</p>
        pub fn set_client_properties(
            mut self,
            input: std::option::Option<crate::model::ClientProperties>,
        ) -> Self {
            self.client_properties = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientPropertiesResult`](crate::model::ClientPropertiesResult).
        pub fn build(self) -> crate::model::ClientPropertiesResult {
            crate::model::ClientPropertiesResult {
                resource_id: self.resource_id,
                client_properties: self.client_properties,
            }
        }
    }
}
impl ClientPropertiesResult {
    /// Creates a new builder-style object to manufacture [`ClientPropertiesResult`](crate::model::ClientPropertiesResult).
    pub fn builder() -> crate::model::client_properties_result::Builder {
        crate::model::client_properties_result::Builder::default()
    }
}

/// <p>Describes a modification to the configuration of Bring Your Own License (BYOL) for the specified account. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AccountModification {
    /// <p>The state of the modification to the configuration of BYOL.</p>
    #[doc(hidden)]
    pub modification_state:
        std::option::Option<crate::model::DedicatedTenancyModificationStateEnum>,
    /// <p>The status of BYOL (whether BYOL is being enabled or disabled).</p>
    #[doc(hidden)]
    pub dedicated_tenancy_support:
        std::option::Option<crate::model::DedicatedTenancySupportResultEnum>,
    /// <p>The IP address range, specified as an IPv4 CIDR block, for the management network interface used for the account.</p>
    #[doc(hidden)]
    pub dedicated_tenancy_management_cidr_range: std::option::Option<std::string::String>,
    /// <p>The timestamp when the modification of the BYOL configuration was started.</p>
    #[doc(hidden)]
    pub start_time: std::option::Option<aws_smithy_types::DateTime>,
    /// <p>The error code that is returned if the configuration of BYOL cannot be modified.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The text of the error message that is returned if the configuration of BYOL cannot be modified.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl AccountModification {
    /// <p>The state of the modification to the configuration of BYOL.</p>
    pub fn modification_state(
        &self,
    ) -> std::option::Option<&crate::model::DedicatedTenancyModificationStateEnum> {
        self.modification_state.as_ref()
    }
    /// <p>The status of BYOL (whether BYOL is being enabled or disabled).</p>
    pub fn dedicated_tenancy_support(
        &self,
    ) -> std::option::Option<&crate::model::DedicatedTenancySupportResultEnum> {
        self.dedicated_tenancy_support.as_ref()
    }
    /// <p>The IP address range, specified as an IPv4 CIDR block, for the management network interface used for the account.</p>
    pub fn dedicated_tenancy_management_cidr_range(&self) -> std::option::Option<&str> {
        self.dedicated_tenancy_management_cidr_range.as_deref()
    }
    /// <p>The timestamp when the modification of the BYOL configuration was started.</p>
    pub fn start_time(&self) -> std::option::Option<&aws_smithy_types::DateTime> {
        self.start_time.as_ref()
    }
    /// <p>The error code that is returned if the configuration of BYOL cannot be modified.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The text of the error message that is returned if the configuration of BYOL cannot be modified.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`AccountModification`](crate::model::AccountModification).
pub mod account_modification {

    /// A builder for [`AccountModification`](crate::model::AccountModification).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) modification_state:
            std::option::Option<crate::model::DedicatedTenancyModificationStateEnum>,
        pub(crate) dedicated_tenancy_support:
            std::option::Option<crate::model::DedicatedTenancySupportResultEnum>,
        pub(crate) dedicated_tenancy_management_cidr_range:
            std::option::Option<std::string::String>,
        pub(crate) start_time: std::option::Option<aws_smithy_types::DateTime>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>The state of the modification to the configuration of BYOL.</p>
        pub fn modification_state(
            mut self,
            input: crate::model::DedicatedTenancyModificationStateEnum,
        ) -> Self {
            self.modification_state = Some(input);
            self
        }
        /// <p>The state of the modification to the configuration of BYOL.</p>
        pub fn set_modification_state(
            mut self,
            input: std::option::Option<crate::model::DedicatedTenancyModificationStateEnum>,
        ) -> Self {
            self.modification_state = input;
            self
        }
        /// <p>The status of BYOL (whether BYOL is being enabled or disabled).</p>
        pub fn dedicated_tenancy_support(
            mut self,
            input: crate::model::DedicatedTenancySupportResultEnum,
        ) -> Self {
            self.dedicated_tenancy_support = Some(input);
            self
        }
        /// <p>The status of BYOL (whether BYOL is being enabled or disabled).</p>
        pub fn set_dedicated_tenancy_support(
            mut self,
            input: std::option::Option<crate::model::DedicatedTenancySupportResultEnum>,
        ) -> Self {
            self.dedicated_tenancy_support = input;
            self
        }
        /// <p>The IP address range, specified as an IPv4 CIDR block, for the management network interface used for the account.</p>
        pub fn dedicated_tenancy_management_cidr_range(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.dedicated_tenancy_management_cidr_range = Some(input.into());
            self
        }
        /// <p>The IP address range, specified as an IPv4 CIDR block, for the management network interface used for the account.</p>
        pub fn set_dedicated_tenancy_management_cidr_range(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.dedicated_tenancy_management_cidr_range = input;
            self
        }
        /// <p>The timestamp when the modification of the BYOL configuration was started.</p>
        pub fn start_time(mut self, input: aws_smithy_types::DateTime) -> Self {
            self.start_time = Some(input);
            self
        }
        /// <p>The timestamp when the modification of the BYOL configuration was started.</p>
        pub fn set_start_time(
            mut self,
            input: std::option::Option<aws_smithy_types::DateTime>,
        ) -> Self {
            self.start_time = input;
            self
        }
        /// <p>The error code that is returned if the configuration of BYOL cannot be modified.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code that is returned if the configuration of BYOL cannot be modified.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The text of the error message that is returned if the configuration of BYOL cannot be modified.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The text of the error message that is returned if the configuration of BYOL cannot be modified.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`AccountModification`](crate::model::AccountModification).
        pub fn build(self) -> crate::model::AccountModification {
            crate::model::AccountModification {
                modification_state: self.modification_state,
                dedicated_tenancy_support: self.dedicated_tenancy_support,
                dedicated_tenancy_management_cidr_range: self
                    .dedicated_tenancy_management_cidr_range,
                start_time: self.start_time,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl AccountModification {
    /// Creates a new builder-style object to manufacture [`AccountModification`](crate::model::AccountModification).
    pub fn builder() -> crate::model::account_modification::Builder {
        crate::model::account_modification::Builder::default()
    }
}

/// When writing a match expression against `DedicatedTenancySupportResultEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dedicatedtenancysupportresultenum = unimplemented!();
/// match dedicatedtenancysupportresultenum {
///     DedicatedTenancySupportResultEnum::Disabled => { /* ... */ },
///     DedicatedTenancySupportResultEnum::Enabled => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dedicatedtenancysupportresultenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DedicatedTenancySupportResultEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DedicatedTenancySupportResultEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DedicatedTenancySupportResultEnum::NewFeature` is defined.
/// Specifically, when `dedicatedtenancysupportresultenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DedicatedTenancySupportResultEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DedicatedTenancySupportResultEnum {
    #[allow(missing_docs)] // documentation missing in model
    Disabled,
    #[allow(missing_docs)] // documentation missing in model
    Enabled,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DedicatedTenancySupportResultEnum {
    fn from(s: &str) -> Self {
        match s {
            "DISABLED" => DedicatedTenancySupportResultEnum::Disabled,
            "ENABLED" => DedicatedTenancySupportResultEnum::Enabled,
            other => DedicatedTenancySupportResultEnum::Unknown(crate::types::UnknownVariantValue(
                other.to_owned(),
            )),
        }
    }
}
impl std::str::FromStr for DedicatedTenancySupportResultEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DedicatedTenancySupportResultEnum::from(s))
    }
}
impl DedicatedTenancySupportResultEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DedicatedTenancySupportResultEnum::Disabled => "DISABLED",
            DedicatedTenancySupportResultEnum::Enabled => "ENABLED",
            DedicatedTenancySupportResultEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["DISABLED", "ENABLED"]
    }
}
impl AsRef<str> for DedicatedTenancySupportResultEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `DedicatedTenancyModificationStateEnum`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let dedicatedtenancymodificationstateenum = unimplemented!();
/// match dedicatedtenancymodificationstateenum {
///     DedicatedTenancyModificationStateEnum::Completed => { /* ... */ },
///     DedicatedTenancyModificationStateEnum::Failed => { /* ... */ },
///     DedicatedTenancyModificationStateEnum::Pending => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `dedicatedtenancymodificationstateenum` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `DedicatedTenancyModificationStateEnum::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `DedicatedTenancyModificationStateEnum::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `DedicatedTenancyModificationStateEnum::NewFeature` is defined.
/// Specifically, when `dedicatedtenancymodificationstateenum` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `DedicatedTenancyModificationStateEnum::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum DedicatedTenancyModificationStateEnum {
    #[allow(missing_docs)] // documentation missing in model
    Completed,
    #[allow(missing_docs)] // documentation missing in model
    Failed,
    #[allow(missing_docs)] // documentation missing in model
    Pending,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for DedicatedTenancyModificationStateEnum {
    fn from(s: &str) -> Self {
        match s {
            "COMPLETED" => DedicatedTenancyModificationStateEnum::Completed,
            "FAILED" => DedicatedTenancyModificationStateEnum::Failed,
            "PENDING" => DedicatedTenancyModificationStateEnum::Pending,
            other => DedicatedTenancyModificationStateEnum::Unknown(
                crate::types::UnknownVariantValue(other.to_owned()),
            ),
        }
    }
}
impl std::str::FromStr for DedicatedTenancyModificationStateEnum {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(DedicatedTenancyModificationStateEnum::from(s))
    }
}
impl DedicatedTenancyModificationStateEnum {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            DedicatedTenancyModificationStateEnum::Completed => "COMPLETED",
            DedicatedTenancyModificationStateEnum::Failed => "FAILED",
            DedicatedTenancyModificationStateEnum::Pending => "PENDING",
            DedicatedTenancyModificationStateEnum::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &["COMPLETED", "FAILED", "PENDING"]
    }
}
impl AsRef<str> for DedicatedTenancyModificationStateEnum {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// When writing a match expression against `ClientDeviceType`, it is important to ensure
/// your code is forward-compatible. That is, if a match arm handles a case for a
/// feature that is supported by the service but has not been represented as an enum
/// variant in a current version of SDK, your code should continue to work when you
/// upgrade SDK to a future version in which the enum does include a variant for that
/// feature.
///
/// Here is an example of how you can make a match expression forward-compatible:
///
/// ```text
/// # let clientdevicetype = unimplemented!();
/// match clientdevicetype {
///     ClientDeviceType::DeviceTypeAndroid => { /* ... */ },
///     ClientDeviceType::DeviceTypeIos => { /* ... */ },
///     ClientDeviceType::DeviceTypeLinux => { /* ... */ },
///     ClientDeviceType::DeviceTypeOsx => { /* ... */ },
///     ClientDeviceType::DeviceTypeWeb => { /* ... */ },
///     ClientDeviceType::DeviceTypeWindows => { /* ... */ },
///     other @ _ if other.as_str() == "NewFeature" => { /* handles a case for `NewFeature` */ },
///     _ => { /* ... */ },
/// }
/// ```
/// The above code demonstrates that when `clientdevicetype` represents
/// `NewFeature`, the execution path will lead to the second last match arm,
/// even though the enum does not contain a variant `ClientDeviceType::NewFeature`
/// in the current version of SDK. The reason is that the variable `other`,
/// created by the `@` operator, is bound to
/// `ClientDeviceType::Unknown(UnknownVariantValue("NewFeature".to_owned()))`
/// and calling `as_str` on it yields `"NewFeature"`.
/// This match expression is forward-compatible when executed with a newer
/// version of SDK where the variant `ClientDeviceType::NewFeature` is defined.
/// Specifically, when `clientdevicetype` represents `NewFeature`,
/// the execution path will hit the second last match arm as before by virtue of
/// calling `as_str` on `ClientDeviceType::NewFeature` also yielding `"NewFeature"`.
///
/// Explicitly matching on the `Unknown` variant should
/// be avoided for two reasons:
/// - The inner data `UnknownVariantValue` is opaque, and no further information can be extracted.
/// - It might inadvertently shadow other intended match arms.
#[allow(missing_docs)] // documentation missing in model
#[non_exhaustive]
#[derive(
    std::clone::Clone,
    std::cmp::Eq,
    std::cmp::Ord,
    std::cmp::PartialEq,
    std::cmp::PartialOrd,
    std::fmt::Debug,
    std::hash::Hash,
)]
pub enum ClientDeviceType {
    #[allow(missing_docs)] // documentation missing in model
    DeviceTypeAndroid,
    #[allow(missing_docs)] // documentation missing in model
    DeviceTypeIos,
    #[allow(missing_docs)] // documentation missing in model
    DeviceTypeLinux,
    #[allow(missing_docs)] // documentation missing in model
    DeviceTypeOsx,
    #[allow(missing_docs)] // documentation missing in model
    DeviceTypeWeb,
    #[allow(missing_docs)] // documentation missing in model
    DeviceTypeWindows,
    /// `Unknown` contains new variants that have been added since this code was generated.
    Unknown(crate::types::UnknownVariantValue),
}
impl std::convert::From<&str> for ClientDeviceType {
    fn from(s: &str) -> Self {
        match s {
            "DeviceTypeAndroid" => ClientDeviceType::DeviceTypeAndroid,
            "DeviceTypeIos" => ClientDeviceType::DeviceTypeIos,
            "DeviceTypeLinux" => ClientDeviceType::DeviceTypeLinux,
            "DeviceTypeOsx" => ClientDeviceType::DeviceTypeOsx,
            "DeviceTypeWeb" => ClientDeviceType::DeviceTypeWeb,
            "DeviceTypeWindows" => ClientDeviceType::DeviceTypeWindows,
            other => ClientDeviceType::Unknown(crate::types::UnknownVariantValue(other.to_owned())),
        }
    }
}
impl std::str::FromStr for ClientDeviceType {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        Ok(ClientDeviceType::from(s))
    }
}
impl ClientDeviceType {
    /// Returns the `&str` value of the enum member.
    pub fn as_str(&self) -> &str {
        match self {
            ClientDeviceType::DeviceTypeAndroid => "DeviceTypeAndroid",
            ClientDeviceType::DeviceTypeIos => "DeviceTypeIos",
            ClientDeviceType::DeviceTypeLinux => "DeviceTypeLinux",
            ClientDeviceType::DeviceTypeOsx => "DeviceTypeOsx",
            ClientDeviceType::DeviceTypeWeb => "DeviceTypeWeb",
            ClientDeviceType::DeviceTypeWindows => "DeviceTypeWindows",
            ClientDeviceType::Unknown(value) => value.as_str(),
        }
    }
    /// Returns all the `&str` representations of the enum members.
    pub const fn values() -> &'static [&'static str] {
        &[
            "DeviceTypeAndroid",
            "DeviceTypeIos",
            "DeviceTypeLinux",
            "DeviceTypeOsx",
            "DeviceTypeWeb",
            "DeviceTypeWindows",
        ]
    }
}
impl AsRef<str> for ClientDeviceType {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}

/// <p>Describes a WorkSpace that cannot be created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedCreateWorkspaceRequest {
    /// <p>Information about the WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_request: std::option::Option<crate::model::WorkspaceRequest>,
    /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The text of the error message that is returned if the WorkSpace cannot be created.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl FailedCreateWorkspaceRequest {
    /// <p>Information about the WorkSpace.</p>
    pub fn workspace_request(&self) -> std::option::Option<&crate::model::WorkspaceRequest> {
        self.workspace_request.as_ref()
    }
    /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The text of the error message that is returned if the WorkSpace cannot be created.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`FailedCreateWorkspaceRequest`](crate::model::FailedCreateWorkspaceRequest).
pub mod failed_create_workspace_request {

    /// A builder for [`FailedCreateWorkspaceRequest`](crate::model::FailedCreateWorkspaceRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) workspace_request: std::option::Option<crate::model::WorkspaceRequest>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the WorkSpace.</p>
        pub fn workspace_request(mut self, input: crate::model::WorkspaceRequest) -> Self {
            self.workspace_request = Some(input);
            self
        }
        /// <p>Information about the WorkSpace.</p>
        pub fn set_workspace_request(
            mut self,
            input: std::option::Option<crate::model::WorkspaceRequest>,
        ) -> Self {
            self.workspace_request = input;
            self
        }
        /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code that is returned if the WorkSpace cannot be created.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The text of the error message that is returned if the WorkSpace cannot be created.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The text of the error message that is returned if the WorkSpace cannot be created.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedCreateWorkspaceRequest`](crate::model::FailedCreateWorkspaceRequest).
        pub fn build(self) -> crate::model::FailedCreateWorkspaceRequest {
            crate::model::FailedCreateWorkspaceRequest {
                workspace_request: self.workspace_request,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl FailedCreateWorkspaceRequest {
    /// Creates a new builder-style object to manufacture [`FailedCreateWorkspaceRequest`](crate::model::FailedCreateWorkspaceRequest).
    pub fn builder() -> crate::model::failed_create_workspace_request::Builder {
        crate::model::failed_create_workspace_request::Builder::default()
    }
}

/// <p>Describes the information used to create a WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct WorkspaceRequest {
    /// <p>The identifier of the Directory Service directory for the WorkSpace. You can use <code>DescribeWorkspaceDirectories</code> to list the available directories.</p>
    #[doc(hidden)]
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The user name of the user for the WorkSpace. This user name must exist in the Directory Service directory for the WorkSpace.</p>
    #[doc(hidden)]
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The identifier of the bundle for the WorkSpace. You can use <code>DescribeWorkspaceBundles</code> to list the available bundles.</p>
    #[doc(hidden)]
    pub bundle_id: std::option::Option<std::string::String>,
    /// <p>The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.</p>
    #[doc(hidden)]
    pub volume_encryption_key: std::option::Option<std::string::String>,
    /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
    #[doc(hidden)]
    pub user_volume_encryption_enabled: std::option::Option<bool>,
    /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
    #[doc(hidden)]
    pub root_volume_encryption_enabled: std::option::Option<bool>,
    /// <p>The WorkSpace properties.</p>
    #[doc(hidden)]
    pub workspace_properties: std::option::Option<crate::model::WorkspaceProperties>,
    /// <p>The tags for the WorkSpace.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl WorkspaceRequest {
    /// <p>The identifier of the Directory Service directory for the WorkSpace. You can use <code>DescribeWorkspaceDirectories</code> to list the available directories.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>The user name of the user for the WorkSpace. This user name must exist in the Directory Service directory for the WorkSpace.</p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
    /// <p>The identifier of the bundle for the WorkSpace. You can use <code>DescribeWorkspaceBundles</code> to list the available bundles.</p>
    pub fn bundle_id(&self) -> std::option::Option<&str> {
        self.bundle_id.as_deref()
    }
    /// <p>The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.</p>
    pub fn volume_encryption_key(&self) -> std::option::Option<&str> {
        self.volume_encryption_key.as_deref()
    }
    /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
    pub fn user_volume_encryption_enabled(&self) -> std::option::Option<bool> {
        self.user_volume_encryption_enabled
    }
    /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
    pub fn root_volume_encryption_enabled(&self) -> std::option::Option<bool> {
        self.root_volume_encryption_enabled
    }
    /// <p>The WorkSpace properties.</p>
    pub fn workspace_properties(&self) -> std::option::Option<&crate::model::WorkspaceProperties> {
        self.workspace_properties.as_ref()
    }
    /// <p>The tags for the WorkSpace.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`WorkspaceRequest`](crate::model::WorkspaceRequest).
pub mod workspace_request {

    /// A builder for [`WorkspaceRequest`](crate::model::WorkspaceRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) bundle_id: std::option::Option<std::string::String>,
        pub(crate) volume_encryption_key: std::option::Option<std::string::String>,
        pub(crate) user_volume_encryption_enabled: std::option::Option<bool>,
        pub(crate) root_volume_encryption_enabled: std::option::Option<bool>,
        pub(crate) workspace_properties: std::option::Option<crate::model::WorkspaceProperties>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The identifier of the Directory Service directory for the WorkSpace. You can use <code>DescribeWorkspaceDirectories</code> to list the available directories.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Directory Service directory for the WorkSpace. You can use <code>DescribeWorkspaceDirectories</code> to list the available directories.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The user name of the user for the WorkSpace. This user name must exist in the Directory Service directory for the WorkSpace.</p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>The user name of the user for the WorkSpace. This user name must exist in the Directory Service directory for the WorkSpace.</p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// <p>The identifier of the bundle for the WorkSpace. You can use <code>DescribeWorkspaceBundles</code> to list the available bundles.</p>
        pub fn bundle_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.bundle_id = Some(input.into());
            self
        }
        /// <p>The identifier of the bundle for the WorkSpace. You can use <code>DescribeWorkspaceBundles</code> to list the available bundles.</p>
        pub fn set_bundle_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.bundle_id = input;
            self
        }
        /// <p>The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.</p>
        pub fn volume_encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_encryption_key = Some(input.into());
            self
        }
        /// <p>The symmetric KMS key used to encrypt data stored on your WorkSpace. Amazon WorkSpaces does not support asymmetric KMS keys.</p>
        pub fn set_volume_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_encryption_key = input;
            self
        }
        /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
        pub fn user_volume_encryption_enabled(mut self, input: bool) -> Self {
            self.user_volume_encryption_enabled = Some(input);
            self
        }
        /// <p>Indicates whether the data stored on the user volume is encrypted.</p>
        pub fn set_user_volume_encryption_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.user_volume_encryption_enabled = input;
            self
        }
        /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
        pub fn root_volume_encryption_enabled(mut self, input: bool) -> Self {
            self.root_volume_encryption_enabled = Some(input);
            self
        }
        /// <p>Indicates whether the data stored on the root volume is encrypted.</p>
        pub fn set_root_volume_encryption_enabled(
            mut self,
            input: std::option::Option<bool>,
        ) -> Self {
            self.root_volume_encryption_enabled = input;
            self
        }
        /// <p>The WorkSpace properties.</p>
        pub fn workspace_properties(mut self, input: crate::model::WorkspaceProperties) -> Self {
            self.workspace_properties = Some(input);
            self
        }
        /// <p>The WorkSpace properties.</p>
        pub fn set_workspace_properties(
            mut self,
            input: std::option::Option<crate::model::WorkspaceProperties>,
        ) -> Self {
            self.workspace_properties = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags for the WorkSpace.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags for the WorkSpace.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`WorkspaceRequest`](crate::model::WorkspaceRequest).
        pub fn build(self) -> crate::model::WorkspaceRequest {
            crate::model::WorkspaceRequest {
                directory_id: self.directory_id,
                user_name: self.user_name,
                bundle_id: self.bundle_id,
                volume_encryption_key: self.volume_encryption_key,
                user_volume_encryption_enabled: self.user_volume_encryption_enabled,
                root_volume_encryption_enabled: self.root_volume_encryption_enabled,
                workspace_properties: self.workspace_properties,
                tags: self.tags,
            }
        }
    }
}
impl WorkspaceRequest {
    /// Creates a new builder-style object to manufacture [`WorkspaceRequest`](crate::model::WorkspaceRequest).
    pub fn builder() -> crate::model::workspace_request::Builder {
        crate::model::workspace_request::Builder::default()
    }
}

/// <p>Information about the Standby WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PendingCreateStandbyWorkspacesRequest {
    /// <p>Describes the Standby WorkSpace that was created.</p>
    /// <p>Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html"> DescribeWorkspaces</a> before the WorkSpace is created, the information returned can be incomplete. </p>
    #[doc(hidden)]
    pub user_name: std::option::Option<std::string::String>,
    /// <p>The identifier of the directory for the Standby WorkSpace.</p>
    #[doc(hidden)]
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The operational state of the Standby WorkSpace.</p>
    #[doc(hidden)]
    pub state: std::option::Option<crate::model::WorkspaceState>,
    /// <p>The identifier of the Standby WorkSpace.</p>
    #[doc(hidden)]
    pub workspace_id: std::option::Option<std::string::String>,
}
impl PendingCreateStandbyWorkspacesRequest {
    /// <p>Describes the Standby WorkSpace that was created.</p>
    /// <p>Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html"> DescribeWorkspaces</a> before the WorkSpace is created, the information returned can be incomplete. </p>
    pub fn user_name(&self) -> std::option::Option<&str> {
        self.user_name.as_deref()
    }
    /// <p>The identifier of the directory for the Standby WorkSpace.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>The operational state of the Standby WorkSpace.</p>
    pub fn state(&self) -> std::option::Option<&crate::model::WorkspaceState> {
        self.state.as_ref()
    }
    /// <p>The identifier of the Standby WorkSpace.</p>
    pub fn workspace_id(&self) -> std::option::Option<&str> {
        self.workspace_id.as_deref()
    }
}
/// See [`PendingCreateStandbyWorkspacesRequest`](crate::model::PendingCreateStandbyWorkspacesRequest).
pub mod pending_create_standby_workspaces_request {

    /// A builder for [`PendingCreateStandbyWorkspacesRequest`](crate::model::PendingCreateStandbyWorkspacesRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) user_name: std::option::Option<std::string::String>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) state: std::option::Option<crate::model::WorkspaceState>,
        pub(crate) workspace_id: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Describes the Standby WorkSpace that was created.</p>
        /// <p>Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html"> DescribeWorkspaces</a> before the WorkSpace is created, the information returned can be incomplete. </p>
        pub fn user_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.user_name = Some(input.into());
            self
        }
        /// <p>Describes the Standby WorkSpace that was created.</p>
        /// <p>Because this operation is asynchronous, the identifier returned is not immediately available for use with other operations. For example, if you call <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html"> DescribeWorkspaces</a> before the WorkSpace is created, the information returned can be incomplete. </p>
        pub fn set_user_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.user_name = input;
            self
        }
        /// <p>The identifier of the directory for the Standby WorkSpace.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The identifier of the directory for the Standby WorkSpace.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// <p>The operational state of the Standby WorkSpace.</p>
        pub fn state(mut self, input: crate::model::WorkspaceState) -> Self {
            self.state = Some(input);
            self
        }
        /// <p>The operational state of the Standby WorkSpace.</p>
        pub fn set_state(
            mut self,
            input: std::option::Option<crate::model::WorkspaceState>,
        ) -> Self {
            self.state = input;
            self
        }
        /// <p>The identifier of the Standby WorkSpace.</p>
        pub fn workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Standby WorkSpace.</p>
        pub fn set_workspace_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.workspace_id = input;
            self
        }
        /// Consumes the builder and constructs a [`PendingCreateStandbyWorkspacesRequest`](crate::model::PendingCreateStandbyWorkspacesRequest).
        pub fn build(self) -> crate::model::PendingCreateStandbyWorkspacesRequest {
            crate::model::PendingCreateStandbyWorkspacesRequest {
                user_name: self.user_name,
                directory_id: self.directory_id,
                state: self.state,
                workspace_id: self.workspace_id,
            }
        }
    }
}
impl PendingCreateStandbyWorkspacesRequest {
    /// Creates a new builder-style object to manufacture [`PendingCreateStandbyWorkspacesRequest`](crate::model::PendingCreateStandbyWorkspacesRequest).
    pub fn builder() -> crate::model::pending_create_standby_workspaces_request::Builder {
        crate::model::pending_create_standby_workspaces_request::Builder::default()
    }
}

/// <p>Describes the Standby WorkSpace that could not be created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FailedCreateStandbyWorkspacesRequest {
    /// <p>Information about the Standby WorkSpace that could not be created.</p>
    #[doc(hidden)]
    pub standby_workspace_request: std::option::Option<crate::model::StandbyWorkspace>,
    /// <p>The error code that is returned if the Standby WorkSpace could not be created.</p>
    #[doc(hidden)]
    pub error_code: std::option::Option<std::string::String>,
    /// <p>The text of the error message that is returned if the Standby WorkSpace could not be created.</p>
    #[doc(hidden)]
    pub error_message: std::option::Option<std::string::String>,
}
impl FailedCreateStandbyWorkspacesRequest {
    /// <p>Information about the Standby WorkSpace that could not be created.</p>
    pub fn standby_workspace_request(
        &self,
    ) -> std::option::Option<&crate::model::StandbyWorkspace> {
        self.standby_workspace_request.as_ref()
    }
    /// <p>The error code that is returned if the Standby WorkSpace could not be created.</p>
    pub fn error_code(&self) -> std::option::Option<&str> {
        self.error_code.as_deref()
    }
    /// <p>The text of the error message that is returned if the Standby WorkSpace could not be created.</p>
    pub fn error_message(&self) -> std::option::Option<&str> {
        self.error_message.as_deref()
    }
}
/// See [`FailedCreateStandbyWorkspacesRequest`](crate::model::FailedCreateStandbyWorkspacesRequest).
pub mod failed_create_standby_workspaces_request {

    /// A builder for [`FailedCreateStandbyWorkspacesRequest`](crate::model::FailedCreateStandbyWorkspacesRequest).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) standby_workspace_request: std::option::Option<crate::model::StandbyWorkspace>,
        pub(crate) error_code: std::option::Option<std::string::String>,
        pub(crate) error_message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Information about the Standby WorkSpace that could not be created.</p>
        pub fn standby_workspace_request(mut self, input: crate::model::StandbyWorkspace) -> Self {
            self.standby_workspace_request = Some(input);
            self
        }
        /// <p>Information about the Standby WorkSpace that could not be created.</p>
        pub fn set_standby_workspace_request(
            mut self,
            input: std::option::Option<crate::model::StandbyWorkspace>,
        ) -> Self {
            self.standby_workspace_request = input;
            self
        }
        /// <p>The error code that is returned if the Standby WorkSpace could not be created.</p>
        pub fn error_code(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_code = Some(input.into());
            self
        }
        /// <p>The error code that is returned if the Standby WorkSpace could not be created.</p>
        pub fn set_error_code(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.error_code = input;
            self
        }
        /// <p>The text of the error message that is returned if the Standby WorkSpace could not be created.</p>
        pub fn error_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.error_message = Some(input.into());
            self
        }
        /// <p>The text of the error message that is returned if the Standby WorkSpace could not be created.</p>
        pub fn set_error_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.error_message = input;
            self
        }
        /// Consumes the builder and constructs a [`FailedCreateStandbyWorkspacesRequest`](crate::model::FailedCreateStandbyWorkspacesRequest).
        pub fn build(self) -> crate::model::FailedCreateStandbyWorkspacesRequest {
            crate::model::FailedCreateStandbyWorkspacesRequest {
                standby_workspace_request: self.standby_workspace_request,
                error_code: self.error_code,
                error_message: self.error_message,
            }
        }
    }
}
impl FailedCreateStandbyWorkspacesRequest {
    /// Creates a new builder-style object to manufacture [`FailedCreateStandbyWorkspacesRequest`](crate::model::FailedCreateStandbyWorkspacesRequest).
    pub fn builder() -> crate::model::failed_create_standby_workspaces_request::Builder {
        crate::model::failed_create_standby_workspaces_request::Builder::default()
    }
}

/// <p>Describes a Standby WorkSpace.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct StandbyWorkspace {
    /// <p>The identifier of the Standby WorkSpace.</p>
    #[doc(hidden)]
    pub primary_workspace_id: std::option::Option<std::string::String>,
    /// <p>The volume encryption key of the Standby WorkSpace.</p>
    #[doc(hidden)]
    pub volume_encryption_key: std::option::Option<std::string::String>,
    /// <p>The identifier of the directory for the Standby WorkSpace.</p>
    #[doc(hidden)]
    pub directory_id: std::option::Option<std::string::String>,
    /// <p>The tags associated with the Standby WorkSpace.</p>
    #[doc(hidden)]
    pub tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
}
impl StandbyWorkspace {
    /// <p>The identifier of the Standby WorkSpace.</p>
    pub fn primary_workspace_id(&self) -> std::option::Option<&str> {
        self.primary_workspace_id.as_deref()
    }
    /// <p>The volume encryption key of the Standby WorkSpace.</p>
    pub fn volume_encryption_key(&self) -> std::option::Option<&str> {
        self.volume_encryption_key.as_deref()
    }
    /// <p>The identifier of the directory for the Standby WorkSpace.</p>
    pub fn directory_id(&self) -> std::option::Option<&str> {
        self.directory_id.as_deref()
    }
    /// <p>The tags associated with the Standby WorkSpace.</p>
    pub fn tags(&self) -> std::option::Option<&[crate::model::Tag]> {
        self.tags.as_deref()
    }
}
/// See [`StandbyWorkspace`](crate::model::StandbyWorkspace).
pub mod standby_workspace {

    /// A builder for [`StandbyWorkspace`](crate::model::StandbyWorkspace).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) primary_workspace_id: std::option::Option<std::string::String>,
        pub(crate) volume_encryption_key: std::option::Option<std::string::String>,
        pub(crate) directory_id: std::option::Option<std::string::String>,
        pub(crate) tags: std::option::Option<std::vec::Vec<crate::model::Tag>>,
    }
    impl Builder {
        /// <p>The identifier of the Standby WorkSpace.</p>
        pub fn primary_workspace_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.primary_workspace_id = Some(input.into());
            self
        }
        /// <p>The identifier of the Standby WorkSpace.</p>
        pub fn set_primary_workspace_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.primary_workspace_id = input;
            self
        }
        /// <p>The volume encryption key of the Standby WorkSpace.</p>
        pub fn volume_encryption_key(mut self, input: impl Into<std::string::String>) -> Self {
            self.volume_encryption_key = Some(input.into());
            self
        }
        /// <p>The volume encryption key of the Standby WorkSpace.</p>
        pub fn set_volume_encryption_key(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.volume_encryption_key = input;
            self
        }
        /// <p>The identifier of the directory for the Standby WorkSpace.</p>
        pub fn directory_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.directory_id = Some(input.into());
            self
        }
        /// <p>The identifier of the directory for the Standby WorkSpace.</p>
        pub fn set_directory_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.directory_id = input;
            self
        }
        /// Appends an item to `tags`.
        ///
        /// To override the contents of this collection use [`set_tags`](Self::set_tags).
        ///
        /// <p>The tags associated with the Standby WorkSpace.</p>
        pub fn tags(mut self, input: crate::model::Tag) -> Self {
            let mut v = self.tags.unwrap_or_default();
            v.push(input);
            self.tags = Some(v);
            self
        }
        /// <p>The tags associated with the Standby WorkSpace.</p>
        pub fn set_tags(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Tag>>,
        ) -> Self {
            self.tags = input;
            self
        }
        /// Consumes the builder and constructs a [`StandbyWorkspace`](crate::model::StandbyWorkspace).
        pub fn build(self) -> crate::model::StandbyWorkspace {
            crate::model::StandbyWorkspace {
                primary_workspace_id: self.primary_workspace_id,
                volume_encryption_key: self.volume_encryption_key,
                directory_id: self.directory_id,
                tags: self.tags,
            }
        }
    }
}
impl StandbyWorkspace {
    /// Creates a new builder-style object to manufacture [`StandbyWorkspace`](crate::model::StandbyWorkspace).
    pub fn builder() -> crate::model::standby_workspace::Builder {
        crate::model::standby_workspace::Builder::default()
    }
}
