// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Associates the specified connection alias with the specified directory to enable cross-Region redirection.
/// For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
/// Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
/// <note>
/// <p>Before performing this operation, call <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeConnectionAliases.html">
/// DescribeConnectionAliases</a> to make sure that the current state of the connection alias is <code>CREATED</code>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateConnectionAlias {
    _private: (),
}
impl AssociateConnectionAlias {
    /// Creates a new builder-style object to manufacture [`AssociateConnectionAliasInput`](crate::input::AssociateConnectionAliasInput)
    pub fn builder() -> crate::input::associate_connection_alias_input::Builder {
        crate::input::associate_connection_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateConnectionAlias {
    type Output = std::result::Result<
        crate::output::AssociateConnectionAliasOutput,
        crate::error::AssociateConnectionAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_connection_alias_error(response)
        } else {
            crate::operation_deser::parse_associate_connection_alias_response(response)
        }
    }
}

/// <p>Associates the specified IP access control group with the specified directory.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateIpGroups {
    _private: (),
}
impl AssociateIpGroups {
    /// Creates a new builder-style object to manufacture [`AssociateIpGroupsInput`](crate::input::AssociateIpGroupsInput)
    pub fn builder() -> crate::input::associate_ip_groups_input::Builder {
        crate::input::associate_ip_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateIpGroups {
    type Output = std::result::Result<
        crate::output::AssociateIpGroupsOutput,
        crate::error::AssociateIpGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_ip_groups_error(response)
        } else {
            crate::operation_deser::parse_associate_ip_groups_response(response)
        }
    }
}

/// <p>Adds one or more rules to the specified IP access control group.</p>
/// <p>This action gives users permission to access their WorkSpaces from the CIDR address
/// ranges specified in the rules.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AuthorizeIpRules {
    _private: (),
}
impl AuthorizeIpRules {
    /// Creates a new builder-style object to manufacture [`AuthorizeIpRulesInput`](crate::input::AuthorizeIpRulesInput)
    pub fn builder() -> crate::input::authorize_ip_rules_input::Builder {
        crate::input::authorize_ip_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AuthorizeIpRules {
    type Output = std::result::Result<
        crate::output::AuthorizeIpRulesOutput,
        crate::error::AuthorizeIpRulesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_authorize_ip_rules_error(response)
        } else {
            crate::operation_deser::parse_authorize_ip_rules_response(response)
        }
    }
}

/// <p>Copies the specified image from the specified Region to the current Region.
/// For more information about copying images, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/copy-custom-image.html">
/// Copy a Custom WorkSpaces Image</a>.</p>
/// <note>
/// <p>In the China (Ningxia) Region, you can copy images only within the same Region.</p>
/// <p>In the AWS GovCloud (US-West) Region, to copy images to and from other AWS Regions,
/// contact AWS Support.</p>
/// </note>
/// <important>
/// <p>Before copying a shared image, be sure to verify that it has been shared from the
/// correct AWS account. To determine if an image has been shared and to see the AWS
/// account ID that owns an image, use the <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceImages.html">DescribeWorkSpaceImages</a> and <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaceImagePermissions.html">DescribeWorkspaceImagePermissions</a> API operations. </p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CopyWorkspaceImage {
    _private: (),
}
impl CopyWorkspaceImage {
    /// Creates a new builder-style object to manufacture [`CopyWorkspaceImageInput`](crate::input::CopyWorkspaceImageInput)
    pub fn builder() -> crate::input::copy_workspace_image_input::Builder {
        crate::input::copy_workspace_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CopyWorkspaceImage {
    type Output = std::result::Result<
        crate::output::CopyWorkspaceImageOutput,
        crate::error::CopyWorkspaceImageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_copy_workspace_image_error(response)
        } else {
            crate::operation_deser::parse_copy_workspace_image_response(response)
        }
    }
}

/// <p>Creates the specified connection alias for use with cross-Region redirection. For more information, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
/// Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateConnectionAlias {
    _private: (),
}
impl CreateConnectionAlias {
    /// Creates a new builder-style object to manufacture [`CreateConnectionAliasInput`](crate::input::CreateConnectionAliasInput)
    pub fn builder() -> crate::input::create_connection_alias_input::Builder {
        crate::input::create_connection_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateConnectionAlias {
    type Output = std::result::Result<
        crate::output::CreateConnectionAliasOutput,
        crate::error::CreateConnectionAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_connection_alias_error(response)
        } else {
            crate::operation_deser::parse_create_connection_alias_response(response)
        }
    }
}

/// <p>Creates an IP access control group.</p>
/// <p>An IP access control group provides you with the ability to control the IP addresses
/// from which users are allowed to access their WorkSpaces. To specify the CIDR address
/// ranges, add rules to your IP access control group and then associate the group with your
/// directory. You can add rules when you create the group or at any time using <a>AuthorizeIpRules</a>.</p>
/// <p>There is a default IP access control group associated with your directory. If you don't
/// associate an IP access control group with your directory, the default group is used. The
/// default group includes a default rule that allows users to access their WorkSpaces from
/// anywhere. You cannot modify the default IP access control group for your directory.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateIpGroup {
    _private: (),
}
impl CreateIpGroup {
    /// Creates a new builder-style object to manufacture [`CreateIpGroupInput`](crate::input::CreateIpGroupInput)
    pub fn builder() -> crate::input::create_ip_group_input::Builder {
        crate::input::create_ip_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateIpGroup {
    type Output =
        std::result::Result<crate::output::CreateIpGroupOutput, crate::error::CreateIpGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_ip_group_error(response)
        } else {
            crate::operation_deser::parse_create_ip_group_response(response)
        }
    }
}

/// <p>Creates the specified tags for the specified WorkSpaces resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateTags {
    _private: (),
}
impl CreateTags {
    /// Creates a new builder-style object to manufacture [`CreateTagsInput`](crate::input::CreateTagsInput)
    pub fn builder() -> crate::input::create_tags_input::Builder {
        crate::input::create_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateTags {
    type Output =
        std::result::Result<crate::output::CreateTagsOutput, crate::error::CreateTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_tags_error(response)
        } else {
            crate::operation_deser::parse_create_tags_response(response)
        }
    }
}

/// <p>Creates the specified WorkSpace bundle. For more information about creating WorkSpace bundles, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/create-custom-bundle.html">
/// Create a Custom WorkSpaces Image and Bundle</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateWorkspaceBundle {
    _private: (),
}
impl CreateWorkspaceBundle {
    /// Creates a new builder-style object to manufacture [`CreateWorkspaceBundleInput`](crate::input::CreateWorkspaceBundleInput)
    pub fn builder() -> crate::input::create_workspace_bundle_input::Builder {
        crate::input::create_workspace_bundle_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateWorkspaceBundle {
    type Output = std::result::Result<
        crate::output::CreateWorkspaceBundleOutput,
        crate::error::CreateWorkspaceBundleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_workspace_bundle_error(response)
        } else {
            crate::operation_deser::parse_create_workspace_bundle_response(response)
        }
    }
}

/// <p>Creates one or more WorkSpaces.</p>
/// <p>This operation is asynchronous and returns before the WorkSpaces are created.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateWorkspaces {
    _private: (),
}
impl CreateWorkspaces {
    /// Creates a new builder-style object to manufacture [`CreateWorkspacesInput`](crate::input::CreateWorkspacesInput)
    pub fn builder() -> crate::input::create_workspaces_input::Builder {
        crate::input::create_workspaces_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateWorkspaces {
    type Output = std::result::Result<
        crate::output::CreateWorkspacesOutput,
        crate::error::CreateWorkspacesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_workspaces_error(response)
        } else {
            crate::operation_deser::parse_create_workspaces_response(response)
        }
    }
}

/// <p>Deletes the specified connection alias. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
/// Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
/// <important>
/// <p>
/// <b>If you will no longer be using a fully qualified domain name (FQDN) as the registration code
/// for your WorkSpaces users, you must take certain precautions to prevent potential security issues.</b>
/// For more information, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html#cross-region-redirection-security-considerations">
/// Security Considerations if You Stop Using Cross-Region Redirection</a>.</p>
/// </important>
/// <note>
/// <p>To delete a connection alias that has been shared, the shared account must first disassociate the connection alias
/// from any directories it has been associated with. Then you must unshare the connection alias from the account it has
/// been shared with. You can delete a connection alias only after it is no longer shared with any accounts or
/// associated with any directories.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteConnectionAlias {
    _private: (),
}
impl DeleteConnectionAlias {
    /// Creates a new builder-style object to manufacture [`DeleteConnectionAliasInput`](crate::input::DeleteConnectionAliasInput)
    pub fn builder() -> crate::input::delete_connection_alias_input::Builder {
        crate::input::delete_connection_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteConnectionAlias {
    type Output = std::result::Result<
        crate::output::DeleteConnectionAliasOutput,
        crate::error::DeleteConnectionAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_connection_alias_error(response)
        } else {
            crate::operation_deser::parse_delete_connection_alias_response(response)
        }
    }
}

/// <p>Deletes the specified IP access control group.</p>
/// <p>You cannot delete an IP access control group that is associated with a directory.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteIpGroup {
    _private: (),
}
impl DeleteIpGroup {
    /// Creates a new builder-style object to manufacture [`DeleteIpGroupInput`](crate::input::DeleteIpGroupInput)
    pub fn builder() -> crate::input::delete_ip_group_input::Builder {
        crate::input::delete_ip_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteIpGroup {
    type Output =
        std::result::Result<crate::output::DeleteIpGroupOutput, crate::error::DeleteIpGroupError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_ip_group_error(response)
        } else {
            crate::operation_deser::parse_delete_ip_group_response(response)
        }
    }
}

/// <p>Deletes the specified tags from the specified WorkSpaces resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteTags {
    _private: (),
}
impl DeleteTags {
    /// Creates a new builder-style object to manufacture [`DeleteTagsInput`](crate::input::DeleteTagsInput)
    pub fn builder() -> crate::input::delete_tags_input::Builder {
        crate::input::delete_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteTags {
    type Output =
        std::result::Result<crate::output::DeleteTagsOutput, crate::error::DeleteTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_tags_error(response)
        } else {
            crate::operation_deser::parse_delete_tags_response(response)
        }
    }
}

/// <p>Deletes the specified WorkSpace bundle. For more information about deleting WorkSpace bundles, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/delete_bundle.html">
/// Delete a Custom WorkSpaces Bundle or Image</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteWorkspaceBundle {
    _private: (),
}
impl DeleteWorkspaceBundle {
    /// Creates a new builder-style object to manufacture [`DeleteWorkspaceBundleInput`](crate::input::DeleteWorkspaceBundleInput)
    pub fn builder() -> crate::input::delete_workspace_bundle_input::Builder {
        crate::input::delete_workspace_bundle_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteWorkspaceBundle {
    type Output = std::result::Result<
        crate::output::DeleteWorkspaceBundleOutput,
        crate::error::DeleteWorkspaceBundleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_workspace_bundle_error(response)
        } else {
            crate::operation_deser::parse_delete_workspace_bundle_response(response)
        }
    }
}

/// <p>Deletes the specified image from your account. To delete an image, you must first delete
/// any bundles that are associated with the image and unshare the image if it is shared with
/// other accounts. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteWorkspaceImage {
    _private: (),
}
impl DeleteWorkspaceImage {
    /// Creates a new builder-style object to manufacture [`DeleteWorkspaceImageInput`](crate::input::DeleteWorkspaceImageInput)
    pub fn builder() -> crate::input::delete_workspace_image_input::Builder {
        crate::input::delete_workspace_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteWorkspaceImage {
    type Output = std::result::Result<
        crate::output::DeleteWorkspaceImageOutput,
        crate::error::DeleteWorkspaceImageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_workspace_image_error(response)
        } else {
            crate::operation_deser::parse_delete_workspace_image_response(response)
        }
    }
}

/// <p>Deregisters the specified directory. This operation is asynchronous
/// and returns before the WorkSpace directory is deregistered. If any WorkSpaces are
/// registered to this directory, you must remove them before you can deregister the directory.</p>
/// <note>
/// <p>Simple AD and AD Connector are made available to you free of charge to use with WorkSpaces.
/// If there are no WorkSpaces being used with your Simple AD or AD Connector directory for 30
/// consecutive days, this directory will be automatically deregistered for use with Amazon WorkSpaces,
/// and you will be charged for this directory as per the
/// <a href="http://aws.amazon.com/directoryservice/pricing/">AWS Directory Services pricing terms</a>.</p>
/// <p>To delete empty directories, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/delete-workspaces-directory.html">
/// Delete the Directory for Your WorkSpaces</a>. If you delete your
/// Simple AD or AD Connector directory, you can always create a new one when you want to start using
/// WorkSpaces again.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeregisterWorkspaceDirectory {
    _private: (),
}
impl DeregisterWorkspaceDirectory {
    /// Creates a new builder-style object to manufacture [`DeregisterWorkspaceDirectoryInput`](crate::input::DeregisterWorkspaceDirectoryInput)
    pub fn builder() -> crate::input::deregister_workspace_directory_input::Builder {
        crate::input::deregister_workspace_directory_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeregisterWorkspaceDirectory {
    type Output = std::result::Result<
        crate::output::DeregisterWorkspaceDirectoryOutput,
        crate::error::DeregisterWorkspaceDirectoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_deregister_workspace_directory_error(response)
        } else {
            crate::operation_deser::parse_deregister_workspace_directory_response(response)
        }
    }
}

/// <p>Retrieves a list that describes the configuration of Bring Your Own License (BYOL) for
/// the specified account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccount {
    _private: (),
}
impl DescribeAccount {
    /// Creates a new builder-style object to manufacture [`DescribeAccountInput`](crate::input::DescribeAccountInput)
    pub fn builder() -> crate::input::describe_account_input::Builder {
        crate::input::describe_account_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccount {
    type Output = std::result::Result<
        crate::output::DescribeAccountOutput,
        crate::error::DescribeAccountError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_account_error(response)
        } else {
            crate::operation_deser::parse_describe_account_response(response)
        }
    }
}

/// <p>Retrieves a list that describes modifications to the configuration of Bring Your Own
/// License (BYOL) for the specified account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeAccountModifications {
    _private: (),
}
impl DescribeAccountModifications {
    /// Creates a new builder-style object to manufacture [`DescribeAccountModificationsInput`](crate::input::DescribeAccountModificationsInput)
    pub fn builder() -> crate::input::describe_account_modifications_input::Builder {
        crate::input::describe_account_modifications_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeAccountModifications {
    type Output = std::result::Result<
        crate::output::DescribeAccountModificationsOutput,
        crate::error::DescribeAccountModificationsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_account_modifications_error(response)
        } else {
            crate::operation_deser::parse_describe_account_modifications_response(response)
        }
    }
}

/// <p>Retrieves a list that describes one or more specified Amazon WorkSpaces clients.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeClientProperties {
    _private: (),
}
impl DescribeClientProperties {
    /// Creates a new builder-style object to manufacture [`DescribeClientPropertiesInput`](crate::input::DescribeClientPropertiesInput)
    pub fn builder() -> crate::input::describe_client_properties_input::Builder {
        crate::input::describe_client_properties_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeClientProperties {
    type Output = std::result::Result<
        crate::output::DescribeClientPropertiesOutput,
        crate::error::DescribeClientPropertiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_client_properties_error(response)
        } else {
            crate::operation_deser::parse_describe_client_properties_response(response)
        }
    }
}

/// <p>Retrieves a list that describes the connection aliases used for cross-Region redirection. For more information, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
/// Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConnectionAliases {
    _private: (),
}
impl DescribeConnectionAliases {
    /// Creates a new builder-style object to manufacture [`DescribeConnectionAliasesInput`](crate::input::DescribeConnectionAliasesInput)
    pub fn builder() -> crate::input::describe_connection_aliases_input::Builder {
        crate::input::describe_connection_aliases_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConnectionAliases {
    type Output = std::result::Result<
        crate::output::DescribeConnectionAliasesOutput,
        crate::error::DescribeConnectionAliasesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_connection_aliases_error(response)
        } else {
            crate::operation_deser::parse_describe_connection_aliases_response(response)
        }
    }
}

/// <p>Describes the permissions that the owner of a connection alias has granted to another AWS account for
/// the specified connection alias. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
/// Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeConnectionAliasPermissions {
    _private: (),
}
impl DescribeConnectionAliasPermissions {
    /// Creates a new builder-style object to manufacture [`DescribeConnectionAliasPermissionsInput`](crate::input::DescribeConnectionAliasPermissionsInput)
    pub fn builder() -> crate::input::describe_connection_alias_permissions_input::Builder {
        crate::input::describe_connection_alias_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeConnectionAliasPermissions {
    type Output = std::result::Result<
        crate::output::DescribeConnectionAliasPermissionsOutput,
        crate::error::DescribeConnectionAliasPermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_connection_alias_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_connection_alias_permissions_response(response)
        }
    }
}

/// <p>Describes one or more of your IP access control groups.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeIpGroups {
    _private: (),
}
impl DescribeIpGroups {
    /// Creates a new builder-style object to manufacture [`DescribeIpGroupsInput`](crate::input::DescribeIpGroupsInput)
    pub fn builder() -> crate::input::describe_ip_groups_input::Builder {
        crate::input::describe_ip_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeIpGroups {
    type Output = std::result::Result<
        crate::output::DescribeIpGroupsOutput,
        crate::error::DescribeIpGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_ip_groups_error(response)
        } else {
            crate::operation_deser::parse_describe_ip_groups_response(response)
        }
    }
}

/// <p>Describes the specified tags for the specified WorkSpaces resource.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeTags {
    _private: (),
}
impl DescribeTags {
    /// Creates a new builder-style object to manufacture [`DescribeTagsInput`](crate::input::DescribeTagsInput)
    pub fn builder() -> crate::input::describe_tags_input::Builder {
        crate::input::describe_tags_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeTags {
    type Output =
        std::result::Result<crate::output::DescribeTagsOutput, crate::error::DescribeTagsError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_tags_error(response)
        } else {
            crate::operation_deser::parse_describe_tags_response(response)
        }
    }
}

/// <p>Retrieves a list that describes the available WorkSpace bundles.</p>
/// <p>You can filter the results using either bundle ID or owner, but not both.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkspaceBundles {
    _private: (),
}
impl DescribeWorkspaceBundles {
    /// Creates a new builder-style object to manufacture [`DescribeWorkspaceBundlesInput`](crate::input::DescribeWorkspaceBundlesInput)
    pub fn builder() -> crate::input::describe_workspace_bundles_input::Builder {
        crate::input::describe_workspace_bundles_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkspaceBundles {
    type Output = std::result::Result<
        crate::output::DescribeWorkspaceBundlesOutput,
        crate::error::DescribeWorkspaceBundlesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workspace_bundles_error(response)
        } else {
            crate::operation_deser::parse_describe_workspace_bundles_response(response)
        }
    }
}

/// <p>Describes the available directories that are registered with
/// Amazon WorkSpaces.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkspaceDirectories {
    _private: (),
}
impl DescribeWorkspaceDirectories {
    /// Creates a new builder-style object to manufacture [`DescribeWorkspaceDirectoriesInput`](crate::input::DescribeWorkspaceDirectoriesInput)
    pub fn builder() -> crate::input::describe_workspace_directories_input::Builder {
        crate::input::describe_workspace_directories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkspaceDirectories {
    type Output = std::result::Result<
        crate::output::DescribeWorkspaceDirectoriesOutput,
        crate::error::DescribeWorkspaceDirectoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workspace_directories_error(response)
        } else {
            crate::operation_deser::parse_describe_workspace_directories_response(response)
        }
    }
}

/// <p>Describes the permissions that the owner of an image has granted to other
/// AWS accounts for an image.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkspaceImagePermissions {
    _private: (),
}
impl DescribeWorkspaceImagePermissions {
    /// Creates a new builder-style object to manufacture [`DescribeWorkspaceImagePermissionsInput`](crate::input::DescribeWorkspaceImagePermissionsInput)
    pub fn builder() -> crate::input::describe_workspace_image_permissions_input::Builder {
        crate::input::describe_workspace_image_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkspaceImagePermissions {
    type Output = std::result::Result<
        crate::output::DescribeWorkspaceImagePermissionsOutput,
        crate::error::DescribeWorkspaceImagePermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workspace_image_permissions_error(response)
        } else {
            crate::operation_deser::parse_describe_workspace_image_permissions_response(response)
        }
    }
}

/// <p>Retrieves a list that describes one or more specified images, if the image identifiers
/// are provided. Otherwise, all images in the account are described. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkspaceImages {
    _private: (),
}
impl DescribeWorkspaceImages {
    /// Creates a new builder-style object to manufacture [`DescribeWorkspaceImagesInput`](crate::input::DescribeWorkspaceImagesInput)
    pub fn builder() -> crate::input::describe_workspace_images_input::Builder {
        crate::input::describe_workspace_images_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkspaceImages {
    type Output = std::result::Result<
        crate::output::DescribeWorkspaceImagesOutput,
        crate::error::DescribeWorkspaceImagesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workspace_images_error(response)
        } else {
            crate::operation_deser::parse_describe_workspace_images_response(response)
        }
    }
}

/// <p>Describes the specified WorkSpaces.</p>
/// <p>You can filter the results by using the bundle identifier, directory identifier, or
/// owner, but you can specify only one filter at a time.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkspaces {
    _private: (),
}
impl DescribeWorkspaces {
    /// Creates a new builder-style object to manufacture [`DescribeWorkspacesInput`](crate::input::DescribeWorkspacesInput)
    pub fn builder() -> crate::input::describe_workspaces_input::Builder {
        crate::input::describe_workspaces_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkspaces {
    type Output = std::result::Result<
        crate::output::DescribeWorkspacesOutput,
        crate::error::DescribeWorkspacesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workspaces_error(response)
        } else {
            crate::operation_deser::parse_describe_workspaces_response(response)
        }
    }
}

/// <p>Describes the connection status of the specified WorkSpaces.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkspacesConnectionStatus {
    _private: (),
}
impl DescribeWorkspacesConnectionStatus {
    /// Creates a new builder-style object to manufacture [`DescribeWorkspacesConnectionStatusInput`](crate::input::DescribeWorkspacesConnectionStatusInput)
    pub fn builder() -> crate::input::describe_workspaces_connection_status_input::Builder {
        crate::input::describe_workspaces_connection_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkspacesConnectionStatus {
    type Output = std::result::Result<
        crate::output::DescribeWorkspacesConnectionStatusOutput,
        crate::error::DescribeWorkspacesConnectionStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workspaces_connection_status_error(response)
        } else {
            crate::operation_deser::parse_describe_workspaces_connection_status_response(response)
        }
    }
}

/// <p>Describes the snapshots for the specified WorkSpace.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeWorkspaceSnapshots {
    _private: (),
}
impl DescribeWorkspaceSnapshots {
    /// Creates a new builder-style object to manufacture [`DescribeWorkspaceSnapshotsInput`](crate::input::DescribeWorkspaceSnapshotsInput)
    pub fn builder() -> crate::input::describe_workspace_snapshots_input::Builder {
        crate::input::describe_workspace_snapshots_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeWorkspaceSnapshots {
    type Output = std::result::Result<
        crate::output::DescribeWorkspaceSnapshotsOutput,
        crate::error::DescribeWorkspaceSnapshotsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_workspace_snapshots_error(response)
        } else {
            crate::operation_deser::parse_describe_workspace_snapshots_response(response)
        }
    }
}

/// <p>Disassociates a connection alias from a directory. Disassociating a connection alias disables cross-Region
/// redirection between two directories in different AWS Regions. For more information, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
/// Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
/// <note>
/// <p>Before performing this operation, call <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeConnectionAliases.html">
/// DescribeConnectionAliases</a> to make sure that the current state of the connection alias is <code>CREATED</code>.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateConnectionAlias {
    _private: (),
}
impl DisassociateConnectionAlias {
    /// Creates a new builder-style object to manufacture [`DisassociateConnectionAliasInput`](crate::input::DisassociateConnectionAliasInput)
    pub fn builder() -> crate::input::disassociate_connection_alias_input::Builder {
        crate::input::disassociate_connection_alias_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateConnectionAlias {
    type Output = std::result::Result<
        crate::output::DisassociateConnectionAliasOutput,
        crate::error::DisassociateConnectionAliasError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_connection_alias_error(response)
        } else {
            crate::operation_deser::parse_disassociate_connection_alias_response(response)
        }
    }
}

/// <p>Disassociates the specified IP access control group from the specified directory.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateIpGroups {
    _private: (),
}
impl DisassociateIpGroups {
    /// Creates a new builder-style object to manufacture [`DisassociateIpGroupsInput`](crate::input::DisassociateIpGroupsInput)
    pub fn builder() -> crate::input::disassociate_ip_groups_input::Builder {
        crate::input::disassociate_ip_groups_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateIpGroups {
    type Output = std::result::Result<
        crate::output::DisassociateIpGroupsOutput,
        crate::error::DisassociateIpGroupsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_ip_groups_error(response)
        } else {
            crate::operation_deser::parse_disassociate_ip_groups_response(response)
        }
    }
}

/// <p>Imports the specified Windows 10 Bring Your Own License (BYOL) image into Amazon
/// WorkSpaces. The image must be an already licensed Amazon EC2 image that is in your AWS
/// account, and you must own the image. For more information about creating BYOL images, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/byol-windows-images.html">
/// Bring Your Own Windows Desktop Licenses</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ImportWorkspaceImage {
    _private: (),
}
impl ImportWorkspaceImage {
    /// Creates a new builder-style object to manufacture [`ImportWorkspaceImageInput`](crate::input::ImportWorkspaceImageInput)
    pub fn builder() -> crate::input::import_workspace_image_input::Builder {
        crate::input::import_workspace_image_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ImportWorkspaceImage {
    type Output = std::result::Result<
        crate::output::ImportWorkspaceImageOutput,
        crate::error::ImportWorkspaceImageError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_import_workspace_image_error(response)
        } else {
            crate::operation_deser::parse_import_workspace_image_response(response)
        }
    }
}

/// <p>Retrieves a list of IP address ranges, specified as IPv4 CIDR blocks, that you can use
/// for the network management interface when you enable Bring Your Own License (BYOL). </p>
/// <p>This operation can be run only by AWS accounts that are enabled for BYOL. If your account
/// isn't enabled for BYOL, you'll receive an <code>AccessDeniedException</code> error.</p>
/// <p>The management network interface is connected to a secure Amazon WorkSpaces management
/// network. It is used for interactive streaming of the WorkSpace desktop to Amazon WorkSpaces
/// clients, and to allow Amazon WorkSpaces to manage the WorkSpace.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAvailableManagementCidrRanges {
    _private: (),
}
impl ListAvailableManagementCidrRanges {
    /// Creates a new builder-style object to manufacture [`ListAvailableManagementCidrRangesInput`](crate::input::ListAvailableManagementCidrRangesInput)
    pub fn builder() -> crate::input::list_available_management_cidr_ranges_input::Builder {
        crate::input::list_available_management_cidr_ranges_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListAvailableManagementCidrRanges {
    type Output = std::result::Result<
        crate::output::ListAvailableManagementCidrRangesOutput,
        crate::error::ListAvailableManagementCidrRangesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_available_management_cidr_ranges_error(response)
        } else {
            crate::operation_deser::parse_list_available_management_cidr_ranges_response(response)
        }
    }
}

/// <p>Migrates a WorkSpace from one operating system or bundle type to another, while retaining the data on the user volume.</p>
/// <p>The migration process recreates the WorkSpace by using a new root volume from the target bundle image and the user volume
/// from the last available snapshot of the original WorkSpace. During migration, the original <code>D:\Users\%USERNAME%</code>
/// user profile folder is renamed to <code>D:\Users\%USERNAME%MMddyyTHHmmss%.NotMigrated</code>. A new <code>D:\Users\%USERNAME%\</code>
/// folder is generated by the new OS. Certain files in the old user profile are moved to the new user profile.</p>
/// <p>For available migration scenarios, details about what happens during migration, and best practices, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/migrate-workspaces.html">Migrate a WorkSpace</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct MigrateWorkspace {
    _private: (),
}
impl MigrateWorkspace {
    /// Creates a new builder-style object to manufacture [`MigrateWorkspaceInput`](crate::input::MigrateWorkspaceInput)
    pub fn builder() -> crate::input::migrate_workspace_input::Builder {
        crate::input::migrate_workspace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for MigrateWorkspace {
    type Output = std::result::Result<
        crate::output::MigrateWorkspaceOutput,
        crate::error::MigrateWorkspaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_migrate_workspace_error(response)
        } else {
            crate::operation_deser::parse_migrate_workspace_response(response)
        }
    }
}

/// <p>Modifies the configuration of Bring Your Own License (BYOL) for the specified
/// account.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyAccount {
    _private: (),
}
impl ModifyAccount {
    /// Creates a new builder-style object to manufacture [`ModifyAccountInput`](crate::input::ModifyAccountInput)
    pub fn builder() -> crate::input::modify_account_input::Builder {
        crate::input::modify_account_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyAccount {
    type Output =
        std::result::Result<crate::output::ModifyAccountOutput, crate::error::ModifyAccountError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_account_error(response)
        } else {
            crate::operation_deser::parse_modify_account_response(response)
        }
    }
}

/// <p>Modifies the properties of the specified Amazon WorkSpaces clients.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyClientProperties {
    _private: (),
}
impl ModifyClientProperties {
    /// Creates a new builder-style object to manufacture [`ModifyClientPropertiesInput`](crate::input::ModifyClientPropertiesInput)
    pub fn builder() -> crate::input::modify_client_properties_input::Builder {
        crate::input::modify_client_properties_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyClientProperties {
    type Output = std::result::Result<
        crate::output::ModifyClientPropertiesOutput,
        crate::error::ModifyClientPropertiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_client_properties_error(response)
        } else {
            crate::operation_deser::parse_modify_client_properties_response(response)
        }
    }
}

/// <p>Modifies the self-service WorkSpace management capabilities for your users. For more
/// information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/enable-user-self-service-workspace-management.html">Enable Self-Service WorkSpace Management Capabilities for Your Users</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifySelfservicePermissions {
    _private: (),
}
impl ModifySelfservicePermissions {
    /// Creates a new builder-style object to manufacture [`ModifySelfservicePermissionsInput`](crate::input::ModifySelfservicePermissionsInput)
    pub fn builder() -> crate::input::modify_selfservice_permissions_input::Builder {
        crate::input::modify_selfservice_permissions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifySelfservicePermissions {
    type Output = std::result::Result<
        crate::output::ModifySelfservicePermissionsOutput,
        crate::error::ModifySelfservicePermissionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_selfservice_permissions_error(response)
        } else {
            crate::operation_deser::parse_modify_selfservice_permissions_response(response)
        }
    }
}

/// <p>Specifies which devices and operating systems users can use to access their WorkSpaces.
/// For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/update-directory-details.html#control-device-access">
/// Control Device Access</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyWorkspaceAccessProperties {
    _private: (),
}
impl ModifyWorkspaceAccessProperties {
    /// Creates a new builder-style object to manufacture [`ModifyWorkspaceAccessPropertiesInput`](crate::input::ModifyWorkspaceAccessPropertiesInput)
    pub fn builder() -> crate::input::modify_workspace_access_properties_input::Builder {
        crate::input::modify_workspace_access_properties_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyWorkspaceAccessProperties {
    type Output = std::result::Result<
        crate::output::ModifyWorkspaceAccessPropertiesOutput,
        crate::error::ModifyWorkspaceAccessPropertiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_workspace_access_properties_error(response)
        } else {
            crate::operation_deser::parse_modify_workspace_access_properties_response(response)
        }
    }
}

/// <p>Modify the default properties used to create WorkSpaces.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyWorkspaceCreationProperties {
    _private: (),
}
impl ModifyWorkspaceCreationProperties {
    /// Creates a new builder-style object to manufacture [`ModifyWorkspaceCreationPropertiesInput`](crate::input::ModifyWorkspaceCreationPropertiesInput)
    pub fn builder() -> crate::input::modify_workspace_creation_properties_input::Builder {
        crate::input::modify_workspace_creation_properties_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyWorkspaceCreationProperties {
    type Output = std::result::Result<
        crate::output::ModifyWorkspaceCreationPropertiesOutput,
        crate::error::ModifyWorkspaceCreationPropertiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_workspace_creation_properties_error(response)
        } else {
            crate::operation_deser::parse_modify_workspace_creation_properties_response(response)
        }
    }
}

/// <p>Modifies the specified WorkSpace properties. For important information about how
/// to modify the size of the root and user volumes, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/modify-workspaces.html">
/// Modify a WorkSpace</a>.
/// </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyWorkspaceProperties {
    _private: (),
}
impl ModifyWorkspaceProperties {
    /// Creates a new builder-style object to manufacture [`ModifyWorkspacePropertiesInput`](crate::input::ModifyWorkspacePropertiesInput)
    pub fn builder() -> crate::input::modify_workspace_properties_input::Builder {
        crate::input::modify_workspace_properties_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyWorkspaceProperties {
    type Output = std::result::Result<
        crate::output::ModifyWorkspacePropertiesOutput,
        crate::error::ModifyWorkspacePropertiesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_workspace_properties_error(response)
        } else {
            crate::operation_deser::parse_modify_workspace_properties_response(response)
        }
    }
}

/// <p>Sets the state of the specified WorkSpace.</p>
/// <p>To maintain a WorkSpace without being interrupted, set the WorkSpace state to
/// <code>ADMIN_MAINTENANCE</code>. WorkSpaces in this state do not respond to requests to
/// reboot, stop, start, rebuild, or restore. An AutoStop WorkSpace in this state is not
/// stopped. Users cannot log into a WorkSpace in the <code>ADMIN_MAINTENANCE</code>
/// state.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ModifyWorkspaceState {
    _private: (),
}
impl ModifyWorkspaceState {
    /// Creates a new builder-style object to manufacture [`ModifyWorkspaceStateInput`](crate::input::ModifyWorkspaceStateInput)
    pub fn builder() -> crate::input::modify_workspace_state_input::Builder {
        crate::input::modify_workspace_state_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ModifyWorkspaceState {
    type Output = std::result::Result<
        crate::output::ModifyWorkspaceStateOutput,
        crate::error::ModifyWorkspaceStateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_modify_workspace_state_error(response)
        } else {
            crate::operation_deser::parse_modify_workspace_state_response(response)
        }
    }
}

/// <p>Reboots the specified WorkSpaces.</p>
/// <p>You cannot reboot a WorkSpace unless its state is <code>AVAILABLE</code> or
/// <code>UNHEALTHY</code>.</p>
/// <p>This operation is asynchronous and returns before the WorkSpaces have rebooted.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RebootWorkspaces {
    _private: (),
}
impl RebootWorkspaces {
    /// Creates a new builder-style object to manufacture [`RebootWorkspacesInput`](crate::input::RebootWorkspacesInput)
    pub fn builder() -> crate::input::reboot_workspaces_input::Builder {
        crate::input::reboot_workspaces_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RebootWorkspaces {
    type Output = std::result::Result<
        crate::output::RebootWorkspacesOutput,
        crate::error::RebootWorkspacesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_reboot_workspaces_error(response)
        } else {
            crate::operation_deser::parse_reboot_workspaces_response(response)
        }
    }
}

/// <p>Rebuilds the specified WorkSpace.</p>
/// <p>You cannot rebuild a WorkSpace unless its state is <code>AVAILABLE</code>,
/// <code>ERROR</code>, <code>UNHEALTHY</code>, <code>STOPPED</code>, or <code>REBOOTING</code>.</p>
/// <p>Rebuilding a WorkSpace is a potentially destructive action that can result in the loss
/// of data. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/reset-workspace.html">Rebuild a
/// WorkSpace</a>.</p>
/// <p>This operation is asynchronous and returns before the WorkSpaces have been completely
/// rebuilt.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RebuildWorkspaces {
    _private: (),
}
impl RebuildWorkspaces {
    /// Creates a new builder-style object to manufacture [`RebuildWorkspacesInput`](crate::input::RebuildWorkspacesInput)
    pub fn builder() -> crate::input::rebuild_workspaces_input::Builder {
        crate::input::rebuild_workspaces_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RebuildWorkspaces {
    type Output = std::result::Result<
        crate::output::RebuildWorkspacesOutput,
        crate::error::RebuildWorkspacesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_rebuild_workspaces_error(response)
        } else {
            crate::operation_deser::parse_rebuild_workspaces_response(response)
        }
    }
}

/// <p>Registers the specified directory. This operation is asynchronous
/// and returns before the WorkSpace directory is registered. If this is the first time you are
/// registering a directory, you will need to create the workspaces_DefaultRole role before you can
/// register a directory. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/workspaces-access-control.html#create-default-role">
/// Creating the workspaces_DefaultRole Role</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RegisterWorkspaceDirectory {
    _private: (),
}
impl RegisterWorkspaceDirectory {
    /// Creates a new builder-style object to manufacture [`RegisterWorkspaceDirectoryInput`](crate::input::RegisterWorkspaceDirectoryInput)
    pub fn builder() -> crate::input::register_workspace_directory_input::Builder {
        crate::input::register_workspace_directory_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RegisterWorkspaceDirectory {
    type Output = std::result::Result<
        crate::output::RegisterWorkspaceDirectoryOutput,
        crate::error::RegisterWorkspaceDirectoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_register_workspace_directory_error(response)
        } else {
            crate::operation_deser::parse_register_workspace_directory_response(response)
        }
    }
}

/// <p>Restores the specified WorkSpace to its last known healthy state.</p>
/// <p>You cannot restore a WorkSpace unless its state is <code> AVAILABLE</code>,
/// <code>ERROR</code>, <code>UNHEALTHY</code>, or <code>STOPPED</code>.</p>
/// <p>Restoring a WorkSpace is a potentially destructive action that can result in the loss of
/// data. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/restore-workspace.html">Restore a
/// WorkSpace</a>.</p>
/// <p>This operation is asynchronous and returns before the WorkSpace is completely
/// restored.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RestoreWorkspace {
    _private: (),
}
impl RestoreWorkspace {
    /// Creates a new builder-style object to manufacture [`RestoreWorkspaceInput`](crate::input::RestoreWorkspaceInput)
    pub fn builder() -> crate::input::restore_workspace_input::Builder {
        crate::input::restore_workspace_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RestoreWorkspace {
    type Output = std::result::Result<
        crate::output::RestoreWorkspaceOutput,
        crate::error::RestoreWorkspaceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_restore_workspace_error(response)
        } else {
            crate::operation_deser::parse_restore_workspace_response(response)
        }
    }
}

/// <p>Removes one or more rules from the specified IP access control group.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct RevokeIpRules {
    _private: (),
}
impl RevokeIpRules {
    /// Creates a new builder-style object to manufacture [`RevokeIpRulesInput`](crate::input::RevokeIpRulesInput)
    pub fn builder() -> crate::input::revoke_ip_rules_input::Builder {
        crate::input::revoke_ip_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for RevokeIpRules {
    type Output =
        std::result::Result<crate::output::RevokeIpRulesOutput, crate::error::RevokeIpRulesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_revoke_ip_rules_error(response)
        } else {
            crate::operation_deser::parse_revoke_ip_rules_response(response)
        }
    }
}

/// <p>Starts the specified WorkSpaces.</p>
/// <p>You cannot start a WorkSpace unless it has a running mode of <code>AutoStop</code> and a
/// state of <code>STOPPED</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StartWorkspaces {
    _private: (),
}
impl StartWorkspaces {
    /// Creates a new builder-style object to manufacture [`StartWorkspacesInput`](crate::input::StartWorkspacesInput)
    pub fn builder() -> crate::input::start_workspaces_input::Builder {
        crate::input::start_workspaces_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StartWorkspaces {
    type Output = std::result::Result<
        crate::output::StartWorkspacesOutput,
        crate::error::StartWorkspacesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_start_workspaces_error(response)
        } else {
            crate::operation_deser::parse_start_workspaces_response(response)
        }
    }
}

/// <p> Stops the specified WorkSpaces.</p>
/// <p>You cannot stop a WorkSpace unless it has a running mode of <code>AutoStop</code> and a
/// state of <code>AVAILABLE</code>, <code>IMPAIRED</code>, <code>UNHEALTHY</code>, or
/// <code>ERROR</code>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct StopWorkspaces {
    _private: (),
}
impl StopWorkspaces {
    /// Creates a new builder-style object to manufacture [`StopWorkspacesInput`](crate::input::StopWorkspacesInput)
    pub fn builder() -> crate::input::stop_workspaces_input::Builder {
        crate::input::stop_workspaces_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for StopWorkspaces {
    type Output =
        std::result::Result<crate::output::StopWorkspacesOutput, crate::error::StopWorkspacesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_stop_workspaces_error(response)
        } else {
            crate::operation_deser::parse_stop_workspaces_response(response)
        }
    }
}

/// <p>Terminates the specified WorkSpaces.</p>
/// <important>
/// <p>Terminating a WorkSpace is a permanent action and cannot be undone. The user's data is
/// destroyed. If you need to archive any user data, contact AWS Support before
/// terminating the WorkSpace.</p>
/// </important>
/// <p>You can terminate a WorkSpace that is in any state except <code>SUSPENDED</code>.</p>
/// <p>This operation is asynchronous and returns before the WorkSpaces have been completely
/// terminated. After a WorkSpace is terminated, the <code>TERMINATED</code> state is returned
/// only briefly before the WorkSpace directory metadata is cleaned up, so this state is rarely
/// returned. To confirm that a WorkSpace is terminated, check for the WorkSpace ID by using
/// <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeWorkspaces.html">
/// DescribeWorkSpaces</a>. If the WorkSpace ID isn't returned, then the WorkSpace has
/// been successfully terminated.</p>      
/// <note>
/// <p>Simple AD and AD Connector are made available to you free of charge to use with WorkSpaces.
/// If there are no WorkSpaces being used with your Simple AD or AD Connector directory for 30
/// consecutive days, this directory will be automatically deregistered for use with Amazon WorkSpaces,
/// and you will be charged for this directory as per the
/// <a href="http://aws.amazon.com/directoryservice/pricing/">AWS Directory Services pricing terms</a>.</p>
/// <p>To delete empty directories, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/delete-workspaces-directory.html">
/// Delete the Directory for Your WorkSpaces</a>. If you delete your
/// Simple AD or AD Connector directory, you can always create a new one when you want to start using
/// WorkSpaces again.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TerminateWorkspaces {
    _private: (),
}
impl TerminateWorkspaces {
    /// Creates a new builder-style object to manufacture [`TerminateWorkspacesInput`](crate::input::TerminateWorkspacesInput)
    pub fn builder() -> crate::input::terminate_workspaces_input::Builder {
        crate::input::terminate_workspaces_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TerminateWorkspaces {
    type Output = std::result::Result<
        crate::output::TerminateWorkspacesOutput,
        crate::error::TerminateWorkspacesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_terminate_workspaces_error(response)
        } else {
            crate::operation_deser::parse_terminate_workspaces_response(response)
        }
    }
}

/// <p>Shares or unshares a connection alias with one account by specifying whether that account has permission to
/// associate the connection alias with a directory. If the association permission is granted, the connection alias
/// is shared with that account. If the association permission is revoked, the connection alias is unshared with the
/// account. For more information, see <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/cross-region-redirection.html">
/// Cross-Region Redirection for Amazon WorkSpaces</a>.</p>
/// <note>
/// <ul>
/// <li>
/// <p>Before performing this operation, call <a href="https://docs.aws.amazon.com/workspaces/latest/api/API_DescribeConnectionAliases.html">
/// DescribeConnectionAliases</a> to make sure that the current state of the connection alias is <code>CREATED</code>.</p>
/// </li>
/// <li>
/// <p>To delete a connection alias that has been shared, the shared account must first disassociate the
/// connection alias from any directories it has been associated with. Then you must unshare the connection
/// alias from the account it has been shared with. You can delete a connection alias only after it is no
/// longer shared with any accounts or associated with any directories.</p>
/// </li>
/// </ul>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateConnectionAliasPermission {
    _private: (),
}
impl UpdateConnectionAliasPermission {
    /// Creates a new builder-style object to manufacture [`UpdateConnectionAliasPermissionInput`](crate::input::UpdateConnectionAliasPermissionInput)
    pub fn builder() -> crate::input::update_connection_alias_permission_input::Builder {
        crate::input::update_connection_alias_permission_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateConnectionAliasPermission {
    type Output = std::result::Result<
        crate::output::UpdateConnectionAliasPermissionOutput,
        crate::error::UpdateConnectionAliasPermissionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_connection_alias_permission_error(response)
        } else {
            crate::operation_deser::parse_update_connection_alias_permission_response(response)
        }
    }
}

/// <p>Replaces the current rules of the specified IP access control group with the specified
/// rules.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRulesOfIpGroup {
    _private: (),
}
impl UpdateRulesOfIpGroup {
    /// Creates a new builder-style object to manufacture [`UpdateRulesOfIpGroupInput`](crate::input::UpdateRulesOfIpGroupInput)
    pub fn builder() -> crate::input::update_rules_of_ip_group_input::Builder {
        crate::input::update_rules_of_ip_group_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRulesOfIpGroup {
    type Output = std::result::Result<
        crate::output::UpdateRulesOfIpGroupOutput,
        crate::error::UpdateRulesOfIpGroupError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_rules_of_ip_group_error(response)
        } else {
            crate::operation_deser::parse_update_rules_of_ip_group_response(response)
        }
    }
}

/// <p>Updates a WorkSpace bundle with a new image. For more information about updating WorkSpace bundles, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/update-custom-bundle.html">
/// Update a Custom WorkSpaces Bundle</a>.</p>
/// <important>
/// <p>Existing WorkSpaces aren't automatically updated when you update the bundle that they're
/// based on. To update existing WorkSpaces that are based on a bundle that you've updated, you
/// must either rebuild the WorkSpaces or delete and recreate them.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateWorkspaceBundle {
    _private: (),
}
impl UpdateWorkspaceBundle {
    /// Creates a new builder-style object to manufacture [`UpdateWorkspaceBundleInput`](crate::input::UpdateWorkspaceBundleInput)
    pub fn builder() -> crate::input::update_workspace_bundle_input::Builder {
        crate::input::update_workspace_bundle_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateWorkspaceBundle {
    type Output = std::result::Result<
        crate::output::UpdateWorkspaceBundleOutput,
        crate::error::UpdateWorkspaceBundleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_workspace_bundle_error(response)
        } else {
            crate::operation_deser::parse_update_workspace_bundle_response(response)
        }
    }
}

/// <p>Shares or unshares an image with one account in the same AWS Region by specifying whether that account has
/// permission to copy the image. If the copy image permission is granted, the image is shared with that account.
/// If the copy image permission is revoked, the image is unshared with the account.</p>
/// <p>After an image has been shared, the recipient account can copy the image to other AWS Regions as needed.</p>
/// <note>
/// <p>In the China (Ningxia) Region, you can copy images only within the same Region.</p>
/// <p>In the AWS GovCloud (US-West) Region, to copy images to and from other AWS Regions,
/// contact AWS Support.</p>
/// </note>
/// <p>For more information about sharing images, see
/// <a href="https://docs.aws.amazon.com/workspaces/latest/adminguide/share-custom-image.html">
/// Share or Unshare a Custom WorkSpaces Image</a>.</p>
/// <note>
/// <ul>
/// <li>
/// <p>To delete an image that has been shared, you must unshare the image before you delete it.</p>
/// </li>
/// <li>
/// <p>Sharing Bring Your Own License (BYOL) images across AWS accounts isn't supported at
/// this time in the AWS GovCloud (US-West) Region. To share BYOL images across accounts in
/// the AWS GovCloud (US-West) Region, contact AWS Support.</p>
/// </li>
/// </ul>         
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateWorkspaceImagePermission {
    _private: (),
}
impl UpdateWorkspaceImagePermission {
    /// Creates a new builder-style object to manufacture [`UpdateWorkspaceImagePermissionInput`](crate::input::UpdateWorkspaceImagePermissionInput)
    pub fn builder() -> crate::input::update_workspace_image_permission_input::Builder {
        crate::input::update_workspace_image_permission_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateWorkspaceImagePermission {
    type Output = std::result::Result<
        crate::output::UpdateWorkspaceImagePermissionOutput,
        crate::error::UpdateWorkspaceImagePermissionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_workspace_image_permission_error(response)
        } else {
            crate::operation_deser::parse_update_workspace_image_permission_response(response)
        }
    }
}
