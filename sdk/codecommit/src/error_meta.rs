// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
    ActorDoesNotExistException(crate::error::ActorDoesNotExistException),
    /// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
    ApprovalRuleContentRequiredException(crate::error::ApprovalRuleContentRequiredException),
    /// <p>The specified approval rule does not exist.</p>
    ApprovalRuleDoesNotExistException(crate::error::ApprovalRuleDoesNotExistException),
    /// <p>An approval rule with that name already exists. Approval rule names must be unique within the scope of a pull request.</p>
    ApprovalRuleNameAlreadyExistsException(crate::error::ApprovalRuleNameAlreadyExistsException),
    /// <p>An approval rule name is required, but was not specified.</p>
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    /// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
    ApprovalRuleTemplateContentRequiredException(crate::error::ApprovalRuleTemplateContentRequiredException),
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(crate::error::ApprovalRuleTemplateDoesNotExistException),
    /// <p>The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove all associations, and then try again.</p>
    ApprovalRuleTemplateInUseException(crate::error::ApprovalRuleTemplateInUseException),
    /// <p>You cannot create an approval rule template with that name because a template with that name already exists in this AWS Region for your AWS account. Approval rule template names must be unique.</p>
    ApprovalRuleTemplateNameAlreadyExistsException(crate::error::ApprovalRuleTemplateNameAlreadyExistsException),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(crate::error::ApprovalRuleTemplateNameRequiredException),
    /// <p>An approval state is required, but was not specified.</p>
    ApprovalStateRequiredException(crate::error::ApprovalStateRequiredException),
    /// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
    AuthorDoesNotExistException(crate::error::AuthorDoesNotExistException),
    /// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
    BeforeCommitIdAndAfterCommitIdAreSameException(crate::error::BeforeCommitIdAndAfterCommitIdAreSameException),
    /// <p>The specified blob does not exist.</p>
    BlobIdDoesNotExistException(crate::error::BlobIdDoesNotExistException),
    /// <p>A blob ID is required, but was not specified.</p>
    BlobIdRequiredException(crate::error::BlobIdRequiredException),
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name. Branch names must be unique.</p>
    BranchNameExistsException(crate::error::BranchNameExistsException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The approval rule cannot be deleted from the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
    CannotDeleteApprovalRuleFromTemplateException(crate::error::CannotDeleteApprovalRuleFromTemplateException),
    /// <p>The approval rule cannot be modified for the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
    CannotModifyApprovalRuleFromTemplateException(crate::error::CannotModifyApprovalRuleFromTemplateException),
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(crate::error::CommentContentSizeLimitExceededException),
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>You cannot modify or delete this comment. Only comment authors can modify or delete their comments.</p>
    CommentNotCreatedByCallerException(crate::error::CommentNotCreatedByCallerException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>The specified commit ID does not exist.</p>
    CommitIdDoesNotExistException(crate::error::CommitIdDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.</p>
    CommitIdsLimitExceededException(crate::error::CommitIdsLimitExceededException),
    /// <p>A list of commit IDs is required, but was either not specified or the list was empty.</p>
    CommitIdsListRequiredException(crate::error::CommitIdsListRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.</p>
    DefaultBranchCannotBeDeletedException(crate::error::DefaultBranchCannotBeDeletedException),
    /// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
    DirectoryNameConflictsWithFileNameException(crate::error::DirectoryNameConflictsWithFileNameException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(crate::error::EncryptionIntegrityChecksFailedException),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.</p>
    FileContentAndSourceFileSpecifiedException(crate::error::FileContentAndSourceFileSpecifiedException),
    /// <p>The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.</p>
    FileContentRequiredException(crate::error::FileContentRequiredException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    /// <p>The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.</p>
    FileEntryRequiredException(crate::error::FileEntryRequiredException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::error::FileModeRequiredException),
    /// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
    FileNameConflictsWithDirectoryNameException(crate::error::FileNameConflictsWithDirectoryNameException),
    /// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
    FilePathConflictsWithSubmodulePathException(crate::error::FilePathConflictsWithSubmodulePathException),
    /// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    FileTooLargeException(crate::error::FileTooLargeException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified folder does not exist. Either the folder name is not correct, or you did not enter the full path to the folder.</p>
    FolderDoesNotExistException(crate::error::FolderDoesNotExistException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    /// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request, and then try again.</p>
    InvalidActorArnException(crate::error::InvalidActorArnException),
    /// <p>The content for the approval rule is not valid.</p>
    InvalidApprovalRuleContentException(crate::error::InvalidApprovalRuleContentException),
    /// <p>The name for the approval rule is not valid.</p>
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    /// <p>The content of the approval rule template is not valid.</p>
    InvalidApprovalRuleTemplateContentException(crate::error::InvalidApprovalRuleTemplateContentException),
    /// <p>The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateDescriptionException(crate::error::InvalidApprovalRuleTemplateDescriptionException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(crate::error::InvalidApprovalRuleTemplateNameException),
    /// <p>The state for the approval is not valid. Valid values include APPROVE and REVOKE. </p>
    InvalidApprovalStateException(crate::error::InvalidApprovalStateException),
    /// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.</p>
    InvalidAuthorArnException(crate::error::InvalidAuthorArnException),
    /// <p>The specified blob is not valid.</p>
    InvalidBlobIdException(crate::error::InvalidBlobIdException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(crate::error::InvalidConflictResolutionStrategyException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified deletion parameter is not valid.</p>
    InvalidDeletionParameterException(crate::error::InvalidDeletionParameterException),
    /// <p>The pull request description is not valid. Descriptions cannot be more than 1,000 characters.</p>
    InvalidDescriptionException(crate::error::InvalidDescriptionException),
    /// <p>The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID. </p>
    InvalidDestinationCommitSpecifierException(crate::error::InvalidDestinationCommitSpecifierException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The location of the file is not valid. Make sure that you include the file name and extension.</p>
    InvalidFileLocationException(crate::error::InvalidFileLocationException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
    InvalidFilePositionException(crate::error::InvalidFilePositionException),
    /// <p>The specified value for the number of conflict files to return is not valid.</p>
    InvalidMaxConflictFilesException(crate::error::InvalidMaxConflictFilesException),
    /// <p>The specified value for the number of merge hunks to return is not valid.</p>
    InvalidMaxMergeHunksException(crate::error::InvalidMaxMergeHunksException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    /// <p>The specified sort order is not valid.</p>
    InvalidOrderException(crate::error::InvalidOrderException),
    /// <p>The override status is not valid. Valid statuses are OVERRIDE and REVOKE.</p>
    InvalidOverrideStatusException(crate::error::InvalidOverrideStatusException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>The pull request event type is not valid. </p>
    InvalidPullRequestEventTypeException(crate::error::InvalidPullRequestEventTypeException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
    InvalidPullRequestStatusException(crate::error::InvalidPullRequestStatusException),
    /// <p>The pull request status update is not valid. The only valid update is from <code>OPEN</code> to <code>CLOSED</code>.</p>
    InvalidPullRequestStatusUpdateException(crate::error::InvalidPullRequestStatusUpdateException),
    /// <p>The Amazon Resource Name (ARN) of the user or identity is not valid.</p>
    InvalidReactionUserArnException(crate::error::InvalidReactionUserArnException),
    /// <p>The value of the reaction is not valid. For more information, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit User Guide</a>.</p>
    InvalidReactionValueException(crate::error::InvalidReactionValueException),
    /// <p>The specified reference name format is not valid. Reference names must conform to the Git references format (for example, refs/heads/master). For more information, see <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">Git Internals - Git References</a> or consult your Git documentation.</p>
    InvalidReferenceNameException(crate::error::InvalidReferenceNameException),
    /// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
    InvalidRelativeFileVersionEnumException(crate::error::InvalidRelativeFileVersionEnumException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>The specified repository description is not valid.</p>
    InvalidRepositoryDescriptionException(crate::error::InvalidRepositoryDescriptionException),
    /// <p>A specified repository name is not valid.</p> <note> 
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p> 
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>One or more branch names specified for the trigger is not valid.</p>
    InvalidRepositoryTriggerBranchNameException(crate::error::InvalidRepositoryTriggerBranchNameException),
    /// <p>The custom data provided for the trigger is not valid.</p>
    InvalidRepositoryTriggerCustomDataException(crate::error::InvalidRepositoryTriggerCustomDataException),
    /// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
    InvalidRepositoryTriggerDestinationArnException(crate::error::InvalidRepositoryTriggerDestinationArnException),
    /// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
    InvalidRepositoryTriggerEventsException(crate::error::InvalidRepositoryTriggerEventsException),
    /// <p>The name of the trigger is not valid.</p>
    InvalidRepositoryTriggerNameException(crate::error::InvalidRepositoryTriggerNameException),
    /// <p>The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.</p>
    InvalidRepositoryTriggerRegionException(crate::error::InvalidRepositoryTriggerRegionException),
    /// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The SHA-256 hash signature for the rule content is not valid.</p>
    InvalidRuleContentSha256Exception(crate::error::InvalidRuleContentSha256Exception),
    /// <p>The specified sort by value is not valid.</p>
    InvalidSortByException(crate::error::InvalidSortByException),
    /// <p>The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.</p>
    InvalidSourceCommitSpecifierException(crate::error::InvalidSourceCommitSpecifierException),
    /// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    /// <p>The list of tags is not valid.</p>
    InvalidTagKeysListException(crate::error::InvalidTagKeysListException),
    /// <p>The map of tags is not valid.</p>
    InvalidTagsMapException(crate::error::InvalidTagsMapException),
    /// <p>The specified target branch is not valid.</p>
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    /// <p>The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
    InvalidTargetException(crate::error::InvalidTargetException),
    /// <p>The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for the repository name, source branch, and destination branch for a pull request.</p>
    InvalidTargetsException(crate::error::InvalidTargetsException),
    /// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
    InvalidTitleException(crate::error::InvalidTitleException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of branches for the trigger was exceeded.</p>
    MaximumBranchesExceededException(crate::error::MaximumBranchesExceededException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(crate::error::MaximumConflictResolutionEntriesExceededException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(crate::error::MaximumFileContentToLoadExceededException),
    /// <p>The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.</p>
    MaximumFileEntriesExceededException(crate::error::MaximumFileEntriesExceededException),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>The number of approvals required for the approval rule exceeds the maximum number allowed.</p>
    MaximumNumberOfApprovalsExceededException(crate::error::MaximumNumberOfApprovalsExceededException),
    /// <p>You cannot create the pull request because the repository has too many open pull requests. The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.</p>
    MaximumOpenPullRequestsExceededException(crate::error::MaximumOpenPullRequestsExceededException),
    /// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    /// <p>The number of triggers allowed for the repository was exceeded.</p>
    MaximumRepositoryTriggersExceededException(crate::error::MaximumRepositoryTriggersExceededException),
    /// <p>The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25 approval rule templates with a repository.</p>
    MaximumRuleTemplatesAssociatedWithRepositoryException(crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(crate::error::MultipleConflictResolutionEntriesException),
    /// <p>You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.</p>
    MultipleRepositoriesInPullRequestException(crate::error::MultipleRepositoriesInPullRequestException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.</p>
    NoChangeException(crate::error::NoChangeException),
    /// <p>The maximum number of approval rule templates has been exceeded for this AWS Region. </p>
    NumberOfRuleTemplatesExceededException(crate::error::NumberOfRuleTemplatesExceededException),
    /// <p>The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.</p>
    NumberOfRulesExceededException(crate::error::NumberOfRulesExceededException),
    /// <p>The pull request has already had its approval rules set to override.</p>
    OverrideAlreadySetException(crate::error::OverrideAlreadySetException),
    /// <p>An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.</p>
    OverrideStatusRequiredException(crate::error::OverrideStatusRequiredException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    /// <p>The specified path does not exist.</p>
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(crate::error::PullRequestApprovalRulesNotSatisfiedException),
    /// <p>The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull request that you created.</p>
    PullRequestCannotBeApprovedByAuthorException(crate::error::PullRequestCannotBeApprovedByAuthorException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A pull request status is required, but none was provided.</p>
    PullRequestStatusRequiredException(crate::error::PullRequestStatusRequiredException),
    /// <p>The commit cannot be created because one or more files specified in the commit reference both a file and a folder.</p>
    PutFileEntryConflictException(crate::error::PutFileEntryConflictException),
    /// <p>The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.</p>
    ReactionLimitExceededException(crate::error::ReactionLimitExceededException),
    /// <p>A reaction value is required. </p>
    ReactionValueRequiredException(crate::error::ReactionValueRequiredException),
    /// <p>The specified reference does not exist. You must provide a full commit ID.</p>
    ReferenceDoesNotExistException(crate::error::ReferenceDoesNotExistException),
    /// <p>A reference name is required, but none was provided.</p>
    ReferenceNameRequiredException(crate::error::ReferenceNameRequiredException),
    /// <p>The specified reference is not a supported type. </p>
    ReferenceTypeNotSupportedException(crate::error::ReferenceTypeNotSupportedException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository resource limit was exceeded.</p>
    RepositoryLimitExceededException(crate::error::RepositoryLimitExceededException),
    /// <p>The specified repository name already exists.</p>
    RepositoryNameExistsException(crate::error::RepositoryNameExistsException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>At least one repository name object is required, but was not specified.</p>
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(crate::error::RepositoryNotAssociatedWithPullRequestException),
    /// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
    RepositoryTriggerBranchNameListRequiredException(crate::error::RepositoryTriggerBranchNameListRequiredException),
    /// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
    RepositoryTriggerDestinationArnRequiredException(crate::error::RepositoryTriggerDestinationArnRequiredException),
    /// <p>At least one event for the trigger is required, but was not specified.</p>
    RepositoryTriggerEventsListRequiredException(crate::error::RepositoryTriggerEventsListRequiredException),
    /// <p>A name for the trigger is required, but was not specified.</p>
    RepositoryTriggerNameRequiredException(crate::error::RepositoryTriggerNameRequiredException),
    /// <p>The list of triggers for the repository is required, but was not specified.</p>
    RepositoryTriggersListRequiredException(crate::error::RepositoryTriggersListRequiredException),
    /// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// <p>The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.</p>
    RestrictedSourceFileException(crate::error::RestrictedSourceFileException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// <p>The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.</p>
    SameFileContentException(crate::error::SameFileContentException),
    /// <p>The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.</p>
    SamePathRequestException(crate::error::SamePathRequestException),
    /// <p>The source branch and destination branch for the pull request are the same. You must specify different branches for the source and destination.</p>
    SourceAndDestinationAreSameException(crate::error::SourceAndDestinationAreSameException),
    /// <p>The commit cannot be created because no source files or file content have been specified for the commit.</p>
    SourceFileOrContentRequiredException(crate::error::SourceFileOrContentRequiredException),
    /// <p>A list of tag keys is required. The list cannot be empty or null.</p>
    TagKeysListRequiredException(crate::error::TagKeysListRequiredException),
    /// <p>The tag policy is not valid.</p>
    TagPolicyException(crate::error::TagPolicyException),
    /// <p>A map of tags is required.</p>
    TagsMapRequiredException(crate::error::TagsMapRequiredException),
    /// <p>A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
    TargetRequiredException(crate::error::TargetRequiredException),
    /// <p>An array of target objects is required. It cannot be empty or null.</p>
    TargetsRequiredException(crate::error::TargetsRequiredException),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(crate::error::TipOfSourceReferenceIsDifferentException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// <p>A pull request title is required. It cannot be empty or null.</p>
    TitleRequiredException(crate::error::TitleRequiredException),
    /// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled)
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::ActorDoesNotExistException(inner) => inner.fmt(f),
            Error::ApprovalRuleContentRequiredException(inner) => inner.fmt(f),
            Error::ApprovalRuleDoesNotExistException(inner) => inner.fmt(f),
            Error::ApprovalRuleNameAlreadyExistsException(inner) => inner.fmt(f),
            Error::ApprovalRuleNameRequiredException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateContentRequiredException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateDoesNotExistException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateInUseException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateNameAlreadyExistsException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateNameRequiredException(inner) => inner.fmt(f),
            Error::ApprovalStateRequiredException(inner) => inner.fmt(f),
            Error::AuthorDoesNotExistException(inner) => inner.fmt(f),
            Error::BeforeCommitIdAndAfterCommitIdAreSameException(inner) => inner.fmt(f),
            Error::BlobIdDoesNotExistException(inner) => inner.fmt(f),
            Error::BlobIdRequiredException(inner) => inner.fmt(f),
            Error::BranchDoesNotExistException(inner) => inner.fmt(f),
            Error::BranchNameExistsException(inner) => inner.fmt(f),
            Error::BranchNameIsTagNameException(inner) => inner.fmt(f),
            Error::BranchNameRequiredException(inner) => inner.fmt(f),
            Error::CannotDeleteApprovalRuleFromTemplateException(inner) => inner.fmt(f),
            Error::CannotModifyApprovalRuleFromTemplateException(inner) => inner.fmt(f),
            Error::ClientRequestTokenRequiredException(inner) => inner.fmt(f),
            Error::CommentContentRequiredException(inner) => inner.fmt(f),
            Error::CommentContentSizeLimitExceededException(inner) => inner.fmt(f),
            Error::CommentDeletedException(inner) => inner.fmt(f),
            Error::CommentDoesNotExistException(inner) => inner.fmt(f),
            Error::CommentIdRequiredException(inner) => inner.fmt(f),
            Error::CommentNotCreatedByCallerException(inner) => inner.fmt(f),
            Error::CommitDoesNotExistException(inner) => inner.fmt(f),
            Error::CommitIdDoesNotExistException(inner) => inner.fmt(f),
            Error::CommitIdRequiredException(inner) => inner.fmt(f),
            Error::CommitIdsLimitExceededException(inner) => inner.fmt(f),
            Error::CommitIdsListRequiredException(inner) => inner.fmt(f),
            Error::CommitMessageLengthExceededException(inner) => inner.fmt(f),
            Error::CommitRequiredException(inner) => inner.fmt(f),
            Error::ConcurrentReferenceUpdateException(inner) => inner.fmt(f),
            Error::DefaultBranchCannotBeDeletedException(inner) => inner.fmt(f),
            Error::DirectoryNameConflictsWithFileNameException(inner) => inner.fmt(f),
            Error::EncryptionIntegrityChecksFailedException(inner) => inner.fmt(f),
            Error::EncryptionKeyAccessDeniedException(inner) => inner.fmt(f),
            Error::EncryptionKeyDisabledException(inner) => inner.fmt(f),
            Error::EncryptionKeyNotFoundException(inner) => inner.fmt(f),
            Error::EncryptionKeyUnavailableException(inner) => inner.fmt(f),
            Error::FileContentAndSourceFileSpecifiedException(inner) => inner.fmt(f),
            Error::FileContentRequiredException(inner) => inner.fmt(f),
            Error::FileContentSizeLimitExceededException(inner) => inner.fmt(f),
            Error::FileDoesNotExistException(inner) => inner.fmt(f),
            Error::FileEntryRequiredException(inner) => inner.fmt(f),
            Error::FileModeRequiredException(inner) => inner.fmt(f),
            Error::FileNameConflictsWithDirectoryNameException(inner) => inner.fmt(f),
            Error::FilePathConflictsWithSubmodulePathException(inner) => inner.fmt(f),
            Error::FileTooLargeException(inner) => inner.fmt(f),
            Error::FolderContentSizeLimitExceededException(inner) => inner.fmt(f),
            Error::FolderDoesNotExistException(inner) => inner.fmt(f),
            Error::IdempotencyParameterMismatchException(inner) => inner.fmt(f),
            Error::InvalidActorArnException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleContentException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleNameException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleTemplateContentException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleTemplateDescriptionException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleTemplateNameException(inner) => inner.fmt(f),
            Error::InvalidApprovalStateException(inner) => inner.fmt(f),
            Error::InvalidAuthorArnException(inner) => inner.fmt(f),
            Error::InvalidBlobIdException(inner) => inner.fmt(f),
            Error::InvalidBranchNameException(inner) => inner.fmt(f),
            Error::InvalidClientRequestTokenException(inner) => inner.fmt(f),
            Error::InvalidCommentIdException(inner) => inner.fmt(f),
            Error::InvalidCommitException(inner) => inner.fmt(f),
            Error::InvalidCommitIdException(inner) => inner.fmt(f),
            Error::InvalidConflictDetailLevelException(inner) => inner.fmt(f),
            Error::InvalidConflictResolutionException(inner) => inner.fmt(f),
            Error::InvalidConflictResolutionStrategyException(inner) => inner.fmt(f),
            Error::InvalidContinuationTokenException(inner) => inner.fmt(f),
            Error::InvalidDeletionParameterException(inner) => inner.fmt(f),
            Error::InvalidDescriptionException(inner) => inner.fmt(f),
            Error::InvalidDestinationCommitSpecifierException(inner) => inner.fmt(f),
            Error::InvalidEmailException(inner) => inner.fmt(f),
            Error::InvalidFileLocationException(inner) => inner.fmt(f),
            Error::InvalidFileModeException(inner) => inner.fmt(f),
            Error::InvalidFilePositionException(inner) => inner.fmt(f),
            Error::InvalidMaxConflictFilesException(inner) => inner.fmt(f),
            Error::InvalidMaxMergeHunksException(inner) => inner.fmt(f),
            Error::InvalidMaxResultsException(inner) => inner.fmt(f),
            Error::InvalidMergeOptionException(inner) => inner.fmt(f),
            Error::InvalidOrderException(inner) => inner.fmt(f),
            Error::InvalidOverrideStatusException(inner) => inner.fmt(f),
            Error::InvalidParentCommitIdException(inner) => inner.fmt(f),
            Error::InvalidPathException(inner) => inner.fmt(f),
            Error::InvalidPullRequestEventTypeException(inner) => inner.fmt(f),
            Error::InvalidPullRequestIdException(inner) => inner.fmt(f),
            Error::InvalidPullRequestStatusException(inner) => inner.fmt(f),
            Error::InvalidPullRequestStatusUpdateException(inner) => inner.fmt(f),
            Error::InvalidReactionUserArnException(inner) => inner.fmt(f),
            Error::InvalidReactionValueException(inner) => inner.fmt(f),
            Error::InvalidReferenceNameException(inner) => inner.fmt(f),
            Error::InvalidRelativeFileVersionEnumException(inner) => inner.fmt(f),
            Error::InvalidReplacementContentException(inner) => inner.fmt(f),
            Error::InvalidReplacementTypeException(inner) => inner.fmt(f),
            Error::InvalidRepositoryDescriptionException(inner) => inner.fmt(f),
            Error::InvalidRepositoryNameException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerBranchNameException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerCustomDataException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerDestinationArnException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerEventsException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerNameException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerRegionException(inner) => inner.fmt(f),
            Error::InvalidResourceArnException(inner) => inner.fmt(f),
            Error::InvalidRevisionIdException(inner) => inner.fmt(f),
            Error::InvalidRuleContentSha256Exception(inner) => inner.fmt(f),
            Error::InvalidSortByException(inner) => inner.fmt(f),
            Error::InvalidSourceCommitSpecifierException(inner) => inner.fmt(f),
            Error::InvalidSystemTagUsageException(inner) => inner.fmt(f),
            Error::InvalidTagKeysListException(inner) => inner.fmt(f),
            Error::InvalidTagsMapException(inner) => inner.fmt(f),
            Error::InvalidTargetBranchException(inner) => inner.fmt(f),
            Error::InvalidTargetException(inner) => inner.fmt(f),
            Error::InvalidTargetsException(inner) => inner.fmt(f),
            Error::InvalidTitleException(inner) => inner.fmt(f),
            Error::ManualMergeRequiredException(inner) => inner.fmt(f),
            Error::MaximumBranchesExceededException(inner) => inner.fmt(f),
            Error::MaximumConflictResolutionEntriesExceededException(inner) => inner.fmt(f),
            Error::MaximumFileContentToLoadExceededException(inner) => inner.fmt(f),
            Error::MaximumFileEntriesExceededException(inner) => inner.fmt(f),
            Error::MaximumItemsToCompareExceededException(inner) => inner.fmt(f),
            Error::MaximumNumberOfApprovalsExceededException(inner) => inner.fmt(f),
            Error::MaximumOpenPullRequestsExceededException(inner) => inner.fmt(f),
            Error::MaximumRepositoryNamesExceededException(inner) => inner.fmt(f),
            Error::MaximumRepositoryTriggersExceededException(inner) => inner.fmt(f),
            Error::MaximumRuleTemplatesAssociatedWithRepositoryException(inner) => inner.fmt(f),
            Error::MergeOptionRequiredException(inner) => inner.fmt(f),
            Error::MultipleConflictResolutionEntriesException(inner) => inner.fmt(f),
            Error::MultipleRepositoriesInPullRequestException(inner) => inner.fmt(f),
            Error::NameLengthExceededException(inner) => inner.fmt(f),
            Error::NoChangeException(inner) => inner.fmt(f),
            Error::NumberOfRuleTemplatesExceededException(inner) => inner.fmt(f),
            Error::NumberOfRulesExceededException(inner) => inner.fmt(f),
            Error::OverrideAlreadySetException(inner) => inner.fmt(f),
            Error::OverrideStatusRequiredException(inner) => inner.fmt(f),
            Error::ParentCommitDoesNotExistException(inner) => inner.fmt(f),
            Error::ParentCommitIdOutdatedException(inner) => inner.fmt(f),
            Error::ParentCommitIdRequiredException(inner) => inner.fmt(f),
            Error::PathDoesNotExistException(inner) => inner.fmt(f),
            Error::PathRequiredException(inner) => inner.fmt(f),
            Error::PullRequestAlreadyClosedException(inner) => inner.fmt(f),
            Error::PullRequestApprovalRulesNotSatisfiedException(inner) => inner.fmt(f),
            Error::PullRequestCannotBeApprovedByAuthorException(inner) => inner.fmt(f),
            Error::PullRequestDoesNotExistException(inner) => inner.fmt(f),
            Error::PullRequestIdRequiredException(inner) => inner.fmt(f),
            Error::PullRequestStatusRequiredException(inner) => inner.fmt(f),
            Error::PutFileEntryConflictException(inner) => inner.fmt(f),
            Error::ReactionLimitExceededException(inner) => inner.fmt(f),
            Error::ReactionValueRequiredException(inner) => inner.fmt(f),
            Error::ReferenceDoesNotExistException(inner) => inner.fmt(f),
            Error::ReferenceNameRequiredException(inner) => inner.fmt(f),
            Error::ReferenceTypeNotSupportedException(inner) => inner.fmt(f),
            Error::ReplacementContentRequiredException(inner) => inner.fmt(f),
            Error::ReplacementTypeRequiredException(inner) => inner.fmt(f),
            Error::RepositoryDoesNotExistException(inner) => inner.fmt(f),
            Error::RepositoryLimitExceededException(inner) => inner.fmt(f),
            Error::RepositoryNameExistsException(inner) => inner.fmt(f),
            Error::RepositoryNameRequiredException(inner) => inner.fmt(f),
            Error::RepositoryNamesRequiredException(inner) => inner.fmt(f),
            Error::RepositoryNotAssociatedWithPullRequestException(inner) => inner.fmt(f),
            Error::RepositoryTriggerBranchNameListRequiredException(inner) => inner.fmt(f),
            Error::RepositoryTriggerDestinationArnRequiredException(inner) => inner.fmt(f),
            Error::RepositoryTriggerEventsListRequiredException(inner) => inner.fmt(f),
            Error::RepositoryTriggerNameRequiredException(inner) => inner.fmt(f),
            Error::RepositoryTriggersListRequiredException(inner) => inner.fmt(f),
            Error::ResourceArnRequiredException(inner) => inner.fmt(f),
            Error::RestrictedSourceFileException(inner) => inner.fmt(f),
            Error::RevisionIdRequiredException(inner) => inner.fmt(f),
            Error::RevisionNotCurrentException(inner) => inner.fmt(f),
            Error::SameFileContentException(inner) => inner.fmt(f),
            Error::SamePathRequestException(inner) => inner.fmt(f),
            Error::SourceAndDestinationAreSameException(inner) => inner.fmt(f),
            Error::SourceFileOrContentRequiredException(inner) => inner.fmt(f),
            Error::TagKeysListRequiredException(inner) => inner.fmt(f),
            Error::TagPolicyException(inner) => inner.fmt(f),
            Error::TagsMapRequiredException(inner) => inner.fmt(f),
            Error::TargetRequiredException(inner) => inner.fmt(f),
            Error::TargetsRequiredException(inner) => inner.fmt(f),
            Error::TipOfSourceReferenceIsDifferentException(inner) => inner.fmt(f),
            Error::TipsDivergenceExceededException(inner) => inner.fmt(f),
            Error::TitleRequiredException(inner) => inner.fmt(f),
            Error::TooManyTagsException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f)
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::AssociateApprovalRuleTemplateWithRepositoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::AssociateApprovalRuleTemplateWithRepositoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::AssociateApprovalRuleTemplateWithRepositoryError> for Error {
    fn from(err: crate::error::AssociateApprovalRuleTemplateWithRepositoryError) -> Self {
        match err {
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::MaximumRuleTemplatesAssociatedWithRepositoryException(inner) => Error::MaximumRuleTemplatesAssociatedWithRepositoryException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::AssociateApprovalRuleTemplateWithRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError> for Error {
    fn from(err: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError) -> Self {
        match err {
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::MaximumRepositoryNamesExceededException(inner) => Error::MaximumRepositoryNamesExceededException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::RepositoryNamesRequiredException(inner) => Error::RepositoryNamesRequiredException(inner),
            crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchDescribeMergeConflictsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchDescribeMergeConflictsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::BatchDescribeMergeConflictsError> for Error {
    fn from(err: crate::error::BatchDescribeMergeConflictsError) -> Self {
        match err {
            crate::error::BatchDescribeMergeConflictsError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::BatchDescribeMergeConflictsError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::BatchDescribeMergeConflictsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::BatchDescribeMergeConflictsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::BatchDescribeMergeConflictsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::BatchDescribeMergeConflictsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::BatchDescribeMergeConflictsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::BatchDescribeMergeConflictsError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::BatchDescribeMergeConflictsError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::BatchDescribeMergeConflictsError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::BatchDescribeMergeConflictsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::BatchDescribeMergeConflictsError::InvalidMaxConflictFilesException(inner) => Error::InvalidMaxConflictFilesException(inner),
            crate::error::BatchDescribeMergeConflictsError::InvalidMaxMergeHunksException(inner) => Error::InvalidMaxMergeHunksException(inner),
            crate::error::BatchDescribeMergeConflictsError::InvalidMergeOptionException(inner) => Error::InvalidMergeOptionException(inner),
            crate::error::BatchDescribeMergeConflictsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::BatchDescribeMergeConflictsError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::error::BatchDescribeMergeConflictsError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::error::BatchDescribeMergeConflictsError::MergeOptionRequiredException(inner) => Error::MergeOptionRequiredException(inner),
            crate::error::BatchDescribeMergeConflictsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::BatchDescribeMergeConflictsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::BatchDescribeMergeConflictsError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::BatchDescribeMergeConflictsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError> for Error {
    fn from(err: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError) -> Self {
        match err {
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::MaximumRepositoryNamesExceededException(inner) => Error::MaximumRepositoryNamesExceededException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::RepositoryNamesRequiredException(inner) => Error::RepositoryNamesRequiredException(inner),
            crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetCommitsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetCommitsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::BatchGetCommitsError> for Error {
    fn from(err: crate::error::BatchGetCommitsError) -> Self {
        match err {
            crate::error::BatchGetCommitsError::CommitIdsLimitExceededException(inner) => Error::CommitIdsLimitExceededException(inner),
            crate::error::BatchGetCommitsError::CommitIdsListRequiredException(inner) => Error::CommitIdsListRequiredException(inner),
            crate::error::BatchGetCommitsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::BatchGetCommitsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::BatchGetCommitsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::BatchGetCommitsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::BatchGetCommitsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::BatchGetCommitsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::BatchGetCommitsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::BatchGetCommitsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::BatchGetCommitsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::BatchGetRepositoriesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::BatchGetRepositoriesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::BatchGetRepositoriesError> for Error {
    fn from(err: crate::error::BatchGetRepositoriesError) -> Self {
        match err {
            crate::error::BatchGetRepositoriesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::BatchGetRepositoriesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::BatchGetRepositoriesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::BatchGetRepositoriesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::BatchGetRepositoriesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::BatchGetRepositoriesError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::BatchGetRepositoriesError::MaximumRepositoryNamesExceededException(inner) => Error::MaximumRepositoryNamesExceededException(inner),
            crate::error::BatchGetRepositoriesError::RepositoryNamesRequiredException(inner) => Error::RepositoryNamesRequiredException(inner),
            crate::error::BatchGetRepositoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateApprovalRuleTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateApprovalRuleTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateApprovalRuleTemplateError> for Error {
    fn from(err: crate::error::CreateApprovalRuleTemplateError) -> Self {
        match err {
            crate::error::CreateApprovalRuleTemplateError::ApprovalRuleTemplateContentRequiredException(inner) => Error::ApprovalRuleTemplateContentRequiredException(inner),
            crate::error::CreateApprovalRuleTemplateError::ApprovalRuleTemplateNameAlreadyExistsException(inner) => Error::ApprovalRuleTemplateNameAlreadyExistsException(inner),
            crate::error::CreateApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateContentException(inner) => Error::InvalidApprovalRuleTemplateContentException(inner),
            crate::error::CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateDescriptionException(inner) => Error::InvalidApprovalRuleTemplateDescriptionException(inner),
            crate::error::CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::CreateApprovalRuleTemplateError::NumberOfRuleTemplatesExceededException(inner) => Error::NumberOfRuleTemplatesExceededException(inner),
            crate::error::CreateApprovalRuleTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateBranchError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateBranchError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateBranchError> for Error {
    fn from(err: crate::error::CreateBranchError) -> Self {
        match err {
            crate::error::CreateBranchError::BranchNameExistsException(inner) => Error::BranchNameExistsException(inner),
            crate::error::CreateBranchError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::CreateBranchError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::CreateBranchError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::error::CreateBranchError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::CreateBranchError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::CreateBranchError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::CreateBranchError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::CreateBranchError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::CreateBranchError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::CreateBranchError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::CreateBranchError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::CreateBranchError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::CreateBranchError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::CreateBranchError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateCommitError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateCommitError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateCommitError> for Error {
    fn from(err: crate::error::CreateCommitError) -> Self {
        match err {
            crate::error::CreateCommitError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::error::CreateCommitError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::error::CreateCommitError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::CreateCommitError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::error::CreateCommitError::DirectoryNameConflictsWithFileNameException(inner) => Error::DirectoryNameConflictsWithFileNameException(inner),
            crate::error::CreateCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::CreateCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::CreateCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::CreateCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::CreateCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::CreateCommitError::FileContentAndSourceFileSpecifiedException(inner) => Error::FileContentAndSourceFileSpecifiedException(inner),
            crate::error::CreateCommitError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::error::CreateCommitError::FileDoesNotExistException(inner) => Error::FileDoesNotExistException(inner),
            crate::error::CreateCommitError::FileEntryRequiredException(inner) => Error::FileEntryRequiredException(inner),
            crate::error::CreateCommitError::FileModeRequiredException(inner) => Error::FileModeRequiredException(inner),
            crate::error::CreateCommitError::FileNameConflictsWithDirectoryNameException(inner) => Error::FileNameConflictsWithDirectoryNameException(inner),
            crate::error::CreateCommitError::FilePathConflictsWithSubmodulePathException(inner) => Error::FilePathConflictsWithSubmodulePathException(inner),
            crate::error::CreateCommitError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::error::CreateCommitError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::CreateCommitError::InvalidDeletionParameterException(inner) => Error::InvalidDeletionParameterException(inner),
            crate::error::CreateCommitError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::error::CreateCommitError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::error::CreateCommitError::InvalidParentCommitIdException(inner) => Error::InvalidParentCommitIdException(inner),
            crate::error::CreateCommitError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::CreateCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::CreateCommitError::MaximumFileEntriesExceededException(inner) => Error::MaximumFileEntriesExceededException(inner),
            crate::error::CreateCommitError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::error::CreateCommitError::NoChangeException(inner) => Error::NoChangeException(inner),
            crate::error::CreateCommitError::ParentCommitDoesNotExistException(inner) => Error::ParentCommitDoesNotExistException(inner),
            crate::error::CreateCommitError::ParentCommitIdOutdatedException(inner) => Error::ParentCommitIdOutdatedException(inner),
            crate::error::CreateCommitError::ParentCommitIdRequiredException(inner) => Error::ParentCommitIdRequiredException(inner),
            crate::error::CreateCommitError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::CreateCommitError::PutFileEntryConflictException(inner) => Error::PutFileEntryConflictException(inner),
            crate::error::CreateCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::CreateCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::CreateCommitError::RestrictedSourceFileException(inner) => Error::RestrictedSourceFileException(inner),
            crate::error::CreateCommitError::SamePathRequestException(inner) => Error::SamePathRequestException(inner),
            crate::error::CreateCommitError::SourceFileOrContentRequiredException(inner) => Error::SourceFileOrContentRequiredException(inner),
            crate::error::CreateCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreatePullRequestError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreatePullRequestError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreatePullRequestError> for Error {
    fn from(err: crate::error::CreatePullRequestError) -> Self {
        match err {
            crate::error::CreatePullRequestError::ClientRequestTokenRequiredException(inner) => Error::ClientRequestTokenRequiredException(inner),
            crate::error::CreatePullRequestError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::CreatePullRequestError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::CreatePullRequestError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::CreatePullRequestError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::CreatePullRequestError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::CreatePullRequestError::IdempotencyParameterMismatchException(inner) => Error::IdempotencyParameterMismatchException(inner),
            crate::error::CreatePullRequestError::InvalidClientRequestTokenException(inner) => Error::InvalidClientRequestTokenException(inner),
            crate::error::CreatePullRequestError::InvalidDescriptionException(inner) => Error::InvalidDescriptionException(inner),
            crate::error::CreatePullRequestError::InvalidReferenceNameException(inner) => Error::InvalidReferenceNameException(inner),
            crate::error::CreatePullRequestError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::CreatePullRequestError::InvalidTargetException(inner) => Error::InvalidTargetException(inner),
            crate::error::CreatePullRequestError::InvalidTargetsException(inner) => Error::InvalidTargetsException(inner),
            crate::error::CreatePullRequestError::InvalidTitleException(inner) => Error::InvalidTitleException(inner),
            crate::error::CreatePullRequestError::MaximumOpenPullRequestsExceededException(inner) => Error::MaximumOpenPullRequestsExceededException(inner),
            crate::error::CreatePullRequestError::MultipleRepositoriesInPullRequestException(inner) => Error::MultipleRepositoriesInPullRequestException(inner),
            crate::error::CreatePullRequestError::ReferenceDoesNotExistException(inner) => Error::ReferenceDoesNotExistException(inner),
            crate::error::CreatePullRequestError::ReferenceNameRequiredException(inner) => Error::ReferenceNameRequiredException(inner),
            crate::error::CreatePullRequestError::ReferenceTypeNotSupportedException(inner) => Error::ReferenceTypeNotSupportedException(inner),
            crate::error::CreatePullRequestError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::CreatePullRequestError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::CreatePullRequestError::SourceAndDestinationAreSameException(inner) => Error::SourceAndDestinationAreSameException(inner),
            crate::error::CreatePullRequestError::TargetRequiredException(inner) => Error::TargetRequiredException(inner),
            crate::error::CreatePullRequestError::TargetsRequiredException(inner) => Error::TargetsRequiredException(inner),
            crate::error::CreatePullRequestError::TitleRequiredException(inner) => Error::TitleRequiredException(inner),
            crate::error::CreatePullRequestError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreatePullRequestApprovalRuleError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreatePullRequestApprovalRuleError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreatePullRequestApprovalRuleError> for Error {
    fn from(err: crate::error::CreatePullRequestApprovalRuleError) -> Self {
        match err {
            crate::error::CreatePullRequestApprovalRuleError::ApprovalRuleContentRequiredException(inner) => Error::ApprovalRuleContentRequiredException(inner),
            crate::error::CreatePullRequestApprovalRuleError::ApprovalRuleNameAlreadyExistsException(inner) => Error::ApprovalRuleNameAlreadyExistsException(inner),
            crate::error::CreatePullRequestApprovalRuleError::ApprovalRuleNameRequiredException(inner) => Error::ApprovalRuleNameRequiredException(inner),
            crate::error::CreatePullRequestApprovalRuleError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::CreatePullRequestApprovalRuleError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::CreatePullRequestApprovalRuleError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::CreatePullRequestApprovalRuleError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::CreatePullRequestApprovalRuleError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::CreatePullRequestApprovalRuleError::InvalidApprovalRuleContentException(inner) => Error::InvalidApprovalRuleContentException(inner),
            crate::error::CreatePullRequestApprovalRuleError::InvalidApprovalRuleNameException(inner) => Error::InvalidApprovalRuleNameException(inner),
            crate::error::CreatePullRequestApprovalRuleError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::CreatePullRequestApprovalRuleError::NumberOfRulesExceededException(inner) => Error::NumberOfRulesExceededException(inner),
            crate::error::CreatePullRequestApprovalRuleError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::CreatePullRequestApprovalRuleError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::CreatePullRequestApprovalRuleError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::CreatePullRequestApprovalRuleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateRepositoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateRepositoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateRepositoryError> for Error {
    fn from(err: crate::error::CreateRepositoryError) -> Self {
        match err {
            crate::error::CreateRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::CreateRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::CreateRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::CreateRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::CreateRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::CreateRepositoryError::InvalidRepositoryDescriptionException(inner) => Error::InvalidRepositoryDescriptionException(inner),
            crate::error::CreateRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::CreateRepositoryError::InvalidSystemTagUsageException(inner) => Error::InvalidSystemTagUsageException(inner),
            crate::error::CreateRepositoryError::InvalidTagsMapException(inner) => Error::InvalidTagsMapException(inner),
            crate::error::CreateRepositoryError::RepositoryLimitExceededException(inner) => Error::RepositoryLimitExceededException(inner),
            crate::error::CreateRepositoryError::RepositoryNameExistsException(inner) => Error::RepositoryNameExistsException(inner),
            crate::error::CreateRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::CreateRepositoryError::TagPolicyException(inner) => Error::TagPolicyException(inner),
            crate::error::CreateRepositoryError::TooManyTagsException(inner) => Error::TooManyTagsException(inner),
            crate::error::CreateRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::CreateUnreferencedMergeCommitError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::CreateUnreferencedMergeCommitError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::CreateUnreferencedMergeCommitError> for Error {
    fn from(err: crate::error::CreateUnreferencedMergeCommitError) -> Self {
        match err {
            crate::error::CreateUnreferencedMergeCommitError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::CreateUnreferencedMergeCommitError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::error::CreateUnreferencedMergeCommitError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::CreateUnreferencedMergeCommitError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::error::CreateUnreferencedMergeCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::CreateUnreferencedMergeCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::CreateUnreferencedMergeCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::CreateUnreferencedMergeCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::CreateUnreferencedMergeCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::CreateUnreferencedMergeCommitError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::error::CreateUnreferencedMergeCommitError::FileModeRequiredException(inner) => Error::FileModeRequiredException(inner),
            crate::error::CreateUnreferencedMergeCommitError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidMergeOptionException(inner) => Error::InvalidMergeOptionException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::error::CreateUnreferencedMergeCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::CreateUnreferencedMergeCommitError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::error::CreateUnreferencedMergeCommitError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::error::CreateUnreferencedMergeCommitError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::error::CreateUnreferencedMergeCommitError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::error::CreateUnreferencedMergeCommitError::MergeOptionRequiredException(inner) => Error::MergeOptionRequiredException(inner),
            crate::error::CreateUnreferencedMergeCommitError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::error::CreateUnreferencedMergeCommitError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::error::CreateUnreferencedMergeCommitError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::CreateUnreferencedMergeCommitError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::error::CreateUnreferencedMergeCommitError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::error::CreateUnreferencedMergeCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::CreateUnreferencedMergeCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::CreateUnreferencedMergeCommitError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::CreateUnreferencedMergeCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteApprovalRuleTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteApprovalRuleTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteApprovalRuleTemplateError> for Error {
    fn from(err: crate::error::DeleteApprovalRuleTemplateError) -> Self {
        match err {
            crate::error::DeleteApprovalRuleTemplateError::ApprovalRuleTemplateInUseException(inner) => Error::ApprovalRuleTemplateInUseException(inner),
            crate::error::DeleteApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::DeleteApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::DeleteApprovalRuleTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteBranchError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteBranchError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteBranchError> for Error {
    fn from(err: crate::error::DeleteBranchError) -> Self {
        match err {
            crate::error::DeleteBranchError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::DeleteBranchError::DefaultBranchCannotBeDeletedException(inner) => Error::DefaultBranchCannotBeDeletedException(inner),
            crate::error::DeleteBranchError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::DeleteBranchError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::DeleteBranchError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::DeleteBranchError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::DeleteBranchError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::DeleteBranchError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::DeleteBranchError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::DeleteBranchError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::DeleteBranchError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::DeleteBranchError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteCommentContentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteCommentContentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteCommentContentError> for Error {
    fn from(err: crate::error::DeleteCommentContentError) -> Self {
        match err {
            crate::error::DeleteCommentContentError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::error::DeleteCommentContentError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::error::DeleteCommentContentError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::error::DeleteCommentContentError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::error::DeleteCommentContentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteFileError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteFileError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteFileError> for Error {
    fn from(err: crate::error::DeleteFileError) -> Self {
        match err {
            crate::error::DeleteFileError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::error::DeleteFileError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::error::DeleteFileError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::DeleteFileError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::error::DeleteFileError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::DeleteFileError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::DeleteFileError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::DeleteFileError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::DeleteFileError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::DeleteFileError::FileDoesNotExistException(inner) => Error::FileDoesNotExistException(inner),
            crate::error::DeleteFileError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::DeleteFileError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::error::DeleteFileError::InvalidParentCommitIdException(inner) => Error::InvalidParentCommitIdException(inner),
            crate::error::DeleteFileError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::DeleteFileError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::DeleteFileError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::error::DeleteFileError::ParentCommitDoesNotExistException(inner) => Error::ParentCommitDoesNotExistException(inner),
            crate::error::DeleteFileError::ParentCommitIdOutdatedException(inner) => Error::ParentCommitIdOutdatedException(inner),
            crate::error::DeleteFileError::ParentCommitIdRequiredException(inner) => Error::ParentCommitIdRequiredException(inner),
            crate::error::DeleteFileError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::DeleteFileError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::DeleteFileError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::DeleteFileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeletePullRequestApprovalRuleError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeletePullRequestApprovalRuleError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeletePullRequestApprovalRuleError> for Error {
    fn from(err: crate::error::DeletePullRequestApprovalRuleError) -> Self {
        match err {
            crate::error::DeletePullRequestApprovalRuleError::ApprovalRuleNameRequiredException(inner) => Error::ApprovalRuleNameRequiredException(inner),
            crate::error::DeletePullRequestApprovalRuleError::CannotDeleteApprovalRuleFromTemplateException(inner) => Error::CannotDeleteApprovalRuleFromTemplateException(inner),
            crate::error::DeletePullRequestApprovalRuleError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::DeletePullRequestApprovalRuleError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::DeletePullRequestApprovalRuleError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::DeletePullRequestApprovalRuleError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::DeletePullRequestApprovalRuleError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::DeletePullRequestApprovalRuleError::InvalidApprovalRuleNameException(inner) => Error::InvalidApprovalRuleNameException(inner),
            crate::error::DeletePullRequestApprovalRuleError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::DeletePullRequestApprovalRuleError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::DeletePullRequestApprovalRuleError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::DeletePullRequestApprovalRuleError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::DeletePullRequestApprovalRuleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DeleteRepositoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DeleteRepositoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DeleteRepositoryError> for Error {
    fn from(err: crate::error::DeleteRepositoryError) -> Self {
        match err {
            crate::error::DeleteRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::DeleteRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::DeleteRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::DeleteRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::DeleteRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::DeleteRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::DeleteRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::DeleteRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribeMergeConflictsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribeMergeConflictsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribeMergeConflictsError> for Error {
    fn from(err: crate::error::DescribeMergeConflictsError) -> Self {
        match err {
            crate::error::DescribeMergeConflictsError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::DescribeMergeConflictsError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::DescribeMergeConflictsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::DescribeMergeConflictsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::DescribeMergeConflictsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::DescribeMergeConflictsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::DescribeMergeConflictsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::DescribeMergeConflictsError::FileDoesNotExistException(inner) => Error::FileDoesNotExistException(inner),
            crate::error::DescribeMergeConflictsError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::DescribeMergeConflictsError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::DescribeMergeConflictsError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::DescribeMergeConflictsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::DescribeMergeConflictsError::InvalidMaxMergeHunksException(inner) => Error::InvalidMaxMergeHunksException(inner),
            crate::error::DescribeMergeConflictsError::InvalidMergeOptionException(inner) => Error::InvalidMergeOptionException(inner),
            crate::error::DescribeMergeConflictsError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::DescribeMergeConflictsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::DescribeMergeConflictsError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::error::DescribeMergeConflictsError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::error::DescribeMergeConflictsError::MergeOptionRequiredException(inner) => Error::MergeOptionRequiredException(inner),
            crate::error::DescribeMergeConflictsError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::DescribeMergeConflictsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::DescribeMergeConflictsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::DescribeMergeConflictsError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::DescribeMergeConflictsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DescribePullRequestEventsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DescribePullRequestEventsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DescribePullRequestEventsError> for Error {
    fn from(err: crate::error::DescribePullRequestEventsError) -> Self {
        match err {
            crate::error::DescribePullRequestEventsError::ActorDoesNotExistException(inner) => Error::ActorDoesNotExistException(inner),
            crate::error::DescribePullRequestEventsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::DescribePullRequestEventsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::DescribePullRequestEventsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::DescribePullRequestEventsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::DescribePullRequestEventsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::DescribePullRequestEventsError::InvalidActorArnException(inner) => Error::InvalidActorArnException(inner),
            crate::error::DescribePullRequestEventsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::DescribePullRequestEventsError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::error::DescribePullRequestEventsError::InvalidPullRequestEventTypeException(inner) => Error::InvalidPullRequestEventTypeException(inner),
            crate::error::DescribePullRequestEventsError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::DescribePullRequestEventsError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::DescribePullRequestEventsError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::DescribePullRequestEventsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::DisassociateApprovalRuleTemplateFromRepositoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::DisassociateApprovalRuleTemplateFromRepositoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::DisassociateApprovalRuleTemplateFromRepositoryError> for Error {
    fn from(err: crate::error::DisassociateApprovalRuleTemplateFromRepositoryError) -> Self {
        match err {
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::EvaluatePullRequestApprovalRulesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::EvaluatePullRequestApprovalRulesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::EvaluatePullRequestApprovalRulesError> for Error {
    fn from(err: crate::error::EvaluatePullRequestApprovalRulesError) -> Self {
        match err {
            crate::error::EvaluatePullRequestApprovalRulesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::RevisionNotCurrentException(inner) => Error::RevisionNotCurrentException(inner),
            crate::error::EvaluatePullRequestApprovalRulesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetApprovalRuleTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetApprovalRuleTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetApprovalRuleTemplateError> for Error {
    fn from(err: crate::error::GetApprovalRuleTemplateError) -> Self {
        match err {
            crate::error::GetApprovalRuleTemplateError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::error::GetApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::GetApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::GetApprovalRuleTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetBlobError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetBlobError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetBlobError> for Error {
    fn from(err: crate::error::GetBlobError) -> Self {
        match err {
            crate::error::GetBlobError::BlobIdDoesNotExistException(inner) => Error::BlobIdDoesNotExistException(inner),
            crate::error::GetBlobError::BlobIdRequiredException(inner) => Error::BlobIdRequiredException(inner),
            crate::error::GetBlobError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetBlobError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetBlobError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetBlobError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetBlobError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetBlobError::FileTooLargeException(inner) => Error::FileTooLargeException(inner),
            crate::error::GetBlobError::InvalidBlobIdException(inner) => Error::InvalidBlobIdException(inner),
            crate::error::GetBlobError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetBlobError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetBlobError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetBlobError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetBranchError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetBranchError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetBranchError> for Error {
    fn from(err: crate::error::GetBranchError) -> Self {
        match err {
            crate::error::GetBranchError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::error::GetBranchError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::GetBranchError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetBranchError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetBranchError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetBranchError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetBranchError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetBranchError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::GetBranchError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetBranchError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetBranchError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetBranchError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCommentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCommentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetCommentError> for Error {
    fn from(err: crate::error::GetCommentError) -> Self {
        match err {
            crate::error::GetCommentError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::error::GetCommentError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::error::GetCommentError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::error::GetCommentError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetCommentError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetCommentError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetCommentError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetCommentError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetCommentError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::error::GetCommentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCommentReactionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCommentReactionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetCommentReactionsError> for Error {
    fn from(err: crate::error::GetCommentReactionsError) -> Self {
        match err {
            crate::error::GetCommentReactionsError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::error::GetCommentReactionsError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::error::GetCommentReactionsError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::error::GetCommentReactionsError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::error::GetCommentReactionsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::GetCommentReactionsError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::error::GetCommentReactionsError::InvalidReactionUserArnException(inner) => Error::InvalidReactionUserArnException(inner),
            crate::error::GetCommentReactionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCommentsForComparedCommitError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCommentsForComparedCommitError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetCommentsForComparedCommitError> for Error {
    fn from(err: crate::error::GetCommentsForComparedCommitError) -> Self {
        match err {
            crate::error::GetCommentsForComparedCommitError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::GetCommentsForComparedCommitError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::error::GetCommentsForComparedCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetCommentsForComparedCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetCommentsForComparedCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetCommentsForComparedCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetCommentsForComparedCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetCommentsForComparedCommitError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::GetCommentsForComparedCommitError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::GetCommentsForComparedCommitError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::error::GetCommentsForComparedCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetCommentsForComparedCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetCommentsForComparedCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetCommentsForComparedCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCommentsForPullRequestError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCommentsForPullRequestError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetCommentsForPullRequestError> for Error {
    fn from(err: crate::error::GetCommentsForPullRequestError) -> Self {
        match err {
            crate::error::GetCommentsForPullRequestError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::GetCommentsForPullRequestError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::error::GetCommentsForPullRequestError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetCommentsForPullRequestError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetCommentsForPullRequestError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetCommentsForPullRequestError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetCommentsForPullRequestError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetCommentsForPullRequestError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::GetCommentsForPullRequestError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::GetCommentsForPullRequestError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::error::GetCommentsForPullRequestError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::GetCommentsForPullRequestError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetCommentsForPullRequestError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::GetCommentsForPullRequestError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::GetCommentsForPullRequestError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetCommentsForPullRequestError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetCommentsForPullRequestError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::error::GetCommentsForPullRequestError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetCommitError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetCommitError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetCommitError> for Error {
    fn from(err: crate::error::GetCommitError) -> Self {
        match err {
            crate::error::GetCommitError::CommitIdDoesNotExistException(inner) => Error::CommitIdDoesNotExistException(inner),
            crate::error::GetCommitError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::error::GetCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetCommitError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::GetCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetDifferencesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetDifferencesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetDifferencesError> for Error {
    fn from(err: crate::error::GetDifferencesError) -> Self {
        match err {
            crate::error::GetDifferencesError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::GetDifferencesError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::GetDifferencesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetDifferencesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetDifferencesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetDifferencesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetDifferencesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetDifferencesError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::GetDifferencesError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::GetDifferencesError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::GetDifferencesError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::error::GetDifferencesError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::GetDifferencesError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetDifferencesError::PathDoesNotExistException(inner) => Error::PathDoesNotExistException(inner),
            crate::error::GetDifferencesError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetDifferencesError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetDifferencesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetFileError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetFileError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetFileError> for Error {
    fn from(err: crate::error::GetFileError) -> Self {
        match err {
            crate::error::GetFileError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::GetFileError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetFileError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetFileError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetFileError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetFileError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetFileError::FileDoesNotExistException(inner) => Error::FileDoesNotExistException(inner),
            crate::error::GetFileError::FileTooLargeException(inner) => Error::FileTooLargeException(inner),
            crate::error::GetFileError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::GetFileError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::GetFileError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetFileError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::GetFileError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetFileError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetFileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetFolderError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetFolderError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetFolderError> for Error {
    fn from(err: crate::error::GetFolderError) -> Self {
        match err {
            crate::error::GetFolderError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::GetFolderError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetFolderError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetFolderError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetFolderError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetFolderError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetFolderError::FolderDoesNotExistException(inner) => Error::FolderDoesNotExistException(inner),
            crate::error::GetFolderError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::GetFolderError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::GetFolderError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetFolderError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::GetFolderError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetFolderError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetMergeCommitError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetMergeCommitError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetMergeCommitError> for Error {
    fn from(err: crate::error::GetMergeCommitError) -> Self {
        match err {
            crate::error::GetMergeCommitError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::GetMergeCommitError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::GetMergeCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetMergeCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetMergeCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetMergeCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetMergeCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetMergeCommitError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::GetMergeCommitError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::GetMergeCommitError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::GetMergeCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetMergeCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetMergeCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetMergeCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetMergeConflictsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetMergeConflictsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetMergeConflictsError> for Error {
    fn from(err: crate::error::GetMergeConflictsError) -> Self {
        match err {
            crate::error::GetMergeConflictsError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::GetMergeConflictsError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::GetMergeConflictsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetMergeConflictsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetMergeConflictsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetMergeConflictsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetMergeConflictsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetMergeConflictsError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::GetMergeConflictsError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::GetMergeConflictsError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::GetMergeConflictsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::GetMergeConflictsError::InvalidDestinationCommitSpecifierException(inner) => Error::InvalidDestinationCommitSpecifierException(inner),
            crate::error::GetMergeConflictsError::InvalidMaxConflictFilesException(inner) => Error::InvalidMaxConflictFilesException(inner),
            crate::error::GetMergeConflictsError::InvalidMergeOptionException(inner) => Error::InvalidMergeOptionException(inner),
            crate::error::GetMergeConflictsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetMergeConflictsError::InvalidSourceCommitSpecifierException(inner) => Error::InvalidSourceCommitSpecifierException(inner),
            crate::error::GetMergeConflictsError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::error::GetMergeConflictsError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::error::GetMergeConflictsError::MergeOptionRequiredException(inner) => Error::MergeOptionRequiredException(inner),
            crate::error::GetMergeConflictsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetMergeConflictsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetMergeConflictsError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::GetMergeConflictsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetMergeOptionsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetMergeOptionsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetMergeOptionsError> for Error {
    fn from(err: crate::error::GetMergeOptionsError) -> Self {
        match err {
            crate::error::GetMergeOptionsError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::GetMergeOptionsError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::GetMergeOptionsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetMergeOptionsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetMergeOptionsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetMergeOptionsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetMergeOptionsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetMergeOptionsError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::GetMergeOptionsError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::GetMergeOptionsError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::GetMergeOptionsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetMergeOptionsError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::error::GetMergeOptionsError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::error::GetMergeOptionsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetMergeOptionsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetMergeOptionsError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::GetMergeOptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetPullRequestError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetPullRequestError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetPullRequestError> for Error {
    fn from(err: crate::error::GetPullRequestError) -> Self {
        match err {
            crate::error::GetPullRequestError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetPullRequestError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetPullRequestError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetPullRequestError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetPullRequestError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetPullRequestError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::GetPullRequestError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::GetPullRequestError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::GetPullRequestError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetPullRequestApprovalStatesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetPullRequestApprovalStatesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetPullRequestApprovalStatesError> for Error {
    fn from(err: crate::error::GetPullRequestApprovalStatesError) -> Self {
        match err {
            crate::error::GetPullRequestApprovalStatesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetPullRequestApprovalStatesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetPullRequestApprovalStatesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetPullRequestApprovalStatesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetPullRequestApprovalStatesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetPullRequestApprovalStatesError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::GetPullRequestApprovalStatesError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::error::GetPullRequestApprovalStatesError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::GetPullRequestApprovalStatesError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::GetPullRequestApprovalStatesError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::error::GetPullRequestApprovalStatesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetPullRequestOverrideStateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetPullRequestOverrideStateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetPullRequestOverrideStateError> for Error {
    fn from(err: crate::error::GetPullRequestOverrideStateError) -> Self {
        match err {
            crate::error::GetPullRequestOverrideStateError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetPullRequestOverrideStateError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetPullRequestOverrideStateError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetPullRequestOverrideStateError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetPullRequestOverrideStateError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetPullRequestOverrideStateError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::GetPullRequestOverrideStateError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::error::GetPullRequestOverrideStateError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::GetPullRequestOverrideStateError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::GetPullRequestOverrideStateError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::error::GetPullRequestOverrideStateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetRepositoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetRepositoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetRepositoryError> for Error {
    fn from(err: crate::error::GetRepositoryError) -> Self {
        match err {
            crate::error::GetRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetRepositoryError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::GetRepositoryTriggersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::GetRepositoryTriggersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::GetRepositoryTriggersError> for Error {
    fn from(err: crate::error::GetRepositoryTriggersError) -> Self {
        match err {
            crate::error::GetRepositoryTriggersError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::GetRepositoryTriggersError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::GetRepositoryTriggersError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::GetRepositoryTriggersError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::GetRepositoryTriggersError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::GetRepositoryTriggersError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::GetRepositoryTriggersError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::GetRepositoryTriggersError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::GetRepositoryTriggersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListApprovalRuleTemplatesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListApprovalRuleTemplatesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListApprovalRuleTemplatesError> for Error {
    fn from(err: crate::error::ListApprovalRuleTemplatesError) -> Self {
        match err {
            crate::error::ListApprovalRuleTemplatesError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::ListApprovalRuleTemplatesError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::error::ListApprovalRuleTemplatesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError> for Error {
    fn from(err: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError) -> Self {
        match err {
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListBranchesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListBranchesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListBranchesError> for Error {
    fn from(err: crate::error::ListBranchesError) -> Self {
        match err {
            crate::error::ListBranchesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::ListBranchesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::ListBranchesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::ListBranchesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::ListBranchesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::ListBranchesError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::ListBranchesError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::ListBranchesError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::ListBranchesError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::ListBranchesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListPullRequestsError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListPullRequestsError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListPullRequestsError> for Error {
    fn from(err: crate::error::ListPullRequestsError) -> Self {
        match err {
            crate::error::ListPullRequestsError::AuthorDoesNotExistException(inner) => Error::AuthorDoesNotExistException(inner),
            crate::error::ListPullRequestsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::ListPullRequestsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::ListPullRequestsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::ListPullRequestsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::ListPullRequestsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::ListPullRequestsError::InvalidAuthorArnException(inner) => Error::InvalidAuthorArnException(inner),
            crate::error::ListPullRequestsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::ListPullRequestsError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::error::ListPullRequestsError::InvalidPullRequestStatusException(inner) => Error::InvalidPullRequestStatusException(inner),
            crate::error::ListPullRequestsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::ListPullRequestsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::ListPullRequestsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::ListPullRequestsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListRepositoriesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListRepositoriesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListRepositoriesError> for Error {
    fn from(err: crate::error::ListRepositoriesError) -> Self {
        match err {
            crate::error::ListRepositoriesError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::ListRepositoriesError::InvalidOrderException(inner) => Error::InvalidOrderException(inner),
            crate::error::ListRepositoriesError::InvalidSortByException(inner) => Error::InvalidSortByException(inner),
            crate::error::ListRepositoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListRepositoriesForApprovalRuleTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListRepositoriesForApprovalRuleTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListRepositoriesForApprovalRuleTemplateError> for Error {
    fn from(err: crate::error::ListRepositoriesForApprovalRuleTemplateError) -> Self {
        match err {
            crate::error::ListRepositoriesForApprovalRuleTemplateError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::error::ListRepositoriesForApprovalRuleTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::ListTagsForResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::ListTagsForResourceError> for Error {
    fn from(err: crate::error::ListTagsForResourceError) -> Self {
        match err {
            crate::error::ListTagsForResourceError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::ListTagsForResourceError::InvalidResourceArnException(inner) => Error::InvalidResourceArnException(inner),
            crate::error::ListTagsForResourceError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::ListTagsForResourceError::ResourceArnRequiredException(inner) => Error::ResourceArnRequiredException(inner),
            crate::error::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::MergeBranchesByFastForwardError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::MergeBranchesByFastForwardError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::MergeBranchesByFastForwardError> for Error {
    fn from(err: crate::error::MergeBranchesByFastForwardError) -> Self {
        match err {
            crate::error::MergeBranchesByFastForwardError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::error::MergeBranchesByFastForwardError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::error::MergeBranchesByFastForwardError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::MergeBranchesByFastForwardError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::MergeBranchesByFastForwardError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::MergeBranchesByFastForwardError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::error::MergeBranchesByFastForwardError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::MergeBranchesByFastForwardError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::MergeBranchesByFastForwardError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::MergeBranchesByFastForwardError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::MergeBranchesByFastForwardError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::MergeBranchesByFastForwardError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::MergeBranchesByFastForwardError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::MergeBranchesByFastForwardError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::MergeBranchesByFastForwardError::InvalidTargetBranchException(inner) => Error::InvalidTargetBranchException(inner),
            crate::error::MergeBranchesByFastForwardError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::error::MergeBranchesByFastForwardError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::MergeBranchesByFastForwardError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::MergeBranchesByFastForwardError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::MergeBranchesByFastForwardError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::MergeBranchesBySquashError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::MergeBranchesBySquashError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::MergeBranchesBySquashError> for Error {
    fn from(err: crate::error::MergeBranchesBySquashError) -> Self {
        match err {
            crate::error::MergeBranchesBySquashError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::error::MergeBranchesBySquashError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::error::MergeBranchesBySquashError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::MergeBranchesBySquashError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::MergeBranchesBySquashError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::error::MergeBranchesBySquashError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::MergeBranchesBySquashError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::error::MergeBranchesBySquashError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::MergeBranchesBySquashError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::MergeBranchesBySquashError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::MergeBranchesBySquashError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::MergeBranchesBySquashError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::MergeBranchesBySquashError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::error::MergeBranchesBySquashError::FileModeRequiredException(inner) => Error::FileModeRequiredException(inner),
            crate::error::MergeBranchesBySquashError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::error::MergeBranchesBySquashError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::MergeBranchesBySquashError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::MergeBranchesBySquashError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::MergeBranchesBySquashError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::error::MergeBranchesBySquashError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::MergeBranchesBySquashError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::error::MergeBranchesBySquashError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::error::MergeBranchesBySquashError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::MergeBranchesBySquashError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::error::MergeBranchesBySquashError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::error::MergeBranchesBySquashError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::MergeBranchesBySquashError::InvalidTargetBranchException(inner) => Error::InvalidTargetBranchException(inner),
            crate::error::MergeBranchesBySquashError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::error::MergeBranchesBySquashError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::error::MergeBranchesBySquashError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::error::MergeBranchesBySquashError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::error::MergeBranchesBySquashError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::error::MergeBranchesBySquashError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::error::MergeBranchesBySquashError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::MergeBranchesBySquashError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::error::MergeBranchesBySquashError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::error::MergeBranchesBySquashError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::MergeBranchesBySquashError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::MergeBranchesBySquashError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::MergeBranchesBySquashError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::MergeBranchesByThreeWayError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::MergeBranchesByThreeWayError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::MergeBranchesByThreeWayError> for Error {
    fn from(err: crate::error::MergeBranchesByThreeWayError) -> Self {
        match err {
            crate::error::MergeBranchesByThreeWayError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::error::MergeBranchesByThreeWayError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::error::MergeBranchesByThreeWayError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::MergeBranchesByThreeWayError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::MergeBranchesByThreeWayError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::error::MergeBranchesByThreeWayError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::error::MergeBranchesByThreeWayError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::error::MergeBranchesByThreeWayError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::MergeBranchesByThreeWayError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::MergeBranchesByThreeWayError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::MergeBranchesByThreeWayError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::MergeBranchesByThreeWayError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::MergeBranchesByThreeWayError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::error::MergeBranchesByThreeWayError::FileModeRequiredException(inner) => Error::FileModeRequiredException(inner),
            crate::error::MergeBranchesByThreeWayError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::MergeBranchesByThreeWayError::InvalidTargetBranchException(inner) => Error::InvalidTargetBranchException(inner),
            crate::error::MergeBranchesByThreeWayError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::error::MergeBranchesByThreeWayError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::error::MergeBranchesByThreeWayError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::error::MergeBranchesByThreeWayError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::error::MergeBranchesByThreeWayError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::error::MergeBranchesByThreeWayError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::error::MergeBranchesByThreeWayError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::MergeBranchesByThreeWayError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::error::MergeBranchesByThreeWayError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::error::MergeBranchesByThreeWayError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::MergeBranchesByThreeWayError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::MergeBranchesByThreeWayError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::MergeBranchesByThreeWayError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::MergePullRequestByFastForwardError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::MergePullRequestByFastForwardError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::MergePullRequestByFastForwardError> for Error {
    fn from(err: crate::error::MergePullRequestByFastForwardError) -> Self {
        match err {
            crate::error::MergePullRequestByFastForwardError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::error::MergePullRequestByFastForwardError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::MergePullRequestByFastForwardError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::MergePullRequestByFastForwardError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::MergePullRequestByFastForwardError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::MergePullRequestByFastForwardError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::MergePullRequestByFastForwardError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::MergePullRequestByFastForwardError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::MergePullRequestByFastForwardError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::MergePullRequestByFastForwardError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::error::MergePullRequestByFastForwardError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::MergePullRequestByFastForwardError::PullRequestApprovalRulesNotSatisfiedException(inner) => Error::PullRequestApprovalRulesNotSatisfiedException(inner),
            crate::error::MergePullRequestByFastForwardError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::MergePullRequestByFastForwardError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::MergePullRequestByFastForwardError::ReferenceDoesNotExistException(inner) => Error::ReferenceDoesNotExistException(inner),
            crate::error::MergePullRequestByFastForwardError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::MergePullRequestByFastForwardError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::MergePullRequestByFastForwardError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::error::MergePullRequestByFastForwardError::TipOfSourceReferenceIsDifferentException(inner) => Error::TipOfSourceReferenceIsDifferentException(inner),
            crate::error::MergePullRequestByFastForwardError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::MergePullRequestBySquashError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::MergePullRequestBySquashError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::MergePullRequestBySquashError> for Error {
    fn from(err: crate::error::MergePullRequestBySquashError) -> Self {
        match err {
            crate::error::MergePullRequestBySquashError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::error::MergePullRequestBySquashError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::error::MergePullRequestBySquashError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::MergePullRequestBySquashError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::MergePullRequestBySquashError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::MergePullRequestBySquashError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::MergePullRequestBySquashError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::MergePullRequestBySquashError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::error::MergePullRequestBySquashError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::error::MergePullRequestBySquashError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::MergePullRequestBySquashError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::MergePullRequestBySquashError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::error::MergePullRequestBySquashError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::MergePullRequestBySquashError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::error::MergePullRequestBySquashError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::error::MergePullRequestBySquashError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::MergePullRequestBySquashError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::MergePullRequestBySquashError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::error::MergePullRequestBySquashError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::error::MergePullRequestBySquashError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::MergePullRequestBySquashError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::error::MergePullRequestBySquashError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::error::MergePullRequestBySquashError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::error::MergePullRequestBySquashError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::error::MergePullRequestBySquashError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::error::MergePullRequestBySquashError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::error::MergePullRequestBySquashError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::MergePullRequestBySquashError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::MergePullRequestBySquashError::PullRequestApprovalRulesNotSatisfiedException(inner) => Error::PullRequestApprovalRulesNotSatisfiedException(inner),
            crate::error::MergePullRequestBySquashError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::MergePullRequestBySquashError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::MergePullRequestBySquashError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::error::MergePullRequestBySquashError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::error::MergePullRequestBySquashError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::MergePullRequestBySquashError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::MergePullRequestBySquashError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::error::MergePullRequestBySquashError::TipOfSourceReferenceIsDifferentException(inner) => Error::TipOfSourceReferenceIsDifferentException(inner),
            crate::error::MergePullRequestBySquashError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::MergePullRequestBySquashError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::MergePullRequestByThreeWayError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::MergePullRequestByThreeWayError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::MergePullRequestByThreeWayError> for Error {
    fn from(err: crate::error::MergePullRequestByThreeWayError) -> Self {
        match err {
            crate::error::MergePullRequestByThreeWayError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::error::MergePullRequestByThreeWayError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::error::MergePullRequestByThreeWayError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::MergePullRequestByThreeWayError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::MergePullRequestByThreeWayError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::MergePullRequestByThreeWayError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::MergePullRequestByThreeWayError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::MergePullRequestByThreeWayError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::error::MergePullRequestByThreeWayError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::error::MergePullRequestByThreeWayError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::MergePullRequestByThreeWayError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::error::MergePullRequestByThreeWayError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::error::MergePullRequestByThreeWayError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::error::MergePullRequestByThreeWayError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::error::MergePullRequestByThreeWayError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::error::MergePullRequestByThreeWayError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::error::MergePullRequestByThreeWayError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::MergePullRequestByThreeWayError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::MergePullRequestByThreeWayError::PullRequestApprovalRulesNotSatisfiedException(inner) => Error::PullRequestApprovalRulesNotSatisfiedException(inner),
            crate::error::MergePullRequestByThreeWayError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::MergePullRequestByThreeWayError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::MergePullRequestByThreeWayError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::error::MergePullRequestByThreeWayError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::error::MergePullRequestByThreeWayError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::MergePullRequestByThreeWayError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::MergePullRequestByThreeWayError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::error::MergePullRequestByThreeWayError::TipOfSourceReferenceIsDifferentException(inner) => Error::TipOfSourceReferenceIsDifferentException(inner),
            crate::error::MergePullRequestByThreeWayError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::error::MergePullRequestByThreeWayError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::OverridePullRequestApprovalRulesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::OverridePullRequestApprovalRulesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::OverridePullRequestApprovalRulesError> for Error {
    fn from(err: crate::error::OverridePullRequestApprovalRulesError) -> Self {
        match err {
            crate::error::OverridePullRequestApprovalRulesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::OverridePullRequestApprovalRulesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::OverridePullRequestApprovalRulesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::OverridePullRequestApprovalRulesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::OverridePullRequestApprovalRulesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::OverridePullRequestApprovalRulesError::InvalidOverrideStatusException(inner) => Error::InvalidOverrideStatusException(inner),
            crate::error::OverridePullRequestApprovalRulesError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::OverridePullRequestApprovalRulesError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::error::OverridePullRequestApprovalRulesError::OverrideAlreadySetException(inner) => Error::OverrideAlreadySetException(inner),
            crate::error::OverridePullRequestApprovalRulesError::OverrideStatusRequiredException(inner) => Error::OverrideStatusRequiredException(inner),
            crate::error::OverridePullRequestApprovalRulesError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::OverridePullRequestApprovalRulesError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::OverridePullRequestApprovalRulesError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::OverridePullRequestApprovalRulesError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::error::OverridePullRequestApprovalRulesError::RevisionNotCurrentException(inner) => Error::RevisionNotCurrentException(inner),
            crate::error::OverridePullRequestApprovalRulesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PostCommentForComparedCommitError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PostCommentForComparedCommitError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::PostCommentForComparedCommitError> for Error {
    fn from(err: crate::error::PostCommentForComparedCommitError) -> Self {
        match err {
            crate::error::PostCommentForComparedCommitError::BeforeCommitIdAndAfterCommitIdAreSameException(inner) => Error::BeforeCommitIdAndAfterCommitIdAreSameException(inner),
            crate::error::PostCommentForComparedCommitError::ClientRequestTokenRequiredException(inner) => Error::ClientRequestTokenRequiredException(inner),
            crate::error::PostCommentForComparedCommitError::CommentContentRequiredException(inner) => Error::CommentContentRequiredException(inner),
            crate::error::PostCommentForComparedCommitError::CommentContentSizeLimitExceededException(inner) => Error::CommentContentSizeLimitExceededException(inner),
            crate::error::PostCommentForComparedCommitError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::PostCommentForComparedCommitError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::error::PostCommentForComparedCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::PostCommentForComparedCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::PostCommentForComparedCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::PostCommentForComparedCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::PostCommentForComparedCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::PostCommentForComparedCommitError::IdempotencyParameterMismatchException(inner) => Error::IdempotencyParameterMismatchException(inner),
            crate::error::PostCommentForComparedCommitError::InvalidClientRequestTokenException(inner) => Error::InvalidClientRequestTokenException(inner),
            crate::error::PostCommentForComparedCommitError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::PostCommentForComparedCommitError::InvalidFileLocationException(inner) => Error::InvalidFileLocationException(inner),
            crate::error::PostCommentForComparedCommitError::InvalidFilePositionException(inner) => Error::InvalidFilePositionException(inner),
            crate::error::PostCommentForComparedCommitError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::PostCommentForComparedCommitError::InvalidRelativeFileVersionEnumException(inner) => Error::InvalidRelativeFileVersionEnumException(inner),
            crate::error::PostCommentForComparedCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::PostCommentForComparedCommitError::PathDoesNotExistException(inner) => Error::PathDoesNotExistException(inner),
            crate::error::PostCommentForComparedCommitError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::PostCommentForComparedCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::PostCommentForComparedCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::PostCommentForComparedCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PostCommentForPullRequestError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PostCommentForPullRequestError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::PostCommentForPullRequestError> for Error {
    fn from(err: crate::error::PostCommentForPullRequestError) -> Self {
        match err {
            crate::error::PostCommentForPullRequestError::BeforeCommitIdAndAfterCommitIdAreSameException(inner) => Error::BeforeCommitIdAndAfterCommitIdAreSameException(inner),
            crate::error::PostCommentForPullRequestError::ClientRequestTokenRequiredException(inner) => Error::ClientRequestTokenRequiredException(inner),
            crate::error::PostCommentForPullRequestError::CommentContentRequiredException(inner) => Error::CommentContentRequiredException(inner),
            crate::error::PostCommentForPullRequestError::CommentContentSizeLimitExceededException(inner) => Error::CommentContentSizeLimitExceededException(inner),
            crate::error::PostCommentForPullRequestError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::error::PostCommentForPullRequestError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::error::PostCommentForPullRequestError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::PostCommentForPullRequestError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::PostCommentForPullRequestError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::PostCommentForPullRequestError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::PostCommentForPullRequestError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::PostCommentForPullRequestError::IdempotencyParameterMismatchException(inner) => Error::IdempotencyParameterMismatchException(inner),
            crate::error::PostCommentForPullRequestError::InvalidClientRequestTokenException(inner) => Error::InvalidClientRequestTokenException(inner),
            crate::error::PostCommentForPullRequestError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::error::PostCommentForPullRequestError::InvalidFileLocationException(inner) => Error::InvalidFileLocationException(inner),
            crate::error::PostCommentForPullRequestError::InvalidFilePositionException(inner) => Error::InvalidFilePositionException(inner),
            crate::error::PostCommentForPullRequestError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::PostCommentForPullRequestError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::PostCommentForPullRequestError::InvalidRelativeFileVersionEnumException(inner) => Error::InvalidRelativeFileVersionEnumException(inner),
            crate::error::PostCommentForPullRequestError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::PostCommentForPullRequestError::PathDoesNotExistException(inner) => Error::PathDoesNotExistException(inner),
            crate::error::PostCommentForPullRequestError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::PostCommentForPullRequestError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::PostCommentForPullRequestError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::PostCommentForPullRequestError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::PostCommentForPullRequestError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::PostCommentForPullRequestError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::error::PostCommentForPullRequestError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PostCommentReplyError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PostCommentReplyError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::PostCommentReplyError> for Error {
    fn from(err: crate::error::PostCommentReplyError) -> Self {
        match err {
            crate::error::PostCommentReplyError::ClientRequestTokenRequiredException(inner) => Error::ClientRequestTokenRequiredException(inner),
            crate::error::PostCommentReplyError::CommentContentRequiredException(inner) => Error::CommentContentRequiredException(inner),
            crate::error::PostCommentReplyError::CommentContentSizeLimitExceededException(inner) => Error::CommentContentSizeLimitExceededException(inner),
            crate::error::PostCommentReplyError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::error::PostCommentReplyError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::error::PostCommentReplyError::IdempotencyParameterMismatchException(inner) => Error::IdempotencyParameterMismatchException(inner),
            crate::error::PostCommentReplyError::InvalidClientRequestTokenException(inner) => Error::InvalidClientRequestTokenException(inner),
            crate::error::PostCommentReplyError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::error::PostCommentReplyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutCommentReactionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutCommentReactionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::PutCommentReactionError> for Error {
    fn from(err: crate::error::PutCommentReactionError) -> Self {
        match err {
            crate::error::PutCommentReactionError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::error::PutCommentReactionError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::error::PutCommentReactionError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::error::PutCommentReactionError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::error::PutCommentReactionError::InvalidReactionValueException(inner) => Error::InvalidReactionValueException(inner),
            crate::error::PutCommentReactionError::ReactionLimitExceededException(inner) => Error::ReactionLimitExceededException(inner),
            crate::error::PutCommentReactionError::ReactionValueRequiredException(inner) => Error::ReactionValueRequiredException(inner),
            crate::error::PutCommentReactionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutFileError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutFileError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::PutFileError> for Error {
    fn from(err: crate::error::PutFileError) -> Self {
        match err {
            crate::error::PutFileError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::error::PutFileError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::error::PutFileError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::PutFileError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::error::PutFileError::DirectoryNameConflictsWithFileNameException(inner) => Error::DirectoryNameConflictsWithFileNameException(inner),
            crate::error::PutFileError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::PutFileError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::PutFileError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::PutFileError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::PutFileError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::PutFileError::FileContentRequiredException(inner) => Error::FileContentRequiredException(inner),
            crate::error::PutFileError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::error::PutFileError::FileNameConflictsWithDirectoryNameException(inner) => Error::FileNameConflictsWithDirectoryNameException(inner),
            crate::error::PutFileError::FilePathConflictsWithSubmodulePathException(inner) => Error::FilePathConflictsWithSubmodulePathException(inner),
            crate::error::PutFileError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::error::PutFileError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::PutFileError::InvalidDeletionParameterException(inner) => Error::InvalidDeletionParameterException(inner),
            crate::error::PutFileError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::error::PutFileError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::error::PutFileError::InvalidParentCommitIdException(inner) => Error::InvalidParentCommitIdException(inner),
            crate::error::PutFileError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::error::PutFileError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::PutFileError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::error::PutFileError::ParentCommitDoesNotExistException(inner) => Error::ParentCommitDoesNotExistException(inner),
            crate::error::PutFileError::ParentCommitIdOutdatedException(inner) => Error::ParentCommitIdOutdatedException(inner),
            crate::error::PutFileError::ParentCommitIdRequiredException(inner) => Error::ParentCommitIdRequiredException(inner),
            crate::error::PutFileError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::error::PutFileError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::PutFileError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::PutFileError::SameFileContentException(inner) => Error::SameFileContentException(inner),
            crate::error::PutFileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::PutRepositoryTriggersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::PutRepositoryTriggersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::PutRepositoryTriggersError> for Error {
    fn from(err: crate::error::PutRepositoryTriggersError) -> Self {
        match err {
            crate::error::PutRepositoryTriggersError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::PutRepositoryTriggersError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::PutRepositoryTriggersError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::PutRepositoryTriggersError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::PutRepositoryTriggersError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::PutRepositoryTriggersError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException(inner) => Error::InvalidRepositoryTriggerBranchNameException(inner),
            crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException(inner) => Error::InvalidRepositoryTriggerCustomDataException(inner),
            crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException(inner) => Error::InvalidRepositoryTriggerDestinationArnException(inner),
            crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerEventsException(inner) => Error::InvalidRepositoryTriggerEventsException(inner),
            crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerNameException(inner) => Error::InvalidRepositoryTriggerNameException(inner),
            crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerRegionException(inner) => Error::InvalidRepositoryTriggerRegionException(inner),
            crate::error::PutRepositoryTriggersError::MaximumBranchesExceededException(inner) => Error::MaximumBranchesExceededException(inner),
            crate::error::PutRepositoryTriggersError::MaximumRepositoryTriggersExceededException(inner) => Error::MaximumRepositoryTriggersExceededException(inner),
            crate::error::PutRepositoryTriggersError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::PutRepositoryTriggersError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::PutRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException(inner) => Error::RepositoryTriggerBranchNameListRequiredException(inner),
            crate::error::PutRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException(inner) => Error::RepositoryTriggerDestinationArnRequiredException(inner),
            crate::error::PutRepositoryTriggersError::RepositoryTriggerEventsListRequiredException(inner) => Error::RepositoryTriggerEventsListRequiredException(inner),
            crate::error::PutRepositoryTriggersError::RepositoryTriggerNameRequiredException(inner) => Error::RepositoryTriggerNameRequiredException(inner),
            crate::error::PutRepositoryTriggersError::RepositoryTriggersListRequiredException(inner) => Error::RepositoryTriggersListRequiredException(inner),
            crate::error::PutRepositoryTriggersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::TagResourceError> for Error {
    fn from(err: crate::error::TagResourceError) -> Self {
        match err {
            crate::error::TagResourceError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::TagResourceError::InvalidResourceArnException(inner) => Error::InvalidResourceArnException(inner),
            crate::error::TagResourceError::InvalidSystemTagUsageException(inner) => Error::InvalidSystemTagUsageException(inner),
            crate::error::TagResourceError::InvalidTagsMapException(inner) => Error::InvalidTagsMapException(inner),
            crate::error::TagResourceError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::TagResourceError::ResourceArnRequiredException(inner) => Error::ResourceArnRequiredException(inner),
            crate::error::TagResourceError::TagPolicyException(inner) => Error::TagPolicyException(inner),
            crate::error::TagResourceError::TagsMapRequiredException(inner) => Error::TagsMapRequiredException(inner),
            crate::error::TagResourceError::TooManyTagsException(inner) => Error::TooManyTagsException(inner),
            crate::error::TagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::TestRepositoryTriggersError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::TestRepositoryTriggersError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::TestRepositoryTriggersError> for Error {
    fn from(err: crate::error::TestRepositoryTriggersError) -> Self {
        match err {
            crate::error::TestRepositoryTriggersError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::TestRepositoryTriggersError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::TestRepositoryTriggersError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::TestRepositoryTriggersError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::TestRepositoryTriggersError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::TestRepositoryTriggersError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException(inner) => Error::InvalidRepositoryTriggerBranchNameException(inner),
            crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException(inner) => Error::InvalidRepositoryTriggerCustomDataException(inner),
            crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException(inner) => Error::InvalidRepositoryTriggerDestinationArnException(inner),
            crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerEventsException(inner) => Error::InvalidRepositoryTriggerEventsException(inner),
            crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerNameException(inner) => Error::InvalidRepositoryTriggerNameException(inner),
            crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerRegionException(inner) => Error::InvalidRepositoryTriggerRegionException(inner),
            crate::error::TestRepositoryTriggersError::MaximumBranchesExceededException(inner) => Error::MaximumBranchesExceededException(inner),
            crate::error::TestRepositoryTriggersError::MaximumRepositoryTriggersExceededException(inner) => Error::MaximumRepositoryTriggersExceededException(inner),
            crate::error::TestRepositoryTriggersError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::TestRepositoryTriggersError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::TestRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException(inner) => Error::RepositoryTriggerBranchNameListRequiredException(inner),
            crate::error::TestRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException(inner) => Error::RepositoryTriggerDestinationArnRequiredException(inner),
            crate::error::TestRepositoryTriggersError::RepositoryTriggerEventsListRequiredException(inner) => Error::RepositoryTriggerEventsListRequiredException(inner),
            crate::error::TestRepositoryTriggersError::RepositoryTriggerNameRequiredException(inner) => Error::RepositoryTriggerNameRequiredException(inner),
            crate::error::TestRepositoryTriggersError::RepositoryTriggersListRequiredException(inner) => Error::RepositoryTriggersListRequiredException(inner),
            crate::error::TestRepositoryTriggersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UntagResourceError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UntagResourceError> for Error {
    fn from(err: crate::error::UntagResourceError) -> Self {
        match err {
            crate::error::UntagResourceError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::UntagResourceError::InvalidResourceArnException(inner) => Error::InvalidResourceArnException(inner),
            crate::error::UntagResourceError::InvalidSystemTagUsageException(inner) => Error::InvalidSystemTagUsageException(inner),
            crate::error::UntagResourceError::InvalidTagKeysListException(inner) => Error::InvalidTagKeysListException(inner),
            crate::error::UntagResourceError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::UntagResourceError::ResourceArnRequiredException(inner) => Error::ResourceArnRequiredException(inner),
            crate::error::UntagResourceError::TagKeysListRequiredException(inner) => Error::TagKeysListRequiredException(inner),
            crate::error::UntagResourceError::TagPolicyException(inner) => Error::TagPolicyException(inner),
            crate::error::UntagResourceError::TooManyTagsException(inner) => Error::TooManyTagsException(inner),
            crate::error::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateApprovalRuleTemplateContentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateApprovalRuleTemplateContentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateApprovalRuleTemplateContentError> for Error {
    fn from(err: crate::error::UpdateApprovalRuleTemplateContentError) -> Self {
        match err {
            crate::error::UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateContentRequiredException(inner) => Error::ApprovalRuleTemplateContentRequiredException(inner),
            crate::error::UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::error::UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::UpdateApprovalRuleTemplateContentError::InvalidApprovalRuleTemplateContentException(inner) => Error::InvalidApprovalRuleTemplateContentException(inner),
            crate::error::UpdateApprovalRuleTemplateContentError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::UpdateApprovalRuleTemplateContentError::InvalidRuleContentSha256Exception(inner) => Error::InvalidRuleContentSha256Exception(inner),
            crate::error::UpdateApprovalRuleTemplateContentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateApprovalRuleTemplateDescriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateApprovalRuleTemplateDescriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateApprovalRuleTemplateDescriptionError> for Error {
    fn from(err: crate::error::UpdateApprovalRuleTemplateDescriptionError) -> Self {
        match err {
            crate::error::UpdateApprovalRuleTemplateDescriptionError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::error::UpdateApprovalRuleTemplateDescriptionError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::UpdateApprovalRuleTemplateDescriptionError::InvalidApprovalRuleTemplateDescriptionException(inner) => Error::InvalidApprovalRuleTemplateDescriptionException(inner),
            crate::error::UpdateApprovalRuleTemplateDescriptionError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::UpdateApprovalRuleTemplateDescriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateApprovalRuleTemplateNameError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateApprovalRuleTemplateNameError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateApprovalRuleTemplateNameError> for Error {
    fn from(err: crate::error::UpdateApprovalRuleTemplateNameError) -> Self {
        match err {
            crate::error::UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::error::UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateNameAlreadyExistsException(inner) => Error::ApprovalRuleTemplateNameAlreadyExistsException(inner),
            crate::error::UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::error::UpdateApprovalRuleTemplateNameError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::error::UpdateApprovalRuleTemplateNameError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateCommentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateCommentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateCommentError> for Error {
    fn from(err: crate::error::UpdateCommentError) -> Self {
        match err {
            crate::error::UpdateCommentError::CommentContentRequiredException(inner) => Error::CommentContentRequiredException(inner),
            crate::error::UpdateCommentError::CommentContentSizeLimitExceededException(inner) => Error::CommentContentSizeLimitExceededException(inner),
            crate::error::UpdateCommentError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::error::UpdateCommentError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::error::UpdateCommentError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::error::UpdateCommentError::CommentNotCreatedByCallerException(inner) => Error::CommentNotCreatedByCallerException(inner),
            crate::error::UpdateCommentError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::error::UpdateCommentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateDefaultBranchError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateDefaultBranchError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateDefaultBranchError> for Error {
    fn from(err: crate::error::UpdateDefaultBranchError) -> Self {
        match err {
            crate::error::UpdateDefaultBranchError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::error::UpdateDefaultBranchError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::error::UpdateDefaultBranchError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::UpdateDefaultBranchError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::UpdateDefaultBranchError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::UpdateDefaultBranchError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::UpdateDefaultBranchError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::UpdateDefaultBranchError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::error::UpdateDefaultBranchError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::UpdateDefaultBranchError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::UpdateDefaultBranchError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::UpdateDefaultBranchError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestApprovalRuleContentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestApprovalRuleContentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdatePullRequestApprovalRuleContentError> for Error {
    fn from(err: crate::error::UpdatePullRequestApprovalRuleContentError) -> Self {
        match err {
            crate::error::UpdatePullRequestApprovalRuleContentError::ApprovalRuleContentRequiredException(inner) => Error::ApprovalRuleContentRequiredException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::ApprovalRuleDoesNotExistException(inner) => Error::ApprovalRuleDoesNotExistException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::ApprovalRuleNameRequiredException(inner) => Error::ApprovalRuleNameRequiredException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::CannotModifyApprovalRuleFromTemplateException(inner) => Error::CannotModifyApprovalRuleFromTemplateException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::InvalidApprovalRuleContentException(inner) => Error::InvalidApprovalRuleContentException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::InvalidApprovalRuleNameException(inner) => Error::InvalidApprovalRuleNameException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::InvalidRuleContentSha256Exception(inner) => Error::InvalidRuleContentSha256Exception(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::UpdatePullRequestApprovalRuleContentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestApprovalStateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestApprovalStateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdatePullRequestApprovalStateError> for Error {
    fn from(err: crate::error::UpdatePullRequestApprovalStateError) -> Self {
        match err {
            crate::error::UpdatePullRequestApprovalStateError::ApprovalStateRequiredException(inner) => Error::ApprovalStateRequiredException(inner),
            crate::error::UpdatePullRequestApprovalStateError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::UpdatePullRequestApprovalStateError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::UpdatePullRequestApprovalStateError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::UpdatePullRequestApprovalStateError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::UpdatePullRequestApprovalStateError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::UpdatePullRequestApprovalStateError::InvalidApprovalStateException(inner) => Error::InvalidApprovalStateException(inner),
            crate::error::UpdatePullRequestApprovalStateError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::UpdatePullRequestApprovalStateError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::error::UpdatePullRequestApprovalStateError::MaximumNumberOfApprovalsExceededException(inner) => Error::MaximumNumberOfApprovalsExceededException(inner),
            crate::error::UpdatePullRequestApprovalStateError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::UpdatePullRequestApprovalStateError::PullRequestCannotBeApprovedByAuthorException(inner) => Error::PullRequestCannotBeApprovedByAuthorException(inner),
            crate::error::UpdatePullRequestApprovalStateError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::UpdatePullRequestApprovalStateError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::UpdatePullRequestApprovalStateError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::error::UpdatePullRequestApprovalStateError::RevisionNotCurrentException(inner) => Error::RevisionNotCurrentException(inner),
            crate::error::UpdatePullRequestApprovalStateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestDescriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestDescriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdatePullRequestDescriptionError> for Error {
    fn from(err: crate::error::UpdatePullRequestDescriptionError) -> Self {
        match err {
            crate::error::UpdatePullRequestDescriptionError::InvalidDescriptionException(inner) => Error::InvalidDescriptionException(inner),
            crate::error::UpdatePullRequestDescriptionError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::UpdatePullRequestDescriptionError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::UpdatePullRequestDescriptionError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::UpdatePullRequestDescriptionError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::UpdatePullRequestDescriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestStatusError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestStatusError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdatePullRequestStatusError> for Error {
    fn from(err: crate::error::UpdatePullRequestStatusError) -> Self {
        match err {
            crate::error::UpdatePullRequestStatusError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::UpdatePullRequestStatusError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::UpdatePullRequestStatusError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::UpdatePullRequestStatusError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::UpdatePullRequestStatusError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::UpdatePullRequestStatusError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::UpdatePullRequestStatusError::InvalidPullRequestStatusException(inner) => Error::InvalidPullRequestStatusException(inner),
            crate::error::UpdatePullRequestStatusError::InvalidPullRequestStatusUpdateException(inner) => Error::InvalidPullRequestStatusUpdateException(inner),
            crate::error::UpdatePullRequestStatusError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::UpdatePullRequestStatusError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::UpdatePullRequestStatusError::PullRequestStatusRequiredException(inner) => Error::PullRequestStatusRequiredException(inner),
            crate::error::UpdatePullRequestStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestTitleError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdatePullRequestTitleError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdatePullRequestTitleError> for Error {
    fn from(err: crate::error::UpdatePullRequestTitleError) -> Self {
        match err {
            crate::error::UpdatePullRequestTitleError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::error::UpdatePullRequestTitleError::InvalidTitleException(inner) => Error::InvalidTitleException(inner),
            crate::error::UpdatePullRequestTitleError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::error::UpdatePullRequestTitleError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::error::UpdatePullRequestTitleError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::error::UpdatePullRequestTitleError::TitleRequiredException(inner) => Error::TitleRequiredException(inner),
            crate::error::UpdatePullRequestTitleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateRepositoryDescriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateRepositoryDescriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateRepositoryDescriptionError> for Error {
    fn from(err: crate::error::UpdateRepositoryDescriptionError) -> Self {
        match err {
            crate::error::UpdateRepositoryDescriptionError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::error::UpdateRepositoryDescriptionError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::error::UpdateRepositoryDescriptionError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::error::UpdateRepositoryDescriptionError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::error::UpdateRepositoryDescriptionError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::error::UpdateRepositoryDescriptionError::InvalidRepositoryDescriptionException(inner) => Error::InvalidRepositoryDescriptionException(inner),
            crate::error::UpdateRepositoryDescriptionError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::UpdateRepositoryDescriptionError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::UpdateRepositoryDescriptionError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::UpdateRepositoryDescriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::error::UpdateRepositoryNameError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::error::UpdateRepositoryNameError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::error::UpdateRepositoryNameError> for Error {
    fn from(err: crate::error::UpdateRepositoryNameError) -> Self {
        match err {
            crate::error::UpdateRepositoryNameError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::error::UpdateRepositoryNameError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::error::UpdateRepositoryNameError::RepositoryNameExistsException(inner) => Error::RepositoryNameExistsException(inner),
            crate::error::UpdateRepositoryNameError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::error::UpdateRepositoryNameError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::ActorDoesNotExistException(e) => e.request_id(),
            Self::ApprovalRuleContentRequiredException(e) => e.request_id(),
            Self::ApprovalRuleDoesNotExistException(e) => e.request_id(),
            Self::ApprovalRuleNameAlreadyExistsException(e) => e.request_id(),
            Self::ApprovalRuleNameRequiredException(e) => e.request_id(),
            Self::ApprovalRuleTemplateContentRequiredException(e) => e.request_id(),
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.request_id(),
            Self::ApprovalRuleTemplateInUseException(e) => e.request_id(),
            Self::ApprovalRuleTemplateNameAlreadyExistsException(e) => e.request_id(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.request_id(),
            Self::ApprovalStateRequiredException(e) => e.request_id(),
            Self::AuthorDoesNotExistException(e) => e.request_id(),
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(e) => e.request_id(),
            Self::BlobIdDoesNotExistException(e) => e.request_id(),
            Self::BlobIdRequiredException(e) => e.request_id(),
            Self::BranchDoesNotExistException(e) => e.request_id(),
            Self::BranchNameExistsException(e) => e.request_id(),
            Self::BranchNameIsTagNameException(e) => e.request_id(),
            Self::BranchNameRequiredException(e) => e.request_id(),
            Self::CannotDeleteApprovalRuleFromTemplateException(e) => e.request_id(),
            Self::CannotModifyApprovalRuleFromTemplateException(e) => e.request_id(),
            Self::ClientRequestTokenRequiredException(e) => e.request_id(),
            Self::CommentContentRequiredException(e) => e.request_id(),
            Self::CommentContentSizeLimitExceededException(e) => e.request_id(),
            Self::CommentDeletedException(e) => e.request_id(),
            Self::CommentDoesNotExistException(e) => e.request_id(),
            Self::CommentIdRequiredException(e) => e.request_id(),
            Self::CommentNotCreatedByCallerException(e) => e.request_id(),
            Self::CommitDoesNotExistException(e) => e.request_id(),
            Self::CommitIdDoesNotExistException(e) => e.request_id(),
            Self::CommitIdRequiredException(e) => e.request_id(),
            Self::CommitIdsLimitExceededException(e) => e.request_id(),
            Self::CommitIdsListRequiredException(e) => e.request_id(),
            Self::CommitMessageLengthExceededException(e) => e.request_id(),
            Self::CommitRequiredException(e) => e.request_id(),
            Self::ConcurrentReferenceUpdateException(e) => e.request_id(),
            Self::DefaultBranchCannotBeDeletedException(e) => e.request_id(),
            Self::DirectoryNameConflictsWithFileNameException(e) => e.request_id(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.request_id(),
            Self::EncryptionKeyAccessDeniedException(e) => e.request_id(),
            Self::EncryptionKeyDisabledException(e) => e.request_id(),
            Self::EncryptionKeyNotFoundException(e) => e.request_id(),
            Self::EncryptionKeyUnavailableException(e) => e.request_id(),
            Self::FileContentAndSourceFileSpecifiedException(e) => e.request_id(),
            Self::FileContentRequiredException(e) => e.request_id(),
            Self::FileContentSizeLimitExceededException(e) => e.request_id(),
            Self::FileDoesNotExistException(e) => e.request_id(),
            Self::FileEntryRequiredException(e) => e.request_id(),
            Self::FileModeRequiredException(e) => e.request_id(),
            Self::FileNameConflictsWithDirectoryNameException(e) => e.request_id(),
            Self::FilePathConflictsWithSubmodulePathException(e) => e.request_id(),
            Self::FileTooLargeException(e) => e.request_id(),
            Self::FolderContentSizeLimitExceededException(e) => e.request_id(),
            Self::FolderDoesNotExistException(e) => e.request_id(),
            Self::IdempotencyParameterMismatchException(e) => e.request_id(),
            Self::InvalidActorArnException(e) => e.request_id(),
            Self::InvalidApprovalRuleContentException(e) => e.request_id(),
            Self::InvalidApprovalRuleNameException(e) => e.request_id(),
            Self::InvalidApprovalRuleTemplateContentException(e) => e.request_id(),
            Self::InvalidApprovalRuleTemplateDescriptionException(e) => e.request_id(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.request_id(),
            Self::InvalidApprovalStateException(e) => e.request_id(),
            Self::InvalidAuthorArnException(e) => e.request_id(),
            Self::InvalidBlobIdException(e) => e.request_id(),
            Self::InvalidBranchNameException(e) => e.request_id(),
            Self::InvalidClientRequestTokenException(e) => e.request_id(),
            Self::InvalidCommentIdException(e) => e.request_id(),
            Self::InvalidCommitException(e) => e.request_id(),
            Self::InvalidCommitIdException(e) => e.request_id(),
            Self::InvalidConflictDetailLevelException(e) => e.request_id(),
            Self::InvalidConflictResolutionException(e) => e.request_id(),
            Self::InvalidConflictResolutionStrategyException(e) => e.request_id(),
            Self::InvalidContinuationTokenException(e) => e.request_id(),
            Self::InvalidDeletionParameterException(e) => e.request_id(),
            Self::InvalidDescriptionException(e) => e.request_id(),
            Self::InvalidDestinationCommitSpecifierException(e) => e.request_id(),
            Self::InvalidEmailException(e) => e.request_id(),
            Self::InvalidFileLocationException(e) => e.request_id(),
            Self::InvalidFileModeException(e) => e.request_id(),
            Self::InvalidFilePositionException(e) => e.request_id(),
            Self::InvalidMaxConflictFilesException(e) => e.request_id(),
            Self::InvalidMaxMergeHunksException(e) => e.request_id(),
            Self::InvalidMaxResultsException(e) => e.request_id(),
            Self::InvalidMergeOptionException(e) => e.request_id(),
            Self::InvalidOrderException(e) => e.request_id(),
            Self::InvalidOverrideStatusException(e) => e.request_id(),
            Self::InvalidParentCommitIdException(e) => e.request_id(),
            Self::InvalidPathException(e) => e.request_id(),
            Self::InvalidPullRequestEventTypeException(e) => e.request_id(),
            Self::InvalidPullRequestIdException(e) => e.request_id(),
            Self::InvalidPullRequestStatusException(e) => e.request_id(),
            Self::InvalidPullRequestStatusUpdateException(e) => e.request_id(),
            Self::InvalidReactionUserArnException(e) => e.request_id(),
            Self::InvalidReactionValueException(e) => e.request_id(),
            Self::InvalidReferenceNameException(e) => e.request_id(),
            Self::InvalidRelativeFileVersionEnumException(e) => e.request_id(),
            Self::InvalidReplacementContentException(e) => e.request_id(),
            Self::InvalidReplacementTypeException(e) => e.request_id(),
            Self::InvalidRepositoryDescriptionException(e) => e.request_id(),
            Self::InvalidRepositoryNameException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerBranchNameException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerCustomDataException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerDestinationArnException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerEventsException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerNameException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerRegionException(e) => e.request_id(),
            Self::InvalidResourceArnException(e) => e.request_id(),
            Self::InvalidRevisionIdException(e) => e.request_id(),
            Self::InvalidRuleContentSha256Exception(e) => e.request_id(),
            Self::InvalidSortByException(e) => e.request_id(),
            Self::InvalidSourceCommitSpecifierException(e) => e.request_id(),
            Self::InvalidSystemTagUsageException(e) => e.request_id(),
            Self::InvalidTagKeysListException(e) => e.request_id(),
            Self::InvalidTagsMapException(e) => e.request_id(),
            Self::InvalidTargetBranchException(e) => e.request_id(),
            Self::InvalidTargetException(e) => e.request_id(),
            Self::InvalidTargetsException(e) => e.request_id(),
            Self::InvalidTitleException(e) => e.request_id(),
            Self::ManualMergeRequiredException(e) => e.request_id(),
            Self::MaximumBranchesExceededException(e) => e.request_id(),
            Self::MaximumConflictResolutionEntriesExceededException(e) => e.request_id(),
            Self::MaximumFileContentToLoadExceededException(e) => e.request_id(),
            Self::MaximumFileEntriesExceededException(e) => e.request_id(),
            Self::MaximumItemsToCompareExceededException(e) => e.request_id(),
            Self::MaximumNumberOfApprovalsExceededException(e) => e.request_id(),
            Self::MaximumOpenPullRequestsExceededException(e) => e.request_id(),
            Self::MaximumRepositoryNamesExceededException(e) => e.request_id(),
            Self::MaximumRepositoryTriggersExceededException(e) => e.request_id(),
            Self::MaximumRuleTemplatesAssociatedWithRepositoryException(e) => e.request_id(),
            Self::MergeOptionRequiredException(e) => e.request_id(),
            Self::MultipleConflictResolutionEntriesException(e) => e.request_id(),
            Self::MultipleRepositoriesInPullRequestException(e) => e.request_id(),
            Self::NameLengthExceededException(e) => e.request_id(),
            Self::NoChangeException(e) => e.request_id(),
            Self::NumberOfRuleTemplatesExceededException(e) => e.request_id(),
            Self::NumberOfRulesExceededException(e) => e.request_id(),
            Self::OverrideAlreadySetException(e) => e.request_id(),
            Self::OverrideStatusRequiredException(e) => e.request_id(),
            Self::ParentCommitDoesNotExistException(e) => e.request_id(),
            Self::ParentCommitIdOutdatedException(e) => e.request_id(),
            Self::ParentCommitIdRequiredException(e) => e.request_id(),
            Self::PathDoesNotExistException(e) => e.request_id(),
            Self::PathRequiredException(e) => e.request_id(),
            Self::PullRequestAlreadyClosedException(e) => e.request_id(),
            Self::PullRequestApprovalRulesNotSatisfiedException(e) => e.request_id(),
            Self::PullRequestCannotBeApprovedByAuthorException(e) => e.request_id(),
            Self::PullRequestDoesNotExistException(e) => e.request_id(),
            Self::PullRequestIdRequiredException(e) => e.request_id(),
            Self::PullRequestStatusRequiredException(e) => e.request_id(),
            Self::PutFileEntryConflictException(e) => e.request_id(),
            Self::ReactionLimitExceededException(e) => e.request_id(),
            Self::ReactionValueRequiredException(e) => e.request_id(),
            Self::ReferenceDoesNotExistException(e) => e.request_id(),
            Self::ReferenceNameRequiredException(e) => e.request_id(),
            Self::ReferenceTypeNotSupportedException(e) => e.request_id(),
            Self::ReplacementContentRequiredException(e) => e.request_id(),
            Self::ReplacementTypeRequiredException(e) => e.request_id(),
            Self::RepositoryDoesNotExistException(e) => e.request_id(),
            Self::RepositoryLimitExceededException(e) => e.request_id(),
            Self::RepositoryNameExistsException(e) => e.request_id(),
            Self::RepositoryNameRequiredException(e) => e.request_id(),
            Self::RepositoryNamesRequiredException(e) => e.request_id(),
            Self::RepositoryNotAssociatedWithPullRequestException(e) => e.request_id(),
            Self::RepositoryTriggerBranchNameListRequiredException(e) => e.request_id(),
            Self::RepositoryTriggerDestinationArnRequiredException(e) => e.request_id(),
            Self::RepositoryTriggerEventsListRequiredException(e) => e.request_id(),
            Self::RepositoryTriggerNameRequiredException(e) => e.request_id(),
            Self::RepositoryTriggersListRequiredException(e) => e.request_id(),
            Self::ResourceArnRequiredException(e) => e.request_id(),
            Self::RestrictedSourceFileException(e) => e.request_id(),
            Self::RevisionIdRequiredException(e) => e.request_id(),
            Self::RevisionNotCurrentException(e) => e.request_id(),
            Self::SameFileContentException(e) => e.request_id(),
            Self::SamePathRequestException(e) => e.request_id(),
            Self::SourceAndDestinationAreSameException(e) => e.request_id(),
            Self::SourceFileOrContentRequiredException(e) => e.request_id(),
            Self::TagKeysListRequiredException(e) => e.request_id(),
            Self::TagPolicyException(e) => e.request_id(),
            Self::TagsMapRequiredException(e) => e.request_id(),
            Self::TargetRequiredException(e) => e.request_id(),
            Self::TargetsRequiredException(e) => e.request_id(),
            Self::TipOfSourceReferenceIsDifferentException(e) => e.request_id(),
            Self::TipsDivergenceExceededException(e) => e.request_id(),
            Self::TitleRequiredException(e) => e.request_id(),
            Self::TooManyTagsException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}

