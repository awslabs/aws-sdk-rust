// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// All possible error types for this service.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum Error {
    /// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
    ActorDoesNotExistException(crate::types::error::ActorDoesNotExistException),
    /// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
    ApprovalRuleContentRequiredException(crate::types::error::ApprovalRuleContentRequiredException),
    /// <p>The specified approval rule does not exist.</p>
    ApprovalRuleDoesNotExistException(crate::types::error::ApprovalRuleDoesNotExistException),
    /// <p>An approval rule with that name already exists. Approval rule names must be unique within the scope of a pull request.</p>
    ApprovalRuleNameAlreadyExistsException(
        crate::types::error::ApprovalRuleNameAlreadyExistsException,
    ),
    /// <p>An approval rule name is required, but was not specified.</p>
    ApprovalRuleNameRequiredException(crate::types::error::ApprovalRuleNameRequiredException),
    /// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
    ApprovalRuleTemplateContentRequiredException(
        crate::types::error::ApprovalRuleTemplateContentRequiredException,
    ),
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::types::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove all associations, and then try again.</p>
    ApprovalRuleTemplateInUseException(crate::types::error::ApprovalRuleTemplateInUseException),
    /// <p>You cannot create an approval rule template with that name because a template with that name already exists in this AWS Region for your AWS account. Approval rule template names must be unique.</p>
    ApprovalRuleTemplateNameAlreadyExistsException(
        crate::types::error::ApprovalRuleTemplateNameAlreadyExistsException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::types::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An approval state is required, but was not specified.</p>
    ApprovalStateRequiredException(crate::types::error::ApprovalStateRequiredException),
    /// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
    AuthorDoesNotExistException(crate::types::error::AuthorDoesNotExistException),
    /// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
    BeforeCommitIdAndAfterCommitIdAreSameException(
        crate::types::error::BeforeCommitIdAndAfterCommitIdAreSameException,
    ),
    /// <p>The specified blob does not exist.</p>
    BlobIdDoesNotExistException(crate::types::error::BlobIdDoesNotExistException),
    /// <p>A blob ID is required, but was not specified.</p>
    BlobIdRequiredException(crate::types::error::BlobIdRequiredException),
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::types::error::BranchDoesNotExistException),
    /// <p>Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name. Branch names must be unique.</p>
    BranchNameExistsException(crate::types::error::BranchNameExistsException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::types::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::types::error::BranchNameRequiredException),
    /// <p>The approval rule cannot be deleted from the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
    CannotDeleteApprovalRuleFromTemplateException(
        crate::types::error::CannotDeleteApprovalRuleFromTemplateException,
    ),
    /// <p>The approval rule cannot be modified for the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
    CannotModifyApprovalRuleFromTemplateException(
        crate::types::error::CannotModifyApprovalRuleFromTemplateException,
    ),
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::types::error::ClientRequestTokenRequiredException),
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::types::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(
        crate::types::error::CommentContentSizeLimitExceededException,
    ),
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::types::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::types::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::types::error::CommentIdRequiredException),
    /// <p>You cannot modify or delete this comment. Only comment authors can modify or delete their comments.</p>
    CommentNotCreatedByCallerException(crate::types::error::CommentNotCreatedByCallerException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::types::error::CommitDoesNotExistException),
    /// <p>The specified commit ID does not exist.</p>
    CommitIdDoesNotExistException(crate::types::error::CommitIdDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::types::error::CommitIdRequiredException),
    /// <p>The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.</p>
    CommitIdsLimitExceededException(crate::types::error::CommitIdsLimitExceededException),
    /// <p>A list of commit IDs is required, but was either not specified or the list was empty.</p>
    CommitIdsListRequiredException(crate::types::error::CommitIdsListRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::types::error::CommitMessageLengthExceededException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::types::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::types::error::ConcurrentReferenceUpdateException),
    /// <p>The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.</p>
    DefaultBranchCannotBeDeletedException(
        crate::types::error::DefaultBranchCannotBeDeletedException,
    ),
    /// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
    DirectoryNameConflictsWithFileNameException(
        crate::types::error::DirectoryNameConflictsWithFileNameException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::types::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::types::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::types::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::types::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::types::error::EncryptionKeyUnavailableException),
    /// <p>The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.</p>
    FileContentAndSourceFileSpecifiedException(
        crate::types::error::FileContentAndSourceFileSpecifiedException,
    ),
    /// <p>The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.</p>
    FileContentRequiredException(crate::types::error::FileContentRequiredException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(
        crate::types::error::FileContentSizeLimitExceededException,
    ),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::types::error::FileDoesNotExistException),
    /// <p>The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.</p>
    FileEntryRequiredException(crate::types::error::FileEntryRequiredException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::types::error::FileModeRequiredException),
    /// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
    FileNameConflictsWithDirectoryNameException(
        crate::types::error::FileNameConflictsWithDirectoryNameException,
    ),
    /// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
    FilePathConflictsWithSubmodulePathException(
        crate::types::error::FilePathConflictsWithSubmodulePathException,
    ),
    /// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    FileTooLargeException(crate::types::error::FileTooLargeException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(
        crate::types::error::FolderContentSizeLimitExceededException,
    ),
    /// <p>The specified folder does not exist. Either the folder name is not correct, or you did not enter the full path to the folder.</p>
    FolderDoesNotExistException(crate::types::error::FolderDoesNotExistException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(
        crate::types::error::IdempotencyParameterMismatchException,
    ),
    /// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request, and then try again.</p>
    InvalidActorArnException(crate::types::error::InvalidActorArnException),
    /// <p>The content for the approval rule is not valid.</p>
    InvalidApprovalRuleContentException(crate::types::error::InvalidApprovalRuleContentException),
    /// <p>The name for the approval rule is not valid.</p>
    InvalidApprovalRuleNameException(crate::types::error::InvalidApprovalRuleNameException),
    /// <p>The content of the approval rule template is not valid.</p>
    InvalidApprovalRuleTemplateContentException(
        crate::types::error::InvalidApprovalRuleTemplateContentException,
    ),
    /// <p>The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateDescriptionException(
        crate::types::error::InvalidApprovalRuleTemplateDescriptionException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::types::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The state for the approval is not valid. Valid values include APPROVE and REVOKE. </p>
    InvalidApprovalStateException(crate::types::error::InvalidApprovalStateException),
    /// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.</p>
    InvalidAuthorArnException(crate::types::error::InvalidAuthorArnException),
    /// <p>The specified blob is not valid.</p>
    InvalidBlobIdException(crate::types::error::InvalidBlobIdException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::types::error::InvalidBranchNameException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::types::error::InvalidClientRequestTokenException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::types::error::InvalidCommentIdException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::types::error::InvalidCommitException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::types::error::InvalidCommitIdException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::types::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::types::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::types::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::types::error::InvalidContinuationTokenException),
    /// <p>The specified deletion parameter is not valid.</p>
    InvalidDeletionParameterException(crate::types::error::InvalidDeletionParameterException),
    /// <p>The pull request description is not valid. Descriptions cannot be more than 1,000 characters.</p>
    InvalidDescriptionException(crate::types::error::InvalidDescriptionException),
    /// <p>The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID. </p>
    InvalidDestinationCommitSpecifierException(
        crate::types::error::InvalidDestinationCommitSpecifierException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::types::error::InvalidEmailException),
    /// <p>The location of the file is not valid. Make sure that you include the file name and extension.</p>
    InvalidFileLocationException(crate::types::error::InvalidFileLocationException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::types::error::InvalidFileModeException),
    /// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
    InvalidFilePositionException(crate::types::error::InvalidFilePositionException),
    /// <p>The specified value for the number of conflict files to return is not valid.</p>
    InvalidMaxConflictFilesException(crate::types::error::InvalidMaxConflictFilesException),
    /// <p>The specified value for the number of merge hunks to return is not valid.</p>
    InvalidMaxMergeHunksException(crate::types::error::InvalidMaxMergeHunksException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::types::error::InvalidMaxResultsException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::types::error::InvalidMergeOptionException),
    /// <p>The specified sort order is not valid.</p>
    InvalidOrderException(crate::types::error::InvalidOrderException),
    /// <p>The override status is not valid. Valid statuses are OVERRIDE and REVOKE.</p>
    InvalidOverrideStatusException(crate::types::error::InvalidOverrideStatusException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::types::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::types::error::InvalidPathException),
    /// <p>The pull request event type is not valid. </p>
    InvalidPullRequestEventTypeException(crate::types::error::InvalidPullRequestEventTypeException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::types::error::InvalidPullRequestIdException),
    /// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
    InvalidPullRequestStatusException(crate::types::error::InvalidPullRequestStatusException),
    /// <p>The pull request status update is not valid. The only valid update is from <code>OPEN</code> to <code>CLOSED</code>.</p>
    InvalidPullRequestStatusUpdateException(
        crate::types::error::InvalidPullRequestStatusUpdateException,
    ),
    /// <p>The Amazon Resource Name (ARN) of the user or identity is not valid.</p>
    InvalidReactionUserArnException(crate::types::error::InvalidReactionUserArnException),
    /// <p>The value of the reaction is not valid. For more information, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit User Guide</a>.</p>
    InvalidReactionValueException(crate::types::error::InvalidReactionValueException),
    /// <p>The specified reference name format is not valid. Reference names must conform to the Git references format (for example, refs/heads/master). For more information, see <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">Git Internals - Git References</a> or consult your Git documentation.</p>
    InvalidReferenceNameException(crate::types::error::InvalidReferenceNameException),
    /// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
    InvalidRelativeFileVersionEnumException(
        crate::types::error::InvalidRelativeFileVersionEnumException,
    ),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::types::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::types::error::InvalidReplacementTypeException),
    /// <p>The specified repository description is not valid.</p>
    InvalidRepositoryDescriptionException(
        crate::types::error::InvalidRepositoryDescriptionException,
    ),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::types::error::InvalidRepositoryNameException),
    /// <p>One or more branch names specified for the trigger is not valid.</p>
    InvalidRepositoryTriggerBranchNameException(
        crate::types::error::InvalidRepositoryTriggerBranchNameException,
    ),
    /// <p>The custom data provided for the trigger is not valid.</p>
    InvalidRepositoryTriggerCustomDataException(
        crate::types::error::InvalidRepositoryTriggerCustomDataException,
    ),
    /// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
    InvalidRepositoryTriggerDestinationArnException(
        crate::types::error::InvalidRepositoryTriggerDestinationArnException,
    ),
    /// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
    InvalidRepositoryTriggerEventsException(
        crate::types::error::InvalidRepositoryTriggerEventsException,
    ),
    /// <p>The name of the trigger is not valid.</p>
    InvalidRepositoryTriggerNameException(
        crate::types::error::InvalidRepositoryTriggerNameException,
    ),
    /// <p>The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.</p>
    InvalidRepositoryTriggerRegionException(
        crate::types::error::InvalidRepositoryTriggerRegionException,
    ),
    /// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    InvalidResourceArnException(crate::types::error::InvalidResourceArnException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::types::error::InvalidRevisionIdException),
    /// <p>The SHA-256 hash signature for the rule content is not valid.</p>
    InvalidRuleContentSha256Exception(crate::types::error::InvalidRuleContentSha256Exception),
    /// <p>The specified sort by value is not valid.</p>
    InvalidSortByException(crate::types::error::InvalidSortByException),
    /// <p>The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.</p>
    InvalidSourceCommitSpecifierException(
        crate::types::error::InvalidSourceCommitSpecifierException,
    ),
    /// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
    InvalidSystemTagUsageException(crate::types::error::InvalidSystemTagUsageException),
    /// <p>The list of tags is not valid.</p>
    InvalidTagKeysListException(crate::types::error::InvalidTagKeysListException),
    /// <p>The map of tags is not valid.</p>
    InvalidTagsMapException(crate::types::error::InvalidTagsMapException),
    /// <p>The specified target branch is not valid.</p>
    InvalidTargetBranchException(crate::types::error::InvalidTargetBranchException),
    /// <p>The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
    InvalidTargetException(crate::types::error::InvalidTargetException),
    /// <p>The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for the repository name, source branch, and destination branch for a pull request.</p>
    InvalidTargetsException(crate::types::error::InvalidTargetsException),
    /// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
    InvalidTitleException(crate::types::error::InvalidTitleException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::types::error::ManualMergeRequiredException),
    /// <p>The number of branches for the trigger was exceeded.</p>
    MaximumBranchesExceededException(crate::types::error::MaximumBranchesExceededException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::types::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::types::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.</p>
    MaximumFileEntriesExceededException(crate::types::error::MaximumFileEntriesExceededException),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(
        crate::types::error::MaximumItemsToCompareExceededException,
    ),
    /// <p>The number of approvals required for the approval rule exceeds the maximum number allowed.</p>
    MaximumNumberOfApprovalsExceededException(
        crate::types::error::MaximumNumberOfApprovalsExceededException,
    ),
    /// <p>You cannot create the pull request because the repository has too many open pull requests. The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.</p>
    MaximumOpenPullRequestsExceededException(
        crate::types::error::MaximumOpenPullRequestsExceededException,
    ),
    /// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
    MaximumRepositoryNamesExceededException(
        crate::types::error::MaximumRepositoryNamesExceededException,
    ),
    /// <p>The number of triggers allowed for the repository was exceeded.</p>
    MaximumRepositoryTriggersExceededException(
        crate::types::error::MaximumRepositoryTriggersExceededException,
    ),
    /// <p>The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25 approval rule templates with a repository.</p>
    MaximumRuleTemplatesAssociatedWithRepositoryException(
        crate::types::error::MaximumRuleTemplatesAssociatedWithRepositoryException,
    ),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::types::error::MergeOptionRequiredException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::types::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.</p>
    MultipleRepositoriesInPullRequestException(
        crate::types::error::MultipleRepositoriesInPullRequestException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::types::error::NameLengthExceededException),
    /// <p>The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.</p>
    NoChangeException(crate::types::error::NoChangeException),
    /// <p>The maximum number of approval rule templates has been exceeded for this AWS Region. </p>
    NumberOfRuleTemplatesExceededException(
        crate::types::error::NumberOfRuleTemplatesExceededException,
    ),
    /// <p>The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.</p>
    NumberOfRulesExceededException(crate::types::error::NumberOfRulesExceededException),
    /// <p>The pull request has already had its approval rules set to override.</p>
    OverrideAlreadySetException(crate::types::error::OverrideAlreadySetException),
    /// <p>An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.</p>
    OverrideStatusRequiredException(crate::types::error::OverrideStatusRequiredException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::types::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::types::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::types::error::ParentCommitIdRequiredException),
    /// <p>The specified path does not exist.</p>
    PathDoesNotExistException(crate::types::error::PathDoesNotExistException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::types::error::PathRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::types::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(
        crate::types::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    /// <p>The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull request that you created.</p>
    PullRequestCannotBeApprovedByAuthorException(
        crate::types::error::PullRequestCannotBeApprovedByAuthorException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::types::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::types::error::PullRequestIdRequiredException),
    /// <p>A pull request status is required, but none was provided.</p>
    PullRequestStatusRequiredException(crate::types::error::PullRequestStatusRequiredException),
    /// <p>The commit cannot be created because one or more files specified in the commit reference both a file and a folder.</p>
    PutFileEntryConflictException(crate::types::error::PutFileEntryConflictException),
    /// <p>The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.</p>
    ReactionLimitExceededException(crate::types::error::ReactionLimitExceededException),
    /// <p>A reaction value is required. </p>
    ReactionValueRequiredException(crate::types::error::ReactionValueRequiredException),
    /// <p>The specified reference does not exist. You must provide a full commit ID.</p>
    ReferenceDoesNotExistException(crate::types::error::ReferenceDoesNotExistException),
    /// <p>A reference name is required, but none was provided.</p>
    ReferenceNameRequiredException(crate::types::error::ReferenceNameRequiredException),
    /// <p>The specified reference is not a supported type. </p>
    ReferenceTypeNotSupportedException(crate::types::error::ReferenceTypeNotSupportedException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::types::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::types::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::types::error::RepositoryDoesNotExistException),
    /// <p>A repository resource limit was exceeded.</p>
    RepositoryLimitExceededException(crate::types::error::RepositoryLimitExceededException),
    /// <p>The specified repository name already exists.</p>
    RepositoryNameExistsException(crate::types::error::RepositoryNameExistsException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::types::error::RepositoryNameRequiredException),
    /// <p>At least one repository name object is required, but was not specified.</p>
    RepositoryNamesRequiredException(crate::types::error::RepositoryNamesRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::types::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
    RepositoryTriggerBranchNameListRequiredException(
        crate::types::error::RepositoryTriggerBranchNameListRequiredException,
    ),
    /// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
    RepositoryTriggerDestinationArnRequiredException(
        crate::types::error::RepositoryTriggerDestinationArnRequiredException,
    ),
    /// <p>At least one event for the trigger is required, but was not specified.</p>
    RepositoryTriggerEventsListRequiredException(
        crate::types::error::RepositoryTriggerEventsListRequiredException,
    ),
    /// <p>A name for the trigger is required, but was not specified.</p>
    RepositoryTriggerNameRequiredException(
        crate::types::error::RepositoryTriggerNameRequiredException,
    ),
    /// <p>The list of triggers for the repository is required, but was not specified.</p>
    RepositoryTriggersListRequiredException(
        crate::types::error::RepositoryTriggersListRequiredException,
    ),
    /// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    ResourceArnRequiredException(crate::types::error::ResourceArnRequiredException),
    /// <p>The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.</p>
    RestrictedSourceFileException(crate::types::error::RestrictedSourceFileException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::types::error::RevisionIdRequiredException),
    /// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
    RevisionNotCurrentException(crate::types::error::RevisionNotCurrentException),
    /// <p>The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.</p>
    SameFileContentException(crate::types::error::SameFileContentException),
    /// <p>The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.</p>
    SamePathRequestException(crate::types::error::SamePathRequestException),
    /// <p>The source branch and destination branch for the pull request are the same. You must specify different branches for the source and destination.</p>
    SourceAndDestinationAreSameException(crate::types::error::SourceAndDestinationAreSameException),
    /// <p>The commit cannot be created because no source files or file content have been specified for the commit.</p>
    SourceFileOrContentRequiredException(crate::types::error::SourceFileOrContentRequiredException),
    /// <p>A list of tag keys is required. The list cannot be empty or null.</p>
    TagKeysListRequiredException(crate::types::error::TagKeysListRequiredException),
    /// <p>The tag policy is not valid.</p>
    TagPolicyException(crate::types::error::TagPolicyException),
    /// <p>A map of tags is required.</p>
    TagsMapRequiredException(crate::types::error::TagsMapRequiredException),
    /// <p>A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
    TargetRequiredException(crate::types::error::TargetRequiredException),
    /// <p>An array of target objects is required. It cannot be empty or null.</p>
    TargetsRequiredException(crate::types::error::TargetsRequiredException),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(
        crate::types::error::TipOfSourceReferenceIsDifferentException,
    ),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::types::error::TipsDivergenceExceededException),
    /// <p>A pull request title is required. It cannot be empty or null.</p>
    TitleRequiredException(crate::types::error::TitleRequiredException),
    /// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
    TooManyTagsException(crate::types::error::TooManyTagsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Error::ActorDoesNotExistException(inner) => inner.fmt(f),
            Error::ApprovalRuleContentRequiredException(inner) => inner.fmt(f),
            Error::ApprovalRuleDoesNotExistException(inner) => inner.fmt(f),
            Error::ApprovalRuleNameAlreadyExistsException(inner) => inner.fmt(f),
            Error::ApprovalRuleNameRequiredException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateContentRequiredException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateDoesNotExistException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateInUseException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateNameAlreadyExistsException(inner) => inner.fmt(f),
            Error::ApprovalRuleTemplateNameRequiredException(inner) => inner.fmt(f),
            Error::ApprovalStateRequiredException(inner) => inner.fmt(f),
            Error::AuthorDoesNotExistException(inner) => inner.fmt(f),
            Error::BeforeCommitIdAndAfterCommitIdAreSameException(inner) => inner.fmt(f),
            Error::BlobIdDoesNotExistException(inner) => inner.fmt(f),
            Error::BlobIdRequiredException(inner) => inner.fmt(f),
            Error::BranchDoesNotExistException(inner) => inner.fmt(f),
            Error::BranchNameExistsException(inner) => inner.fmt(f),
            Error::BranchNameIsTagNameException(inner) => inner.fmt(f),
            Error::BranchNameRequiredException(inner) => inner.fmt(f),
            Error::CannotDeleteApprovalRuleFromTemplateException(inner) => inner.fmt(f),
            Error::CannotModifyApprovalRuleFromTemplateException(inner) => inner.fmt(f),
            Error::ClientRequestTokenRequiredException(inner) => inner.fmt(f),
            Error::CommentContentRequiredException(inner) => inner.fmt(f),
            Error::CommentContentSizeLimitExceededException(inner) => inner.fmt(f),
            Error::CommentDeletedException(inner) => inner.fmt(f),
            Error::CommentDoesNotExistException(inner) => inner.fmt(f),
            Error::CommentIdRequiredException(inner) => inner.fmt(f),
            Error::CommentNotCreatedByCallerException(inner) => inner.fmt(f),
            Error::CommitDoesNotExistException(inner) => inner.fmt(f),
            Error::CommitIdDoesNotExistException(inner) => inner.fmt(f),
            Error::CommitIdRequiredException(inner) => inner.fmt(f),
            Error::CommitIdsLimitExceededException(inner) => inner.fmt(f),
            Error::CommitIdsListRequiredException(inner) => inner.fmt(f),
            Error::CommitMessageLengthExceededException(inner) => inner.fmt(f),
            Error::CommitRequiredException(inner) => inner.fmt(f),
            Error::ConcurrentReferenceUpdateException(inner) => inner.fmt(f),
            Error::DefaultBranchCannotBeDeletedException(inner) => inner.fmt(f),
            Error::DirectoryNameConflictsWithFileNameException(inner) => inner.fmt(f),
            Error::EncryptionIntegrityChecksFailedException(inner) => inner.fmt(f),
            Error::EncryptionKeyAccessDeniedException(inner) => inner.fmt(f),
            Error::EncryptionKeyDisabledException(inner) => inner.fmt(f),
            Error::EncryptionKeyNotFoundException(inner) => inner.fmt(f),
            Error::EncryptionKeyUnavailableException(inner) => inner.fmt(f),
            Error::FileContentAndSourceFileSpecifiedException(inner) => inner.fmt(f),
            Error::FileContentRequiredException(inner) => inner.fmt(f),
            Error::FileContentSizeLimitExceededException(inner) => inner.fmt(f),
            Error::FileDoesNotExistException(inner) => inner.fmt(f),
            Error::FileEntryRequiredException(inner) => inner.fmt(f),
            Error::FileModeRequiredException(inner) => inner.fmt(f),
            Error::FileNameConflictsWithDirectoryNameException(inner) => inner.fmt(f),
            Error::FilePathConflictsWithSubmodulePathException(inner) => inner.fmt(f),
            Error::FileTooLargeException(inner) => inner.fmt(f),
            Error::FolderContentSizeLimitExceededException(inner) => inner.fmt(f),
            Error::FolderDoesNotExistException(inner) => inner.fmt(f),
            Error::IdempotencyParameterMismatchException(inner) => inner.fmt(f),
            Error::InvalidActorArnException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleContentException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleNameException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleTemplateContentException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleTemplateDescriptionException(inner) => inner.fmt(f),
            Error::InvalidApprovalRuleTemplateNameException(inner) => inner.fmt(f),
            Error::InvalidApprovalStateException(inner) => inner.fmt(f),
            Error::InvalidAuthorArnException(inner) => inner.fmt(f),
            Error::InvalidBlobIdException(inner) => inner.fmt(f),
            Error::InvalidBranchNameException(inner) => inner.fmt(f),
            Error::InvalidClientRequestTokenException(inner) => inner.fmt(f),
            Error::InvalidCommentIdException(inner) => inner.fmt(f),
            Error::InvalidCommitException(inner) => inner.fmt(f),
            Error::InvalidCommitIdException(inner) => inner.fmt(f),
            Error::InvalidConflictDetailLevelException(inner) => inner.fmt(f),
            Error::InvalidConflictResolutionException(inner) => inner.fmt(f),
            Error::InvalidConflictResolutionStrategyException(inner) => inner.fmt(f),
            Error::InvalidContinuationTokenException(inner) => inner.fmt(f),
            Error::InvalidDeletionParameterException(inner) => inner.fmt(f),
            Error::InvalidDescriptionException(inner) => inner.fmt(f),
            Error::InvalidDestinationCommitSpecifierException(inner) => inner.fmt(f),
            Error::InvalidEmailException(inner) => inner.fmt(f),
            Error::InvalidFileLocationException(inner) => inner.fmt(f),
            Error::InvalidFileModeException(inner) => inner.fmt(f),
            Error::InvalidFilePositionException(inner) => inner.fmt(f),
            Error::InvalidMaxConflictFilesException(inner) => inner.fmt(f),
            Error::InvalidMaxMergeHunksException(inner) => inner.fmt(f),
            Error::InvalidMaxResultsException(inner) => inner.fmt(f),
            Error::InvalidMergeOptionException(inner) => inner.fmt(f),
            Error::InvalidOrderException(inner) => inner.fmt(f),
            Error::InvalidOverrideStatusException(inner) => inner.fmt(f),
            Error::InvalidParentCommitIdException(inner) => inner.fmt(f),
            Error::InvalidPathException(inner) => inner.fmt(f),
            Error::InvalidPullRequestEventTypeException(inner) => inner.fmt(f),
            Error::InvalidPullRequestIdException(inner) => inner.fmt(f),
            Error::InvalidPullRequestStatusException(inner) => inner.fmt(f),
            Error::InvalidPullRequestStatusUpdateException(inner) => inner.fmt(f),
            Error::InvalidReactionUserArnException(inner) => inner.fmt(f),
            Error::InvalidReactionValueException(inner) => inner.fmt(f),
            Error::InvalidReferenceNameException(inner) => inner.fmt(f),
            Error::InvalidRelativeFileVersionEnumException(inner) => inner.fmt(f),
            Error::InvalidReplacementContentException(inner) => inner.fmt(f),
            Error::InvalidReplacementTypeException(inner) => inner.fmt(f),
            Error::InvalidRepositoryDescriptionException(inner) => inner.fmt(f),
            Error::InvalidRepositoryNameException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerBranchNameException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerCustomDataException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerDestinationArnException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerEventsException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerNameException(inner) => inner.fmt(f),
            Error::InvalidRepositoryTriggerRegionException(inner) => inner.fmt(f),
            Error::InvalidResourceArnException(inner) => inner.fmt(f),
            Error::InvalidRevisionIdException(inner) => inner.fmt(f),
            Error::InvalidRuleContentSha256Exception(inner) => inner.fmt(f),
            Error::InvalidSortByException(inner) => inner.fmt(f),
            Error::InvalidSourceCommitSpecifierException(inner) => inner.fmt(f),
            Error::InvalidSystemTagUsageException(inner) => inner.fmt(f),
            Error::InvalidTagKeysListException(inner) => inner.fmt(f),
            Error::InvalidTagsMapException(inner) => inner.fmt(f),
            Error::InvalidTargetBranchException(inner) => inner.fmt(f),
            Error::InvalidTargetException(inner) => inner.fmt(f),
            Error::InvalidTargetsException(inner) => inner.fmt(f),
            Error::InvalidTitleException(inner) => inner.fmt(f),
            Error::ManualMergeRequiredException(inner) => inner.fmt(f),
            Error::MaximumBranchesExceededException(inner) => inner.fmt(f),
            Error::MaximumConflictResolutionEntriesExceededException(inner) => inner.fmt(f),
            Error::MaximumFileContentToLoadExceededException(inner) => inner.fmt(f),
            Error::MaximumFileEntriesExceededException(inner) => inner.fmt(f),
            Error::MaximumItemsToCompareExceededException(inner) => inner.fmt(f),
            Error::MaximumNumberOfApprovalsExceededException(inner) => inner.fmt(f),
            Error::MaximumOpenPullRequestsExceededException(inner) => inner.fmt(f),
            Error::MaximumRepositoryNamesExceededException(inner) => inner.fmt(f),
            Error::MaximumRepositoryTriggersExceededException(inner) => inner.fmt(f),
            Error::MaximumRuleTemplatesAssociatedWithRepositoryException(inner) => inner.fmt(f),
            Error::MergeOptionRequiredException(inner) => inner.fmt(f),
            Error::MultipleConflictResolutionEntriesException(inner) => inner.fmt(f),
            Error::MultipleRepositoriesInPullRequestException(inner) => inner.fmt(f),
            Error::NameLengthExceededException(inner) => inner.fmt(f),
            Error::NoChangeException(inner) => inner.fmt(f),
            Error::NumberOfRuleTemplatesExceededException(inner) => inner.fmt(f),
            Error::NumberOfRulesExceededException(inner) => inner.fmt(f),
            Error::OverrideAlreadySetException(inner) => inner.fmt(f),
            Error::OverrideStatusRequiredException(inner) => inner.fmt(f),
            Error::ParentCommitDoesNotExistException(inner) => inner.fmt(f),
            Error::ParentCommitIdOutdatedException(inner) => inner.fmt(f),
            Error::ParentCommitIdRequiredException(inner) => inner.fmt(f),
            Error::PathDoesNotExistException(inner) => inner.fmt(f),
            Error::PathRequiredException(inner) => inner.fmt(f),
            Error::PullRequestAlreadyClosedException(inner) => inner.fmt(f),
            Error::PullRequestApprovalRulesNotSatisfiedException(inner) => inner.fmt(f),
            Error::PullRequestCannotBeApprovedByAuthorException(inner) => inner.fmt(f),
            Error::PullRequestDoesNotExistException(inner) => inner.fmt(f),
            Error::PullRequestIdRequiredException(inner) => inner.fmt(f),
            Error::PullRequestStatusRequiredException(inner) => inner.fmt(f),
            Error::PutFileEntryConflictException(inner) => inner.fmt(f),
            Error::ReactionLimitExceededException(inner) => inner.fmt(f),
            Error::ReactionValueRequiredException(inner) => inner.fmt(f),
            Error::ReferenceDoesNotExistException(inner) => inner.fmt(f),
            Error::ReferenceNameRequiredException(inner) => inner.fmt(f),
            Error::ReferenceTypeNotSupportedException(inner) => inner.fmt(f),
            Error::ReplacementContentRequiredException(inner) => inner.fmt(f),
            Error::ReplacementTypeRequiredException(inner) => inner.fmt(f),
            Error::RepositoryDoesNotExistException(inner) => inner.fmt(f),
            Error::RepositoryLimitExceededException(inner) => inner.fmt(f),
            Error::RepositoryNameExistsException(inner) => inner.fmt(f),
            Error::RepositoryNameRequiredException(inner) => inner.fmt(f),
            Error::RepositoryNamesRequiredException(inner) => inner.fmt(f),
            Error::RepositoryNotAssociatedWithPullRequestException(inner) => inner.fmt(f),
            Error::RepositoryTriggerBranchNameListRequiredException(inner) => inner.fmt(f),
            Error::RepositoryTriggerDestinationArnRequiredException(inner) => inner.fmt(f),
            Error::RepositoryTriggerEventsListRequiredException(inner) => inner.fmt(f),
            Error::RepositoryTriggerNameRequiredException(inner) => inner.fmt(f),
            Error::RepositoryTriggersListRequiredException(inner) => inner.fmt(f),
            Error::ResourceArnRequiredException(inner) => inner.fmt(f),
            Error::RestrictedSourceFileException(inner) => inner.fmt(f),
            Error::RevisionIdRequiredException(inner) => inner.fmt(f),
            Error::RevisionNotCurrentException(inner) => inner.fmt(f),
            Error::SameFileContentException(inner) => inner.fmt(f),
            Error::SamePathRequestException(inner) => inner.fmt(f),
            Error::SourceAndDestinationAreSameException(inner) => inner.fmt(f),
            Error::SourceFileOrContentRequiredException(inner) => inner.fmt(f),
            Error::TagKeysListRequiredException(inner) => inner.fmt(f),
            Error::TagPolicyException(inner) => inner.fmt(f),
            Error::TagsMapRequiredException(inner) => inner.fmt(f),
            Error::TargetRequiredException(inner) => inner.fmt(f),
            Error::TargetsRequiredException(inner) => inner.fmt(f),
            Error::TipOfSourceReferenceIsDifferentException(inner) => inner.fmt(f),
            Error::TipsDivergenceExceededException(inner) => inner.fmt(f),
            Error::TitleRequiredException(inner) => inner.fmt(f),
            Error::TooManyTagsException(inner) => inner.fmt(f),
            Error::Unhandled(inner) => inner.fmt(f),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError> for Error {
    fn from(err: crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError) -> Self {
        match err {
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::MaximumRuleTemplatesAssociatedWithRepositoryException(inner) => Error::MaximumRuleTemplatesAssociatedWithRepositoryException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::associate_approval_rule_template_with_repository::AssociateApprovalRuleTemplateWithRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError> for Error {
    fn from(err: crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError) -> Self {
        match err {
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::MaximumRepositoryNamesExceededException(inner) => Error::MaximumRepositoryNamesExceededException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::RepositoryNamesRequiredException(inner) => Error::RepositoryNamesRequiredException(inner),
            crate::operation::batch_associate_approval_rule_template_with_repositories::BatchAssociateApprovalRuleTemplateWithRepositoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError>
    for Error
{
    fn from(
        err: crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError,
    ) -> Self {
        match err {
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::InvalidMaxConflictFilesException(inner) => Error::InvalidMaxConflictFilesException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::InvalidMaxMergeHunksException(inner) => Error::InvalidMaxMergeHunksException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::InvalidMergeOptionException(inner) => Error::InvalidMergeOptionException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::MergeOptionRequiredException(inner) => Error::MergeOptionRequiredException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::batch_describe_merge_conflicts::BatchDescribeMergeConflictsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError> for Error {
    fn from(err: crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError) -> Self {
        match err {
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::MaximumRepositoryNamesExceededException(inner) => Error::MaximumRepositoryNamesExceededException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::RepositoryNamesRequiredException(inner) => Error::RepositoryNamesRequiredException(inner),
            crate::operation::batch_disassociate_approval_rule_template_from_repositories::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::batch_get_commits::BatchGetCommitsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::batch_get_commits::BatchGetCommitsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::batch_get_commits::BatchGetCommitsError> for Error {
    fn from(err: crate::operation::batch_get_commits::BatchGetCommitsError) -> Self {
        match err {
            crate::operation::batch_get_commits::BatchGetCommitsError::CommitIdsLimitExceededException(inner) => Error::CommitIdsLimitExceededException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::CommitIdsListRequiredException(inner) => Error::CommitIdsListRequiredException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::batch_get_commits::BatchGetCommitsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::batch_get_repositories::BatchGetRepositoriesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::batch_get_repositories::BatchGetRepositoriesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::batch_get_repositories::BatchGetRepositoriesError> for Error {
    fn from(err: crate::operation::batch_get_repositories::BatchGetRepositoriesError) -> Self {
        match err {
            crate::operation::batch_get_repositories::BatchGetRepositoriesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::batch_get_repositories::BatchGetRepositoriesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::batch_get_repositories::BatchGetRepositoriesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::batch_get_repositories::BatchGetRepositoriesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::batch_get_repositories::BatchGetRepositoriesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::batch_get_repositories::BatchGetRepositoriesError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::batch_get_repositories::BatchGetRepositoriesError::MaximumRepositoryNamesExceededException(inner) => Error::MaximumRepositoryNamesExceededException(inner),
            crate::operation::batch_get_repositories::BatchGetRepositoriesError::RepositoryNamesRequiredException(inner) => Error::RepositoryNamesRequiredException(inner),
            crate::operation::batch_get_repositories::BatchGetRepositoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError>
    for Error
{
    fn from(
        err: crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError,
    ) -> Self {
        match err {
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError::ApprovalRuleTemplateContentRequiredException(inner) => Error::ApprovalRuleTemplateContentRequiredException(inner),
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError::ApprovalRuleTemplateNameAlreadyExistsException(inner) => Error::ApprovalRuleTemplateNameAlreadyExistsException(inner),
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateContentException(inner) => Error::InvalidApprovalRuleTemplateContentException(inner),
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateDescriptionException(inner) => Error::InvalidApprovalRuleTemplateDescriptionException(inner),
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError::NumberOfRuleTemplatesExceededException(inner) => Error::NumberOfRuleTemplatesExceededException(inner),
            crate::operation::create_approval_rule_template::CreateApprovalRuleTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::create_branch::CreateBranchError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_branch::CreateBranchError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_branch::CreateBranchError> for Error {
    fn from(err: crate::operation::create_branch::CreateBranchError) -> Self {
        match err {
            crate::operation::create_branch::CreateBranchError::BranchNameExistsException(inner) => Error::BranchNameExistsException(inner),
            crate::operation::create_branch::CreateBranchError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::create_branch::CreateBranchError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::create_branch::CreateBranchError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::operation::create_branch::CreateBranchError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::create_branch::CreateBranchError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::create_branch::CreateBranchError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::create_branch::CreateBranchError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::create_branch::CreateBranchError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::create_branch::CreateBranchError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::create_branch::CreateBranchError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::create_branch::CreateBranchError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::create_branch::CreateBranchError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::create_branch::CreateBranchError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::create_branch::CreateBranchError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::create_commit::CreateCommitError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_commit::CreateCommitError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_commit::CreateCommitError> for Error {
    fn from(err: crate::operation::create_commit::CreateCommitError) -> Self {
        match err {
            crate::operation::create_commit::CreateCommitError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::operation::create_commit::CreateCommitError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::operation::create_commit::CreateCommitError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::create_commit::CreateCommitError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::operation::create_commit::CreateCommitError::DirectoryNameConflictsWithFileNameException(inner) => Error::DirectoryNameConflictsWithFileNameException(inner),
            crate::operation::create_commit::CreateCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::create_commit::CreateCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::create_commit::CreateCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::create_commit::CreateCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::create_commit::CreateCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::create_commit::CreateCommitError::FileContentAndSourceFileSpecifiedException(inner) => Error::FileContentAndSourceFileSpecifiedException(inner),
            crate::operation::create_commit::CreateCommitError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::operation::create_commit::CreateCommitError::FileDoesNotExistException(inner) => Error::FileDoesNotExistException(inner),
            crate::operation::create_commit::CreateCommitError::FileEntryRequiredException(inner) => Error::FileEntryRequiredException(inner),
            crate::operation::create_commit::CreateCommitError::FileModeRequiredException(inner) => Error::FileModeRequiredException(inner),
            crate::operation::create_commit::CreateCommitError::FileNameConflictsWithDirectoryNameException(inner) => Error::FileNameConflictsWithDirectoryNameException(inner),
            crate::operation::create_commit::CreateCommitError::FilePathConflictsWithSubmodulePathException(inner) => Error::FilePathConflictsWithSubmodulePathException(inner),
            crate::operation::create_commit::CreateCommitError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::operation::create_commit::CreateCommitError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::create_commit::CreateCommitError::InvalidDeletionParameterException(inner) => Error::InvalidDeletionParameterException(inner),
            crate::operation::create_commit::CreateCommitError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::operation::create_commit::CreateCommitError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::operation::create_commit::CreateCommitError::InvalidParentCommitIdException(inner) => Error::InvalidParentCommitIdException(inner),
            crate::operation::create_commit::CreateCommitError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::create_commit::CreateCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::create_commit::CreateCommitError::MaximumFileEntriesExceededException(inner) => Error::MaximumFileEntriesExceededException(inner),
            crate::operation::create_commit::CreateCommitError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::operation::create_commit::CreateCommitError::NoChangeException(inner) => Error::NoChangeException(inner),
            crate::operation::create_commit::CreateCommitError::ParentCommitDoesNotExistException(inner) => Error::ParentCommitDoesNotExistException(inner),
            crate::operation::create_commit::CreateCommitError::ParentCommitIdOutdatedException(inner) => Error::ParentCommitIdOutdatedException(inner),
            crate::operation::create_commit::CreateCommitError::ParentCommitIdRequiredException(inner) => Error::ParentCommitIdRequiredException(inner),
            crate::operation::create_commit::CreateCommitError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::create_commit::CreateCommitError::PutFileEntryConflictException(inner) => Error::PutFileEntryConflictException(inner),
            crate::operation::create_commit::CreateCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::create_commit::CreateCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::create_commit::CreateCommitError::RestrictedSourceFileException(inner) => Error::RestrictedSourceFileException(inner),
            crate::operation::create_commit::CreateCommitError::SamePathRequestException(inner) => Error::SamePathRequestException(inner),
            crate::operation::create_commit::CreateCommitError::SourceFileOrContentRequiredException(inner) => Error::SourceFileOrContentRequiredException(inner),
            crate::operation::create_commit::CreateCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_pull_request::CreatePullRequestError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_pull_request::CreatePullRequestError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_pull_request::CreatePullRequestError> for Error {
    fn from(err: crate::operation::create_pull_request::CreatePullRequestError) -> Self {
        match err {
            crate::operation::create_pull_request::CreatePullRequestError::ClientRequestTokenRequiredException(inner) => Error::ClientRequestTokenRequiredException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::IdempotencyParameterMismatchException(inner) => Error::IdempotencyParameterMismatchException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::InvalidClientRequestTokenException(inner) => Error::InvalidClientRequestTokenException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::InvalidDescriptionException(inner) => Error::InvalidDescriptionException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::InvalidReferenceNameException(inner) => Error::InvalidReferenceNameException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::InvalidTargetException(inner) => Error::InvalidTargetException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::InvalidTargetsException(inner) => Error::InvalidTargetsException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::InvalidTitleException(inner) => Error::InvalidTitleException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::MaximumOpenPullRequestsExceededException(inner) => Error::MaximumOpenPullRequestsExceededException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::MultipleRepositoriesInPullRequestException(inner) => Error::MultipleRepositoriesInPullRequestException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::ReferenceDoesNotExistException(inner) => Error::ReferenceDoesNotExistException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::ReferenceNameRequiredException(inner) => Error::ReferenceNameRequiredException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::ReferenceTypeNotSupportedException(inner) => Error::ReferenceTypeNotSupportedException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::SourceAndDestinationAreSameException(inner) => Error::SourceAndDestinationAreSameException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::TargetRequiredException(inner) => Error::TargetRequiredException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::TargetsRequiredException(inner) => Error::TargetsRequiredException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::TitleRequiredException(inner) => Error::TitleRequiredException(inner),
            crate::operation::create_pull_request::CreatePullRequestError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError>
    for Error
{
    fn from(
        err: crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError,
    ) -> Self {
        match err {
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::ApprovalRuleContentRequiredException(inner) => Error::ApprovalRuleContentRequiredException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::ApprovalRuleNameAlreadyExistsException(inner) => Error::ApprovalRuleNameAlreadyExistsException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::ApprovalRuleNameRequiredException(inner) => Error::ApprovalRuleNameRequiredException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::InvalidApprovalRuleContentException(inner) => Error::InvalidApprovalRuleContentException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::InvalidApprovalRuleNameException(inner) => Error::InvalidApprovalRuleNameException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::NumberOfRulesExceededException(inner) => Error::NumberOfRulesExceededException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::create_pull_request_approval_rule::CreatePullRequestApprovalRuleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_repository::CreateRepositoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_repository::CreateRepositoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_repository::CreateRepositoryError> for Error {
    fn from(err: crate::operation::create_repository::CreateRepositoryError) -> Self {
        match err {
            crate::operation::create_repository::CreateRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::create_repository::CreateRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::create_repository::CreateRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::create_repository::CreateRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::create_repository::CreateRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::create_repository::CreateRepositoryError::InvalidRepositoryDescriptionException(inner) => Error::InvalidRepositoryDescriptionException(inner),
            crate::operation::create_repository::CreateRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::create_repository::CreateRepositoryError::InvalidSystemTagUsageException(inner) => Error::InvalidSystemTagUsageException(inner),
            crate::operation::create_repository::CreateRepositoryError::InvalidTagsMapException(inner) => Error::InvalidTagsMapException(inner),
            crate::operation::create_repository::CreateRepositoryError::RepositoryLimitExceededException(inner) => Error::RepositoryLimitExceededException(inner),
            crate::operation::create_repository::CreateRepositoryError::RepositoryNameExistsException(inner) => Error::RepositoryNameExistsException(inner),
            crate::operation::create_repository::CreateRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::create_repository::CreateRepositoryError::TagPolicyException(inner) => Error::TagPolicyException(inner),
            crate::operation::create_repository::CreateRepositoryError::TooManyTagsException(inner) => Error::TooManyTagsException(inner),
            crate::operation::create_repository::CreateRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError>
    for Error
{
    fn from(
        err: crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError,
    ) -> Self {
        match err {
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::FileModeRequiredException(inner) => Error::FileModeRequiredException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidMergeOptionException(inner) => Error::InvalidMergeOptionException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::MergeOptionRequiredException(inner) => Error::MergeOptionRequiredException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::create_unreferenced_merge_commit::CreateUnreferencedMergeCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_approval_rule_template::DeleteApprovalRuleTemplateError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_approval_rule_template::DeleteApprovalRuleTemplateError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_approval_rule_template::DeleteApprovalRuleTemplateError>
    for Error
{
    fn from(
        err: crate::operation::delete_approval_rule_template::DeleteApprovalRuleTemplateError,
    ) -> Self {
        match err {
            crate::operation::delete_approval_rule_template::DeleteApprovalRuleTemplateError::ApprovalRuleTemplateInUseException(inner) => Error::ApprovalRuleTemplateInUseException(inner),
            crate::operation::delete_approval_rule_template::DeleteApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::delete_approval_rule_template::DeleteApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::delete_approval_rule_template::DeleteApprovalRuleTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::delete_branch::DeleteBranchError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_branch::DeleteBranchError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_branch::DeleteBranchError> for Error {
    fn from(err: crate::operation::delete_branch::DeleteBranchError) -> Self {
        match err {
            crate::operation::delete_branch::DeleteBranchError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::delete_branch::DeleteBranchError::DefaultBranchCannotBeDeletedException(inner) => Error::DefaultBranchCannotBeDeletedException(inner),
            crate::operation::delete_branch::DeleteBranchError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::delete_branch::DeleteBranchError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::delete_branch::DeleteBranchError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::delete_branch::DeleteBranchError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::delete_branch::DeleteBranchError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::delete_branch::DeleteBranchError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::delete_branch::DeleteBranchError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::delete_branch::DeleteBranchError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::delete_branch::DeleteBranchError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::delete_branch::DeleteBranchError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_comment_content::DeleteCommentContentError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_comment_content::DeleteCommentContentError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_comment_content::DeleteCommentContentError> for Error {
    fn from(err: crate::operation::delete_comment_content::DeleteCommentContentError) -> Self {
        match err {
            crate::operation::delete_comment_content::DeleteCommentContentError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::operation::delete_comment_content::DeleteCommentContentError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::operation::delete_comment_content::DeleteCommentContentError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::operation::delete_comment_content::DeleteCommentContentError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::operation::delete_comment_content::DeleteCommentContentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::delete_file::DeleteFileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::delete_file::DeleteFileError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_file::DeleteFileError> for Error {
    fn from(err: crate::operation::delete_file::DeleteFileError) -> Self {
        match err {
            crate::operation::delete_file::DeleteFileError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::operation::delete_file::DeleteFileError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::operation::delete_file::DeleteFileError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::delete_file::DeleteFileError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::operation::delete_file::DeleteFileError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::delete_file::DeleteFileError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::delete_file::DeleteFileError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::delete_file::DeleteFileError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::delete_file::DeleteFileError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::delete_file::DeleteFileError::FileDoesNotExistException(inner) => Error::FileDoesNotExistException(inner),
            crate::operation::delete_file::DeleteFileError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::delete_file::DeleteFileError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::operation::delete_file::DeleteFileError::InvalidParentCommitIdException(inner) => Error::InvalidParentCommitIdException(inner),
            crate::operation::delete_file::DeleteFileError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::delete_file::DeleteFileError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::delete_file::DeleteFileError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::operation::delete_file::DeleteFileError::ParentCommitDoesNotExistException(inner) => Error::ParentCommitDoesNotExistException(inner),
            crate::operation::delete_file::DeleteFileError::ParentCommitIdOutdatedException(inner) => Error::ParentCommitIdOutdatedException(inner),
            crate::operation::delete_file::DeleteFileError::ParentCommitIdRequiredException(inner) => Error::ParentCommitIdRequiredException(inner),
            crate::operation::delete_file::DeleteFileError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::delete_file::DeleteFileError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::delete_file::DeleteFileError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::delete_file::DeleteFileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError>
    for Error
{
    fn from(
        err: crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError,
    ) -> Self {
        match err {
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::ApprovalRuleNameRequiredException(inner) => Error::ApprovalRuleNameRequiredException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::CannotDeleteApprovalRuleFromTemplateException(inner) => Error::CannotDeleteApprovalRuleFromTemplateException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::InvalidApprovalRuleNameException(inner) => Error::InvalidApprovalRuleNameException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::delete_pull_request_approval_rule::DeletePullRequestApprovalRuleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::delete_repository::DeleteRepositoryError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::delete_repository::DeleteRepositoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::delete_repository::DeleteRepositoryError> for Error {
    fn from(err: crate::operation::delete_repository::DeleteRepositoryError) -> Self {
        match err {
            crate::operation::delete_repository::DeleteRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::delete_repository::DeleteRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::delete_repository::DeleteRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::delete_repository::DeleteRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::delete_repository::DeleteRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::delete_repository::DeleteRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::delete_repository::DeleteRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::delete_repository::DeleteRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_merge_conflicts::DescribeMergeConflictsError> for Error {
    fn from(err: crate::operation::describe_merge_conflicts::DescribeMergeConflictsError) -> Self {
        match err {
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::FileDoesNotExistException(inner) => Error::FileDoesNotExistException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::InvalidMaxMergeHunksException(inner) => Error::InvalidMaxMergeHunksException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::InvalidMergeOptionException(inner) => Error::InvalidMergeOptionException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::MergeOptionRequiredException(inner) => Error::MergeOptionRequiredException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::describe_merge_conflicts::DescribeMergeConflictsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::describe_pull_request_events::DescribePullRequestEventsError>
    for Error
{
    fn from(
        err: crate::operation::describe_pull_request_events::DescribePullRequestEventsError,
    ) -> Self {
        match err {
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::ActorDoesNotExistException(inner) => Error::ActorDoesNotExistException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::InvalidActorArnException(inner) => Error::InvalidActorArnException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::InvalidPullRequestEventTypeException(inner) => Error::InvalidPullRequestEventTypeException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::describe_pull_request_events::DescribePullRequestEventsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError> for Error {
    fn from(err: crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError) -> Self {
        match err {
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::disassociate_approval_rule_template_from_repository::DisassociateApprovalRuleTemplateFromRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError> for Error {
    fn from(err: crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError) -> Self {
        match err {
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::RevisionNotCurrentException(inner) => Error::RevisionNotCurrentException(inner),
            crate::operation::evaluate_pull_request_approval_rules::EvaluatePullRequestApprovalRulesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_approval_rule_template::GetApprovalRuleTemplateError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_approval_rule_template::GetApprovalRuleTemplateError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_approval_rule_template::GetApprovalRuleTemplateError> for Error {
    fn from(
        err: crate::operation::get_approval_rule_template::GetApprovalRuleTemplateError,
    ) -> Self {
        match err {
            crate::operation::get_approval_rule_template::GetApprovalRuleTemplateError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::operation::get_approval_rule_template::GetApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::get_approval_rule_template::GetApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::get_approval_rule_template::GetApprovalRuleTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_blob::GetBlobError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::get_blob::GetBlobError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_blob::GetBlobError> for Error {
    fn from(err: crate::operation::get_blob::GetBlobError) -> Self {
        match err {
            crate::operation::get_blob::GetBlobError::BlobIdDoesNotExistException(inner) => {
                Error::BlobIdDoesNotExistException(inner)
            }
            crate::operation::get_blob::GetBlobError::BlobIdRequiredException(inner) => {
                Error::BlobIdRequiredException(inner)
            }
            crate::operation::get_blob::GetBlobError::EncryptionIntegrityChecksFailedException(
                inner,
            ) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_blob::GetBlobError::EncryptionKeyAccessDeniedException(inner) => {
                Error::EncryptionKeyAccessDeniedException(inner)
            }
            crate::operation::get_blob::GetBlobError::EncryptionKeyDisabledException(inner) => {
                Error::EncryptionKeyDisabledException(inner)
            }
            crate::operation::get_blob::GetBlobError::EncryptionKeyNotFoundException(inner) => {
                Error::EncryptionKeyNotFoundException(inner)
            }
            crate::operation::get_blob::GetBlobError::EncryptionKeyUnavailableException(inner) => {
                Error::EncryptionKeyUnavailableException(inner)
            }
            crate::operation::get_blob::GetBlobError::FileTooLargeException(inner) => {
                Error::FileTooLargeException(inner)
            }
            crate::operation::get_blob::GetBlobError::InvalidBlobIdException(inner) => {
                Error::InvalidBlobIdException(inner)
            }
            crate::operation::get_blob::GetBlobError::InvalidRepositoryNameException(inner) => {
                Error::InvalidRepositoryNameException(inner)
            }
            crate::operation::get_blob::GetBlobError::RepositoryDoesNotExistException(inner) => {
                Error::RepositoryDoesNotExistException(inner)
            }
            crate::operation::get_blob::GetBlobError::RepositoryNameRequiredException(inner) => {
                Error::RepositoryNameRequiredException(inner)
            }
            crate::operation::get_blob::GetBlobError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_branch::GetBranchError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::get_branch::GetBranchError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_branch::GetBranchError> for Error {
    fn from(err: crate::operation::get_branch::GetBranchError) -> Self {
        match err {
            crate::operation::get_branch::GetBranchError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::operation::get_branch::GetBranchError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::get_branch::GetBranchError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_branch::GetBranchError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_branch::GetBranchError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_branch::GetBranchError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_branch::GetBranchError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_branch::GetBranchError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::get_branch::GetBranchError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_branch::GetBranchError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_branch::GetBranchError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_branch::GetBranchError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_comment::GetCommentError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::get_comment::GetCommentError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_comment::GetCommentError> for Error {
    fn from(err: crate::operation::get_comment::GetCommentError) -> Self {
        match err {
            crate::operation::get_comment::GetCommentError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::operation::get_comment::GetCommentError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::operation::get_comment::GetCommentError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::operation::get_comment::GetCommentError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_comment::GetCommentError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_comment::GetCommentError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_comment::GetCommentError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_comment::GetCommentError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_comment::GetCommentError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::operation::get_comment::GetCommentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_comment_reactions::GetCommentReactionsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_comment_reactions::GetCommentReactionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_comment_reactions::GetCommentReactionsError> for Error {
    fn from(err: crate::operation::get_comment_reactions::GetCommentReactionsError) -> Self {
        match err {
            crate::operation::get_comment_reactions::GetCommentReactionsError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::operation::get_comment_reactions::GetCommentReactionsError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::operation::get_comment_reactions::GetCommentReactionsError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::operation::get_comment_reactions::GetCommentReactionsError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::operation::get_comment_reactions::GetCommentReactionsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::get_comment_reactions::GetCommentReactionsError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::operation::get_comment_reactions::GetCommentReactionsError::InvalidReactionUserArnException(inner) => Error::InvalidReactionUserArnException(inner),
            crate::operation::get_comment_reactions::GetCommentReactionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError>
    for Error
{
    fn from(
        err: crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError,
    ) -> Self {
        match err {
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_comments_for_compared_commit::GetCommentsForComparedCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError>
    for Error
{
    fn from(
        err: crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError,
    ) -> Self {
        match err {
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::operation::get_comments_for_pull_request::GetCommentsForPullRequestError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_commit::GetCommitError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::get_commit::GetCommitError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_commit::GetCommitError> for Error {
    fn from(err: crate::operation::get_commit::GetCommitError) -> Self {
        match err {
            crate::operation::get_commit::GetCommitError::CommitIdDoesNotExistException(inner) => Error::CommitIdDoesNotExistException(inner),
            crate::operation::get_commit::GetCommitError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::operation::get_commit::GetCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_commit::GetCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_commit::GetCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_commit::GetCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_commit::GetCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_commit::GetCommitError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::get_commit::GetCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_commit::GetCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_commit::GetCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_commit::GetCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_differences::GetDifferencesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_differences::GetDifferencesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_differences::GetDifferencesError> for Error {
    fn from(err: crate::operation::get_differences::GetDifferencesError) -> Self {
        match err {
            crate::operation::get_differences::GetDifferencesError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::get_differences::GetDifferencesError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::get_differences::GetDifferencesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_differences::GetDifferencesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_differences::GetDifferencesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_differences::GetDifferencesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_differences::GetDifferencesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_differences::GetDifferencesError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::get_differences::GetDifferencesError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::get_differences::GetDifferencesError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::get_differences::GetDifferencesError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::operation::get_differences::GetDifferencesError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::get_differences::GetDifferencesError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_differences::GetDifferencesError::PathDoesNotExistException(inner) => Error::PathDoesNotExistException(inner),
            crate::operation::get_differences::GetDifferencesError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_differences::GetDifferencesError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_differences::GetDifferencesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_file::GetFileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::get_file::GetFileError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_file::GetFileError> for Error {
    fn from(err: crate::operation::get_file::GetFileError) -> Self {
        match err {
            crate::operation::get_file::GetFileError::CommitDoesNotExistException(inner) => {
                Error::CommitDoesNotExistException(inner)
            }
            crate::operation::get_file::GetFileError::EncryptionIntegrityChecksFailedException(
                inner,
            ) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_file::GetFileError::EncryptionKeyAccessDeniedException(inner) => {
                Error::EncryptionKeyAccessDeniedException(inner)
            }
            crate::operation::get_file::GetFileError::EncryptionKeyDisabledException(inner) => {
                Error::EncryptionKeyDisabledException(inner)
            }
            crate::operation::get_file::GetFileError::EncryptionKeyNotFoundException(inner) => {
                Error::EncryptionKeyNotFoundException(inner)
            }
            crate::operation::get_file::GetFileError::EncryptionKeyUnavailableException(inner) => {
                Error::EncryptionKeyUnavailableException(inner)
            }
            crate::operation::get_file::GetFileError::FileDoesNotExistException(inner) => {
                Error::FileDoesNotExistException(inner)
            }
            crate::operation::get_file::GetFileError::FileTooLargeException(inner) => {
                Error::FileTooLargeException(inner)
            }
            crate::operation::get_file::GetFileError::InvalidCommitException(inner) => {
                Error::InvalidCommitException(inner)
            }
            crate::operation::get_file::GetFileError::InvalidPathException(inner) => {
                Error::InvalidPathException(inner)
            }
            crate::operation::get_file::GetFileError::InvalidRepositoryNameException(inner) => {
                Error::InvalidRepositoryNameException(inner)
            }
            crate::operation::get_file::GetFileError::PathRequiredException(inner) => {
                Error::PathRequiredException(inner)
            }
            crate::operation::get_file::GetFileError::RepositoryDoesNotExistException(inner) => {
                Error::RepositoryDoesNotExistException(inner)
            }
            crate::operation::get_file::GetFileError::RepositoryNameRequiredException(inner) => {
                Error::RepositoryNameRequiredException(inner)
            }
            crate::operation::get_file::GetFileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::get_folder::GetFolderError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::get_folder::GetFolderError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_folder::GetFolderError> for Error {
    fn from(err: crate::operation::get_folder::GetFolderError) -> Self {
        match err {
            crate::operation::get_folder::GetFolderError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::get_folder::GetFolderError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_folder::GetFolderError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_folder::GetFolderError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_folder::GetFolderError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_folder::GetFolderError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_folder::GetFolderError::FolderDoesNotExistException(inner) => Error::FolderDoesNotExistException(inner),
            crate::operation::get_folder::GetFolderError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::get_folder::GetFolderError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::get_folder::GetFolderError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_folder::GetFolderError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::get_folder::GetFolderError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_folder::GetFolderError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_folder::GetFolderError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_merge_commit::GetMergeCommitError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_merge_commit::GetMergeCommitError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_merge_commit::GetMergeCommitError> for Error {
    fn from(err: crate::operation::get_merge_commit::GetMergeCommitError) -> Self {
        match err {
            crate::operation::get_merge_commit::GetMergeCommitError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_merge_commit::GetMergeCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_merge_conflicts::GetMergeConflictsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_merge_conflicts::GetMergeConflictsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_merge_conflicts::GetMergeConflictsError> for Error {
    fn from(err: crate::operation::get_merge_conflicts::GetMergeConflictsError) -> Self {
        match err {
            crate::operation::get_merge_conflicts::GetMergeConflictsError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::InvalidDestinationCommitSpecifierException(inner) => Error::InvalidDestinationCommitSpecifierException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::InvalidMaxConflictFilesException(inner) => Error::InvalidMaxConflictFilesException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::InvalidMergeOptionException(inner) => Error::InvalidMergeOptionException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::InvalidSourceCommitSpecifierException(inner) => Error::InvalidSourceCommitSpecifierException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::MergeOptionRequiredException(inner) => Error::MergeOptionRequiredException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::get_merge_conflicts::GetMergeConflictsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_merge_options::GetMergeOptionsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_merge_options::GetMergeOptionsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_merge_options::GetMergeOptionsError> for Error {
    fn from(err: crate::operation::get_merge_options::GetMergeOptionsError) -> Self {
        match err {
            crate::operation::get_merge_options::GetMergeOptionsError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::get_merge_options::GetMergeOptionsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_pull_request::GetPullRequestError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_pull_request::GetPullRequestError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_pull_request::GetPullRequestError> for Error {
    fn from(err: crate::operation::get_pull_request::GetPullRequestError) -> Self {
        match err {
            crate::operation::get_pull_request::GetPullRequestError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_pull_request::GetPullRequestError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_pull_request::GetPullRequestError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_pull_request::GetPullRequestError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_pull_request::GetPullRequestError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_pull_request::GetPullRequestError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::get_pull_request::GetPullRequestError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::get_pull_request::GetPullRequestError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::get_pull_request::GetPullRequestError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError>
    for Error
{
    fn from(
        err: crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError,
    ) -> Self {
        match err {
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::operation::get_pull_request_approval_states::GetPullRequestApprovalStatesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError>
    for Error
{
    fn from(
        err: crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError,
    ) -> Self {
        match err {
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::operation::get_pull_request_override_state::GetPullRequestOverrideStateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::get_repository::GetRepositoryError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_repository::GetRepositoryError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_repository::GetRepositoryError> for Error {
    fn from(err: crate::operation::get_repository::GetRepositoryError) -> Self {
        match err {
            crate::operation::get_repository::GetRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_repository::GetRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_repository::GetRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_repository::GetRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_repository::GetRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_repository::GetRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_repository::GetRepositoryError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_repository::GetRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_repository::GetRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::get_repository_triggers::GetRepositoryTriggersError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::get_repository_triggers::GetRepositoryTriggersError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::get_repository_triggers::GetRepositoryTriggersError> for Error {
    fn from(err: crate::operation::get_repository_triggers::GetRepositoryTriggersError) -> Self {
        match err {
            crate::operation::get_repository_triggers::GetRepositoryTriggersError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::get_repository_triggers::GetRepositoryTriggersError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::get_repository_triggers::GetRepositoryTriggersError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::get_repository_triggers::GetRepositoryTriggersError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::get_repository_triggers::GetRepositoryTriggersError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::get_repository_triggers::GetRepositoryTriggersError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::get_repository_triggers::GetRepositoryTriggersError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::get_repository_triggers::GetRepositoryTriggersError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::get_repository_triggers::GetRepositoryTriggersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_approval_rule_templates::ListApprovalRuleTemplatesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_approval_rule_templates::ListApprovalRuleTemplatesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_approval_rule_templates::ListApprovalRuleTemplatesError>
    for Error
{
    fn from(
        err: crate::operation::list_approval_rule_templates::ListApprovalRuleTemplatesError,
    ) -> Self {
        match err {
            crate::operation::list_approval_rule_templates::ListApprovalRuleTemplatesError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::list_approval_rule_templates::ListApprovalRuleTemplatesError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::operation::list_approval_rule_templates::ListApprovalRuleTemplatesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError> for Error {
    fn from(err: crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError) -> Self {
        match err {
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::list_associated_approval_rule_templates_for_repository::ListAssociatedApprovalRuleTemplatesForRepositoryError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::list_branches::ListBranchesError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_branches::ListBranchesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_branches::ListBranchesError> for Error {
    fn from(err: crate::operation::list_branches::ListBranchesError) -> Self {
        match err {
            crate::operation::list_branches::ListBranchesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::list_branches::ListBranchesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::list_branches::ListBranchesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::list_branches::ListBranchesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::list_branches::ListBranchesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::list_branches::ListBranchesError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::list_branches::ListBranchesError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::list_branches::ListBranchesError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::list_branches::ListBranchesError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::list_branches::ListBranchesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_pull_requests::ListPullRequestsError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_pull_requests::ListPullRequestsError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_pull_requests::ListPullRequestsError> for Error {
    fn from(err: crate::operation::list_pull_requests::ListPullRequestsError) -> Self {
        match err {
            crate::operation::list_pull_requests::ListPullRequestsError::AuthorDoesNotExistException(inner) => Error::AuthorDoesNotExistException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::InvalidAuthorArnException(inner) => Error::InvalidAuthorArnException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::InvalidPullRequestStatusException(inner) => Error::InvalidPullRequestStatusException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::list_pull_requests::ListPullRequestsError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_repositories::ListRepositoriesError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_repositories::ListRepositoriesError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_repositories::ListRepositoriesError> for Error {
    fn from(err: crate::operation::list_repositories::ListRepositoriesError) -> Self {
        match err {
            crate::operation::list_repositories::ListRepositoriesError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::list_repositories::ListRepositoriesError::InvalidOrderException(inner) => Error::InvalidOrderException(inner),
            crate::operation::list_repositories::ListRepositoriesError::InvalidSortByException(inner) => Error::InvalidSortByException(inner),
            crate::operation::list_repositories::ListRepositoriesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError> for Error {
    fn from(err: crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError) -> Self {
        match err {
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::InvalidContinuationTokenException(inner) => Error::InvalidContinuationTokenException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::InvalidMaxResultsException(inner) => Error::InvalidMaxResultsException(inner),
            crate::operation::list_repositories_for_approval_rule_template::ListRepositoriesForApprovalRuleTemplateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::list_tags_for_resource::ListTagsForResourceError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::list_tags_for_resource::ListTagsForResourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::list_tags_for_resource::ListTagsForResourceError> for Error {
    fn from(err: crate::operation::list_tags_for_resource::ListTagsForResourceError) -> Self {
        match err {
            crate::operation::list_tags_for_resource::ListTagsForResourceError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::InvalidResourceArnException(inner) => Error::InvalidResourceArnException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::ResourceArnRequiredException(inner) => Error::ResourceArnRequiredException(inner),
            crate::operation::list_tags_for_resource::ListTagsForResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError>
    for Error
{
    fn from(
        err: crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError,
    ) -> Self {
        match err {
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::InvalidTargetBranchException(inner) => Error::InvalidTargetBranchException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::merge_branches_by_fast_forward::MergeBranchesByFastForwardError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::merge_branches_by_squash::MergeBranchesBySquashError> for Error {
    fn from(err: crate::operation::merge_branches_by_squash::MergeBranchesBySquashError) -> Self {
        match err {
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::FileModeRequiredException(inner) => Error::FileModeRequiredException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::InvalidTargetBranchException(inner) => Error::InvalidTargetBranchException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::merge_branches_by_squash::MergeBranchesBySquashError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError> for Error {
    fn from(
        err: crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError,
    ) -> Self {
        match err {
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::CommitRequiredException(inner) => Error::CommitRequiredException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::FileModeRequiredException(inner) => Error::FileModeRequiredException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidCommitException(inner) => Error::InvalidCommitException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::InvalidTargetBranchException(inner) => Error::InvalidTargetBranchException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::merge_branches_by_three_way::MergeBranchesByThreeWayError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError>
    for Error
{
    fn from(
        err: crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError,
    ) -> Self {
        match err {
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::PullRequestApprovalRulesNotSatisfiedException(inner) => Error::PullRequestApprovalRulesNotSatisfiedException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::ReferenceDoesNotExistException(inner) => Error::ReferenceDoesNotExistException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::TipOfSourceReferenceIsDifferentException(inner) => Error::TipOfSourceReferenceIsDifferentException(inner),
            crate::operation::merge_pull_request_by_fast_forward::MergePullRequestByFastForwardError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError> for Error {
    fn from(
        err: crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError,
    ) -> Self {
        match err {
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::PullRequestApprovalRulesNotSatisfiedException(inner) => Error::PullRequestApprovalRulesNotSatisfiedException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::TipOfSourceReferenceIsDifferentException(inner) => Error::TipOfSourceReferenceIsDifferentException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError>
    for Error
{
    fn from(
        err: crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError,
    ) -> Self {
        match err {
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::ConcurrentReferenceUpdateException(inner) => Error::ConcurrentReferenceUpdateException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidConflictDetailLevelException(inner) => Error::InvalidConflictDetailLevelException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidConflictResolutionException(inner) => Error::InvalidConflictResolutionException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidConflictResolutionStrategyException(inner) => Error::InvalidConflictResolutionStrategyException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidReplacementContentException(inner) => Error::InvalidReplacementContentException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidReplacementTypeException(inner) => Error::InvalidReplacementTypeException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::ManualMergeRequiredException(inner) => Error::ManualMergeRequiredException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::MaximumConflictResolutionEntriesExceededException(inner) => Error::MaximumConflictResolutionEntriesExceededException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::MaximumFileContentToLoadExceededException(inner) => Error::MaximumFileContentToLoadExceededException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::MaximumItemsToCompareExceededException(inner) => Error::MaximumItemsToCompareExceededException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::MultipleConflictResolutionEntriesException(inner) => Error::MultipleConflictResolutionEntriesException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::PullRequestApprovalRulesNotSatisfiedException(inner) => Error::PullRequestApprovalRulesNotSatisfiedException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::ReplacementContentRequiredException(inner) => Error::ReplacementContentRequiredException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::ReplacementTypeRequiredException(inner) => Error::ReplacementTypeRequiredException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::TipOfSourceReferenceIsDifferentException(inner) => Error::TipOfSourceReferenceIsDifferentException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::TipsDivergenceExceededException(inner) => Error::TipsDivergenceExceededException(inner),
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError> for Error {
    fn from(err: crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError) -> Self {
        match err {
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::InvalidOverrideStatusException(inner) => Error::InvalidOverrideStatusException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::OverrideAlreadySetException(inner) => Error::OverrideAlreadySetException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::OverrideStatusRequiredException(inner) => Error::OverrideStatusRequiredException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::RevisionNotCurrentException(inner) => Error::RevisionNotCurrentException(inner),
            crate::operation::override_pull_request_approval_rules::OverridePullRequestApprovalRulesError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError>
    for Error
{
    fn from(
        err: crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError,
    ) -> Self {
        match err {
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::BeforeCommitIdAndAfterCommitIdAreSameException(inner) => Error::BeforeCommitIdAndAfterCommitIdAreSameException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::ClientRequestTokenRequiredException(inner) => Error::ClientRequestTokenRequiredException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::CommentContentRequiredException(inner) => Error::CommentContentRequiredException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::CommentContentSizeLimitExceededException(inner) => Error::CommentContentSizeLimitExceededException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::IdempotencyParameterMismatchException(inner) => Error::IdempotencyParameterMismatchException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::InvalidClientRequestTokenException(inner) => Error::InvalidClientRequestTokenException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::InvalidFileLocationException(inner) => Error::InvalidFileLocationException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::InvalidFilePositionException(inner) => Error::InvalidFilePositionException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::InvalidRelativeFileVersionEnumException(inner) => Error::InvalidRelativeFileVersionEnumException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::PathDoesNotExistException(inner) => Error::PathDoesNotExistException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::post_comment_for_compared_commit::PostCommentForComparedCommitError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError>
    for Error
{
    fn from(
        err: crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError,
    ) -> Self {
        match err {
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::BeforeCommitIdAndAfterCommitIdAreSameException(inner) => Error::BeforeCommitIdAndAfterCommitIdAreSameException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::ClientRequestTokenRequiredException(inner) => Error::ClientRequestTokenRequiredException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::CommentContentRequiredException(inner) => Error::CommentContentRequiredException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::CommentContentSizeLimitExceededException(inner) => Error::CommentContentSizeLimitExceededException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::CommitDoesNotExistException(inner) => Error::CommitDoesNotExistException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::CommitIdRequiredException(inner) => Error::CommitIdRequiredException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::IdempotencyParameterMismatchException(inner) => Error::IdempotencyParameterMismatchException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::InvalidClientRequestTokenException(inner) => Error::InvalidClientRequestTokenException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::InvalidCommitIdException(inner) => Error::InvalidCommitIdException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::InvalidFileLocationException(inner) => Error::InvalidFileLocationException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::InvalidFilePositionException(inner) => Error::InvalidFilePositionException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::InvalidRelativeFileVersionEnumException(inner) => Error::InvalidRelativeFileVersionEnumException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::PathDoesNotExistException(inner) => Error::PathDoesNotExistException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::RepositoryNotAssociatedWithPullRequestException(inner) => Error::RepositoryNotAssociatedWithPullRequestException(inner),
            crate::operation::post_comment_for_pull_request::PostCommentForPullRequestError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::post_comment_reply::PostCommentReplyError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::post_comment_reply::PostCommentReplyError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::post_comment_reply::PostCommentReplyError> for Error {
    fn from(err: crate::operation::post_comment_reply::PostCommentReplyError) -> Self {
        match err {
            crate::operation::post_comment_reply::PostCommentReplyError::ClientRequestTokenRequiredException(inner) => Error::ClientRequestTokenRequiredException(inner),
            crate::operation::post_comment_reply::PostCommentReplyError::CommentContentRequiredException(inner) => Error::CommentContentRequiredException(inner),
            crate::operation::post_comment_reply::PostCommentReplyError::CommentContentSizeLimitExceededException(inner) => Error::CommentContentSizeLimitExceededException(inner),
            crate::operation::post_comment_reply::PostCommentReplyError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::operation::post_comment_reply::PostCommentReplyError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::operation::post_comment_reply::PostCommentReplyError::IdempotencyParameterMismatchException(inner) => Error::IdempotencyParameterMismatchException(inner),
            crate::operation::post_comment_reply::PostCommentReplyError::InvalidClientRequestTokenException(inner) => Error::InvalidClientRequestTokenException(inner),
            crate::operation::post_comment_reply::PostCommentReplyError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::operation::post_comment_reply::PostCommentReplyError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::put_comment_reaction::PutCommentReactionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::put_comment_reaction::PutCommentReactionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::put_comment_reaction::PutCommentReactionError> for Error {
    fn from(err: crate::operation::put_comment_reaction::PutCommentReactionError) -> Self {
        match err {
            crate::operation::put_comment_reaction::PutCommentReactionError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::operation::put_comment_reaction::PutCommentReactionError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::operation::put_comment_reaction::PutCommentReactionError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::operation::put_comment_reaction::PutCommentReactionError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::operation::put_comment_reaction::PutCommentReactionError::InvalidReactionValueException(inner) => Error::InvalidReactionValueException(inner),
            crate::operation::put_comment_reaction::PutCommentReactionError::ReactionLimitExceededException(inner) => Error::ReactionLimitExceededException(inner),
            crate::operation::put_comment_reaction::PutCommentReactionError::ReactionValueRequiredException(inner) => Error::ReactionValueRequiredException(inner),
            crate::operation::put_comment_reaction::PutCommentReactionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::put_file::PutFileError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::put_file::PutFileError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::put_file::PutFileError> for Error {
    fn from(err: crate::operation::put_file::PutFileError) -> Self {
        match err {
            crate::operation::put_file::PutFileError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::operation::put_file::PutFileError::BranchNameIsTagNameException(inner) => Error::BranchNameIsTagNameException(inner),
            crate::operation::put_file::PutFileError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::put_file::PutFileError::CommitMessageLengthExceededException(inner) => Error::CommitMessageLengthExceededException(inner),
            crate::operation::put_file::PutFileError::DirectoryNameConflictsWithFileNameException(inner) => Error::DirectoryNameConflictsWithFileNameException(inner),
            crate::operation::put_file::PutFileError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::put_file::PutFileError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::put_file::PutFileError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::put_file::PutFileError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::put_file::PutFileError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::put_file::PutFileError::FileContentRequiredException(inner) => Error::FileContentRequiredException(inner),
            crate::operation::put_file::PutFileError::FileContentSizeLimitExceededException(inner) => Error::FileContentSizeLimitExceededException(inner),
            crate::operation::put_file::PutFileError::FileNameConflictsWithDirectoryNameException(inner) => Error::FileNameConflictsWithDirectoryNameException(inner),
            crate::operation::put_file::PutFileError::FilePathConflictsWithSubmodulePathException(inner) => Error::FilePathConflictsWithSubmodulePathException(inner),
            crate::operation::put_file::PutFileError::FolderContentSizeLimitExceededException(inner) => Error::FolderContentSizeLimitExceededException(inner),
            crate::operation::put_file::PutFileError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::put_file::PutFileError::InvalidDeletionParameterException(inner) => Error::InvalidDeletionParameterException(inner),
            crate::operation::put_file::PutFileError::InvalidEmailException(inner) => Error::InvalidEmailException(inner),
            crate::operation::put_file::PutFileError::InvalidFileModeException(inner) => Error::InvalidFileModeException(inner),
            crate::operation::put_file::PutFileError::InvalidParentCommitIdException(inner) => Error::InvalidParentCommitIdException(inner),
            crate::operation::put_file::PutFileError::InvalidPathException(inner) => Error::InvalidPathException(inner),
            crate::operation::put_file::PutFileError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::put_file::PutFileError::NameLengthExceededException(inner) => Error::NameLengthExceededException(inner),
            crate::operation::put_file::PutFileError::ParentCommitDoesNotExistException(inner) => Error::ParentCommitDoesNotExistException(inner),
            crate::operation::put_file::PutFileError::ParentCommitIdOutdatedException(inner) => Error::ParentCommitIdOutdatedException(inner),
            crate::operation::put_file::PutFileError::ParentCommitIdRequiredException(inner) => Error::ParentCommitIdRequiredException(inner),
            crate::operation::put_file::PutFileError::PathRequiredException(inner) => Error::PathRequiredException(inner),
            crate::operation::put_file::PutFileError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::put_file::PutFileError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::put_file::PutFileError::SameFileContentException(inner) => Error::SameFileContentException(inner),
            crate::operation::put_file::PutFileError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::put_repository_triggers::PutRepositoryTriggersError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::put_repository_triggers::PutRepositoryTriggersError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::put_repository_triggers::PutRepositoryTriggersError> for Error {
    fn from(err: crate::operation::put_repository_triggers::PutRepositoryTriggersError) -> Self {
        match err {
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException(inner) => Error::InvalidRepositoryTriggerBranchNameException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException(inner) => Error::InvalidRepositoryTriggerCustomDataException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException(inner) => Error::InvalidRepositoryTriggerDestinationArnException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::InvalidRepositoryTriggerEventsException(inner) => Error::InvalidRepositoryTriggerEventsException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::InvalidRepositoryTriggerNameException(inner) => Error::InvalidRepositoryTriggerNameException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::InvalidRepositoryTriggerRegionException(inner) => Error::InvalidRepositoryTriggerRegionException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::MaximumBranchesExceededException(inner) => Error::MaximumBranchesExceededException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::MaximumRepositoryTriggersExceededException(inner) => Error::MaximumRepositoryTriggersExceededException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException(inner) => Error::RepositoryTriggerBranchNameListRequiredException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException(inner) => Error::RepositoryTriggerDestinationArnRequiredException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::RepositoryTriggerEventsListRequiredException(inner) => Error::RepositoryTriggerEventsListRequiredException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::RepositoryTriggerNameRequiredException(inner) => Error::RepositoryTriggerNameRequiredException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::RepositoryTriggersListRequiredException(inner) => Error::RepositoryTriggersListRequiredException(inner),
            crate::operation::put_repository_triggers::PutRepositoryTriggersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::tag_resource::TagResourceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<crate::operation::tag_resource::TagResourceError, R>,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::tag_resource::TagResourceError> for Error {
    fn from(err: crate::operation::tag_resource::TagResourceError) -> Self {
        match err {
            crate::operation::tag_resource::TagResourceError::InvalidRepositoryNameException(
                inner,
            ) => Error::InvalidRepositoryNameException(inner),
            crate::operation::tag_resource::TagResourceError::InvalidResourceArnException(
                inner,
            ) => Error::InvalidResourceArnException(inner),
            crate::operation::tag_resource::TagResourceError::InvalidSystemTagUsageException(
                inner,
            ) => Error::InvalidSystemTagUsageException(inner),
            crate::operation::tag_resource::TagResourceError::InvalidTagsMapException(inner) => {
                Error::InvalidTagsMapException(inner)
            }
            crate::operation::tag_resource::TagResourceError::RepositoryDoesNotExistException(
                inner,
            ) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::tag_resource::TagResourceError::ResourceArnRequiredException(
                inner,
            ) => Error::ResourceArnRequiredException(inner),
            crate::operation::tag_resource::TagResourceError::TagPolicyException(inner) => {
                Error::TagPolicyException(inner)
            }
            crate::operation::tag_resource::TagResourceError::TagsMapRequiredException(inner) => {
                Error::TagsMapRequiredException(inner)
            }
            crate::operation::tag_resource::TagResourceError::TooManyTagsException(inner) => {
                Error::TooManyTagsException(inner)
            }
            crate::operation::tag_resource::TagResourceError::Unhandled(inner) => {
                Error::Unhandled(inner)
            }
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::test_repository_triggers::TestRepositoryTriggersError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::test_repository_triggers::TestRepositoryTriggersError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::test_repository_triggers::TestRepositoryTriggersError> for Error {
    fn from(err: crate::operation::test_repository_triggers::TestRepositoryTriggersError) -> Self {
        match err {
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException(inner) => Error::InvalidRepositoryTriggerBranchNameException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException(inner) => Error::InvalidRepositoryTriggerCustomDataException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException(inner) => Error::InvalidRepositoryTriggerDestinationArnException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::InvalidRepositoryTriggerEventsException(inner) => Error::InvalidRepositoryTriggerEventsException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::InvalidRepositoryTriggerNameException(inner) => Error::InvalidRepositoryTriggerNameException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::InvalidRepositoryTriggerRegionException(inner) => Error::InvalidRepositoryTriggerRegionException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::MaximumBranchesExceededException(inner) => Error::MaximumBranchesExceededException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::MaximumRepositoryTriggersExceededException(inner) => Error::MaximumRepositoryTriggersExceededException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException(inner) => Error::RepositoryTriggerBranchNameListRequiredException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException(inner) => Error::RepositoryTriggerDestinationArnRequiredException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::RepositoryTriggerEventsListRequiredException(inner) => Error::RepositoryTriggerEventsListRequiredException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::RepositoryTriggerNameRequiredException(inner) => Error::RepositoryTriggerNameRequiredException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::RepositoryTriggersListRequiredException(inner) => Error::RepositoryTriggersListRequiredException(inner),
            crate::operation::test_repository_triggers::TestRepositoryTriggersError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::untag_resource::UntagResourceError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::untag_resource::UntagResourceError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::untag_resource::UntagResourceError> for Error {
    fn from(err: crate::operation::untag_resource::UntagResourceError) -> Self {
        match err {
            crate::operation::untag_resource::UntagResourceError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::untag_resource::UntagResourceError::InvalidResourceArnException(inner) => Error::InvalidResourceArnException(inner),
            crate::operation::untag_resource::UntagResourceError::InvalidSystemTagUsageException(inner) => Error::InvalidSystemTagUsageException(inner),
            crate::operation::untag_resource::UntagResourceError::InvalidTagKeysListException(inner) => Error::InvalidTagKeysListException(inner),
            crate::operation::untag_resource::UntagResourceError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::untag_resource::UntagResourceError::ResourceArnRequiredException(inner) => Error::ResourceArnRequiredException(inner),
            crate::operation::untag_resource::UntagResourceError::TagKeysListRequiredException(inner) => Error::TagKeysListRequiredException(inner),
            crate::operation::untag_resource::UntagResourceError::TagPolicyException(inner) => Error::TagPolicyException(inner),
            crate::operation::untag_resource::UntagResourceError::TooManyTagsException(inner) => Error::TooManyTagsException(inner),
            crate::operation::untag_resource::UntagResourceError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError> for Error {
    fn from(err: crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError) -> Self {
        match err {
            crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateContentRequiredException(inner) => Error::ApprovalRuleTemplateContentRequiredException(inner),
            crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError::InvalidApprovalRuleTemplateContentException(inner) => Error::InvalidApprovalRuleTemplateContentException(inner),
            crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError::InvalidRuleContentSha256Exception(inner) => Error::InvalidRuleContentSha256Exception(inner),
            crate::operation::update_approval_rule_template_content::UpdateApprovalRuleTemplateContentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_approval_rule_template_description::UpdateApprovalRuleTemplateDescriptionError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_approval_rule_template_description::UpdateApprovalRuleTemplateDescriptionError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_approval_rule_template_description::UpdateApprovalRuleTemplateDescriptionError> for Error {
    fn from(err: crate::operation::update_approval_rule_template_description::UpdateApprovalRuleTemplateDescriptionError) -> Self {
        match err {
            crate::operation::update_approval_rule_template_description::UpdateApprovalRuleTemplateDescriptionError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::operation::update_approval_rule_template_description::UpdateApprovalRuleTemplateDescriptionError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::update_approval_rule_template_description::UpdateApprovalRuleTemplateDescriptionError::InvalidApprovalRuleTemplateDescriptionException(inner) => Error::InvalidApprovalRuleTemplateDescriptionException(inner),
            crate::operation::update_approval_rule_template_description::UpdateApprovalRuleTemplateDescriptionError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::update_approval_rule_template_description::UpdateApprovalRuleTemplateDescriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_approval_rule_template_name::UpdateApprovalRuleTemplateNameError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_approval_rule_template_name::UpdateApprovalRuleTemplateNameError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_approval_rule_template_name::UpdateApprovalRuleTemplateNameError>
    for Error
{
    fn from(
        err: crate::operation::update_approval_rule_template_name::UpdateApprovalRuleTemplateNameError,
    ) -> Self {
        match err {
            crate::operation::update_approval_rule_template_name::UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateDoesNotExistException(inner) => Error::ApprovalRuleTemplateDoesNotExistException(inner),
            crate::operation::update_approval_rule_template_name::UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateNameAlreadyExistsException(inner) => Error::ApprovalRuleTemplateNameAlreadyExistsException(inner),
            crate::operation::update_approval_rule_template_name::UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateNameRequiredException(inner) => Error::ApprovalRuleTemplateNameRequiredException(inner),
            crate::operation::update_approval_rule_template_name::UpdateApprovalRuleTemplateNameError::InvalidApprovalRuleTemplateNameException(inner) => Error::InvalidApprovalRuleTemplateNameException(inner),
            crate::operation::update_approval_rule_template_name::UpdateApprovalRuleTemplateNameError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<aws_smithy_http::result::SdkError<crate::operation::update_comment::UpdateCommentError, R>>
    for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_comment::UpdateCommentError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_comment::UpdateCommentError> for Error {
    fn from(err: crate::operation::update_comment::UpdateCommentError) -> Self {
        match err {
            crate::operation::update_comment::UpdateCommentError::CommentContentRequiredException(inner) => Error::CommentContentRequiredException(inner),
            crate::operation::update_comment::UpdateCommentError::CommentContentSizeLimitExceededException(inner) => Error::CommentContentSizeLimitExceededException(inner),
            crate::operation::update_comment::UpdateCommentError::CommentDeletedException(inner) => Error::CommentDeletedException(inner),
            crate::operation::update_comment::UpdateCommentError::CommentDoesNotExistException(inner) => Error::CommentDoesNotExistException(inner),
            crate::operation::update_comment::UpdateCommentError::CommentIdRequiredException(inner) => Error::CommentIdRequiredException(inner),
            crate::operation::update_comment::UpdateCommentError::CommentNotCreatedByCallerException(inner) => Error::CommentNotCreatedByCallerException(inner),
            crate::operation::update_comment::UpdateCommentError::InvalidCommentIdException(inner) => Error::InvalidCommentIdException(inner),
            crate::operation::update_comment::UpdateCommentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_default_branch::UpdateDefaultBranchError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_default_branch::UpdateDefaultBranchError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_default_branch::UpdateDefaultBranchError> for Error {
    fn from(err: crate::operation::update_default_branch::UpdateDefaultBranchError) -> Self {
        match err {
            crate::operation::update_default_branch::UpdateDefaultBranchError::BranchDoesNotExistException(inner) => Error::BranchDoesNotExistException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::BranchNameRequiredException(inner) => Error::BranchNameRequiredException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::InvalidBranchNameException(inner) => Error::InvalidBranchNameException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::update_default_branch::UpdateDefaultBranchError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError> for Error {
    fn from(err: crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError) -> Self {
        match err {
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::ApprovalRuleContentRequiredException(inner) => Error::ApprovalRuleContentRequiredException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::ApprovalRuleDoesNotExistException(inner) => Error::ApprovalRuleDoesNotExistException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::ApprovalRuleNameRequiredException(inner) => Error::ApprovalRuleNameRequiredException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::CannotModifyApprovalRuleFromTemplateException(inner) => Error::CannotModifyApprovalRuleFromTemplateException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::InvalidApprovalRuleContentException(inner) => Error::InvalidApprovalRuleContentException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::InvalidApprovalRuleNameException(inner) => Error::InvalidApprovalRuleNameException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::InvalidRuleContentSha256Exception(inner) => Error::InvalidRuleContentSha256Exception(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::update_pull_request_approval_rule_content::UpdatePullRequestApprovalRuleContentError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R> From<aws_smithy_http::result::SdkError<crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError, R>> for Error where R: Send + Sync + std::fmt::Debug + 'static {
    fn from(err: aws_smithy_http::result::SdkError<crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError, R>) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => Self::from(context.into_err()),
            _ => Error::Unhandled(
                                            aws_smithy_types::error::Unhandled::builder()
                                                .meta(aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone())
                                                .source(err)
                                                .build()
                                        ),
        }
    }
}
impl From<crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError>
    for Error
{
    fn from(
        err: crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError,
    ) -> Self {
        match err {
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::ApprovalStateRequiredException(inner) => Error::ApprovalStateRequiredException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::InvalidApprovalStateException(inner) => Error::InvalidApprovalStateException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::InvalidRevisionIdException(inner) => Error::InvalidRevisionIdException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::MaximumNumberOfApprovalsExceededException(inner) => Error::MaximumNumberOfApprovalsExceededException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::PullRequestCannotBeApprovedByAuthorException(inner) => Error::PullRequestCannotBeApprovedByAuthorException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::RevisionIdRequiredException(inner) => Error::RevisionIdRequiredException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::RevisionNotCurrentException(inner) => Error::RevisionNotCurrentException(inner),
            crate::operation::update_pull_request_approval_state::UpdatePullRequestApprovalStateError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError>
    for Error
{
    fn from(
        err: crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError,
    ) -> Self {
        match err {
            crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError::InvalidDescriptionException(inner) => Error::InvalidDescriptionException(inner),
            crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::update_pull_request_description::UpdatePullRequestDescriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_pull_request_status::UpdatePullRequestStatusError> for Error {
    fn from(
        err: crate::operation::update_pull_request_status::UpdatePullRequestStatusError,
    ) -> Self {
        match err {
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::InvalidPullRequestStatusException(inner) => Error::InvalidPullRequestStatusException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::InvalidPullRequestStatusUpdateException(inner) => Error::InvalidPullRequestStatusUpdateException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::PullRequestStatusRequiredException(inner) => Error::PullRequestStatusRequiredException(inner),
            crate::operation::update_pull_request_status::UpdatePullRequestStatusError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_pull_request_title::UpdatePullRequestTitleError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_pull_request_title::UpdatePullRequestTitleError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_pull_request_title::UpdatePullRequestTitleError> for Error {
    fn from(err: crate::operation::update_pull_request_title::UpdatePullRequestTitleError) -> Self {
        match err {
            crate::operation::update_pull_request_title::UpdatePullRequestTitleError::InvalidPullRequestIdException(inner) => Error::InvalidPullRequestIdException(inner),
            crate::operation::update_pull_request_title::UpdatePullRequestTitleError::InvalidTitleException(inner) => Error::InvalidTitleException(inner),
            crate::operation::update_pull_request_title::UpdatePullRequestTitleError::PullRequestAlreadyClosedException(inner) => Error::PullRequestAlreadyClosedException(inner),
            crate::operation::update_pull_request_title::UpdatePullRequestTitleError::PullRequestDoesNotExistException(inner) => Error::PullRequestDoesNotExistException(inner),
            crate::operation::update_pull_request_title::UpdatePullRequestTitleError::PullRequestIdRequiredException(inner) => Error::PullRequestIdRequiredException(inner),
            crate::operation::update_pull_request_title::UpdatePullRequestTitleError::TitleRequiredException(inner) => Error::TitleRequiredException(inner),
            crate::operation::update_pull_request_title::UpdatePullRequestTitleError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_repository_description::UpdateRepositoryDescriptionError>
    for Error
{
    fn from(
        err: crate::operation::update_repository_description::UpdateRepositoryDescriptionError,
    ) -> Self {
        match err {
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::EncryptionIntegrityChecksFailedException(inner) => Error::EncryptionIntegrityChecksFailedException(inner),
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::EncryptionKeyAccessDeniedException(inner) => Error::EncryptionKeyAccessDeniedException(inner),
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::EncryptionKeyDisabledException(inner) => Error::EncryptionKeyDisabledException(inner),
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::EncryptionKeyNotFoundException(inner) => Error::EncryptionKeyNotFoundException(inner),
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::EncryptionKeyUnavailableException(inner) => Error::EncryptionKeyUnavailableException(inner),
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::InvalidRepositoryDescriptionException(inner) => Error::InvalidRepositoryDescriptionException(inner),
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::update_repository_description::UpdateRepositoryDescriptionError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl<R>
    From<
        aws_smithy_http::result::SdkError<
            crate::operation::update_repository_name::UpdateRepositoryNameError,
            R,
        >,
    > for Error
where
    R: Send + Sync + std::fmt::Debug + 'static,
{
    fn from(
        err: aws_smithy_http::result::SdkError<
            crate::operation::update_repository_name::UpdateRepositoryNameError,
            R,
        >,
    ) -> Self {
        match err {
            aws_smithy_http::result::SdkError::ServiceError(context) => {
                Self::from(context.into_err())
            }
            _ => Error::Unhandled(
                aws_smithy_types::error::Unhandled::builder()
                    .meta(
                        aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(&err).clone(),
                    )
                    .source(err)
                    .build(),
            ),
        }
    }
}
impl From<crate::operation::update_repository_name::UpdateRepositoryNameError> for Error {
    fn from(err: crate::operation::update_repository_name::UpdateRepositoryNameError) -> Self {
        match err {
            crate::operation::update_repository_name::UpdateRepositoryNameError::InvalidRepositoryNameException(inner) => Error::InvalidRepositoryNameException(inner),
            crate::operation::update_repository_name::UpdateRepositoryNameError::RepositoryDoesNotExistException(inner) => Error::RepositoryDoesNotExistException(inner),
            crate::operation::update_repository_name::UpdateRepositoryNameError::RepositoryNameExistsException(inner) => Error::RepositoryNameExistsException(inner),
            crate::operation::update_repository_name::UpdateRepositoryNameError::RepositoryNameRequiredException(inner) => Error::RepositoryNameRequiredException(inner),
            crate::operation::update_repository_name::UpdateRepositoryNameError::Unhandled(inner) => Error::Unhandled(inner),
        }
    }
}
impl std::error::Error for Error {}
impl aws_http::request_id::RequestId for Error {
    fn request_id(&self) -> Option<&str> {
        match self {
            Self::ActorDoesNotExistException(e) => e.request_id(),
            Self::ApprovalRuleContentRequiredException(e) => e.request_id(),
            Self::ApprovalRuleDoesNotExistException(e) => e.request_id(),
            Self::ApprovalRuleNameAlreadyExistsException(e) => e.request_id(),
            Self::ApprovalRuleNameRequiredException(e) => e.request_id(),
            Self::ApprovalRuleTemplateContentRequiredException(e) => e.request_id(),
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.request_id(),
            Self::ApprovalRuleTemplateInUseException(e) => e.request_id(),
            Self::ApprovalRuleTemplateNameAlreadyExistsException(e) => e.request_id(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.request_id(),
            Self::ApprovalStateRequiredException(e) => e.request_id(),
            Self::AuthorDoesNotExistException(e) => e.request_id(),
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(e) => e.request_id(),
            Self::BlobIdDoesNotExistException(e) => e.request_id(),
            Self::BlobIdRequiredException(e) => e.request_id(),
            Self::BranchDoesNotExistException(e) => e.request_id(),
            Self::BranchNameExistsException(e) => e.request_id(),
            Self::BranchNameIsTagNameException(e) => e.request_id(),
            Self::BranchNameRequiredException(e) => e.request_id(),
            Self::CannotDeleteApprovalRuleFromTemplateException(e) => e.request_id(),
            Self::CannotModifyApprovalRuleFromTemplateException(e) => e.request_id(),
            Self::ClientRequestTokenRequiredException(e) => e.request_id(),
            Self::CommentContentRequiredException(e) => e.request_id(),
            Self::CommentContentSizeLimitExceededException(e) => e.request_id(),
            Self::CommentDeletedException(e) => e.request_id(),
            Self::CommentDoesNotExistException(e) => e.request_id(),
            Self::CommentIdRequiredException(e) => e.request_id(),
            Self::CommentNotCreatedByCallerException(e) => e.request_id(),
            Self::CommitDoesNotExistException(e) => e.request_id(),
            Self::CommitIdDoesNotExistException(e) => e.request_id(),
            Self::CommitIdRequiredException(e) => e.request_id(),
            Self::CommitIdsLimitExceededException(e) => e.request_id(),
            Self::CommitIdsListRequiredException(e) => e.request_id(),
            Self::CommitMessageLengthExceededException(e) => e.request_id(),
            Self::CommitRequiredException(e) => e.request_id(),
            Self::ConcurrentReferenceUpdateException(e) => e.request_id(),
            Self::DefaultBranchCannotBeDeletedException(e) => e.request_id(),
            Self::DirectoryNameConflictsWithFileNameException(e) => e.request_id(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.request_id(),
            Self::EncryptionKeyAccessDeniedException(e) => e.request_id(),
            Self::EncryptionKeyDisabledException(e) => e.request_id(),
            Self::EncryptionKeyNotFoundException(e) => e.request_id(),
            Self::EncryptionKeyUnavailableException(e) => e.request_id(),
            Self::FileContentAndSourceFileSpecifiedException(e) => e.request_id(),
            Self::FileContentRequiredException(e) => e.request_id(),
            Self::FileContentSizeLimitExceededException(e) => e.request_id(),
            Self::FileDoesNotExistException(e) => e.request_id(),
            Self::FileEntryRequiredException(e) => e.request_id(),
            Self::FileModeRequiredException(e) => e.request_id(),
            Self::FileNameConflictsWithDirectoryNameException(e) => e.request_id(),
            Self::FilePathConflictsWithSubmodulePathException(e) => e.request_id(),
            Self::FileTooLargeException(e) => e.request_id(),
            Self::FolderContentSizeLimitExceededException(e) => e.request_id(),
            Self::FolderDoesNotExistException(e) => e.request_id(),
            Self::IdempotencyParameterMismatchException(e) => e.request_id(),
            Self::InvalidActorArnException(e) => e.request_id(),
            Self::InvalidApprovalRuleContentException(e) => e.request_id(),
            Self::InvalidApprovalRuleNameException(e) => e.request_id(),
            Self::InvalidApprovalRuleTemplateContentException(e) => e.request_id(),
            Self::InvalidApprovalRuleTemplateDescriptionException(e) => e.request_id(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.request_id(),
            Self::InvalidApprovalStateException(e) => e.request_id(),
            Self::InvalidAuthorArnException(e) => e.request_id(),
            Self::InvalidBlobIdException(e) => e.request_id(),
            Self::InvalidBranchNameException(e) => e.request_id(),
            Self::InvalidClientRequestTokenException(e) => e.request_id(),
            Self::InvalidCommentIdException(e) => e.request_id(),
            Self::InvalidCommitException(e) => e.request_id(),
            Self::InvalidCommitIdException(e) => e.request_id(),
            Self::InvalidConflictDetailLevelException(e) => e.request_id(),
            Self::InvalidConflictResolutionException(e) => e.request_id(),
            Self::InvalidConflictResolutionStrategyException(e) => e.request_id(),
            Self::InvalidContinuationTokenException(e) => e.request_id(),
            Self::InvalidDeletionParameterException(e) => e.request_id(),
            Self::InvalidDescriptionException(e) => e.request_id(),
            Self::InvalidDestinationCommitSpecifierException(e) => e.request_id(),
            Self::InvalidEmailException(e) => e.request_id(),
            Self::InvalidFileLocationException(e) => e.request_id(),
            Self::InvalidFileModeException(e) => e.request_id(),
            Self::InvalidFilePositionException(e) => e.request_id(),
            Self::InvalidMaxConflictFilesException(e) => e.request_id(),
            Self::InvalidMaxMergeHunksException(e) => e.request_id(),
            Self::InvalidMaxResultsException(e) => e.request_id(),
            Self::InvalidMergeOptionException(e) => e.request_id(),
            Self::InvalidOrderException(e) => e.request_id(),
            Self::InvalidOverrideStatusException(e) => e.request_id(),
            Self::InvalidParentCommitIdException(e) => e.request_id(),
            Self::InvalidPathException(e) => e.request_id(),
            Self::InvalidPullRequestEventTypeException(e) => e.request_id(),
            Self::InvalidPullRequestIdException(e) => e.request_id(),
            Self::InvalidPullRequestStatusException(e) => e.request_id(),
            Self::InvalidPullRequestStatusUpdateException(e) => e.request_id(),
            Self::InvalidReactionUserArnException(e) => e.request_id(),
            Self::InvalidReactionValueException(e) => e.request_id(),
            Self::InvalidReferenceNameException(e) => e.request_id(),
            Self::InvalidRelativeFileVersionEnumException(e) => e.request_id(),
            Self::InvalidReplacementContentException(e) => e.request_id(),
            Self::InvalidReplacementTypeException(e) => e.request_id(),
            Self::InvalidRepositoryDescriptionException(e) => e.request_id(),
            Self::InvalidRepositoryNameException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerBranchNameException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerCustomDataException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerDestinationArnException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerEventsException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerNameException(e) => e.request_id(),
            Self::InvalidRepositoryTriggerRegionException(e) => e.request_id(),
            Self::InvalidResourceArnException(e) => e.request_id(),
            Self::InvalidRevisionIdException(e) => e.request_id(),
            Self::InvalidRuleContentSha256Exception(e) => e.request_id(),
            Self::InvalidSortByException(e) => e.request_id(),
            Self::InvalidSourceCommitSpecifierException(e) => e.request_id(),
            Self::InvalidSystemTagUsageException(e) => e.request_id(),
            Self::InvalidTagKeysListException(e) => e.request_id(),
            Self::InvalidTagsMapException(e) => e.request_id(),
            Self::InvalidTargetBranchException(e) => e.request_id(),
            Self::InvalidTargetException(e) => e.request_id(),
            Self::InvalidTargetsException(e) => e.request_id(),
            Self::InvalidTitleException(e) => e.request_id(),
            Self::ManualMergeRequiredException(e) => e.request_id(),
            Self::MaximumBranchesExceededException(e) => e.request_id(),
            Self::MaximumConflictResolutionEntriesExceededException(e) => e.request_id(),
            Self::MaximumFileContentToLoadExceededException(e) => e.request_id(),
            Self::MaximumFileEntriesExceededException(e) => e.request_id(),
            Self::MaximumItemsToCompareExceededException(e) => e.request_id(),
            Self::MaximumNumberOfApprovalsExceededException(e) => e.request_id(),
            Self::MaximumOpenPullRequestsExceededException(e) => e.request_id(),
            Self::MaximumRepositoryNamesExceededException(e) => e.request_id(),
            Self::MaximumRepositoryTriggersExceededException(e) => e.request_id(),
            Self::MaximumRuleTemplatesAssociatedWithRepositoryException(e) => e.request_id(),
            Self::MergeOptionRequiredException(e) => e.request_id(),
            Self::MultipleConflictResolutionEntriesException(e) => e.request_id(),
            Self::MultipleRepositoriesInPullRequestException(e) => e.request_id(),
            Self::NameLengthExceededException(e) => e.request_id(),
            Self::NoChangeException(e) => e.request_id(),
            Self::NumberOfRuleTemplatesExceededException(e) => e.request_id(),
            Self::NumberOfRulesExceededException(e) => e.request_id(),
            Self::OverrideAlreadySetException(e) => e.request_id(),
            Self::OverrideStatusRequiredException(e) => e.request_id(),
            Self::ParentCommitDoesNotExistException(e) => e.request_id(),
            Self::ParentCommitIdOutdatedException(e) => e.request_id(),
            Self::ParentCommitIdRequiredException(e) => e.request_id(),
            Self::PathDoesNotExistException(e) => e.request_id(),
            Self::PathRequiredException(e) => e.request_id(),
            Self::PullRequestAlreadyClosedException(e) => e.request_id(),
            Self::PullRequestApprovalRulesNotSatisfiedException(e) => e.request_id(),
            Self::PullRequestCannotBeApprovedByAuthorException(e) => e.request_id(),
            Self::PullRequestDoesNotExistException(e) => e.request_id(),
            Self::PullRequestIdRequiredException(e) => e.request_id(),
            Self::PullRequestStatusRequiredException(e) => e.request_id(),
            Self::PutFileEntryConflictException(e) => e.request_id(),
            Self::ReactionLimitExceededException(e) => e.request_id(),
            Self::ReactionValueRequiredException(e) => e.request_id(),
            Self::ReferenceDoesNotExistException(e) => e.request_id(),
            Self::ReferenceNameRequiredException(e) => e.request_id(),
            Self::ReferenceTypeNotSupportedException(e) => e.request_id(),
            Self::ReplacementContentRequiredException(e) => e.request_id(),
            Self::ReplacementTypeRequiredException(e) => e.request_id(),
            Self::RepositoryDoesNotExistException(e) => e.request_id(),
            Self::RepositoryLimitExceededException(e) => e.request_id(),
            Self::RepositoryNameExistsException(e) => e.request_id(),
            Self::RepositoryNameRequiredException(e) => e.request_id(),
            Self::RepositoryNamesRequiredException(e) => e.request_id(),
            Self::RepositoryNotAssociatedWithPullRequestException(e) => e.request_id(),
            Self::RepositoryTriggerBranchNameListRequiredException(e) => e.request_id(),
            Self::RepositoryTriggerDestinationArnRequiredException(e) => e.request_id(),
            Self::RepositoryTriggerEventsListRequiredException(e) => e.request_id(),
            Self::RepositoryTriggerNameRequiredException(e) => e.request_id(),
            Self::RepositoryTriggersListRequiredException(e) => e.request_id(),
            Self::ResourceArnRequiredException(e) => e.request_id(),
            Self::RestrictedSourceFileException(e) => e.request_id(),
            Self::RevisionIdRequiredException(e) => e.request_id(),
            Self::RevisionNotCurrentException(e) => e.request_id(),
            Self::SameFileContentException(e) => e.request_id(),
            Self::SamePathRequestException(e) => e.request_id(),
            Self::SourceAndDestinationAreSameException(e) => e.request_id(),
            Self::SourceFileOrContentRequiredException(e) => e.request_id(),
            Self::TagKeysListRequiredException(e) => e.request_id(),
            Self::TagPolicyException(e) => e.request_id(),
            Self::TagsMapRequiredException(e) => e.request_id(),
            Self::TargetRequiredException(e) => e.request_id(),
            Self::TargetsRequiredException(e) => e.request_id(),
            Self::TipOfSourceReferenceIsDifferentException(e) => e.request_id(),
            Self::TipsDivergenceExceededException(e) => e.request_id(),
            Self::TitleRequiredException(e) => e.request_id(),
            Self::TooManyTagsException(e) => e.request_id(),
            Self::Unhandled(e) => e.request_id(),
        }
    }
}
