// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateApprovalRuleTemplateWithRepositoryError {
    pub kind: AssociateApprovalRuleTemplateWithRepositoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateApprovalRuleTemplateWithRepositoryErrorKind {
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    MaximumRuleTemplatesAssociatedWithRepositoryException(
        crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException,
    ),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateApprovalRuleTemplateWithRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::MaximumRuleTemplatesAssociatedWithRepositoryException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for AssociateApprovalRuleTemplateWithRepositoryError {
    fn code(&self) -> Option<&str> {
        AssociateApprovalRuleTemplateWithRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateApprovalRuleTemplateWithRepositoryError {
    pub fn new(
        kind: AssociateApprovalRuleTemplateWithRepositoryErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateApprovalRuleTemplateWithRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateApprovalRuleTemplateWithRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyUnavailableException(
                _
            )
        )
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_maximum_rule_templates_associated_with_repository_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::MaximumRuleTemplatesAssociatedWithRepositoryException(_))
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryDoesNotExistException(
                _
            )
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryNameRequiredException(
                _
            )
        )
    }
}
impl std::error::Error for AssociateApprovalRuleTemplateWithRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::MaximumRuleTemplatesAssociatedWithRepositoryException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    pub kind: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind {
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind
    for BatchAssociateApprovalRuleTemplateWithRepositoriesError
{
    fn code(&self) -> Option<&str> {
        BatchAssociateApprovalRuleTemplateWithRepositoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    pub fn new(
        kind: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::Unhandled(
                err.into(),
            ),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::Unhandled(
                err.into(),
            ),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyDisabledException(_))
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyNotFoundException(_))
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyUnavailableException(_))
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    pub fn is_maximum_repository_names_exceeded_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_))
    }
    pub fn is_repository_names_required_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::RepositoryNamesRequiredException(_))
    }
}
impl std::error::Error for BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDescribeMergeConflictsError {
    pub kind: BatchDescribeMergeConflictsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDescribeMergeConflictsErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitRequiredException(crate::error::CommitRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxConflictFilesException(crate::error::InvalidMaxConflictFilesException),
    InvalidMaxMergeHunksException(crate::error::InvalidMaxMergeHunksException),
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDescribeMergeConflictsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDescribeMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(
                _inner,
            ) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMaxConflictFilesException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(
                _inner,
            ) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(
                _inner,
            ) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchDescribeMergeConflictsError {
    fn code(&self) -> Option<&str> {
        BatchDescribeMergeConflictsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDescribeMergeConflictsError {
    pub fn new(kind: BatchDescribeMergeConflictsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDescribeMergeConflictsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDescribeMergeConflictsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_conflict_files_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidMaxConflictFilesException(_)
        )
    }
    pub fn is_invalid_max_merge_hunks_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_)
        )
    }
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidMergeOptionException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::MergeOptionRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for BatchDescribeMergeConflictsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDescribeMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::CommitRequiredException(_inner) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidCommitException(_inner) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(
                _inner,
            ) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMaxConflictFilesException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(
                _inner,
            ) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(
                _inner,
            ) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    pub kind: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind {
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind
    for BatchDisassociateApprovalRuleTemplateFromRepositoriesError
{
    fn code(&self) -> Option<&str> {
        BatchDisassociateApprovalRuleTemplateFromRepositoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    pub fn new(
        kind: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::Unhandled(
                err.into(),
            ),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::Unhandled(
                err.into(),
            ),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyDisabledException(_))
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyNotFoundException(_))
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyUnavailableException(_))
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    pub fn is_maximum_repository_names_exceeded_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_))
    }
    pub fn is_repository_names_required_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::RepositoryNamesRequiredException(_))
    }
}
impl std::error::Error for BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetCommitsError {
    pub kind: BatchGetCommitsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetCommitsErrorKind {
    CommitIdsLimitExceededException(crate::error::CommitIdsLimitExceededException),
    CommitIdsListRequiredException(crate::error::CommitIdsListRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetCommitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetCommitsErrorKind::CommitIdsLimitExceededException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::CommitIdsListRequiredException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetCommitsErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetCommitsError {
    fn code(&self) -> Option<&str> {
        BatchGetCommitsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetCommitsError {
    pub fn new(kind: BatchGetCommitsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetCommitsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetCommitsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_ids_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::CommitIdsLimitExceededException(_)
        )
    }
    pub fn is_commit_ids_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::CommitIdsListRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for BatchGetCommitsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetCommitsErrorKind::CommitIdsLimitExceededException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::CommitIdsListRequiredException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            BatchGetCommitsErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetRepositoriesError {
    pub kind: BatchGetRepositoriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetRepositoriesErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            BatchGetRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            BatchGetRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            BatchGetRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for BatchGetRepositoriesError {
    fn code(&self) -> Option<&str> {
        BatchGetRepositoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetRepositoriesError {
    pub fn new(kind: BatchGetRepositoriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetRepositoriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetRepositoriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_maximum_repository_names_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_)
        )
    }
    pub fn is_repository_names_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::RepositoryNamesRequiredException(_)
        )
    }
}
impl std::error::Error for BatchGetRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            BatchGetRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            BatchGetRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            BatchGetRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            BatchGetRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            BatchGetRepositoriesErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            BatchGetRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) => {
                Some(_inner)
            }
            BatchGetRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) => Some(_inner),
            BatchGetRepositoriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateApprovalRuleTemplateError {
    pub kind: CreateApprovalRuleTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateApprovalRuleTemplateErrorKind {
    ApprovalRuleTemplateContentRequiredException(
        crate::error::ApprovalRuleTemplateContentRequiredException,
    ),
    ApprovalRuleTemplateNameAlreadyExistsException(
        crate::error::ApprovalRuleTemplateNameAlreadyExistsException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    InvalidApprovalRuleTemplateContentException(
        crate::error::InvalidApprovalRuleTemplateContentException,
    ),
    InvalidApprovalRuleTemplateDescriptionException(
        crate::error::InvalidApprovalRuleTemplateDescriptionException,
    ),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    NumberOfRuleTemplatesExceededException(crate::error::NumberOfRuleTemplatesExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateContentException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateDescriptionException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::NumberOfRuleTemplatesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        CreateApprovalRuleTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateApprovalRuleTemplateError {
    pub fn new(kind: CreateApprovalRuleTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateApprovalRuleTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateApprovalRuleTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateContentRequiredException(_)
        )
    }
    pub fn is_approval_rule_template_name_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_)
        )
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_)
        )
    }
    pub fn is_invalid_approval_rule_template_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateContentException(_)
        )
    }
    pub fn is_invalid_approval_rule_template_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateDescriptionException(_)
        )
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
    pub fn is_number_of_rule_templates_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::NumberOfRuleTemplatesExceededException(_)
        )
    }
}
impl std::error::Error for CreateApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateContentRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateContentException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateDescriptionException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::NumberOfRuleTemplatesExceededException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBranchError {
    pub kind: CreateBranchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBranchErrorKind {
    BranchNameExistsException(crate::error::BranchNameExistsException),
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBranchErrorKind::BranchNameExistsException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::CommitIdRequiredException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreateBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateBranchError {
    fn code(&self) -> Option<&str> {
        CreateBranchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBranchError {
    pub fn new(kind: CreateBranchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBranchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBranchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_name_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::BranchNameExistsException(_)
        )
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::BranchNameRequiredException(_)
        )
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::CommitIdRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::InvalidBranchNameException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::InvalidCommitIdException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for CreateBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBranchErrorKind::BranchNameExistsException(_inner) => Some(_inner),
            CreateBranchErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            CreateBranchErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            CreateBranchErrorKind::CommitIdRequiredException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            CreateBranchErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            CreateBranchErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            CreateBranchErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            CreateBranchErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            CreateBranchErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            CreateBranchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCommitError {
    pub kind: CreateCommitErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCommitErrorKind {
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    DirectoryNameConflictsWithFileNameException(
        crate::error::DirectoryNameConflictsWithFileNameException,
    ),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileContentAndSourceFileSpecifiedException(
        crate::error::FileContentAndSourceFileSpecifiedException,
    ),
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    FileEntryRequiredException(crate::error::FileEntryRequiredException),
    FileModeRequiredException(crate::error::FileModeRequiredException),
    FileNameConflictsWithDirectoryNameException(
        crate::error::FileNameConflictsWithDirectoryNameException,
    ),
    FilePathConflictsWithSubmodulePathException(
        crate::error::FilePathConflictsWithSubmodulePathException,
    ),
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidDeletionParameterException(crate::error::InvalidDeletionParameterException),
    InvalidEmailException(crate::error::InvalidEmailException),
    InvalidFileModeException(crate::error::InvalidFileModeException),
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    MaximumFileEntriesExceededException(crate::error::MaximumFileEntriesExceededException),
    NameLengthExceededException(crate::error::NameLengthExceededException),
    NoChangeException(crate::error::NoChangeException),
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    PathRequiredException(crate::error::PathRequiredException),
    PutFileEntryConflictException(crate::error::PutFileEntryConflictException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    RestrictedSourceFileException(crate::error::RestrictedSourceFileException),
    SamePathRequestException(crate::error::SamePathRequestException),
    SourceFileOrContentRequiredException(crate::error::SourceFileOrContentRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCommitErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::DirectoryNameConflictsWithFileNameException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileContentAndSourceFileSpecifiedException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileDoesNotExistException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileEntryRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileModeRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileNameConflictsWithDirectoryNameException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::FilePathConflictsWithSubmodulePathException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidDeletionParameterException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidFileModeException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::MaximumFileEntriesExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::NoChangeException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::PutFileEntryConflictException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::RestrictedSourceFileException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::SamePathRequestException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::SourceFileOrContentRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateCommitError {
    fn code(&self) -> Option<&str> {
        CreateCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCommitError {
    pub fn new(kind: CreateCommitErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCommitErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::BranchDoesNotExistException(_)
        )
    }
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::BranchNameIsTagNameException(_)
        )
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::BranchNameRequiredException(_)
        )
    }
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    pub fn is_directory_name_conflicts_with_file_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::DirectoryNameConflictsWithFileNameException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_content_and_source_file_specified_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileContentAndSourceFileSpecifiedException(_)
        )
    }
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileDoesNotExistException(_)
        )
    }
    pub fn is_file_entry_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileEntryRequiredException(_)
        )
    }
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileModeRequiredException(_)
        )
    }
    pub fn is_file_name_conflicts_with_directory_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileNameConflictsWithDirectoryNameException(_)
        )
    }
    pub fn is_file_path_conflicts_with_submodule_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FilePathConflictsWithSubmodulePathException(_)
        )
    }
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidBranchNameException(_)
        )
    }
    pub fn is_invalid_deletion_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidDeletionParameterException(_)
        )
    }
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(&self.kind, CreateCommitErrorKind::InvalidEmailException(_))
    }
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidFileModeException(_)
        )
    }
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidParentCommitIdException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, CreateCommitErrorKind::InvalidPathException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_maximum_file_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::MaximumFileEntriesExceededException(_)
        )
    }
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::NameLengthExceededException(_)
        )
    }
    pub fn is_no_change_exception(&self) -> bool {
        matches!(&self.kind, CreateCommitErrorKind::NoChangeException(_))
    }
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::ParentCommitDoesNotExistException(_)
        )
    }
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::ParentCommitIdOutdatedException(_)
        )
    }
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::ParentCommitIdRequiredException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, CreateCommitErrorKind::PathRequiredException(_))
    }
    pub fn is_put_file_entry_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::PutFileEntryConflictException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_restricted_source_file_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::RestrictedSourceFileException(_)
        )
    }
    pub fn is_same_path_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::SamePathRequestException(_)
        )
    }
    pub fn is_source_file_or_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::SourceFileOrContentRequiredException(_)
        )
    }
}
impl std::error::Error for CreateCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCommitErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            CreateCommitErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            CreateCommitErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::CommitMessageLengthExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::DirectoryNameConflictsWithFileNameException(_inner) => {
                Some(_inner)
            }
            CreateCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            CreateCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            CreateCommitErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            CreateCommitErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            CreateCommitErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileContentAndSourceFileSpecifiedException(_inner) => {
                Some(_inner)
            }
            CreateCommitErrorKind::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileDoesNotExistException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileEntryRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileModeRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileNameConflictsWithDirectoryNameException(_inner) => {
                Some(_inner)
            }
            CreateCommitErrorKind::FilePathConflictsWithSubmodulePathException(_inner) => {
                Some(_inner)
            }
            CreateCommitErrorKind::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidDeletionParameterException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidEmailException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidFileModeException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidParentCommitIdException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidPathException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            CreateCommitErrorKind::MaximumFileEntriesExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::NoChangeException(_inner) => Some(_inner),
            CreateCommitErrorKind::ParentCommitDoesNotExistException(_inner) => Some(_inner),
            CreateCommitErrorKind::ParentCommitIdOutdatedException(_inner) => Some(_inner),
            CreateCommitErrorKind::ParentCommitIdRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::PathRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::PutFileEntryConflictException(_inner) => Some(_inner),
            CreateCommitErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            CreateCommitErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::RestrictedSourceFileException(_inner) => Some(_inner),
            CreateCommitErrorKind::SamePathRequestException(_inner) => Some(_inner),
            CreateCommitErrorKind::SourceFileOrContentRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePullRequestError {
    pub kind: CreatePullRequestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePullRequestErrorKind {
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    InvalidDescriptionException(crate::error::InvalidDescriptionException),
    InvalidReferenceNameException(crate::error::InvalidReferenceNameException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidTargetException(crate::error::InvalidTargetException),
    InvalidTargetsException(crate::error::InvalidTargetsException),
    InvalidTitleException(crate::error::InvalidTitleException),
    MaximumOpenPullRequestsExceededException(
        crate::error::MaximumOpenPullRequestsExceededException,
    ),
    MultipleRepositoriesInPullRequestException(
        crate::error::MultipleRepositoriesInPullRequestException,
    ),
    ReferenceDoesNotExistException(crate::error::ReferenceDoesNotExistException),
    ReferenceNameRequiredException(crate::error::ReferenceNameRequiredException),
    ReferenceTypeNotSupportedException(crate::error::ReferenceTypeNotSupportedException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    SourceAndDestinationAreSameException(crate::error::SourceAndDestinationAreSameException),
    TargetRequiredException(crate::error::TargetRequiredException),
    TargetsRequiredException(crate::error::TargetsRequiredException),
    TitleRequiredException(crate::error::TitleRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePullRequestErrorKind::ClientRequestTokenRequiredException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::IdempotencyParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::InvalidClientRequestTokenException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidDescriptionException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidReferenceNameException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidTargetException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidTargetsException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidTitleException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::MaximumOpenPullRequestsExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::MultipleRepositoriesInPullRequestException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::ReferenceDoesNotExistException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::ReferenceNameRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::ReferenceTypeNotSupportedException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::SourceAndDestinationAreSameException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::TargetRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::TargetsRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::TitleRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePullRequestError {
    fn code(&self) -> Option<&str> {
        CreatePullRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePullRequestError {
    pub fn new(kind: CreatePullRequestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePullRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePullRequestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::ClientRequestTokenRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::IdempotencyParameterMismatchException(_)
        )
    }
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidClientRequestTokenException(_)
        )
    }
    pub fn is_invalid_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidDescriptionException(_)
        )
    }
    pub fn is_invalid_reference_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidReferenceNameException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_target_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidTargetException(_)
        )
    }
    pub fn is_invalid_targets_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidTargetsException(_)
        )
    }
    pub fn is_invalid_title_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidTitleException(_)
        )
    }
    pub fn is_maximum_open_pull_requests_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::MaximumOpenPullRequestsExceededException(_)
        )
    }
    pub fn is_multiple_repositories_in_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::MultipleRepositoriesInPullRequestException(_)
        )
    }
    pub fn is_reference_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::ReferenceDoesNotExistException(_)
        )
    }
    pub fn is_reference_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::ReferenceNameRequiredException(_)
        )
    }
    pub fn is_reference_type_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::ReferenceTypeNotSupportedException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_source_and_destination_are_same_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::SourceAndDestinationAreSameException(_)
        )
    }
    pub fn is_target_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::TargetRequiredException(_)
        )
    }
    pub fn is_targets_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::TargetsRequiredException(_)
        )
    }
    pub fn is_title_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::TitleRequiredException(_)
        )
    }
}
impl std::error::Error for CreatePullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePullRequestErrorKind::ClientRequestTokenRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::IdempotencyParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::InvalidClientRequestTokenException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidDescriptionException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidReferenceNameException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidTargetException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidTargetsException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidTitleException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::MaximumOpenPullRequestsExceededException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::MultipleRepositoriesInPullRequestException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::ReferenceDoesNotExistException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::ReferenceNameRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::ReferenceTypeNotSupportedException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::SourceAndDestinationAreSameException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::TargetRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::TargetsRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::TitleRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePullRequestApprovalRuleError {
    pub kind: CreatePullRequestApprovalRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePullRequestApprovalRuleErrorKind {
    ApprovalRuleContentRequiredException(crate::error::ApprovalRuleContentRequiredException),
    ApprovalRuleNameAlreadyExistsException(crate::error::ApprovalRuleNameAlreadyExistsException),
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidApprovalRuleContentException(crate::error::InvalidApprovalRuleContentException),
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    NumberOfRulesExceededException(crate::error::NumberOfRulesExceededException),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePullRequestApprovalRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleContentRequiredException(
                _inner,
            ) => _inner.fmt(f),
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameAlreadyExistsException(
                _inner,
            ) => _inner.fmt(f),
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleContentException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::NumberOfRulesExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreatePullRequestApprovalRuleError {
    fn code(&self) -> Option<&str> {
        CreatePullRequestApprovalRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePullRequestApprovalRuleError {
    pub fn new(kind: CreatePullRequestApprovalRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePullRequestApprovalRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePullRequestApprovalRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleContentRequiredException(_)
        )
    }
    pub fn is_approval_rule_name_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameAlreadyExistsException(_)
        )
    }
    pub fn is_approval_rule_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_approval_rule_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleContentException(_)
        )
    }
    pub fn is_invalid_approval_rule_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_number_of_rules_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::NumberOfRulesExceededException(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for CreatePullRequestApprovalRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleContentRequiredException(
                _inner,
            ) => Some(_inner),
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameAlreadyExistsException(
                _inner,
            ) => Some(_inner),
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleContentException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::NumberOfRulesExceededException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRepositoryError {
    pub kind: CreateRepositoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRepositoryErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidRepositoryDescriptionException(crate::error::InvalidRepositoryDescriptionException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    InvalidTagsMapException(crate::error::InvalidTagsMapException),
    RepositoryLimitExceededException(crate::error::RepositoryLimitExceededException),
    RepositoryNameExistsException(crate::error::RepositoryNameExistsException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    TagPolicyException(crate::error::TagPolicyException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreateRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::InvalidRepositoryDescriptionException(_inner) => {
                _inner.fmt(f)
            }
            CreateRepositoryErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::InvalidSystemTagUsageException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::InvalidTagsMapException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::RepositoryLimitExceededException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::RepositoryNameExistsException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::TagPolicyException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateRepositoryError {
    fn code(&self) -> Option<&str> {
        CreateRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRepositoryError {
    pub fn new(kind: CreateRepositoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_repository_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::InvalidRepositoryDescriptionException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_system_tag_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::InvalidSystemTagUsageException(_)
        )
    }
    pub fn is_invalid_tags_map_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::InvalidTagsMapException(_)
        )
    }
    pub fn is_repository_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::RepositoryLimitExceededException(_)
        )
    }
    pub fn is_repository_name_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::RepositoryNameExistsException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(&self.kind, CreateRepositoryErrorKind::TagPolicyException(_))
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for CreateRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            CreateRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::InvalidRepositoryDescriptionException(_inner) => {
                Some(_inner)
            }
            CreateRepositoryErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::InvalidSystemTagUsageException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::InvalidTagsMapException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::RepositoryLimitExceededException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::RepositoryNameExistsException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::TagPolicyException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::TooManyTagsException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUnreferencedMergeCommitError {
    pub kind: CreateUnreferencedMergeCommitErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUnreferencedMergeCommitErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    CommitRequiredException(crate::error::CommitRequiredException),
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    FileModeRequiredException(crate::error::FileModeRequiredException),
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidEmailException(crate::error::InvalidEmailException),
    InvalidFileModeException(crate::error::InvalidFileModeException),
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    NameLengthExceededException(crate::error::NameLengthExceededException),
    PathRequiredException(crate::error::PathRequiredException),
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUnreferencedMergeCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUnreferencedMergeCommitErrorKind::CommitDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::CommitMessageLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::CommitRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::FileContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::FileModeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidCommitException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictDetailLevelException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidEmailException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidFileModeException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidMergeOptionException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidPathException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementContentException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementTypeException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::ManualMergeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MergeOptionRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::NameLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::PathRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::ReplacementContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::ReplacementTypeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::TipsDivergenceExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for CreateUnreferencedMergeCommitError {
    fn code(&self) -> Option<&str> {
        CreateUnreferencedMergeCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUnreferencedMergeCommitError {
    pub fn new(kind: CreateUnreferencedMergeCommitErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUnreferencedMergeCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUnreferencedMergeCommitErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::FileModeRequiredException(_)
        )
    }
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidEmailException(_)
        )
    }
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidFileModeException(_)
        )
    }
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidMergeOptionException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidPathException(_)
        )
    }
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementContentException(_)
        )
    }
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementTypeException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::ManualMergeRequiredException(_)
        )
    }
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateUnreferencedMergeCommitErrorKind::MaximumConflictResolutionEntriesExceededException(_))
    }
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::MergeOptionRequiredException(_)
        )
    }
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::NameLengthExceededException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::PathRequiredException(_)
        )
    }
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::ReplacementContentRequiredException(_)
        )
    }
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for CreateUnreferencedMergeCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUnreferencedMergeCommitErrorKind::CommitDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::CommitMessageLengthExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::CommitRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::FileContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::FileModeRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidCommitException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictDetailLevelException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidEmailException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidFileModeException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidMergeOptionException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidPathException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementContentException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementTypeException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::ManualMergeRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MergeOptionRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::NameLengthExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::PathRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::ReplacementContentRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::ReplacementTypeRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::TipsDivergenceExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApprovalRuleTemplateError {
    pub kind: DeleteApprovalRuleTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApprovalRuleTemplateErrorKind {
    ApprovalRuleTemplateInUseException(crate::error::ApprovalRuleTemplateInUseException),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateInUseException(_inner) => {
                _inner.fmt(f)
            }
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(
                _inner,
            ) => _inner.fmt(f),
            DeleteApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(
                _inner,
            ) => _inner.fmt(f),
            DeleteApprovalRuleTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteApprovalRuleTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApprovalRuleTemplateError {
    pub fn new(kind: DeleteApprovalRuleTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApprovalRuleTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApprovalRuleTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateInUseException(_)
        )
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_)
        )
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
}
impl std::error::Error for DeleteApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateInUseException(_inner) => {
                Some(_inner)
            }
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(
                _inner,
            ) => Some(_inner),
            DeleteApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(
                _inner,
            ) => Some(_inner),
            DeleteApprovalRuleTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBranchError {
    pub kind: DeleteBranchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBranchErrorKind {
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    DefaultBranchCannotBeDeletedException(crate::error::DefaultBranchCannotBeDeletedException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBranchErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::DefaultBranchCannotBeDeletedException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteBranchError {
    fn code(&self) -> Option<&str> {
        DeleteBranchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBranchError {
    pub fn new(kind: DeleteBranchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBranchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBranchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::BranchNameRequiredException(_)
        )
    }
    pub fn is_default_branch_cannot_be_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::DefaultBranchCannotBeDeletedException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::InvalidBranchNameException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for DeleteBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBranchErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            DeleteBranchErrorKind::DefaultBranchCannotBeDeletedException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            DeleteBranchErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            DeleteBranchErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            DeleteBranchErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            DeleteBranchErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            DeleteBranchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCommentContentError {
    pub kind: DeleteCommentContentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCommentContentErrorKind {
    CommentDeletedException(crate::error::CommentDeletedException),
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCommentContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCommentContentErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            DeleteCommentContentErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteCommentContentErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            DeleteCommentContentErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            DeleteCommentContentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteCommentContentError {
    fn code(&self) -> Option<&str> {
        DeleteCommentContentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCommentContentError {
    pub fn new(kind: DeleteCommentContentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCommentContentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCommentContentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCommentContentErrorKind::CommentDeletedException(_)
        )
    }
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCommentContentErrorKind::CommentDoesNotExistException(_)
        )
    }
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCommentContentErrorKind::CommentIdRequiredException(_)
        )
    }
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCommentContentErrorKind::InvalidCommentIdException(_)
        )
    }
}
impl std::error::Error for DeleteCommentContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCommentContentErrorKind::CommentDeletedException(_inner) => Some(_inner),
            DeleteCommentContentErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            DeleteCommentContentErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            DeleteCommentContentErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            DeleteCommentContentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFileError {
    pub kind: DeleteFileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFileErrorKind {
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidEmailException(crate::error::InvalidEmailException),
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    NameLengthExceededException(crate::error::NameLengthExceededException),
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    PathRequiredException(crate::error::PathRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFileErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::FileDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteFileError {
    fn code(&self) -> Option<&str> {
        DeleteFileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFileError {
    pub fn new(kind: DeleteFileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::BranchDoesNotExistException(_)
        )
    }
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::BranchNameIsTagNameException(_)
        )
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::BranchNameRequiredException(_)
        )
    }
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::FileDoesNotExistException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::InvalidBranchNameException(_)
        )
    }
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(&self.kind, DeleteFileErrorKind::InvalidEmailException(_))
    }
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::InvalidParentCommitIdException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, DeleteFileErrorKind::InvalidPathException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::NameLengthExceededException(_)
        )
    }
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::ParentCommitDoesNotExistException(_)
        )
    }
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::ParentCommitIdOutdatedException(_)
        )
    }
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::ParentCommitIdRequiredException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, DeleteFileErrorKind::PathRequiredException(_))
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for DeleteFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFileErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            DeleteFileErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            DeleteFileErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            DeleteFileErrorKind::CommitMessageLengthExceededException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            DeleteFileErrorKind::FileDoesNotExistException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidEmailException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidParentCommitIdException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidPathException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            DeleteFileErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            DeleteFileErrorKind::ParentCommitDoesNotExistException(_inner) => Some(_inner),
            DeleteFileErrorKind::ParentCommitIdOutdatedException(_inner) => Some(_inner),
            DeleteFileErrorKind::ParentCommitIdRequiredException(_inner) => Some(_inner),
            DeleteFileErrorKind::PathRequiredException(_inner) => Some(_inner),
            DeleteFileErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            DeleteFileErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            DeleteFileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePullRequestApprovalRuleError {
    pub kind: DeletePullRequestApprovalRuleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePullRequestApprovalRuleErrorKind {
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    CannotDeleteApprovalRuleFromTemplateException(
        crate::error::CannotDeleteApprovalRuleFromTemplateException,
    ),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePullRequestApprovalRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::CannotDeleteApprovalRuleFromTemplateException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeletePullRequestApprovalRuleError {
    fn code(&self) -> Option<&str> {
        DeletePullRequestApprovalRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePullRequestApprovalRuleError {
    pub fn new(kind: DeletePullRequestApprovalRuleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePullRequestApprovalRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePullRequestApprovalRuleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_)
        )
    }
    pub fn is_cannot_delete_approval_rule_from_template_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::CannotDeleteApprovalRuleFromTemplateException(
                _
            )
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_approval_rule_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for DeletePullRequestApprovalRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::CannotDeleteApprovalRuleFromTemplateException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRepositoryError {
    pub kind: DeleteRepositoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRepositoryErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DeleteRepositoryError {
    fn code(&self) -> Option<&str> {
        DeleteRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRepositoryError {
    pub fn new(kind: DeleteRepositoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for DeleteRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            DeleteRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMergeConflictsError {
    pub kind: DescribeMergeConflictsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMergeConflictsErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitRequiredException(crate::error::CommitRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxMergeHunksException(crate::error::InvalidMaxMergeHunksException),
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    PathRequiredException(crate::error::PathRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMergeConflictsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::FileDoesNotExistException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribeMergeConflictsError {
    fn code(&self) -> Option<&str> {
        DescribeMergeConflictsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMergeConflictsError {
    pub fn new(kind: DescribeMergeConflictsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMergeConflictsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMergeConflictsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::FileDoesNotExistException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_merge_hunks_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_)
        )
    }
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidMergeOptionException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidPathException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::MergeOptionRequiredException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::PathRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for DescribeMergeConflictsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::CommitRequiredException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::FileDoesNotExistException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidCommitException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidPathException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::PathRequiredException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePullRequestEventsError {
    pub kind: DescribePullRequestEventsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePullRequestEventsErrorKind {
    ActorDoesNotExistException(crate::error::ActorDoesNotExistException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidActorArnException(crate::error::InvalidActorArnException),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    InvalidPullRequestEventTypeException(crate::error::InvalidPullRequestEventTypeException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePullRequestEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePullRequestEventsErrorKind::ActorDoesNotExistException(_inner) => _inner.fmt(f),
            DescribePullRequestEventsErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            DescribePullRequestEventsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::InvalidActorArnException(_inner) => _inner.fmt(f),
            DescribePullRequestEventsErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            DescribePullRequestEventsErrorKind::InvalidPullRequestEventTypeException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DescribePullRequestEventsError {
    fn code(&self) -> Option<&str> {
        DescribePullRequestEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePullRequestEventsError {
    pub fn new(kind: DescribePullRequestEventsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePullRequestEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePullRequestEventsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_actor_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::ActorDoesNotExistException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_actor_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidActorArnException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidMaxResultsException(_)
        )
    }
    pub fn is_invalid_pull_request_event_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidPullRequestEventTypeException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for DescribePullRequestEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePullRequestEventsErrorKind::ActorDoesNotExistException(_inner) => Some(_inner),
            DescribePullRequestEventsErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            DescribePullRequestEventsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::InvalidActorArnException(_inner) => Some(_inner),
            DescribePullRequestEventsErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            DescribePullRequestEventsErrorKind::InvalidPullRequestEventTypeException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateApprovalRuleTemplateFromRepositoryError {
    pub kind: DisassociateApprovalRuleTemplateFromRepositoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateApprovalRuleTemplateFromRepositoryErrorKind {
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateApprovalRuleTemplateFromRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for DisassociateApprovalRuleTemplateFromRepositoryError {
    fn code(&self) -> Option<&str> {
        DisassociateApprovalRuleTemplateFromRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateApprovalRuleTemplateFromRepositoryError {
    pub fn new(
        kind: DisassociateApprovalRuleTemplateFromRepositoryErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateApprovalRuleTemplateFromRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateApprovalRuleTemplateFromRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyDisabledException(
                _
            )
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyNotFoundException(
                _
            )
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyUnavailableException(_))
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidRepositoryNameException(
                _
            )
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryDoesNotExistException(_))
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for DisassociateApprovalRuleTemplateFromRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EvaluatePullRequestApprovalRulesError {
    pub kind: EvaluatePullRequestApprovalRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EvaluatePullRequestApprovalRulesErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EvaluatePullRequestApprovalRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(
                _inner,
            ) => _inner.fmt(f),
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            EvaluatePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for EvaluatePullRequestApprovalRulesError {
    fn code(&self) -> Option<&str> {
        EvaluatePullRequestApprovalRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl EvaluatePullRequestApprovalRulesError {
    pub fn new(kind: EvaluatePullRequestApprovalRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EvaluatePullRequestApprovalRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EvaluatePullRequestApprovalRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_)
        )
    }
    pub fn is_revision_not_current_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_)
        )
    }
}
impl std::error::Error for EvaluatePullRequestApprovalRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(
                _inner,
            ) => Some(_inner),
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(
                _inner,
            ) => Some(_inner),
            EvaluatePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApprovalRuleTemplateError {
    pub kind: GetApprovalRuleTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApprovalRuleTemplateErrorKind {
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) => {
                _inner.fmt(f)
            }
            GetApprovalRuleTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        GetApprovalRuleTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApprovalRuleTemplateError {
    pub fn new(kind: GetApprovalRuleTemplateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApprovalRuleTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApprovalRuleTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_)
        )
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_)
        )
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
}
impl std::error::Error for GetApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) => {
                Some(_inner)
            }
            GetApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) => {
                Some(_inner)
            }
            GetApprovalRuleTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBlobError {
    pub kind: GetBlobErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBlobErrorKind {
    BlobIdDoesNotExistException(crate::error::BlobIdDoesNotExistException),
    BlobIdRequiredException(crate::error::BlobIdRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileTooLargeException(crate::error::FileTooLargeException),
    InvalidBlobIdException(crate::error::InvalidBlobIdException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBlobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBlobErrorKind::BlobIdDoesNotExistException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::BlobIdRequiredException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::FileTooLargeException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::InvalidBlobIdException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBlobError {
    fn code(&self) -> Option<&str> {
        GetBlobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBlobError {
    pub fn new(kind: GetBlobErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBlobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBlobErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_blob_id_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, GetBlobErrorKind::BlobIdDoesNotExistException(_))
    }
    pub fn is_blob_id_required_exception(&self) -> bool {
        matches!(&self.kind, GetBlobErrorKind::BlobIdRequiredException(_))
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_too_large_exception(&self) -> bool {
        matches!(&self.kind, GetBlobErrorKind::FileTooLargeException(_))
    }
    pub fn is_invalid_blob_id_exception(&self) -> bool {
        matches!(&self.kind, GetBlobErrorKind::InvalidBlobIdException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetBlobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBlobErrorKind::BlobIdDoesNotExistException(_inner) => Some(_inner),
            GetBlobErrorKind::BlobIdRequiredException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetBlobErrorKind::FileTooLargeException(_inner) => Some(_inner),
            GetBlobErrorKind::InvalidBlobIdException(_inner) => Some(_inner),
            GetBlobErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetBlobErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetBlobErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetBlobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBranchError {
    pub kind: GetBranchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBranchErrorKind {
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBranchErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetBranchError {
    fn code(&self) -> Option<&str> {
        GetBranchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBranchError {
    pub fn new(kind: GetBranchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBranchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBranchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::BranchDoesNotExistException(_)
        )
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::BranchNameRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::InvalidBranchNameException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBranchErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            GetBranchErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetBranchErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            GetBranchErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetBranchErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetBranchErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetBranchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommentError {
    pub kind: GetCommentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentErrorKind {
    CommentDeletedException(crate::error::CommentDeletedException),
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommentErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCommentError {
    fn code(&self) -> Option<&str> {
        GetCommentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentError {
    pub fn new(kind: GetCommentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(&self.kind, GetCommentErrorKind::CommentDeletedException(_))
    }
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::CommentDoesNotExistException(_)
        )
    }
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::CommentIdRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::InvalidCommentIdException(_)
        )
    }
}
impl std::error::Error for GetCommentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommentErrorKind::CommentDeletedException(_inner) => Some(_inner),
            GetCommentErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            GetCommentErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetCommentErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            GetCommentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommentReactionsError {
    pub kind: GetCommentReactionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentReactionsErrorKind {
    CommentDeletedException(crate::error::CommentDeletedException),
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    InvalidReactionUserArnException(crate::error::InvalidReactionUserArnException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommentReactionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommentReactionsErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentReactionsErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::InvalidReactionUserArnException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCommentReactionsError {
    fn code(&self) -> Option<&str> {
        GetCommentReactionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentReactionsError {
    pub fn new(kind: GetCommentReactionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommentReactionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommentReactionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::CommentDeletedException(_)
        )
    }
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::CommentDoesNotExistException(_)
        )
    }
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::CommentIdRequiredException(_)
        )
    }
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::InvalidCommentIdException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::InvalidMaxResultsException(_)
        )
    }
    pub fn is_invalid_reaction_user_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::InvalidReactionUserArnException(_)
        )
    }
}
impl std::error::Error for GetCommentReactionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommentReactionsErrorKind::CommentDeletedException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::InvalidReactionUserArnException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommentsForComparedCommitError {
    pub kind: GetCommentsForComparedCommitErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentsForComparedCommitErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommentsForComparedCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommentsForComparedCommitErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::CommitIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            GetCommentsForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::InvalidCommitIdException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::InvalidMaxResultsException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCommentsForComparedCommitError {
    fn code(&self) -> Option<&str> {
        GetCommentsForComparedCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentsForComparedCommitError {
    pub fn new(kind: GetCommentsForComparedCommitErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommentsForComparedCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommentsForComparedCommitErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::CommitIdRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::InvalidCommitIdException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::InvalidMaxResultsException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetCommentsForComparedCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommentsForComparedCommitErrorKind::CommitDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::CommitIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            GetCommentsForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            GetCommentsForComparedCommitErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::InvalidMaxResultsException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommentsForPullRequestError {
    pub kind: GetCommentsForPullRequestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentsForPullRequestErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommentsForPullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommentsForPullRequestErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::CommitIdRequiredException(_inner) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _inner,
            ) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCommentsForPullRequestError {
    fn code(&self) -> Option<&str> {
        GetCommentsForPullRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentsForPullRequestError {
    pub fn new(kind: GetCommentsForPullRequestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommentsForPullRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommentsForPullRequestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::CommitIdRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidCommitIdException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidMaxResultsException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
}
impl std::error::Error for GetCommentsForPullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommentsForPullRequestErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetCommentsForPullRequestErrorKind::CommitIdRequiredException(_inner) => Some(_inner),
            GetCommentsForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            GetCommentsForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            GetCommentsForPullRequestErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            GetCommentsForPullRequestErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _inner,
            ) => Some(_inner),
            GetCommentsForPullRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommitError {
    pub kind: GetCommitErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommitErrorKind {
    CommitIdDoesNotExistException(crate::error::CommitIdDoesNotExistException),
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommitErrorKind::CommitIdDoesNotExistException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::CommitIdRequiredException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetCommitError {
    fn code(&self) -> Option<&str> {
        GetCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommitError {
    pub fn new(kind: GetCommitErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommitErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_id_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::CommitIdDoesNotExistException(_)
        )
    }
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(&self.kind, GetCommitErrorKind::CommitIdRequiredException(_))
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(&self.kind, GetCommitErrorKind::InvalidCommitIdException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommitErrorKind::CommitIdDoesNotExistException(_inner) => Some(_inner),
            GetCommitErrorKind::CommitIdRequiredException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetCommitErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            GetCommitErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetCommitErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetCommitErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetCommitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDifferencesError {
    pub kind: GetDifferencesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDifferencesErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitRequiredException(crate::error::CommitRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDifferencesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDifferencesErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetDifferencesErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::PathDoesNotExistException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetDifferencesError {
    fn code(&self) -> Option<&str> {
        GetDifferencesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDifferencesError {
    pub fn new(kind: GetDifferencesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDifferencesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDifferencesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidCommitIdException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidMaxResultsException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, GetDifferencesErrorKind::InvalidPathException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_path_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::PathDoesNotExistException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetDifferencesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDifferencesErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetDifferencesErrorKind::CommitRequiredException(_inner) => Some(_inner),
            GetDifferencesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetDifferencesErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetDifferencesErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetDifferencesErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetDifferencesErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidPathException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetDifferencesErrorKind::PathDoesNotExistException(_inner) => Some(_inner),
            GetDifferencesErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetDifferencesErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetDifferencesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFileError {
    pub kind: GetFileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFileErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    FileTooLargeException(crate::error::FileTooLargeException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    PathRequiredException(crate::error::PathRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFileErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetFileErrorKind::FileDoesNotExistException(_inner) => _inner.fmt(f),
            GetFileErrorKind::FileTooLargeException(_inner) => _inner.fmt(f),
            GetFileErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetFileErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            GetFileErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetFileErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            GetFileErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetFileErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetFileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFileError {
    fn code(&self) -> Option<&str> {
        GetFileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFileError {
    pub fn new(kind: GetFileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::CommitDoesNotExistException(_))
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::FileDoesNotExistException(_))
    }
    pub fn is_file_too_large_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::FileTooLargeException(_))
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::InvalidCommitException(_))
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::InvalidPathException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::PathRequiredException(_))
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFileErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetFileErrorKind::FileDoesNotExistException(_inner) => Some(_inner),
            GetFileErrorKind::FileTooLargeException(_inner) => Some(_inner),
            GetFileErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetFileErrorKind::InvalidPathException(_inner) => Some(_inner),
            GetFileErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetFileErrorKind::PathRequiredException(_inner) => Some(_inner),
            GetFileErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetFileErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetFileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFolderError {
    pub kind: GetFolderErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFolderErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FolderDoesNotExistException(crate::error::FolderDoesNotExistException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    PathRequiredException(crate::error::PathRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFolderErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::FolderDoesNotExistException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetFolderError {
    fn code(&self) -> Option<&str> {
        GetFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFolderError {
    pub fn new(kind: GetFolderErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFolderErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_folder_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::FolderDoesNotExistException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(&self.kind, GetFolderErrorKind::InvalidCommitException(_))
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, GetFolderErrorKind::InvalidPathException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, GetFolderErrorKind::PathRequiredException(_))
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFolderErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetFolderErrorKind::FolderDoesNotExistException(_inner) => Some(_inner),
            GetFolderErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetFolderErrorKind::InvalidPathException(_inner) => Some(_inner),
            GetFolderErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetFolderErrorKind::PathRequiredException(_inner) => Some(_inner),
            GetFolderErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetFolderErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetFolderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMergeCommitError {
    pub kind: GetMergeCommitErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMergeCommitErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitRequiredException(crate::error::CommitRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMergeCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMergeCommitErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeCommitErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMergeCommitError {
    fn code(&self) -> Option<&str> {
        GetMergeCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMergeCommitError {
    pub fn new(kind: GetMergeCommitErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMergeCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMergeCommitErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetMergeCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMergeCommitErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::CommitRequiredException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            GetMergeCommitErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMergeConflictsError {
    pub kind: GetMergeConflictsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMergeConflictsErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitRequiredException(crate::error::CommitRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidDestinationCommitSpecifierException(
        crate::error::InvalidDestinationCommitSpecifierException,
    ),
    InvalidMaxConflictFilesException(crate::error::InvalidMaxConflictFilesException),
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidSourceCommitSpecifierException(crate::error::InvalidSourceCommitSpecifierException),
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMergeConflictsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidDestinationCommitSpecifierException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::InvalidMaxConflictFilesException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidSourceCommitSpecifierException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMergeConflictsError {
    fn code(&self) -> Option<&str> {
        GetMergeConflictsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMergeConflictsError {
    pub fn new(kind: GetMergeConflictsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMergeConflictsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMergeConflictsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_destination_commit_specifier_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidDestinationCommitSpecifierException(_)
        )
    }
    pub fn is_invalid_max_conflict_files_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidMaxConflictFilesException(_)
        )
    }
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidMergeOptionException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_source_commit_specifier_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidSourceCommitSpecifierException(_)
        )
    }
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::MergeOptionRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for GetMergeConflictsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::CommitRequiredException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidDestinationCommitSpecifierException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::InvalidMaxConflictFilesException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidSourceCommitSpecifierException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMergeOptionsError {
    pub kind: GetMergeOptionsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMergeOptionsErrorKind {
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitRequiredException(crate::error::CommitRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMergeOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMergeOptionsErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeOptionsErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeOptionsErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeOptionsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeOptionsErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetMergeOptionsError {
    fn code(&self) -> Option<&str> {
        GetMergeOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMergeOptionsError {
    pub fn new(kind: GetMergeOptionsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMergeOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMergeOptionsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for GetMergeOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMergeOptionsErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::CommitRequiredException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetMergeOptionsErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            GetMergeOptionsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            GetMergeOptionsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            GetMergeOptionsErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::TipsDivergenceExceededException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPullRequestError {
    pub kind: GetPullRequestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPullRequestErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPullRequestError {
    fn code(&self) -> Option<&str> {
        GetPullRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPullRequestError {
    pub fn new(kind: GetPullRequestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPullRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPullRequestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for GetPullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetPullRequestErrorKind::InvalidPullRequestIdException(_inner) => Some(_inner),
            GetPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => Some(_inner),
            GetPullRequestErrorKind::PullRequestIdRequiredException(_inner) => Some(_inner),
            GetPullRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPullRequestApprovalStatesError {
    pub kind: GetPullRequestApprovalStatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPullRequestApprovalStatesErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPullRequestApprovalStatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPullRequestApprovalStatesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::InvalidRevisionIdException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::RevisionIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPullRequestApprovalStatesError {
    fn code(&self) -> Option<&str> {
        GetPullRequestApprovalStatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPullRequestApprovalStatesError {
    pub fn new(kind: GetPullRequestApprovalStatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPullRequestApprovalStatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPullRequestApprovalStatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::InvalidRevisionIdException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::RevisionIdRequiredException(_)
        )
    }
}
impl std::error::Error for GetPullRequestApprovalStatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPullRequestApprovalStatesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::InvalidRevisionIdException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::RevisionIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPullRequestOverrideStateError {
    pub kind: GetPullRequestOverrideStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPullRequestOverrideStateErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPullRequestOverrideStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPullRequestOverrideStateErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            GetPullRequestOverrideStateErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::InvalidRevisionIdException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::RevisionIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetPullRequestOverrideStateError {
    fn code(&self) -> Option<&str> {
        GetPullRequestOverrideStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPullRequestOverrideStateError {
    pub fn new(kind: GetPullRequestOverrideStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPullRequestOverrideStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPullRequestOverrideStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::InvalidRevisionIdException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::RevisionIdRequiredException(_)
        )
    }
}
impl std::error::Error for GetPullRequestOverrideStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPullRequestOverrideStateErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            GetPullRequestOverrideStateErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::InvalidRevisionIdException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::RevisionIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRepositoryError {
    pub kind: GetRepositoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRepositoryErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRepositoryError {
    fn code(&self) -> Option<&str> {
        GetRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRepositoryError {
    pub fn new(kind: GetRepositoryErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetRepositoryErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetRepositoryErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetRepositoryErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetRepositoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRepositoryTriggersError {
    pub kind: GetRepositoryTriggersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRepositoryTriggersErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for GetRepositoryTriggersError {
    fn code(&self) -> Option<&str> {
        GetRepositoryTriggersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRepositoryTriggersError {
    pub fn new(kind: GetRepositoryTriggersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRepositoryTriggersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRepositoryTriggersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetRepositoryTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListApprovalRuleTemplatesError {
    pub kind: ListApprovalRuleTemplatesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListApprovalRuleTemplatesErrorKind {
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListApprovalRuleTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListApprovalRuleTemplatesErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            ListApprovalRuleTemplatesErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            ListApprovalRuleTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListApprovalRuleTemplatesError {
    fn code(&self) -> Option<&str> {
        ListApprovalRuleTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListApprovalRuleTemplatesError {
    pub fn new(kind: ListApprovalRuleTemplatesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListApprovalRuleTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListApprovalRuleTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApprovalRuleTemplatesErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApprovalRuleTemplatesErrorKind::InvalidMaxResultsException(_)
        )
    }
}
impl std::error::Error for ListApprovalRuleTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListApprovalRuleTemplatesErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            ListApprovalRuleTemplatesErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            ListApprovalRuleTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssociatedApprovalRuleTemplatesForRepositoryError {
    pub kind: ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssociatedApprovalRuleTemplatesForRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidContinuationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidMaxResultsException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind
    for ListAssociatedApprovalRuleTemplatesForRepositoryError
{
    fn code(&self) -> Option<&str> {
        ListAssociatedApprovalRuleTemplatesForRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssociatedApprovalRuleTemplatesForRepositoryError {
    pub fn new(
        kind: ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyDisabledException(_))
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyNotFoundException(_))
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyUnavailableException(_))
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidContinuationTokenException(_))
    }
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidMaxResultsException(
                _
            )
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidRepositoryNameException(_))
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryDoesNotExistException(_))
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for ListAssociatedApprovalRuleTemplatesForRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidContinuationTokenException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidMaxResultsException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBranchesError {
    pub kind: ListBranchesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBranchesErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBranchesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBranchesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            ListBranchesErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListBranchesError {
    fn code(&self) -> Option<&str> {
        ListBranchesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBranchesError {
    pub fn new(kind: ListBranchesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBranchesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBranchesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for ListBranchesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBranchesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            ListBranchesErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            ListBranchesErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            ListBranchesErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            ListBranchesErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            ListBranchesErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            ListBranchesErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            ListBranchesErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            ListBranchesErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            ListBranchesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPullRequestsError {
    pub kind: ListPullRequestsErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPullRequestsErrorKind {
    AuthorDoesNotExistException(crate::error::AuthorDoesNotExistException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidAuthorArnException(crate::error::InvalidAuthorArnException),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    InvalidPullRequestStatusException(crate::error::InvalidPullRequestStatusException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPullRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPullRequestsErrorKind::AuthorDoesNotExistException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            ListPullRequestsErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidAuthorArnException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidPullRequestStatusException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListPullRequestsError {
    fn code(&self) -> Option<&str> {
        ListPullRequestsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPullRequestsError {
    pub fn new(kind: ListPullRequestsErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPullRequestsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPullRequestsErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_author_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::AuthorDoesNotExistException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_author_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidAuthorArnException(_)
        )
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidMaxResultsException(_)
        )
    }
    pub fn is_invalid_pull_request_status_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidPullRequestStatusException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for ListPullRequestsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPullRequestsErrorKind::AuthorDoesNotExistException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            ListPullRequestsErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidAuthorArnException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidPullRequestStatusException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRepositoriesError {
    pub kind: ListRepositoriesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRepositoriesErrorKind {
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidOrderException(crate::error::InvalidOrderException),
    InvalidSortByException(crate::error::InvalidSortByException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRepositoriesErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            ListRepositoriesErrorKind::InvalidOrderException(_inner) => _inner.fmt(f),
            ListRepositoriesErrorKind::InvalidSortByException(_inner) => _inner.fmt(f),
            ListRepositoriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRepositoriesError {
    fn code(&self) -> Option<&str> {
        ListRepositoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRepositoriesError {
    pub fn new(kind: ListRepositoriesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRepositoriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRepositoriesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_order_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesErrorKind::InvalidOrderException(_)
        )
    }
    pub fn is_invalid_sort_by_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesErrorKind::InvalidSortByException(_)
        )
    }
}
impl std::error::Error for ListRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRepositoriesErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            ListRepositoriesErrorKind::InvalidOrderException(_inner) => Some(_inner),
            ListRepositoriesErrorKind::InvalidSortByException(_inner) => Some(_inner),
            ListRepositoriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRepositoriesForApprovalRuleTemplateError {
    pub kind: ListRepositoriesForApprovalRuleTemplateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRepositoriesForApprovalRuleTemplateErrorKind {
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRepositoriesForApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidContinuationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidMaxResultsException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListRepositoriesForApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        ListRepositoriesForApprovalRuleTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRepositoriesForApprovalRuleTemplateError {
    pub fn new(
        kind: ListRepositoriesForApprovalRuleTemplateErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRepositoriesForApprovalRuleTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRepositoriesForApprovalRuleTemplateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidContinuationTokenException(_)
        )
    }
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidMaxResultsException(_)
        )
    }
}
impl std::error::Error for ListRepositoriesForApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidContinuationTokenException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidMaxResultsException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    pub kind: ListTagsForResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidResourceArnException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    pub fn new(kind: ListTagsForResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_resource_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidResourceArnException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceArnRequiredException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidResourceArnException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceArnRequiredException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergeBranchesByFastForwardError {
    pub kind: MergeBranchesByFastForwardErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergeBranchesByFastForwardErrorKind {
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitRequiredException(crate::error::CommitRequiredException),
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergeBranchesByFastForwardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergeBranchesByFastForwardErrorKind::BranchDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::BranchNameIsTagNameException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::BranchNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByFastForwardErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::InvalidBranchNameException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            MergeBranchesByFastForwardErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::InvalidTargetBranchException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::ManualMergeRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for MergeBranchesByFastForwardError {
    fn code(&self) -> Option<&str> {
        MergeBranchesByFastForwardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergeBranchesByFastForwardError {
    pub fn new(kind: MergeBranchesByFastForwardErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergeBranchesByFastForwardErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergeBranchesByFastForwardErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::BranchDoesNotExistException(_)
        )
    }
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::BranchNameIsTagNameException(_)
        )
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::BranchNameRequiredException(_)
        )
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::InvalidBranchNameException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_target_branch_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::InvalidTargetBranchException(_)
        )
    }
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::ManualMergeRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergeBranchesByFastForwardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergeBranchesByFastForwardErrorKind::BranchDoesNotExistException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::BranchNameIsTagNameException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::BranchNameRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::CommitDoesNotExistException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::CommitRequiredException(_inner) => Some(_inner),
            MergeBranchesByFastForwardErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            MergeBranchesByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            MergeBranchesByFastForwardErrorKind::InvalidCommitException(_inner) => Some(_inner),
            MergeBranchesByFastForwardErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::InvalidTargetBranchException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::ManualMergeRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::TipsDivergenceExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergeBranchesBySquashError {
    pub kind: MergeBranchesBySquashErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergeBranchesBySquashErrorKind {
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    CommitRequiredException(crate::error::CommitRequiredException),
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    FileModeRequiredException(crate::error::FileModeRequiredException),
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidEmailException(crate::error::InvalidEmailException),
    InvalidFileModeException(crate::error::InvalidFileModeException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    NameLengthExceededException(crate::error::NameLengthExceededException),
    PathRequiredException(crate::error::PathRequiredException),
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergeBranchesBySquashError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergeBranchesBySquashErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::CommitMessageLengthExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::FileContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::FileModeRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::FolderContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidFileModeException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidReplacementContentException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidReplacementTypeException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidTargetBranchException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::MultipleConflictResolutionEntriesException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::ReplacementContentRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::ReplacementTypeRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for MergeBranchesBySquashError {
    fn code(&self) -> Option<&str> {
        MergeBranchesBySquashError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergeBranchesBySquashError {
    pub fn new(kind: MergeBranchesBySquashErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergeBranchesBySquashErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergeBranchesBySquashErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::BranchDoesNotExistException(_)
        )
    }
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::BranchNameIsTagNameException(_)
        )
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::BranchNameRequiredException(_)
        )
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::FileModeRequiredException(_)
        )
    }
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidBranchNameException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidEmailException(_)
        )
    }
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidFileModeException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidPathException(_)
        )
    }
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidReplacementContentException(_)
        )
    }
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidReplacementTypeException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_target_branch_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidTargetBranchException(_)
        )
    }
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::ManualMergeRequiredException(_)
        )
    }
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::NameLengthExceededException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::PathRequiredException(_)
        )
    }
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::ReplacementContentRequiredException(_)
        )
    }
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergeBranchesBySquashError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergeBranchesBySquashErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::CommitMessageLengthExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::CommitRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::FileContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::FileModeRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::FolderContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidCommitException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidConflictDetailLevelException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidEmailException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidFileModeException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidPathException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidReplacementContentException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidReplacementTypeException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidTargetBranchException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::ManualMergeRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(
                _inner,
            ) => Some(_inner),
            MergeBranchesBySquashErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::MultipleConflictResolutionEntriesException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::PathRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::ReplacementContentRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::ReplacementTypeRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::TipsDivergenceExceededException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergeBranchesByThreeWayError {
    pub kind: MergeBranchesByThreeWayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergeBranchesByThreeWayErrorKind {
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    CommitRequiredException(crate::error::CommitRequiredException),
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    FileModeRequiredException(crate::error::FileModeRequiredException),
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidCommitException(crate::error::InvalidCommitException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidEmailException(crate::error::InvalidEmailException),
    InvalidFileModeException(crate::error::InvalidFileModeException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    NameLengthExceededException(crate::error::NameLengthExceededException),
    PathRequiredException(crate::error::PathRequiredException),
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergeBranchesByThreeWayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergeBranchesByThreeWayErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::CommitMessageLengthExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::FileContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::FileModeRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::FolderContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionStrategyException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidFileModeException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidReplacementContentException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidReplacementTypeException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidTargetBranchException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::MultipleConflictResolutionEntriesException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::ReplacementContentRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::ReplacementTypeRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for MergeBranchesByThreeWayError {
    fn code(&self) -> Option<&str> {
        MergeBranchesByThreeWayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergeBranchesByThreeWayError {
    pub fn new(kind: MergeBranchesByThreeWayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergeBranchesByThreeWayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergeBranchesByThreeWayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::BranchDoesNotExistException(_)
        )
    }
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::BranchNameIsTagNameException(_)
        )
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::BranchNameRequiredException(_)
        )
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::CommitRequiredException(_)
        )
    }
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::FileModeRequiredException(_)
        )
    }
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidBranchNameException(_)
        )
    }
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidCommitException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidEmailException(_)
        )
    }
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidFileModeException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidPathException(_)
        )
    }
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidReplacementContentException(_)
        )
    }
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidReplacementTypeException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_target_branch_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidTargetBranchException(_)
        )
    }
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::ManualMergeRequiredException(_)
        )
    }
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::NameLengthExceededException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::PathRequiredException(_)
        )
    }
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::ReplacementContentRequiredException(_)
        )
    }
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergeBranchesByThreeWayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergeBranchesByThreeWayErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::CommitMessageLengthExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::CommitRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::FileContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::FileModeRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::FolderContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidCommitException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidConflictDetailLevelException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionStrategyException(
                _inner,
            ) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidEmailException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidFileModeException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidPathException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidReplacementContentException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidReplacementTypeException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidTargetBranchException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::ManualMergeRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(
                _inner,
            ) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::MultipleConflictResolutionEntriesException(
                _inner,
            ) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::PathRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::ReplacementContentRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::ReplacementTypeRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::TipsDivergenceExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergePullRequestByFastForwardError {
    pub kind: MergePullRequestByFastForwardErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestByFastForwardErrorKind {
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestApprovalRulesNotSatisfiedException(
        crate::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    ReferenceDoesNotExistException(crate::error::ReferenceDoesNotExistException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    TipOfSourceReferenceIsDifferentException(
        crate::error::TipOfSourceReferenceIsDifferentException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergePullRequestByFastForwardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergePullRequestByFastForwardErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidCommitIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::ManualMergeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::ReferenceDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for MergePullRequestByFastForwardError {
    fn code(&self) -> Option<&str> {
        MergePullRequestByFastForwardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestByFastForwardError {
    pub fn new(kind: MergePullRequestByFastForwardErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergePullRequestByFastForwardErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergePullRequestByFastForwardErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::InvalidCommitIdException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::ManualMergeRequiredException(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::PullRequestApprovalRulesNotSatisfiedException(
                _
            )
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_reference_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::ReferenceDoesNotExistException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _
            )
        )
    }
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::TipOfSourceReferenceIsDifferentException(_)
        )
    }
}
impl std::error::Error for MergePullRequestByFastForwardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergePullRequestByFastForwardErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidCommitIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::ManualMergeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::ReferenceDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergePullRequestBySquashError {
    pub kind: MergePullRequestBySquashErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestBySquashErrorKind {
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidEmailException(crate::error::InvalidEmailException),
    InvalidFileModeException(crate::error::InvalidFileModeException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    NameLengthExceededException(crate::error::NameLengthExceededException),
    PathRequiredException(crate::error::PathRequiredException),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestApprovalRulesNotSatisfiedException(
        crate::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    TipOfSourceReferenceIsDifferentException(
        crate::error::TipOfSourceReferenceIsDifferentException,
    ),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergePullRequestBySquashError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergePullRequestBySquashErrorKind::CommitMessageLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::FileContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidCommitIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictDetailLevelException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidEmailException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidFileModeException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidPathException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidReplacementContentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidReplacementTypeException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::ManualMergeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::NameLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PathRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::ReplacementContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::ReplacementTypeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::TipsDivergenceExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for MergePullRequestBySquashError {
    fn code(&self) -> Option<&str> {
        MergePullRequestBySquashError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestBySquashError {
    pub fn new(kind: MergePullRequestBySquashErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergePullRequestBySquashErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergePullRequestBySquashErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidCommitIdException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidEmailException(_)
        )
    }
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidFileModeException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidPathException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidReplacementContentException(_)
        )
    }
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidReplacementTypeException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::ManualMergeRequiredException(_)
        )
    }
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::NameLengthExceededException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PathRequiredException(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PullRequestApprovalRulesNotSatisfiedException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::ReplacementContentRequiredException(_)
        )
    }
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::TipOfSourceReferenceIsDifferentException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergePullRequestBySquashError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergePullRequestBySquashErrorKind::CommitMessageLengthExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::FileContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidCommitIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictDetailLevelException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidEmailException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidFileModeException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidPathException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidReplacementContentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidReplacementTypeException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::ManualMergeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::NameLengthExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PathRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::ReplacementContentRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::ReplacementTypeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::TipsDivergenceExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergePullRequestByThreeWayError {
    pub kind: MergePullRequestByThreeWayErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestByThreeWayErrorKind {
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    InvalidEmailException(crate::error::InvalidEmailException),
    InvalidFileModeException(crate::error::InvalidFileModeException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    NameLengthExceededException(crate::error::NameLengthExceededException),
    PathRequiredException(crate::error::PathRequiredException),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestApprovalRulesNotSatisfiedException(
        crate::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    TipOfSourceReferenceIsDifferentException(
        crate::error::TipOfSourceReferenceIsDifferentException,
    ),
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergePullRequestByThreeWayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergePullRequestByThreeWayErrorKind::CommitMessageLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::FileContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidCommitIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictDetailLevelException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidEmailException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidFileModeException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidPathException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementContentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementTypeException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::ManualMergeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::NameLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PathRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::ReplacementContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::ReplacementTypeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::TipsDivergenceExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for MergePullRequestByThreeWayError {
    fn code(&self) -> Option<&str> {
        MergePullRequestByThreeWayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestByThreeWayError {
    pub fn new(kind: MergePullRequestByThreeWayErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergePullRequestByThreeWayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergePullRequestByThreeWayErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidCommitIdException(_)
        )
    }
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionException(_)
        )
    }
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidEmailException(_)
        )
    }
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidFileModeException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidPathException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementContentException(_)
        )
    }
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementTypeException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::ManualMergeRequiredException(_)
        )
    }
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(
                _
            )
        )
    }
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::NameLengthExceededException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PathRequiredException(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PullRequestApprovalRulesNotSatisfiedException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::ReplacementContentRequiredException(_)
        )
    }
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::TipOfSourceReferenceIsDifferentException(_)
        )
    }
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergePullRequestByThreeWayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergePullRequestByThreeWayErrorKind::CommitMessageLengthExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::FileContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidCommitIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictDetailLevelException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidEmailException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidFileModeException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidPathException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementContentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementTypeException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::ManualMergeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::NameLengthExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PathRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::ReplacementContentRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::ReplacementTypeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::TipsDivergenceExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct OverridePullRequestApprovalRulesError {
    pub kind: OverridePullRequestApprovalRulesErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum OverridePullRequestApprovalRulesErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidOverrideStatusException(crate::error::InvalidOverrideStatusException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    OverrideAlreadySetException(crate::error::OverrideAlreadySetException),
    OverrideStatusRequiredException(crate::error::OverrideStatusRequiredException),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for OverridePullRequestApprovalRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            OverridePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(
                _inner,
            ) => _inner.fmt(f),
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            OverridePullRequestApprovalRulesErrorKind::InvalidOverrideStatusException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::OverrideAlreadySetException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::OverrideStatusRequiredException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::PullRequestAlreadyClosedException(
                _inner,
            ) => _inner.fmt(f),
            OverridePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for OverridePullRequestApprovalRulesError {
    fn code(&self) -> Option<&str> {
        OverridePullRequestApprovalRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl OverridePullRequestApprovalRulesError {
    pub fn new(kind: OverridePullRequestApprovalRulesErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: OverridePullRequestApprovalRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: OverridePullRequestApprovalRulesErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_override_status_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::InvalidOverrideStatusException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_)
        )
    }
    pub fn is_override_already_set_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::OverrideAlreadySetException(_)
        )
    }
    pub fn is_override_status_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::OverrideStatusRequiredException(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_)
        )
    }
    pub fn is_revision_not_current_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_)
        )
    }
}
impl std::error::Error for OverridePullRequestApprovalRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            OverridePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(
                _inner,
            ) => Some(_inner),
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(
                _inner,
            ) => Some(_inner),
            OverridePullRequestApprovalRulesErrorKind::InvalidOverrideStatusException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::OverrideAlreadySetException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::OverrideStatusRequiredException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::PullRequestAlreadyClosedException(
                _inner,
            ) => Some(_inner),
            OverridePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PostCommentForComparedCommitError {
    pub kind: PostCommentForComparedCommitErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PostCommentForComparedCommitErrorKind {
    BeforeCommitIdAndAfterCommitIdAreSameException(
        crate::error::BeforeCommitIdAndAfterCommitIdAreSameException,
    ),
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidFileLocationException(crate::error::InvalidFileLocationException),
    InvalidFilePositionException(crate::error::InvalidFilePositionException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidRelativeFileVersionEnumException(crate::error::InvalidRelativeFileVersionEnumException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    PathRequiredException(crate::error::PathRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PostCommentForComparedCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PostCommentForComparedCommitErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::ClientRequestTokenRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::CommentContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::CommentContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::CommitDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::CommitIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::IdempotencyParameterMismatchException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidClientRequestTokenException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidCommitIdException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidFileLocationException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidFilePositionException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidPathException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidRelativeFileVersionEnumException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::PathDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::PathRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PostCommentForComparedCommitError {
    fn code(&self) -> Option<&str> {
        PostCommentForComparedCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PostCommentForComparedCommitError {
    pub fn new(kind: PostCommentForComparedCommitErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PostCommentForComparedCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PostCommentForComparedCommitErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_before_commit_id_and_after_commit_id_are_same_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(
                _
            )
        )
    }
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::ClientRequestTokenRequiredException(_)
        )
    }
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::CommentContentRequiredException(_)
        )
    }
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::CommentContentSizeLimitExceededException(_)
        )
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::CommitIdRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::IdempotencyParameterMismatchException(_)
        )
    }
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidClientRequestTokenException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidCommitIdException(_)
        )
    }
    pub fn is_invalid_file_location_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidFileLocationException(_)
        )
    }
    pub fn is_invalid_file_position_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidFilePositionException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidPathException(_)
        )
    }
    pub fn is_invalid_relative_file_version_enum_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidRelativeFileVersionEnumException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_path_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::PathDoesNotExistException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::PathRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for PostCommentForComparedCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PostCommentForComparedCommitErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::ClientRequestTokenRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::CommentContentRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::CommentContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::CommitDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::CommitIdRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::IdempotencyParameterMismatchException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidClientRequestTokenException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidCommitIdException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidFileLocationException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidFilePositionException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidPathException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidRelativeFileVersionEnumException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::PathDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::PathRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PostCommentForPullRequestError {
    pub kind: PostCommentForPullRequestErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PostCommentForPullRequestErrorKind {
    BeforeCommitIdAndAfterCommitIdAreSameException(
        crate::error::BeforeCommitIdAndAfterCommitIdAreSameException,
    ),
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    InvalidFileLocationException(crate::error::InvalidFileLocationException),
    InvalidFilePositionException(crate::error::InvalidFilePositionException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidRelativeFileVersionEnumException(crate::error::InvalidRelativeFileVersionEnumException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    PathRequiredException(crate::error::PathRequiredException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PostCommentForPullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PostCommentForPullRequestErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(
                _inner,
            ) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::ClientRequestTokenRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::CommentContentRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::CommentContentSizeLimitExceededException(
                _inner,
            ) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::CommitIdRequiredException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::IdempotencyParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidClientRequestTokenException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::InvalidFileLocationException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidFilePositionException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidRelativeFileVersionEnumException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::PathDoesNotExistException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _inner,
            ) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PostCommentForPullRequestError {
    fn code(&self) -> Option<&str> {
        PostCommentForPullRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PostCommentForPullRequestError {
    pub fn new(kind: PostCommentForPullRequestErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PostCommentForPullRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PostCommentForPullRequestErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_before_commit_id_and_after_commit_id_are_same_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(_)
        )
    }
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::ClientRequestTokenRequiredException(_)
        )
    }
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::CommentContentRequiredException(_)
        )
    }
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::CommentContentSizeLimitExceededException(_)
        )
    }
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::CommitDoesNotExistException(_)
        )
    }
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::CommitIdRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::IdempotencyParameterMismatchException(_)
        )
    }
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidClientRequestTokenException(_)
        )
    }
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidCommitIdException(_)
        )
    }
    pub fn is_invalid_file_location_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidFileLocationException(_)
        )
    }
    pub fn is_invalid_file_position_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidFilePositionException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidPathException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_relative_file_version_enum_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidRelativeFileVersionEnumException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_path_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::PathDoesNotExistException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::PathRequiredException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
}
impl std::error::Error for PostCommentForPullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PostCommentForPullRequestErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(
                _inner,
            ) => Some(_inner),
            PostCommentForPullRequestErrorKind::ClientRequestTokenRequiredException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::CommentContentRequiredException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::CommentContentSizeLimitExceededException(
                _inner,
            ) => Some(_inner),
            PostCommentForPullRequestErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::CommitIdRequiredException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            PostCommentForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::IdempotencyParameterMismatchException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidClientRequestTokenException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::InvalidFileLocationException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidFilePositionException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidPathException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidRelativeFileVersionEnumException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::PathDoesNotExistException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::PathRequiredException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _inner,
            ) => Some(_inner),
            PostCommentForPullRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PostCommentReplyError {
    pub kind: PostCommentReplyErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PostCommentReplyErrorKind {
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PostCommentReplyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PostCommentReplyErrorKind::ClientRequestTokenRequiredException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::CommentContentRequiredException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::CommentContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentReplyErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::IdempotencyParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentReplyErrorKind::InvalidClientRequestTokenException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PostCommentReplyError {
    fn code(&self) -> Option<&str> {
        PostCommentReplyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PostCommentReplyError {
    pub fn new(kind: PostCommentReplyErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PostCommentReplyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PostCommentReplyErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::ClientRequestTokenRequiredException(_)
        )
    }
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::CommentContentRequiredException(_)
        )
    }
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::CommentContentSizeLimitExceededException(_)
        )
    }
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::CommentDoesNotExistException(_)
        )
    }
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::CommentIdRequiredException(_)
        )
    }
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::IdempotencyParameterMismatchException(_)
        )
    }
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::InvalidClientRequestTokenException(_)
        )
    }
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::InvalidCommentIdException(_)
        )
    }
}
impl std::error::Error for PostCommentReplyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PostCommentReplyErrorKind::ClientRequestTokenRequiredException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::CommentContentRequiredException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::CommentContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            PostCommentReplyErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::IdempotencyParameterMismatchException(_inner) => {
                Some(_inner)
            }
            PostCommentReplyErrorKind::InvalidClientRequestTokenException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutCommentReactionError {
    pub kind: PutCommentReactionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutCommentReactionErrorKind {
    CommentDeletedException(crate::error::CommentDeletedException),
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    InvalidReactionValueException(crate::error::InvalidReactionValueException),
    ReactionLimitExceededException(crate::error::ReactionLimitExceededException),
    ReactionValueRequiredException(crate::error::ReactionValueRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutCommentReactionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutCommentReactionErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::InvalidReactionValueException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::ReactionLimitExceededException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::ReactionValueRequiredException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutCommentReactionError {
    fn code(&self) -> Option<&str> {
        PutCommentReactionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutCommentReactionError {
    pub fn new(kind: PutCommentReactionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutCommentReactionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutCommentReactionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::CommentDeletedException(_)
        )
    }
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::CommentDoesNotExistException(_)
        )
    }
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::CommentIdRequiredException(_)
        )
    }
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::InvalidCommentIdException(_)
        )
    }
    pub fn is_invalid_reaction_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::InvalidReactionValueException(_)
        )
    }
    pub fn is_reaction_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::ReactionLimitExceededException(_)
        )
    }
    pub fn is_reaction_value_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::ReactionValueRequiredException(_)
        )
    }
}
impl std::error::Error for PutCommentReactionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutCommentReactionErrorKind::CommentDeletedException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::InvalidReactionValueException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::ReactionLimitExceededException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::ReactionValueRequiredException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutFileError {
    pub kind: PutFileErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFileErrorKind {
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    DirectoryNameConflictsWithFileNameException(
        crate::error::DirectoryNameConflictsWithFileNameException,
    ),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    FileContentRequiredException(crate::error::FileContentRequiredException),
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    FileNameConflictsWithDirectoryNameException(
        crate::error::FileNameConflictsWithDirectoryNameException,
    ),
    FilePathConflictsWithSubmodulePathException(
        crate::error::FilePathConflictsWithSubmodulePathException,
    ),
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidDeletionParameterException(crate::error::InvalidDeletionParameterException),
    InvalidEmailException(crate::error::InvalidEmailException),
    InvalidFileModeException(crate::error::InvalidFileModeException),
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    InvalidPathException(crate::error::InvalidPathException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    NameLengthExceededException(crate::error::NameLengthExceededException),
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    PathRequiredException(crate::error::PathRequiredException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    SameFileContentException(crate::error::SameFileContentException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutFileErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            PutFileErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            PutFileErrorKind::DirectoryNameConflictsWithFileNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FileContentRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FileNameConflictsWithDirectoryNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FilePathConflictsWithSubmodulePathException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidDeletionParameterException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidFileModeException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            PutFileErrorKind::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            PutFileErrorKind::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            PutFileErrorKind::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            PutFileErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::SameFileContentException(_inner) => _inner.fmt(f),
            PutFileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutFileError {
    fn code(&self) -> Option<&str> {
        PutFileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutFileError {
    pub fn new(kind: PutFileErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutFileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutFileErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::BranchDoesNotExistException(_))
    }
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::BranchNameIsTagNameException(_)
        )
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::BranchNameRequiredException(_))
    }
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    pub fn is_directory_name_conflicts_with_file_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::DirectoryNameConflictsWithFileNameException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_file_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FileContentRequiredException(_)
        )
    }
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    pub fn is_file_name_conflicts_with_directory_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FileNameConflictsWithDirectoryNameException(_)
        )
    }
    pub fn is_file_path_conflicts_with_submodule_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FilePathConflictsWithSubmodulePathException(_)
        )
    }
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::InvalidBranchNameException(_))
    }
    pub fn is_invalid_deletion_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::InvalidDeletionParameterException(_)
        )
    }
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::InvalidEmailException(_))
    }
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::InvalidFileModeException(_))
    }
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::InvalidParentCommitIdException(_)
        )
    }
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::InvalidPathException(_))
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::NameLengthExceededException(_))
    }
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::ParentCommitDoesNotExistException(_)
        )
    }
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::ParentCommitIdOutdatedException(_)
        )
    }
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::ParentCommitIdRequiredException(_)
        )
    }
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::PathRequiredException(_))
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_same_file_content_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::SameFileContentException(_))
    }
}
impl std::error::Error for PutFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutFileErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            PutFileErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            PutFileErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::CommitMessageLengthExceededException(_inner) => Some(_inner),
            PutFileErrorKind::DirectoryNameConflictsWithFileNameException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            PutFileErrorKind::FileContentRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            PutFileErrorKind::FileNameConflictsWithDirectoryNameException(_inner) => Some(_inner),
            PutFileErrorKind::FilePathConflictsWithSubmodulePathException(_inner) => Some(_inner),
            PutFileErrorKind::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidDeletionParameterException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidEmailException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidFileModeException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidParentCommitIdException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidPathException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            PutFileErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            PutFileErrorKind::ParentCommitDoesNotExistException(_inner) => Some(_inner),
            PutFileErrorKind::ParentCommitIdOutdatedException(_inner) => Some(_inner),
            PutFileErrorKind::ParentCommitIdRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::PathRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            PutFileErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::SameFileContentException(_inner) => Some(_inner),
            PutFileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRepositoryTriggersError {
    pub kind: PutRepositoryTriggersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRepositoryTriggersErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidRepositoryTriggerBranchNameException(
        crate::error::InvalidRepositoryTriggerBranchNameException,
    ),
    InvalidRepositoryTriggerCustomDataException(
        crate::error::InvalidRepositoryTriggerCustomDataException,
    ),
    InvalidRepositoryTriggerDestinationArnException(
        crate::error::InvalidRepositoryTriggerDestinationArnException,
    ),
    InvalidRepositoryTriggerEventsException(crate::error::InvalidRepositoryTriggerEventsException),
    InvalidRepositoryTriggerNameException(crate::error::InvalidRepositoryTriggerNameException),
    InvalidRepositoryTriggerRegionException(crate::error::InvalidRepositoryTriggerRegionException),
    MaximumBranchesExceededException(crate::error::MaximumBranchesExceededException),
    MaximumRepositoryTriggersExceededException(
        crate::error::MaximumRepositoryTriggersExceededException,
    ),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    RepositoryTriggerBranchNameListRequiredException(
        crate::error::RepositoryTriggerBranchNameListRequiredException,
    ),
    RepositoryTriggerDestinationArnRequiredException(
        crate::error::RepositoryTriggerDestinationArnRequiredException,
    ),
    RepositoryTriggerEventsListRequiredException(
        crate::error::RepositoryTriggerEventsListRequiredException,
    ),
    RepositoryTriggerNameRequiredException(crate::error::RepositoryTriggerNameRequiredException),
    RepositoryTriggersListRequiredException(crate::error::RepositoryTriggersListRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(
                _inner,
            ) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::MaximumBranchesExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(
                _inner,
            ) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(
                _inner,
            ) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(
                _inner,
            ) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for PutRepositoryTriggersError {
    fn code(&self) -> Option<&str> {
        PutRepositoryTriggersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRepositoryTriggersError {
    pub fn new(kind: PutRepositoryTriggersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRepositoryTriggersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRepositoryTriggersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_repository_trigger_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(_)
        )
    }
    pub fn is_invalid_repository_trigger_custom_data_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(_)
        )
    }
    pub fn is_invalid_repository_trigger_destination_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(_)
        )
    }
    pub fn is_invalid_repository_trigger_events_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_)
        )
    }
    pub fn is_invalid_repository_trigger_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_)
        )
    }
    pub fn is_invalid_repository_trigger_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_)
        )
    }
    pub fn is_maximum_branches_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::MaximumBranchesExceededException(_)
        )
    }
    pub fn is_maximum_repository_triggers_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_repository_trigger_branch_name_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(_)
        )
    }
    pub fn is_repository_trigger_destination_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(_)
        )
    }
    pub fn is_repository_trigger_events_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(_)
        )
    }
    pub fn is_repository_trigger_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_)
        )
    }
    pub fn is_repository_triggers_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_)
        )
    }
}
impl std::error::Error for PutRepositoryTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(
                _inner,
            ) => Some(_inner),
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::MaximumBranchesExceededException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(
                _inner,
            ) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(
                _inner,
            ) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(
                _inner,
            ) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    pub kind: TagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    InvalidTagsMapException(crate::error::InvalidTagsMapException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    TagPolicyException(crate::error::TagPolicyException),
    TagsMapRequiredException(crate::error::TagsMapRequiredException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidResourceArnException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidSystemTagUsageException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidTagsMapException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagPolicyException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagsMapRequiredException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    pub fn new(kind: TagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_resource_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidResourceArnException(_)
        )
    }
    pub fn is_invalid_system_tag_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidSystemTagUsageException(_)
        )
    }
    pub fn is_invalid_tags_map_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidTagsMapException(_))
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceArnRequiredException(_)
        )
    }
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TagPolicyException(_))
    }
    pub fn is_tags_map_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::TagsMapRequiredException(_)
        )
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TooManyTagsException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidResourceArnException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidSystemTagUsageException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidTagsMapException(_inner) => Some(_inner),
            TagResourceErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceArnRequiredException(_inner) => Some(_inner),
            TagResourceErrorKind::TagPolicyException(_inner) => Some(_inner),
            TagResourceErrorKind::TagsMapRequiredException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestRepositoryTriggersError {
    pub kind: TestRepositoryTriggersErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestRepositoryTriggersErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidRepositoryTriggerBranchNameException(
        crate::error::InvalidRepositoryTriggerBranchNameException,
    ),
    InvalidRepositoryTriggerCustomDataException(
        crate::error::InvalidRepositoryTriggerCustomDataException,
    ),
    InvalidRepositoryTriggerDestinationArnException(
        crate::error::InvalidRepositoryTriggerDestinationArnException,
    ),
    InvalidRepositoryTriggerEventsException(crate::error::InvalidRepositoryTriggerEventsException),
    InvalidRepositoryTriggerNameException(crate::error::InvalidRepositoryTriggerNameException),
    InvalidRepositoryTriggerRegionException(crate::error::InvalidRepositoryTriggerRegionException),
    MaximumBranchesExceededException(crate::error::MaximumBranchesExceededException),
    MaximumRepositoryTriggersExceededException(
        crate::error::MaximumRepositoryTriggersExceededException,
    ),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    RepositoryTriggerBranchNameListRequiredException(
        crate::error::RepositoryTriggerBranchNameListRequiredException,
    ),
    RepositoryTriggerDestinationArnRequiredException(
        crate::error::RepositoryTriggerDestinationArnRequiredException,
    ),
    RepositoryTriggerEventsListRequiredException(
        crate::error::RepositoryTriggerEventsListRequiredException,
    ),
    RepositoryTriggerNameRequiredException(crate::error::RepositoryTriggerNameRequiredException),
    RepositoryTriggersListRequiredException(crate::error::RepositoryTriggersListRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::MaximumBranchesExceededException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for TestRepositoryTriggersError {
    fn code(&self) -> Option<&str> {
        TestRepositoryTriggersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestRepositoryTriggersError {
    pub fn new(kind: TestRepositoryTriggersErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestRepositoryTriggersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestRepositoryTriggersErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_repository_trigger_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(_)
        )
    }
    pub fn is_invalid_repository_trigger_custom_data_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(_)
        )
    }
    pub fn is_invalid_repository_trigger_destination_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(_)
        )
    }
    pub fn is_invalid_repository_trigger_events_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_)
        )
    }
    pub fn is_invalid_repository_trigger_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_)
        )
    }
    pub fn is_invalid_repository_trigger_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_)
        )
    }
    pub fn is_maximum_branches_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::MaximumBranchesExceededException(_)
        )
    }
    pub fn is_maximum_repository_triggers_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryNameRequiredException(_)
        )
    }
    pub fn is_repository_trigger_branch_name_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(_)
        )
    }
    pub fn is_repository_trigger_destination_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(_)
        )
    }
    pub fn is_repository_trigger_events_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(_)
        )
    }
    pub fn is_repository_trigger_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_)
        )
    }
    pub fn is_repository_triggers_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_)
        )
    }
}
impl std::error::Error for TestRepositoryTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            TestRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            TestRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::MaximumBranchesExceededException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    pub kind: UntagResourceErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    InvalidTagKeysListException(crate::error::InvalidTagKeysListException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    TagKeysListRequiredException(crate::error::TagKeysListRequiredException),
    TagPolicyException(crate::error::TagPolicyException),
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidResourceArnException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidSystemTagUsageException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidTagKeysListException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TagKeysListRequiredException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TagPolicyException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    pub fn new(kind: UntagResourceErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_invalid_resource_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidResourceArnException(_)
        )
    }
    pub fn is_invalid_system_tag_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidSystemTagUsageException(_)
        )
    }
    pub fn is_invalid_tag_keys_list_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidTagKeysListException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceArnRequiredException(_)
        )
    }
    pub fn is_tag_keys_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::TagKeysListRequiredException(_)
        )
    }
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::TagPolicyException(_))
    }
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::TooManyTagsException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidResourceArnException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidSystemTagUsageException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidTagKeysListException(_inner) => Some(_inner),
            UntagResourceErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceArnRequiredException(_inner) => Some(_inner),
            UntagResourceErrorKind::TagKeysListRequiredException(_inner) => Some(_inner),
            UntagResourceErrorKind::TagPolicyException(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApprovalRuleTemplateContentError {
    pub kind: UpdateApprovalRuleTemplateContentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApprovalRuleTemplateContentErrorKind {
    ApprovalRuleTemplateContentRequiredException(
        crate::error::ApprovalRuleTemplateContentRequiredException,
    ),
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    InvalidApprovalRuleTemplateContentException(
        crate::error::InvalidApprovalRuleTemplateContentException,
    ),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    InvalidRuleContentSha256Exception(crate::error::InvalidRuleContentSha256Exception),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApprovalRuleTemplateContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateContentException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidRuleContentSha256Exception(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApprovalRuleTemplateContentError {
    fn code(&self) -> Option<&str> {
        UpdateApprovalRuleTemplateContentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApprovalRuleTemplateContentError {
    pub fn new(
        kind: UpdateApprovalRuleTemplateContentErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApprovalRuleTemplateContentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApprovalRuleTemplateContentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_content_required_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateContentRequiredException(_))
    }
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateDoesNotExistException(
                _
            )
        )
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateNameRequiredException(
                _
            )
        )
    }
    pub fn is_invalid_approval_rule_template_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateContentException(
                _
            )
        )
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
    pub fn is_invalid_rule_content_sha256_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidRuleContentSha256Exception(_)
        )
    }
}
impl std::error::Error for UpdateApprovalRuleTemplateContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateContentRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateContentException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidRuleContentSha256Exception(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApprovalRuleTemplateDescriptionError {
    pub kind: UpdateApprovalRuleTemplateDescriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApprovalRuleTemplateDescriptionErrorKind {
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    InvalidApprovalRuleTemplateDescriptionException(
        crate::error::InvalidApprovalRuleTemplateDescriptionException,
    ),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApprovalRuleTemplateDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateDescriptionException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApprovalRuleTemplateDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdateApprovalRuleTemplateDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApprovalRuleTemplateDescriptionError {
    pub fn new(
        kind: UpdateApprovalRuleTemplateDescriptionErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApprovalRuleTemplateDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApprovalRuleTemplateDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    pub fn is_invalid_approval_rule_template_description_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateDescriptionException(_))
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
}
impl std::error::Error for UpdateApprovalRuleTemplateDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateDescriptionException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApprovalRuleTemplateNameError {
    pub kind: UpdateApprovalRuleTemplateNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApprovalRuleTemplateNameErrorKind {
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    ApprovalRuleTemplateNameAlreadyExistsException(
        crate::error::ApprovalRuleTemplateNameAlreadyExistsException,
    ),
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApprovalRuleTemplateNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateApprovalRuleTemplateNameError {
    fn code(&self) -> Option<&str> {
        UpdateApprovalRuleTemplateNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApprovalRuleTemplateNameError {
    pub fn new(kind: UpdateApprovalRuleTemplateNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApprovalRuleTemplateNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApprovalRuleTemplateNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateDoesNotExistException(_)
        )
    }
    pub fn is_approval_rule_template_name_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(
                _
            )
        )
    }
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameRequiredException(_)
        )
    }
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateNameErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
}
impl std::error::Error for UpdateApprovalRuleTemplateNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCommentError {
    pub kind: UpdateCommentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCommentErrorKind {
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    CommentDeletedException(crate::error::CommentDeletedException),
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    CommentNotCreatedByCallerException(crate::error::CommentNotCreatedByCallerException),
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCommentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCommentErrorKind::CommentContentRequiredException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::CommentContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCommentErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::CommentNotCreatedByCallerException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateCommentError {
    fn code(&self) -> Option<&str> {
        UpdateCommentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCommentError {
    pub fn new(kind: UpdateCommentErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCommentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCommentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentContentRequiredException(_)
        )
    }
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentContentSizeLimitExceededException(_)
        )
    }
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentDeletedException(_)
        )
    }
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentDoesNotExistException(_)
        )
    }
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentIdRequiredException(_)
        )
    }
    pub fn is_comment_not_created_by_caller_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentNotCreatedByCallerException(_)
        )
    }
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::InvalidCommentIdException(_)
        )
    }
}
impl std::error::Error for UpdateCommentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCommentErrorKind::CommentContentRequiredException(_inner) => Some(_inner),
            UpdateCommentErrorKind::CommentContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            UpdateCommentErrorKind::CommentDeletedException(_inner) => Some(_inner),
            UpdateCommentErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            UpdateCommentErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            UpdateCommentErrorKind::CommentNotCreatedByCallerException(_inner) => Some(_inner),
            UpdateCommentErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            UpdateCommentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDefaultBranchError {
    pub kind: UpdateDefaultBranchErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDefaultBranchErrorKind {
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDefaultBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDefaultBranchErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDefaultBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDefaultBranchErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDefaultBranchErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateDefaultBranchError {
    fn code(&self) -> Option<&str> {
        UpdateDefaultBranchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDefaultBranchError {
    pub fn new(kind: UpdateDefaultBranchErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDefaultBranchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDefaultBranchErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::BranchDoesNotExistException(_)
        )
    }
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::BranchNameRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::InvalidBranchNameException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for UpdateDefaultBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDefaultBranchErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            UpdateDefaultBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateDefaultBranchErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestApprovalRuleContentError {
    pub kind: UpdatePullRequestApprovalRuleContentErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestApprovalRuleContentErrorKind {
    ApprovalRuleContentRequiredException(crate::error::ApprovalRuleContentRequiredException),
    ApprovalRuleDoesNotExistException(crate::error::ApprovalRuleDoesNotExistException),
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    CannotModifyApprovalRuleFromTemplateException(
        crate::error::CannotModifyApprovalRuleFromTemplateException,
    ),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidApprovalRuleContentException(crate::error::InvalidApprovalRuleContentException),
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidRuleContentSha256Exception(crate::error::InvalidRuleContentSha256Exception),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestApprovalRuleContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::CannotModifyApprovalRuleFromTemplateException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleContentException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleNameException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidRuleContentSha256Exception(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePullRequestApprovalRuleContentError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestApprovalRuleContentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestApprovalRuleContentError {
    pub fn new(
        kind: UpdatePullRequestApprovalRuleContentErrorKind,
        meta: smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestApprovalRuleContentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestApprovalRuleContentErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_rule_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleContentRequiredException(_)
        )
    }
    pub fn is_approval_rule_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleDoesNotExistException(_)
        )
    }
    pub fn is_approval_rule_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleNameRequiredException(_)
        )
    }
    pub fn is_cannot_modify_approval_rule_from_template_exception(&self) -> bool {
        matches!(&self.kind, UpdatePullRequestApprovalRuleContentErrorKind::CannotModifyApprovalRuleFromTemplateException(_))
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionIntegrityChecksFailedException(
                _
            )
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_approval_rule_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleContentException(_)
        )
    }
    pub fn is_invalid_approval_rule_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleNameException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_rule_content_sha256_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidRuleContentSha256Exception(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestApprovalRuleContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleContentRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleNameRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::CannotModifyApprovalRuleFromTemplateException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleContentException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleNameException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidRuleContentSha256Exception(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestApprovalStateError {
    pub kind: UpdatePullRequestApprovalStateErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestApprovalStateErrorKind {
    ApprovalStateRequiredException(crate::error::ApprovalStateRequiredException),
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidApprovalStateException(crate::error::InvalidApprovalStateException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    MaximumNumberOfApprovalsExceededException(
        crate::error::MaximumNumberOfApprovalsExceededException,
    ),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestCannotBeApprovedByAuthorException(
        crate::error::PullRequestCannotBeApprovedByAuthorException,
    ),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestApprovalStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestApprovalStateErrorKind::ApprovalStateRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidApprovalStateException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidRevisionIdException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::MaximumNumberOfApprovalsExceededException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestCannotBeApprovedByAuthorException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::RevisionIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::RevisionNotCurrentException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePullRequestApprovalStateError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestApprovalStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestApprovalStateError {
    pub fn new(kind: UpdatePullRequestApprovalStateErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestApprovalStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestApprovalStateErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_approval_state_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::ApprovalStateRequiredException(_)
        )
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_approval_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::InvalidApprovalStateException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::InvalidRevisionIdException(_)
        )
    }
    pub fn is_maximum_number_of_approvals_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::MaximumNumberOfApprovalsExceededException(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_cannot_be_approved_by_author_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::PullRequestCannotBeApprovedByAuthorException(
                _
            )
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::RevisionIdRequiredException(_)
        )
    }
    pub fn is_revision_not_current_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::RevisionNotCurrentException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestApprovalStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestApprovalStateErrorKind::ApprovalStateRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidApprovalStateException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidRevisionIdException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::MaximumNumberOfApprovalsExceededException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestCannotBeApprovedByAuthorException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::RevisionIdRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::RevisionNotCurrentException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestDescriptionError {
    pub kind: UpdatePullRequestDescriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestDescriptionErrorKind {
    InvalidDescriptionException(crate::error::InvalidDescriptionException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestDescriptionErrorKind::InvalidDescriptionException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestAlreadyClosedException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePullRequestDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestDescriptionError {
    pub fn new(kind: UpdatePullRequestDescriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::InvalidDescriptionException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestDescriptionErrorKind::InvalidDescriptionException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestAlreadyClosedException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestStatusError {
    pub kind: UpdatePullRequestStatusErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestStatusErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidPullRequestStatusException(crate::error::InvalidPullRequestStatusException),
    InvalidPullRequestStatusUpdateException(crate::error::InvalidPullRequestStatusUpdateException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    PullRequestStatusRequiredException(crate::error::PullRequestStatusRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestStatusErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusUpdateException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::PullRequestStatusRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePullRequestStatusError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestStatusError {
    pub fn new(kind: UpdatePullRequestStatusErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestStatusErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_pull_request_status_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusException(_)
        )
    }
    pub fn is_invalid_pull_request_status_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusUpdateException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_pull_request_status_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::PullRequestStatusRequiredException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestStatusErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestIdException(_inner) => Some(_inner),
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusUpdateException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::PullRequestStatusRequiredException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestTitleError {
    pub kind: UpdatePullRequestTitleErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestTitleErrorKind {
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    InvalidTitleException(crate::error::InvalidTitleException),
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    TitleRequiredException(crate::error::TitleRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestTitleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestTitleErrorKind::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            UpdatePullRequestTitleErrorKind::InvalidTitleException(_inner) => _inner.fmt(f),
            UpdatePullRequestTitleErrorKind::PullRequestAlreadyClosedException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestTitleErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestTitleErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestTitleErrorKind::TitleRequiredException(_inner) => _inner.fmt(f),
            UpdatePullRequestTitleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdatePullRequestTitleError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestTitleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestTitleError {
    pub fn new(kind: UpdatePullRequestTitleErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestTitleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestTitleErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::InvalidPullRequestIdException(_)
        )
    }
    pub fn is_invalid_title_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::InvalidTitleException(_)
        )
    }
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::PullRequestIdRequiredException(_)
        )
    }
    pub fn is_title_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::TitleRequiredException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestTitleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestTitleErrorKind::InvalidPullRequestIdException(_inner) => Some(_inner),
            UpdatePullRequestTitleErrorKind::InvalidTitleException(_inner) => Some(_inner),
            UpdatePullRequestTitleErrorKind::PullRequestAlreadyClosedException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestTitleErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestTitleErrorKind::PullRequestIdRequiredException(_inner) => Some(_inner),
            UpdatePullRequestTitleErrorKind::TitleRequiredException(_inner) => Some(_inner),
            UpdatePullRequestTitleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRepositoryDescriptionError {
    pub kind: UpdateRepositoryDescriptionErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRepositoryDescriptionErrorKind {
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    InvalidRepositoryDescriptionException(crate::error::InvalidRepositoryDescriptionException),
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRepositoryDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRepositoryDescriptionErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryDescriptionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRepositoryDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdateRepositoryDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRepositoryDescriptionError {
    pub fn new(kind: UpdateRepositoryDescriptionErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRepositoryDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRepositoryDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    pub fn is_invalid_repository_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryDescriptionException(_)
        )
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for UpdateRepositoryDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRepositoryDescriptionErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryDescriptionException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRepositoryNameError {
    pub kind: UpdateRepositoryNameErrorKind,
    pub(crate) meta: smithy_types::Error,
}
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRepositoryNameErrorKind {
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    RepositoryNameExistsException(crate::error::RepositoryNameExistsException),
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, eg. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRepositoryNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRepositoryNameErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            UpdateRepositoryNameErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateRepositoryNameErrorKind::RepositoryNameExistsException(_inner) => _inner.fmt(f),
            UpdateRepositoryNameErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            UpdateRepositoryNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl smithy_types::retry::ProvideErrorKind for UpdateRepositoryNameError {
    fn code(&self) -> Option<&str> {
        UpdateRepositoryNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRepositoryNameError {
    pub fn new(kind: UpdateRepositoryNameErrorKind, meta: smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRepositoryNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    pub fn generic(err: smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRepositoryNameErrorKind::Unhandled(err.into()),
        }
    }

    // Consider if this should actually be `Option<Cow<&str>>`. This would enable us to use display as implemented
    // by std::Error to generate a message in that case.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    pub fn meta(&self) -> &smithy_types::Error {
        &self.meta
    }

    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryNameErrorKind::InvalidRepositoryNameException(_)
        )
    }
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryNameErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    pub fn is_repository_name_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryNameErrorKind::RepositoryNameExistsException(_)
        )
    }
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryNameErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for UpdateRepositoryNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRepositoryNameErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            UpdateRepositoryNameErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            UpdateRepositoryNameErrorKind::RepositoryNameExistsException(_inner) => Some(_inner),
            UpdateRepositoryNameErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            UpdateRepositoryNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>A repository name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryNameRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNameRequiredException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNameRequiredException {}
/// See [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException)
pub mod repository_name_required_exception {
    /// A builder for [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException)
        pub fn build(self) -> crate::error::RepositoryNameRequiredException {
            crate::error::RepositoryNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryNameRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException)
    pub fn builder() -> crate::error::repository_name_required_exception::Builder {
        crate::error::repository_name_required_exception::Builder::default()
    }
}

/// <p>The specified repository name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryNameExistsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryNameExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryNameExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNameExistsException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNameExistsException {}
/// See [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException)
pub mod repository_name_exists_exception {
    /// A builder for [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException)
        pub fn build(self) -> crate::error::RepositoryNameExistsException {
            crate::error::RepositoryNameExistsException {
                message: self.message,
            }
        }
    }
}
impl RepositoryNameExistsException {
    /// Creates a new builder-style object to manufacture [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException)
    pub fn builder() -> crate::error::repository_name_exists_exception::Builder {
        crate::error::repository_name_exists_exception::Builder::default()
    }
}

/// <p>The specified repository does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryDoesNotExistException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryDoesNotExistException {}
/// See [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException)
pub mod repository_does_not_exist_exception {
    /// A builder for [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException)
        pub fn build(self) -> crate::error::RepositoryDoesNotExistException {
            crate::error::RepositoryDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl RepositoryDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException)
    pub fn builder() -> crate::error::repository_does_not_exist_exception::Builder {
        crate::error::repository_does_not_exist_exception::Builder::default()
    }
}

/// <p>A specified repository name is not valid.</p>
/// <note>
/// <p>This exception occurs only when a specified repository name is not valid. Other
/// exceptions occur when a required repository parameter is missing, or when a
/// specified repository does not exist.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryNameException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryNameException {}
/// See [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException)
pub mod invalid_repository_name_exception {
    /// A builder for [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException)
        pub fn build(self) -> crate::error::InvalidRepositoryNameException {
            crate::error::InvalidRepositoryNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryNameException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException)
    pub fn builder() -> crate::error::invalid_repository_name_exception::Builder {
        crate::error::invalid_repository_name_exception::Builder::default()
    }
}

/// <p>The specified repository description is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryDescriptionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryDescriptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryDescriptionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryDescriptionException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryDescriptionException {}
/// See [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException)
pub mod invalid_repository_description_exception {
    /// A builder for [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException)
        pub fn build(self) -> crate::error::InvalidRepositoryDescriptionException {
            crate::error::InvalidRepositoryDescriptionException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryDescriptionException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException)
    pub fn builder() -> crate::error::invalid_repository_description_exception::Builder {
        crate::error::invalid_repository_description_exception::Builder::default()
    }
}

/// <p>The encryption key is not available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionKeyUnavailableException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionKeyUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionKeyUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionKeyUnavailableException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyUnavailableException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyUnavailableException {}
/// See [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException)
pub mod encryption_key_unavailable_exception {
    /// A builder for [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException)
        pub fn build(self) -> crate::error::EncryptionKeyUnavailableException {
            crate::error::EncryptionKeyUnavailableException {
                message: self.message,
            }
        }
    }
}
impl EncryptionKeyUnavailableException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException)
    pub fn builder() -> crate::error::encryption_key_unavailable_exception::Builder {
        crate::error::encryption_key_unavailable_exception::Builder::default()
    }
}

/// <p>No encryption key was found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionKeyNotFoundException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionKeyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionKeyNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionKeyNotFoundException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyNotFoundException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyNotFoundException {}
/// See [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException)
pub mod encryption_key_not_found_exception {
    /// A builder for [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException)
        pub fn build(self) -> crate::error::EncryptionKeyNotFoundException {
            crate::error::EncryptionKeyNotFoundException {
                message: self.message,
            }
        }
    }
}
impl EncryptionKeyNotFoundException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException)
    pub fn builder() -> crate::error::encryption_key_not_found_exception::Builder {
        crate::error::encryption_key_not_found_exception::Builder::default()
    }
}

/// <p>The encryption key is disabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionKeyDisabledException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionKeyDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionKeyDisabledException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionKeyDisabledException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyDisabledException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyDisabledException {}
/// See [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException)
pub mod encryption_key_disabled_exception {
    /// A builder for [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException)
        pub fn build(self) -> crate::error::EncryptionKeyDisabledException {
            crate::error::EncryptionKeyDisabledException {
                message: self.message,
            }
        }
    }
}
impl EncryptionKeyDisabledException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException)
    pub fn builder() -> crate::error::encryption_key_disabled_exception::Builder {
        crate::error::encryption_key_disabled_exception::Builder::default()
    }
}

/// <p>An encryption key could not be accessed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionKeyAccessDeniedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionKeyAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionKeyAccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionKeyAccessDeniedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyAccessDeniedException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyAccessDeniedException {}
/// See [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException)
pub mod encryption_key_access_denied_exception {
    /// A builder for [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException)
        pub fn build(self) -> crate::error::EncryptionKeyAccessDeniedException {
            crate::error::EncryptionKeyAccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl EncryptionKeyAccessDeniedException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException)
    pub fn builder() -> crate::error::encryption_key_access_denied_exception::Builder {
        crate::error::encryption_key_access_denied_exception::Builder::default()
    }
}

/// <p>An encryption integrity check failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionIntegrityChecksFailedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionIntegrityChecksFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionIntegrityChecksFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionIntegrityChecksFailedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionIntegrityChecksFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionIntegrityChecksFailedException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionIntegrityChecksFailedException {}
/// See [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException)
pub mod encryption_integrity_checks_failed_exception {
    /// A builder for [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException)
        pub fn build(self) -> crate::error::EncryptionIntegrityChecksFailedException {
            crate::error::EncryptionIntegrityChecksFailedException {
                message: self.message,
            }
        }
    }
}
impl EncryptionIntegrityChecksFailedException {
    /// Creates a new builder-style object to manufacture [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException)
    pub fn builder() -> crate::error::encryption_integrity_checks_failed_exception::Builder {
        crate::error::encryption_integrity_checks_failed_exception::Builder::default()
    }
}

/// <p>A pull request title is required. It cannot be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TitleRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TitleRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TitleRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TitleRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TitleRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TitleRequiredException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for TitleRequiredException {}
/// See [`TitleRequiredException`](crate::error::TitleRequiredException)
pub mod title_required_exception {
    /// A builder for [`TitleRequiredException`](crate::error::TitleRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TitleRequiredException`](crate::error::TitleRequiredException)
        pub fn build(self) -> crate::error::TitleRequiredException {
            crate::error::TitleRequiredException {
                message: self.message,
            }
        }
    }
}
impl TitleRequiredException {
    /// Creates a new builder-style object to manufacture [`TitleRequiredException`](crate::error::TitleRequiredException)
    pub fn builder() -> crate::error::title_required_exception::Builder {
        crate::error::title_required_exception::Builder::default()
    }
}

/// <p>A pull request ID is required, but none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestIdRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestIdRequiredException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestIdRequiredException {}
/// See [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException)
pub mod pull_request_id_required_exception {
    /// A builder for [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException)
        pub fn build(self) -> crate::error::PullRequestIdRequiredException {
            crate::error::PullRequestIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl PullRequestIdRequiredException {
    /// Creates a new builder-style object to manufacture [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException)
    pub fn builder() -> crate::error::pull_request_id_required_exception::Builder {
        crate::error::pull_request_id_required_exception::Builder::default()
    }
}

/// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestDoesNotExistException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestDoesNotExistException {}
/// See [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException)
pub mod pull_request_does_not_exist_exception {
    /// A builder for [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException)
        pub fn build(self) -> crate::error::PullRequestDoesNotExistException {
            crate::error::PullRequestDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl PullRequestDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException)
    pub fn builder() -> crate::error::pull_request_does_not_exist_exception::Builder {
        crate::error::pull_request_does_not_exist_exception::Builder::default()
    }
}

/// <p>The pull request status cannot be updated because it is already closed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestAlreadyClosedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestAlreadyClosedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestAlreadyClosedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestAlreadyClosedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestAlreadyClosedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestAlreadyClosedException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestAlreadyClosedException {}
/// See [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException)
pub mod pull_request_already_closed_exception {
    /// A builder for [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException)
        pub fn build(self) -> crate::error::PullRequestAlreadyClosedException {
            crate::error::PullRequestAlreadyClosedException {
                message: self.message,
            }
        }
    }
}
impl PullRequestAlreadyClosedException {
    /// Creates a new builder-style object to manufacture [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException)
    pub fn builder() -> crate::error::pull_request_already_closed_exception::Builder {
        crate::error::pull_request_already_closed_exception::Builder::default()
    }
}

/// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTitleException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTitleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTitleException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTitleException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTitleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTitleException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTitleException {}
/// See [`InvalidTitleException`](crate::error::InvalidTitleException)
pub mod invalid_title_exception {
    /// A builder for [`InvalidTitleException`](crate::error::InvalidTitleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTitleException`](crate::error::InvalidTitleException)
        pub fn build(self) -> crate::error::InvalidTitleException {
            crate::error::InvalidTitleException {
                message: self.message,
            }
        }
    }
}
impl InvalidTitleException {
    /// Creates a new builder-style object to manufacture [`InvalidTitleException`](crate::error::InvalidTitleException)
    pub fn builder() -> crate::error::invalid_title_exception::Builder {
        crate::error::invalid_title_exception::Builder::default()
    }
}

/// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPullRequestIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPullRequestIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPullRequestIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPullRequestIdException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestIdException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestIdException {}
/// See [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException)
pub mod invalid_pull_request_id_exception {
    /// A builder for [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException)
        pub fn build(self) -> crate::error::InvalidPullRequestIdException {
            crate::error::InvalidPullRequestIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidPullRequestIdException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException)
    pub fn builder() -> crate::error::invalid_pull_request_id_exception::Builder {
        crate::error::invalid_pull_request_id_exception::Builder::default()
    }
}

/// <p>A pull request status is required, but none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestStatusRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestStatusRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestStatusRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestStatusRequiredException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestStatusRequiredException {}
/// See [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException)
pub mod pull_request_status_required_exception {
    /// A builder for [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException)
        pub fn build(self) -> crate::error::PullRequestStatusRequiredException {
            crate::error::PullRequestStatusRequiredException {
                message: self.message,
            }
        }
    }
}
impl PullRequestStatusRequiredException {
    /// Creates a new builder-style object to manufacture [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException)
    pub fn builder() -> crate::error::pull_request_status_required_exception::Builder {
        crate::error::pull_request_status_required_exception::Builder::default()
    }
}

/// <p>The pull request status update is not valid. The only valid update is from <code>OPEN</code> to <code>CLOSED</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPullRequestStatusUpdateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPullRequestStatusUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPullRequestStatusUpdateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPullRequestStatusUpdateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestStatusUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestStatusUpdateException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestStatusUpdateException {}
/// See [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException)
pub mod invalid_pull_request_status_update_exception {
    /// A builder for [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException)
        pub fn build(self) -> crate::error::InvalidPullRequestStatusUpdateException {
            crate::error::InvalidPullRequestStatusUpdateException {
                message: self.message,
            }
        }
    }
}
impl InvalidPullRequestStatusUpdateException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException)
    pub fn builder() -> crate::error::invalid_pull_request_status_update_exception::Builder {
        crate::error::invalid_pull_request_status_update_exception::Builder::default()
    }
}

/// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPullRequestStatusException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPullRequestStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPullRequestStatusException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPullRequestStatusException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestStatusException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestStatusException {}
/// See [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException)
pub mod invalid_pull_request_status_exception {
    /// A builder for [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException)
        pub fn build(self) -> crate::error::InvalidPullRequestStatusException {
            crate::error::InvalidPullRequestStatusException {
                message: self.message,
            }
        }
    }
}
impl InvalidPullRequestStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException)
    pub fn builder() -> crate::error::invalid_pull_request_status_exception::Builder {
        crate::error::invalid_pull_request_status_exception::Builder::default()
    }
}

/// <p>The pull request description is not valid. Descriptions cannot be more than 1,000
/// characters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDescriptionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDescriptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDescriptionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDescriptionException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDescriptionException {}
/// See [`InvalidDescriptionException`](crate::error::InvalidDescriptionException)
pub mod invalid_description_exception {
    /// A builder for [`InvalidDescriptionException`](crate::error::InvalidDescriptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDescriptionException`](crate::error::InvalidDescriptionException)
        pub fn build(self) -> crate::error::InvalidDescriptionException {
            crate::error::InvalidDescriptionException {
                message: self.message,
            }
        }
    }
}
impl InvalidDescriptionException {
    /// Creates a new builder-style object to manufacture [`InvalidDescriptionException`](crate::error::InvalidDescriptionException)
    pub fn builder() -> crate::error::invalid_description_exception::Builder {
        crate::error::invalid_description_exception::Builder::default()
    }
}

/// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RevisionNotCurrentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RevisionNotCurrentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RevisionNotCurrentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RevisionNotCurrentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RevisionNotCurrentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RevisionNotCurrentException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for RevisionNotCurrentException {}
/// See [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException)
pub mod revision_not_current_exception {
    /// A builder for [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException)
        pub fn build(self) -> crate::error::RevisionNotCurrentException {
            crate::error::RevisionNotCurrentException {
                message: self.message,
            }
        }
    }
}
impl RevisionNotCurrentException {
    /// Creates a new builder-style object to manufacture [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException)
    pub fn builder() -> crate::error::revision_not_current_exception::Builder {
        crate::error::revision_not_current_exception::Builder::default()
    }
}

/// <p>A revision ID is required, but was not provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RevisionIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RevisionIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RevisionIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RevisionIdRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RevisionIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RevisionIdRequiredException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for RevisionIdRequiredException {}
/// See [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException)
pub mod revision_id_required_exception {
    /// A builder for [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException)
        pub fn build(self) -> crate::error::RevisionIdRequiredException {
            crate::error::RevisionIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl RevisionIdRequiredException {
    /// Creates a new builder-style object to manufacture [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException)
    pub fn builder() -> crate::error::revision_id_required_exception::Builder {
        crate::error::revision_id_required_exception::Builder::default()
    }
}

/// <p>The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull
/// request that you created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestCannotBeApprovedByAuthorException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestCannotBeApprovedByAuthorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestCannotBeApprovedByAuthorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestCannotBeApprovedByAuthorException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestCannotBeApprovedByAuthorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestCannotBeApprovedByAuthorException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestCannotBeApprovedByAuthorException {}
/// See [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException)
pub mod pull_request_cannot_be_approved_by_author_exception {
    /// A builder for [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException)
        pub fn build(self) -> crate::error::PullRequestCannotBeApprovedByAuthorException {
            crate::error::PullRequestCannotBeApprovedByAuthorException {
                message: self.message,
            }
        }
    }
}
impl PullRequestCannotBeApprovedByAuthorException {
    /// Creates a new builder-style object to manufacture [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException)
    pub fn builder() -> crate::error::pull_request_cannot_be_approved_by_author_exception::Builder {
        crate::error::pull_request_cannot_be_approved_by_author_exception::Builder::default()
    }
}

/// <p>The number of approvals required for the approval rule exceeds the maximum number allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumNumberOfApprovalsExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumNumberOfApprovalsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumNumberOfApprovalsExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumNumberOfApprovalsExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumNumberOfApprovalsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumNumberOfApprovalsExceededException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumNumberOfApprovalsExceededException {}
/// See [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException)
pub mod maximum_number_of_approvals_exceeded_exception {
    /// A builder for [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException)
        pub fn build(self) -> crate::error::MaximumNumberOfApprovalsExceededException {
            crate::error::MaximumNumberOfApprovalsExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumNumberOfApprovalsExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException)
    pub fn builder() -> crate::error::maximum_number_of_approvals_exceeded_exception::Builder {
        crate::error::maximum_number_of_approvals_exceeded_exception::Builder::default()
    }
}

/// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRevisionIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRevisionIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRevisionIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRevisionIdException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRevisionIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRevisionIdException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRevisionIdException {}
/// See [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException)
pub mod invalid_revision_id_exception {
    /// A builder for [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException)
        pub fn build(self) -> crate::error::InvalidRevisionIdException {
            crate::error::InvalidRevisionIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidRevisionIdException {
    /// Creates a new builder-style object to manufacture [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException)
    pub fn builder() -> crate::error::invalid_revision_id_exception::Builder {
        crate::error::invalid_revision_id_exception::Builder::default()
    }
}

/// <p>The state for the approval is not valid. Valid values include APPROVE and REVOKE. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalStateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalStateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalStateException")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalStateException {}
/// See [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException)
pub mod invalid_approval_state_exception {
    /// A builder for [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException)
        pub fn build(self) -> crate::error::InvalidApprovalStateException {
            crate::error::InvalidApprovalStateException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalStateException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException)
    pub fn builder() -> crate::error::invalid_approval_state_exception::Builder {
        crate::error::invalid_approval_state_exception::Builder::default()
    }
}

/// <p>An approval state is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalStateRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalStateRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalStateRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalStateRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalStateRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalStateRequiredException")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalStateRequiredException {}
/// See [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException)
pub mod approval_state_required_exception {
    /// A builder for [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException)
        pub fn build(self) -> crate::error::ApprovalStateRequiredException {
            crate::error::ApprovalStateRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalStateRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException)
    pub fn builder() -> crate::error::approval_state_required_exception::Builder {
        crate::error::approval_state_required_exception::Builder::default()
    }
}

/// <p>The SHA-256 hash signature for the rule content is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRuleContentSha256Exception {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRuleContentSha256Exception {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRuleContentSha256Exception");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRuleContentSha256Exception {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRuleContentSha256Exception {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRuleContentSha256Exception")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRuleContentSha256Exception {}
/// See [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception)
pub mod invalid_rule_content_sha256_exception {
    /// A builder for [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception)
        pub fn build(self) -> crate::error::InvalidRuleContentSha256Exception {
            crate::error::InvalidRuleContentSha256Exception {
                message: self.message,
            }
        }
    }
}
impl InvalidRuleContentSha256Exception {
    /// Creates a new builder-style object to manufacture [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception)
    pub fn builder() -> crate::error::invalid_rule_content_sha256_exception::Builder {
        crate::error::invalid_rule_content_sha256_exception::Builder::default()
    }
}

/// <p>The name for the approval rule is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleNameException")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleNameException {}
/// See [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException)
pub mod invalid_approval_rule_name_exception {
    /// A builder for [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleNameException {
            crate::error::InvalidApprovalRuleNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleNameException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException)
    pub fn builder() -> crate::error::invalid_approval_rule_name_exception::Builder {
        crate::error::invalid_approval_rule_name_exception::Builder::default()
    }
}

/// <p>The content for the approval rule is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleContentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleContentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleContentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleContentException")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleContentException {}
/// See [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException)
pub mod invalid_approval_rule_content_exception {
    /// A builder for [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleContentException {
            crate::error::InvalidApprovalRuleContentException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleContentException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException)
    pub fn builder() -> crate::error::invalid_approval_rule_content_exception::Builder {
        crate::error::invalid_approval_rule_content_exception::Builder::default()
    }
}

/// <p>The approval rule cannot be modified for the pull request because it was created by an
/// approval rule template and applied to the pull request automatically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CannotModifyApprovalRuleFromTemplateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CannotModifyApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CannotModifyApprovalRuleFromTemplateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CannotModifyApprovalRuleFromTemplateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CannotModifyApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CannotModifyApprovalRuleFromTemplateException")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for CannotModifyApprovalRuleFromTemplateException {}
/// See [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException)
pub mod cannot_modify_approval_rule_from_template_exception {
    /// A builder for [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException)
        pub fn build(self) -> crate::error::CannotModifyApprovalRuleFromTemplateException {
            crate::error::CannotModifyApprovalRuleFromTemplateException {
                message: self.message,
            }
        }
    }
}
impl CannotModifyApprovalRuleFromTemplateException {
    /// Creates a new builder-style object to manufacture [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException)
    pub fn builder() -> crate::error::cannot_modify_approval_rule_from_template_exception::Builder {
        crate::error::cannot_modify_approval_rule_from_template_exception::Builder::default()
    }
}

/// <p>An approval rule name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleNameRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleNameRequiredException")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleNameRequiredException {}
/// See [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException)
pub mod approval_rule_name_required_exception {
    /// A builder for [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException)
        pub fn build(self) -> crate::error::ApprovalRuleNameRequiredException {
            crate::error::ApprovalRuleNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException)
    pub fn builder() -> crate::error::approval_rule_name_required_exception::Builder {
        crate::error::approval_rule_name_required_exception::Builder::default()
    }
}

/// <p>The specified approval rule does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleDoesNotExistException")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleDoesNotExistException {}
/// See [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException)
pub mod approval_rule_does_not_exist_exception {
    /// A builder for [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException)
        pub fn build(self) -> crate::error::ApprovalRuleDoesNotExistException {
            crate::error::ApprovalRuleDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException)
    pub fn builder() -> crate::error::approval_rule_does_not_exist_exception::Builder {
        crate::error::approval_rule_does_not_exist_exception::Builder::default()
    }
}

/// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleContentRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleContentRequiredException")?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleContentRequiredException {}
/// See [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException)
pub mod approval_rule_content_required_exception {
    /// A builder for [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException)
        pub fn build(self) -> crate::error::ApprovalRuleContentRequiredException {
            crate::error::ApprovalRuleContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleContentRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException)
    pub fn builder() -> crate::error::approval_rule_content_required_exception::Builder {
        crate::error::approval_rule_content_required_exception::Builder::default()
    }
}

/// <p>The specified reference name is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidBranchNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidBranchNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidBranchNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidBranchNameException")?;
        if let Some(inner_35) = &self.message {
            write!(f, ": {}", inner_35)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidBranchNameException {}
/// See [`InvalidBranchNameException`](crate::error::InvalidBranchNameException)
pub mod invalid_branch_name_exception {
    /// A builder for [`InvalidBranchNameException`](crate::error::InvalidBranchNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidBranchNameException`](crate::error::InvalidBranchNameException)
        pub fn build(self) -> crate::error::InvalidBranchNameException {
            crate::error::InvalidBranchNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidBranchNameException {
    /// Creates a new builder-style object to manufacture [`InvalidBranchNameException`](crate::error::InvalidBranchNameException)
    pub fn builder() -> crate::error::invalid_branch_name_exception::Builder {
        crate::error::invalid_branch_name_exception::Builder::default()
    }
}

/// <p>A branch name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BranchNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BranchNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BranchNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BranchNameRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchNameRequiredException")?;
        if let Some(inner_36) = &self.message {
            write!(f, ": {}", inner_36)?;
        }
        Ok(())
    }
}
impl std::error::Error for BranchNameRequiredException {}
/// See [`BranchNameRequiredException`](crate::error::BranchNameRequiredException)
pub mod branch_name_required_exception {
    /// A builder for [`BranchNameRequiredException`](crate::error::BranchNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BranchNameRequiredException`](crate::error::BranchNameRequiredException)
        pub fn build(self) -> crate::error::BranchNameRequiredException {
            crate::error::BranchNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl BranchNameRequiredException {
    /// Creates a new builder-style object to manufacture [`BranchNameRequiredException`](crate::error::BranchNameRequiredException)
    pub fn builder() -> crate::error::branch_name_required_exception::Builder {
        crate::error::branch_name_required_exception::Builder::default()
    }
}

/// <p>The specified branch does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BranchDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BranchDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BranchDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BranchDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchDoesNotExistException")?;
        if let Some(inner_37) = &self.message {
            write!(f, ": {}", inner_37)?;
        }
        Ok(())
    }
}
impl std::error::Error for BranchDoesNotExistException {}
/// See [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException)
pub mod branch_does_not_exist_exception {
    /// A builder for [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException)
        pub fn build(self) -> crate::error::BranchDoesNotExistException {
            crate::error::BranchDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl BranchDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException)
    pub fn builder() -> crate::error::branch_does_not_exist_exception::Builder {
        crate::error::branch_does_not_exist_exception::Builder::default()
    }
}

/// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCommentIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCommentIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCommentIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCommentIdException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommentIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommentIdException")?;
        if let Some(inner_38) = &self.message {
            write!(f, ": {}", inner_38)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommentIdException {}
/// See [`InvalidCommentIdException`](crate::error::InvalidCommentIdException)
pub mod invalid_comment_id_exception {
    /// A builder for [`InvalidCommentIdException`](crate::error::InvalidCommentIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommentIdException`](crate::error::InvalidCommentIdException)
        pub fn build(self) -> crate::error::InvalidCommentIdException {
            crate::error::InvalidCommentIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidCommentIdException {
    /// Creates a new builder-style object to manufacture [`InvalidCommentIdException`](crate::error::InvalidCommentIdException)
    pub fn builder() -> crate::error::invalid_comment_id_exception::Builder {
        crate::error::invalid_comment_id_exception::Builder::default()
    }
}

/// <p>You cannot modify or delete this comment. Only comment authors can modify or delete their comments.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentNotCreatedByCallerException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentNotCreatedByCallerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentNotCreatedByCallerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentNotCreatedByCallerException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentNotCreatedByCallerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentNotCreatedByCallerException")?;
        if let Some(inner_39) = &self.message {
            write!(f, ": {}", inner_39)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentNotCreatedByCallerException {}
/// See [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException)
pub mod comment_not_created_by_caller_exception {
    /// A builder for [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException)
        pub fn build(self) -> crate::error::CommentNotCreatedByCallerException {
            crate::error::CommentNotCreatedByCallerException {
                message: self.message,
            }
        }
    }
}
impl CommentNotCreatedByCallerException {
    /// Creates a new builder-style object to manufacture [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException)
    pub fn builder() -> crate::error::comment_not_created_by_caller_exception::Builder {
        crate::error::comment_not_created_by_caller_exception::Builder::default()
    }
}

/// <p>The comment ID is missing or null. A comment ID is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentIdRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentIdRequiredException")?;
        if let Some(inner_40) = &self.message {
            write!(f, ": {}", inner_40)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentIdRequiredException {}
/// See [`CommentIdRequiredException`](crate::error::CommentIdRequiredException)
pub mod comment_id_required_exception {
    /// A builder for [`CommentIdRequiredException`](crate::error::CommentIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentIdRequiredException`](crate::error::CommentIdRequiredException)
        pub fn build(self) -> crate::error::CommentIdRequiredException {
            crate::error::CommentIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommentIdRequiredException {
    /// Creates a new builder-style object to manufacture [`CommentIdRequiredException`](crate::error::CommentIdRequiredException)
    pub fn builder() -> crate::error::comment_id_required_exception::Builder {
        crate::error::comment_id_required_exception::Builder::default()
    }
}

/// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and
/// then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentDoesNotExistException")?;
        if let Some(inner_41) = &self.message {
            write!(f, ": {}", inner_41)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentDoesNotExistException {}
/// See [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException)
pub mod comment_does_not_exist_exception {
    /// A builder for [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException)
        pub fn build(self) -> crate::error::CommentDoesNotExistException {
            crate::error::CommentDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl CommentDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException)
    pub fn builder() -> crate::error::comment_does_not_exist_exception::Builder {
        crate::error::comment_does_not_exist_exception::Builder::default()
    }
}

/// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentDeletedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentDeletedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentDeletedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentDeletedException")?;
        if let Some(inner_42) = &self.message {
            write!(f, ": {}", inner_42)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentDeletedException {}
/// See [`CommentDeletedException`](crate::error::CommentDeletedException)
pub mod comment_deleted_exception {
    /// A builder for [`CommentDeletedException`](crate::error::CommentDeletedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentDeletedException`](crate::error::CommentDeletedException)
        pub fn build(self) -> crate::error::CommentDeletedException {
            crate::error::CommentDeletedException {
                message: self.message,
            }
        }
    }
}
impl CommentDeletedException {
    /// Creates a new builder-style object to manufacture [`CommentDeletedException`](crate::error::CommentDeletedException)
    pub fn builder() -> crate::error::comment_deleted_exception::Builder {
        crate::error::comment_deleted_exception::Builder::default()
    }
}

/// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentContentSizeLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentContentSizeLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentContentSizeLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentContentSizeLimitExceededException")?;
        if let Some(inner_43) = &self.message {
            write!(f, ": {}", inner_43)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentContentSizeLimitExceededException {}
/// See [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException)
pub mod comment_content_size_limit_exceeded_exception {
    /// A builder for [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException)
        pub fn build(self) -> crate::error::CommentContentSizeLimitExceededException {
            crate::error::CommentContentSizeLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl CommentContentSizeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException)
    pub fn builder() -> crate::error::comment_content_size_limit_exceeded_exception::Builder {
        crate::error::comment_content_size_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentContentRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentContentRequiredException")?;
        if let Some(inner_44) = &self.message {
            write!(f, ": {}", inner_44)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentContentRequiredException {}
/// See [`CommentContentRequiredException`](crate::error::CommentContentRequiredException)
pub mod comment_content_required_exception {
    /// A builder for [`CommentContentRequiredException`](crate::error::CommentContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentContentRequiredException`](crate::error::CommentContentRequiredException)
        pub fn build(self) -> crate::error::CommentContentRequiredException {
            crate::error::CommentContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommentContentRequiredException {
    /// Creates a new builder-style object to manufacture [`CommentContentRequiredException`](crate::error::CommentContentRequiredException)
    pub fn builder() -> crate::error::comment_content_required_exception::Builder {
        crate::error::comment_content_required_exception::Builder::default()
    }
}

/// <p>The name of the approval rule template is not valid. Template names must be between 1
/// and 100 valid characters in length. For more information about limits in AWS CodeCommit,
/// see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS
/// CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleTemplateNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleTemplateNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleTemplateNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleTemplateNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleTemplateNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleTemplateNameException")?;
        if let Some(inner_45) = &self.message {
            write!(f, ": {}", inner_45)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleTemplateNameException {}
/// See [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException)
pub mod invalid_approval_rule_template_name_exception {
    /// A builder for [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleTemplateNameException {
            crate::error::InvalidApprovalRuleTemplateNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleTemplateNameException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException)
    pub fn builder() -> crate::error::invalid_approval_rule_template_name_exception::Builder {
        crate::error::invalid_approval_rule_template_name_exception::Builder::default()
    }
}

/// <p>An approval rule template name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateNameRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateNameRequiredException")?;
        if let Some(inner_46) = &self.message {
            write!(f, ": {}", inner_46)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateNameRequiredException {}
/// See [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException)
pub mod approval_rule_template_name_required_exception {
    /// A builder for [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateNameRequiredException {
            crate::error::ApprovalRuleTemplateNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException)
    pub fn builder() -> crate::error::approval_rule_template_name_required_exception::Builder {
        crate::error::approval_rule_template_name_required_exception::Builder::default()
    }
}

/// <p>You cannot create an approval rule template with that name because a template with
/// that name already exists in this AWS Region for your AWS account. Approval rule template
/// names must be unique.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateNameAlreadyExistsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateNameAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateNameAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateNameAlreadyExistsException")?;
        if let Some(inner_47) = &self.message {
            write!(f, ": {}", inner_47)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateNameAlreadyExistsException {}
/// See [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException)
pub mod approval_rule_template_name_already_exists_exception {
    /// A builder for [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateNameAlreadyExistsException {
            crate::error::ApprovalRuleTemplateNameAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateNameAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException)
    pub fn builder() -> crate::error::approval_rule_template_name_already_exists_exception::Builder
    {
        crate::error::approval_rule_template_name_already_exists_exception::Builder::default()
    }
}

/// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template
/// was created, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateDoesNotExistException")?;
        if let Some(inner_48) = &self.message {
            write!(f, ": {}", inner_48)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateDoesNotExistException {}
/// See [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException)
pub mod approval_rule_template_does_not_exist_exception {
    /// A builder for [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateDoesNotExistException {
            crate::error::ApprovalRuleTemplateDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException)
    pub fn builder() -> crate::error::approval_rule_template_does_not_exist_exception::Builder {
        crate::error::approval_rule_template_does_not_exist_exception::Builder::default()
    }
}

/// <p>The description for the approval rule template is not valid because it exceeds the
/// maximum characters allowed for a description. For more information about limits in AWS
/// CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User
/// Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleTemplateDescriptionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleTemplateDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleTemplateDescriptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleTemplateDescriptionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleTemplateDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleTemplateDescriptionException")?;
        if let Some(inner_49) = &self.message {
            write!(f, ": {}", inner_49)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleTemplateDescriptionException {}
/// See [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException)
pub mod invalid_approval_rule_template_description_exception {
    /// A builder for [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleTemplateDescriptionException {
            crate::error::InvalidApprovalRuleTemplateDescriptionException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleTemplateDescriptionException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException)
    pub fn builder() -> crate::error::invalid_approval_rule_template_description_exception::Builder
    {
        crate::error::invalid_approval_rule_template_description_exception::Builder::default()
    }
}

/// <p>The content of the approval rule template is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleTemplateContentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleTemplateContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleTemplateContentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleTemplateContentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleTemplateContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleTemplateContentException")?;
        if let Some(inner_50) = &self.message {
            write!(f, ": {}", inner_50)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleTemplateContentException {}
/// See [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException)
pub mod invalid_approval_rule_template_content_exception {
    /// A builder for [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleTemplateContentException {
            crate::error::InvalidApprovalRuleTemplateContentException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleTemplateContentException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException)
    pub fn builder() -> crate::error::invalid_approval_rule_template_content_exception::Builder {
        crate::error::invalid_approval_rule_template_content_exception::Builder::default()
    }
}

/// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateContentRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateContentRequiredException")?;
        if let Some(inner_51) = &self.message {
            write!(f, ": {}", inner_51)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateContentRequiredException {}
/// See [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException)
pub mod approval_rule_template_content_required_exception {
    /// A builder for [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateContentRequiredException {
            crate::error::ApprovalRuleTemplateContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateContentRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException)
    pub fn builder() -> crate::error::approval_rule_template_content_required_exception::Builder {
        crate::error::approval_rule_template_content_required_exception::Builder::default()
    }
}

/// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyTagsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_52) = &self.message {
            write!(f, ": {}", inner_52)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
/// See [`TooManyTagsException`](crate::error::TooManyTagsException)
pub mod too_many_tags_exception {
    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException)
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message,
            }
        }
    }
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException)
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}

/// <p>The tag policy is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagPolicyException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagPolicyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagPolicyException")?;
        if let Some(inner_53) = &self.message {
            write!(f, ": {}", inner_53)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagPolicyException {}
/// See [`TagPolicyException`](crate::error::TagPolicyException)
pub mod tag_policy_exception {
    /// A builder for [`TagPolicyException`](crate::error::TagPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagPolicyException`](crate::error::TagPolicyException)
        pub fn build(self) -> crate::error::TagPolicyException {
            crate::error::TagPolicyException {
                message: self.message,
            }
        }
    }
}
impl TagPolicyException {
    /// Creates a new builder-style object to manufacture [`TagPolicyException`](crate::error::TagPolicyException)
    pub fn builder() -> crate::error::tag_policy_exception::Builder {
        crate::error::tag_policy_exception::Builder::default()
    }
}

/// <p>A list of tag keys is required. The list cannot be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagKeysListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagKeysListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagKeysListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagKeysListRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagKeysListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagKeysListRequiredException")?;
        if let Some(inner_54) = &self.message {
            write!(f, ": {}", inner_54)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagKeysListRequiredException {}
/// See [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException)
pub mod tag_keys_list_required_exception {
    /// A builder for [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException)
        pub fn build(self) -> crate::error::TagKeysListRequiredException {
            crate::error::TagKeysListRequiredException {
                message: self.message,
            }
        }
    }
}
impl TagKeysListRequiredException {
    /// Creates a new builder-style object to manufacture [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException)
    pub fn builder() -> crate::error::tag_keys_list_required_exception::Builder {
        crate::error::tag_keys_list_required_exception::Builder::default()
    }
}

/// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see
/// <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a>
/// in the AWS CodeCommit User Guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceArnRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceArnRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceArnRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceArnRequiredException")?;
        if let Some(inner_55) = &self.message {
            write!(f, ": {}", inner_55)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceArnRequiredException {}
/// See [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException)
pub mod resource_arn_required_exception {
    /// A builder for [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException)
        pub fn build(self) -> crate::error::ResourceArnRequiredException {
            crate::error::ResourceArnRequiredException {
                message: self.message,
            }
        }
    }
}
impl ResourceArnRequiredException {
    /// Creates a new builder-style object to manufacture [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException)
    pub fn builder() -> crate::error::resource_arn_required_exception::Builder {
        crate::error::resource_arn_required_exception::Builder::default()
    }
}

/// <p>The list of tags is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTagKeysListException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTagKeysListException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTagKeysListException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTagKeysListException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagKeysListException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagKeysListException")?;
        if let Some(inner_56) = &self.message {
            write!(f, ": {}", inner_56)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagKeysListException {}
/// See [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException)
pub mod invalid_tag_keys_list_exception {
    /// A builder for [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException)
        pub fn build(self) -> crate::error::InvalidTagKeysListException {
            crate::error::InvalidTagKeysListException {
                message: self.message,
            }
        }
    }
}
impl InvalidTagKeysListException {
    /// Creates a new builder-style object to manufacture [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException)
    pub fn builder() -> crate::error::invalid_tag_keys_list_exception::Builder {
        crate::error::invalid_tag_keys_list_exception::Builder::default()
    }
}

/// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSystemTagUsageException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSystemTagUsageException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSystemTagUsageException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSystemTagUsageException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSystemTagUsageException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSystemTagUsageException")?;
        if let Some(inner_57) = &self.message {
            write!(f, ": {}", inner_57)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSystemTagUsageException {}
/// See [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException)
pub mod invalid_system_tag_usage_exception {
    /// A builder for [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException)
        pub fn build(self) -> crate::error::InvalidSystemTagUsageException {
            crate::error::InvalidSystemTagUsageException {
                message: self.message,
            }
        }
    }
}
impl InvalidSystemTagUsageException {
    /// Creates a new builder-style object to manufacture [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException)
    pub fn builder() -> crate::error::invalid_system_tag_usage_exception::Builder {
        crate::error::invalid_system_tag_usage_exception::Builder::default()
    }
}

/// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see
/// <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a>
/// in the AWS CodeCommit User Guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResourceArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResourceArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResourceArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidResourceArnException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResourceArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceArnException")?;
        if let Some(inner_58) = &self.message {
            write!(f, ": {}", inner_58)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResourceArnException {}
/// See [`InvalidResourceArnException`](crate::error::InvalidResourceArnException)
pub mod invalid_resource_arn_exception {
    /// A builder for [`InvalidResourceArnException`](crate::error::InvalidResourceArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResourceArnException`](crate::error::InvalidResourceArnException)
        pub fn build(self) -> crate::error::InvalidResourceArnException {
            crate::error::InvalidResourceArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidResourceArnException {
    /// Creates a new builder-style object to manufacture [`InvalidResourceArnException`](crate::error::InvalidResourceArnException)
    pub fn builder() -> crate::error::invalid_resource_arn_exception::Builder {
        crate::error::invalid_resource_arn_exception::Builder::default()
    }
}

/// <p>The list of triggers for the repository is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggersListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggersListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggersListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggersListRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggersListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggersListRequiredException")?;
        if let Some(inner_59) = &self.message {
            write!(f, ": {}", inner_59)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggersListRequiredException {}
/// See [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException)
pub mod repository_triggers_list_required_exception {
    /// A builder for [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggersListRequiredException {
            crate::error::RepositoryTriggersListRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggersListRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException)
    pub fn builder() -> crate::error::repository_triggers_list_required_exception::Builder {
        crate::error::repository_triggers_list_required_exception::Builder::default()
    }
}

/// <p>A name for the trigger is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggerNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggerNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggerNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggerNameRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerNameRequiredException")?;
        if let Some(inner_60) = &self.message {
            write!(f, ": {}", inner_60)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerNameRequiredException {}
/// See [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException)
pub mod repository_trigger_name_required_exception {
    /// A builder for [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggerNameRequiredException {
            crate::error::RepositoryTriggerNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggerNameRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException)
    pub fn builder() -> crate::error::repository_trigger_name_required_exception::Builder {
        crate::error::repository_trigger_name_required_exception::Builder::default()
    }
}

/// <p>At least one event for the trigger is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggerEventsListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggerEventsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggerEventsListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggerEventsListRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerEventsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerEventsListRequiredException")?;
        if let Some(inner_61) = &self.message {
            write!(f, ": {}", inner_61)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerEventsListRequiredException {}
/// See [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException)
pub mod repository_trigger_events_list_required_exception {
    /// A builder for [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggerEventsListRequiredException {
            crate::error::RepositoryTriggerEventsListRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggerEventsListRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException)
    pub fn builder() -> crate::error::repository_trigger_events_list_required_exception::Builder {
        crate::error::repository_trigger_events_list_required_exception::Builder::default()
    }
}

/// <p>A destination ARN for the target service for the trigger is required, but was not
/// specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggerDestinationArnRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggerDestinationArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggerDestinationArnRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggerDestinationArnRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerDestinationArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerDestinationArnRequiredException")?;
        if let Some(inner_62) = &self.message {
            write!(f, ": {}", inner_62)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerDestinationArnRequiredException {}
/// See [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException)
pub mod repository_trigger_destination_arn_required_exception {
    /// A builder for [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggerDestinationArnRequiredException {
            crate::error::RepositoryTriggerDestinationArnRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggerDestinationArnRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException)
    pub fn builder() -> crate::error::repository_trigger_destination_arn_required_exception::Builder
    {
        crate::error::repository_trigger_destination_arn_required_exception::Builder::default()
    }
}

/// <p>At least one branch name is required, but was not specified in the trigger
/// configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggerBranchNameListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggerBranchNameListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggerBranchNameListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggerBranchNameListRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerBranchNameListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerBranchNameListRequiredException")?;
        if let Some(inner_63) = &self.message {
            write!(f, ": {}", inner_63)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerBranchNameListRequiredException {}
/// See [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException)
pub mod repository_trigger_branch_name_list_required_exception {
    /// A builder for [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggerBranchNameListRequiredException {
            crate::error::RepositoryTriggerBranchNameListRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggerBranchNameListRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException)
    pub fn builder() -> crate::error::repository_trigger_branch_name_list_required_exception::Builder
    {
        crate::error::repository_trigger_branch_name_list_required_exception::Builder::default()
    }
}

/// <p>The number of triggers allowed for the repository was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumRepositoryTriggersExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumRepositoryTriggersExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumRepositoryTriggersExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumRepositoryTriggersExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumRepositoryTriggersExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumRepositoryTriggersExceededException")?;
        if let Some(inner_64) = &self.message {
            write!(f, ": {}", inner_64)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumRepositoryTriggersExceededException {}
/// See [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException)
pub mod maximum_repository_triggers_exceeded_exception {
    /// A builder for [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException)
        pub fn build(self) -> crate::error::MaximumRepositoryTriggersExceededException {
            crate::error::MaximumRepositoryTriggersExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumRepositoryTriggersExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException)
    pub fn builder() -> crate::error::maximum_repository_triggers_exceeded_exception::Builder {
        crate::error::maximum_repository_triggers_exceeded_exception::Builder::default()
    }
}

/// <p>The number of branches for the trigger was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumBranchesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumBranchesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumBranchesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumBranchesExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumBranchesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumBranchesExceededException")?;
        if let Some(inner_65) = &self.message {
            write!(f, ": {}", inner_65)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumBranchesExceededException {}
/// See [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException)
pub mod maximum_branches_exceeded_exception {
    /// A builder for [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException)
        pub fn build(self) -> crate::error::MaximumBranchesExceededException {
            crate::error::MaximumBranchesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumBranchesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException)
    pub fn builder() -> crate::error::maximum_branches_exceeded_exception::Builder {
        crate::error::maximum_branches_exceeded_exception::Builder::default()
    }
}

/// <p>The AWS Region for the trigger target does not match the AWS Region for the
/// repository. Triggers must be created in the same Region as the target for the
/// trigger.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerRegionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerRegionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerRegionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerRegionException")?;
        if let Some(inner_66) = &self.message {
            write!(f, ": {}", inner_66)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerRegionException {}
/// See [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException)
pub mod invalid_repository_trigger_region_exception {
    /// A builder for [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerRegionException {
            crate::error::InvalidRepositoryTriggerRegionException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerRegionException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException)
    pub fn builder() -> crate::error::invalid_repository_trigger_region_exception::Builder {
        crate::error::invalid_repository_trigger_region_exception::Builder::default()
    }
}

/// <p>The name of the trigger is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerNameException")?;
        if let Some(inner_67) = &self.message {
            write!(f, ": {}", inner_67)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerNameException {}
/// See [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException)
pub mod invalid_repository_trigger_name_exception {
    /// A builder for [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerNameException {
            crate::error::InvalidRepositoryTriggerNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerNameException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException)
    pub fn builder() -> crate::error::invalid_repository_trigger_name_exception::Builder {
        crate::error::invalid_repository_trigger_name_exception::Builder::default()
    }
}

/// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerEventsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerEventsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerEventsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerEventsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerEventsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerEventsException")?;
        if let Some(inner_68) = &self.message {
            write!(f, ": {}", inner_68)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerEventsException {}
/// See [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException)
pub mod invalid_repository_trigger_events_exception {
    /// A builder for [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerEventsException {
            crate::error::InvalidRepositoryTriggerEventsException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerEventsException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException)
    pub fn builder() -> crate::error::invalid_repository_trigger_events_exception::Builder {
        crate::error::invalid_repository_trigger_events_exception::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerDestinationArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerDestinationArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerDestinationArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerDestinationArnException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerDestinationArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerDestinationArnException")?;
        if let Some(inner_69) = &self.message {
            write!(f, ": {}", inner_69)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerDestinationArnException {}
/// See [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException)
pub mod invalid_repository_trigger_destination_arn_exception {
    /// A builder for [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerDestinationArnException {
            crate::error::InvalidRepositoryTriggerDestinationArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerDestinationArnException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException)
    pub fn builder() -> crate::error::invalid_repository_trigger_destination_arn_exception::Builder
    {
        crate::error::invalid_repository_trigger_destination_arn_exception::Builder::default()
    }
}

/// <p>The custom data provided for the trigger is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerCustomDataException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerCustomDataException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerCustomDataException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerCustomDataException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerCustomDataException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerCustomDataException")?;
        if let Some(inner_70) = &self.message {
            write!(f, ": {}", inner_70)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerCustomDataException {}
/// See [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException)
pub mod invalid_repository_trigger_custom_data_exception {
    /// A builder for [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerCustomDataException {
            crate::error::InvalidRepositoryTriggerCustomDataException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerCustomDataException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException)
    pub fn builder() -> crate::error::invalid_repository_trigger_custom_data_exception::Builder {
        crate::error::invalid_repository_trigger_custom_data_exception::Builder::default()
    }
}

/// <p>One or more branch names specified for the trigger is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerBranchNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerBranchNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerBranchNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerBranchNameException")?;
        if let Some(inner_71) = &self.message {
            write!(f, ": {}", inner_71)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerBranchNameException {}
/// See [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException)
pub mod invalid_repository_trigger_branch_name_exception {
    /// A builder for [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerBranchNameException {
            crate::error::InvalidRepositoryTriggerBranchNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerBranchNameException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException)
    pub fn builder() -> crate::error::invalid_repository_trigger_branch_name_exception::Builder {
        crate::error::invalid_repository_trigger_branch_name_exception::Builder::default()
    }
}

/// <p>A map of tags is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagsMapRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagsMapRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagsMapRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagsMapRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagsMapRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagsMapRequiredException")?;
        if let Some(inner_72) = &self.message {
            write!(f, ": {}", inner_72)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagsMapRequiredException {}
/// See [`TagsMapRequiredException`](crate::error::TagsMapRequiredException)
pub mod tags_map_required_exception {
    /// A builder for [`TagsMapRequiredException`](crate::error::TagsMapRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagsMapRequiredException`](crate::error::TagsMapRequiredException)
        pub fn build(self) -> crate::error::TagsMapRequiredException {
            crate::error::TagsMapRequiredException {
                message: self.message,
            }
        }
    }
}
impl TagsMapRequiredException {
    /// Creates a new builder-style object to manufacture [`TagsMapRequiredException`](crate::error::TagsMapRequiredException)
    pub fn builder() -> crate::error::tags_map_required_exception::Builder {
        crate::error::tags_map_required_exception::Builder::default()
    }
}

/// <p>The map of tags is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTagsMapException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTagsMapException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTagsMapException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTagsMapException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagsMapException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagsMapException")?;
        if let Some(inner_73) = &self.message {
            write!(f, ": {}", inner_73)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagsMapException {}
/// See [`InvalidTagsMapException`](crate::error::InvalidTagsMapException)
pub mod invalid_tags_map_exception {
    /// A builder for [`InvalidTagsMapException`](crate::error::InvalidTagsMapException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagsMapException`](crate::error::InvalidTagsMapException)
        pub fn build(self) -> crate::error::InvalidTagsMapException {
            crate::error::InvalidTagsMapException {
                message: self.message,
            }
        }
    }
}
impl InvalidTagsMapException {
    /// Creates a new builder-style object to manufacture [`InvalidTagsMapException`](crate::error::InvalidTagsMapException)
    pub fn builder() -> crate::error::invalid_tags_map_exception::Builder {
        crate::error::invalid_tags_map_exception::Builder::default()
    }
}

/// <p>The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch
/// that you specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SameFileContentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SameFileContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SameFileContentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SameFileContentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SameFileContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SameFileContentException")?;
        if let Some(inner_74) = &self.message {
            write!(f, ": {}", inner_74)?;
        }
        Ok(())
    }
}
impl std::error::Error for SameFileContentException {}
/// See [`SameFileContentException`](crate::error::SameFileContentException)
pub mod same_file_content_exception {
    /// A builder for [`SameFileContentException`](crate::error::SameFileContentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SameFileContentException`](crate::error::SameFileContentException)
        pub fn build(self) -> crate::error::SameFileContentException {
            crate::error::SameFileContentException {
                message: self.message,
            }
        }
    }
}
impl SameFileContentException {
    /// Creates a new builder-style object to manufacture [`SameFileContentException`](crate::error::SameFileContentException)
    pub fn builder() -> crate::error::same_file_content_exception::Builder {
        crate::error::same_file_content_exception::Builder::default()
    }
}

/// <p>The folderPath for a location cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PathRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PathRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PathRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PathRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PathRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PathRequiredException")?;
        if let Some(inner_75) = &self.message {
            write!(f, ": {}", inner_75)?;
        }
        Ok(())
    }
}
impl std::error::Error for PathRequiredException {}
/// See [`PathRequiredException`](crate::error::PathRequiredException)
pub mod path_required_exception {
    /// A builder for [`PathRequiredException`](crate::error::PathRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PathRequiredException`](crate::error::PathRequiredException)
        pub fn build(self) -> crate::error::PathRequiredException {
            crate::error::PathRequiredException {
                message: self.message,
            }
        }
    }
}
impl PathRequiredException {
    /// Creates a new builder-style object to manufacture [`PathRequiredException`](crate::error::PathRequiredException)
    pub fn builder() -> crate::error::path_required_exception::Builder {
        crate::error::path_required_exception::Builder::default()
    }
}

/// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <a>GetBranch</a> or a Git command
/// (for example, git pull or git log).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParentCommitIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParentCommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParentCommitIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParentCommitIdRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParentCommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParentCommitIdRequiredException")?;
        if let Some(inner_76) = &self.message {
            write!(f, ": {}", inner_76)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParentCommitIdRequiredException {}
/// See [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException)
pub mod parent_commit_id_required_exception {
    /// A builder for [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException)
        pub fn build(self) -> crate::error::ParentCommitIdRequiredException {
            crate::error::ParentCommitIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl ParentCommitIdRequiredException {
    /// Creates a new builder-style object to manufacture [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException)
    pub fn builder() -> crate::error::parent_commit_id_required_exception::Builder {
        crate::error::parent_commit_id_required_exception::Builder::default()
    }
}

/// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head
/// of the branch, use <a>GetBranch</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParentCommitIdOutdatedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParentCommitIdOutdatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParentCommitIdOutdatedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParentCommitIdOutdatedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParentCommitIdOutdatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParentCommitIdOutdatedException")?;
        if let Some(inner_77) = &self.message {
            write!(f, ": {}", inner_77)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParentCommitIdOutdatedException {}
/// See [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException)
pub mod parent_commit_id_outdated_exception {
    /// A builder for [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException)
        pub fn build(self) -> crate::error::ParentCommitIdOutdatedException {
            crate::error::ParentCommitIdOutdatedException {
                message: self.message,
            }
        }
    }
}
impl ParentCommitIdOutdatedException {
    /// Creates a new builder-style object to manufacture [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException)
    pub fn builder() -> crate::error::parent_commit_id_outdated_exception::Builder {
        crate::error::parent_commit_id_outdated_exception::Builder::default()
    }
}

/// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParentCommitDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParentCommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParentCommitDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParentCommitDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParentCommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParentCommitDoesNotExistException")?;
        if let Some(inner_78) = &self.message {
            write!(f, ": {}", inner_78)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParentCommitDoesNotExistException {}
/// See [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException)
pub mod parent_commit_does_not_exist_exception {
    /// A builder for [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException)
        pub fn build(self) -> crate::error::ParentCommitDoesNotExistException {
            crate::error::ParentCommitDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ParentCommitDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException)
    pub fn builder() -> crate::error::parent_commit_does_not_exist_exception::Builder {
        crate::error::parent_commit_does_not_exist_exception::Builder::default()
    }
}

/// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NameLengthExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NameLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NameLengthExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NameLengthExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NameLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NameLengthExceededException")?;
        if let Some(inner_79) = &self.message {
            write!(f, ": {}", inner_79)?;
        }
        Ok(())
    }
}
impl std::error::Error for NameLengthExceededException {}
/// See [`NameLengthExceededException`](crate::error::NameLengthExceededException)
pub mod name_length_exceeded_exception {
    /// A builder for [`NameLengthExceededException`](crate::error::NameLengthExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NameLengthExceededException`](crate::error::NameLengthExceededException)
        pub fn build(self) -> crate::error::NameLengthExceededException {
            crate::error::NameLengthExceededException {
                message: self.message,
            }
        }
    }
}
impl NameLengthExceededException {
    /// Creates a new builder-style object to manufacture [`NameLengthExceededException`](crate::error::NameLengthExceededException)
    pub fn builder() -> crate::error::name_length_exceeded_exception::Builder {
        crate::error::name_length_exceeded_exception::Builder::default()
    }
}

/// <p>The specified path is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPathException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPathException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPathException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPathException")?;
        if let Some(inner_80) = &self.message {
            write!(f, ": {}", inner_80)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPathException {}
/// See [`InvalidPathException`](crate::error::InvalidPathException)
pub mod invalid_path_exception {
    /// A builder for [`InvalidPathException`](crate::error::InvalidPathException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPathException`](crate::error::InvalidPathException)
        pub fn build(self) -> crate::error::InvalidPathException {
            crate::error::InvalidPathException {
                message: self.message,
            }
        }
    }
}
impl InvalidPathException {
    /// Creates a new builder-style object to manufacture [`InvalidPathException`](crate::error::InvalidPathException)
    pub fn builder() -> crate::error::invalid_path_exception::Builder {
        crate::error::invalid_path_exception::Builder::default()
    }
}

/// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you
/// want to add or update a file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParentCommitIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParentCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParentCommitIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParentCommitIdException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParentCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParentCommitIdException")?;
        if let Some(inner_81) = &self.message {
            write!(f, ": {}", inner_81)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParentCommitIdException {}
/// See [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException)
pub mod invalid_parent_commit_id_exception {
    /// A builder for [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException)
        pub fn build(self) -> crate::error::InvalidParentCommitIdException {
            crate::error::InvalidParentCommitIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidParentCommitIdException {
    /// Creates a new builder-style object to manufacture [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException)
    pub fn builder() -> crate::error::invalid_parent_commit_id_exception::Builder {
        crate::error::invalid_parent_commit_id_exception::Builder::default()
    }
}

/// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <a>PutFile</a>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFileModeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidFileModeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFileModeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidFileModeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFileModeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFileModeException")?;
        if let Some(inner_82) = &self.message {
            write!(f, ": {}", inner_82)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFileModeException {}
/// See [`InvalidFileModeException`](crate::error::InvalidFileModeException)
pub mod invalid_file_mode_exception {
    /// A builder for [`InvalidFileModeException`](crate::error::InvalidFileModeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFileModeException`](crate::error::InvalidFileModeException)
        pub fn build(self) -> crate::error::InvalidFileModeException {
            crate::error::InvalidFileModeException {
                message: self.message,
            }
        }
    }
}
impl InvalidFileModeException {
    /// Creates a new builder-style object to manufacture [`InvalidFileModeException`](crate::error::InvalidFileModeException)
    pub fn builder() -> crate::error::invalid_file_mode_exception::Builder {
        crate::error::invalid_file_mode_exception::Builder::default()
    }
}

/// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters
/// allowed for an email address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidEmailException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidEmailException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidEmailException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidEmailException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEmailException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEmailException")?;
        if let Some(inner_83) = &self.message {
            write!(f, ": {}", inner_83)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEmailException {}
/// See [`InvalidEmailException`](crate::error::InvalidEmailException)
pub mod invalid_email_exception {
    /// A builder for [`InvalidEmailException`](crate::error::InvalidEmailException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEmailException`](crate::error::InvalidEmailException)
        pub fn build(self) -> crate::error::InvalidEmailException {
            crate::error::InvalidEmailException {
                message: self.message,
            }
        }
    }
}
impl InvalidEmailException {
    /// Creates a new builder-style object to manufacture [`InvalidEmailException`](crate::error::InvalidEmailException)
    pub fn builder() -> crate::error::invalid_email_exception::Builder {
        crate::error::invalid_email_exception::Builder::default()
    }
}

/// <p>The specified deletion parameter is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDeletionParameterException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDeletionParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDeletionParameterException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDeletionParameterException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeletionParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeletionParameterException")?;
        if let Some(inner_84) = &self.message {
            write!(f, ": {}", inner_84)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeletionParameterException {}
/// See [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException)
pub mod invalid_deletion_parameter_exception {
    /// A builder for [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException)
        pub fn build(self) -> crate::error::InvalidDeletionParameterException {
            crate::error::InvalidDeletionParameterException {
                message: self.message,
            }
        }
    }
}
impl InvalidDeletionParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException)
    pub fn builder() -> crate::error::invalid_deletion_parameter_exception::Builder {
        crate::error::invalid_deletion_parameter_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because at least one of the overall changes in the commit results in a
/// folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes,
/// or split the changes across multiple folders.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FolderContentSizeLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FolderContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FolderContentSizeLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FolderContentSizeLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FolderContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FolderContentSizeLimitExceededException")?;
        if let Some(inner_85) = &self.message {
            write!(f, ": {}", inner_85)?;
        }
        Ok(())
    }
}
impl std::error::Error for FolderContentSizeLimitExceededException {}
/// See [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException)
pub mod folder_content_size_limit_exceeded_exception {
    /// A builder for [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException)
        pub fn build(self) -> crate::error::FolderContentSizeLimitExceededException {
            crate::error::FolderContentSizeLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl FolderContentSizeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException)
    pub fn builder() -> crate::error::folder_content_size_limit_exceeded_exception::Builder {
        crate::error::folder_content_size_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files
/// have valid file paths that do not point to a submodule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FilePathConflictsWithSubmodulePathException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FilePathConflictsWithSubmodulePathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilePathConflictsWithSubmodulePathException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FilePathConflictsWithSubmodulePathException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FilePathConflictsWithSubmodulePathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FilePathConflictsWithSubmodulePathException")?;
        if let Some(inner_86) = &self.message {
            write!(f, ": {}", inner_86)?;
        }
        Ok(())
    }
}
impl std::error::Error for FilePathConflictsWithSubmodulePathException {}
/// See [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException)
pub mod file_path_conflicts_with_submodule_path_exception {
    /// A builder for [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException)
        pub fn build(self) -> crate::error::FilePathConflictsWithSubmodulePathException {
            crate::error::FilePathConflictsWithSubmodulePathException {
                message: self.message,
            }
        }
    }
}
impl FilePathConflictsWithSubmodulePathException {
    /// Creates a new builder-style object to manufacture [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException)
    pub fn builder() -> crate::error::file_path_conflicts_with_submodule_path_exception::Builder {
        crate::error::file_path_conflicts_with_submodule_path_exception::Builder::default()
    }
}

/// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide
/// another name for the file, or add the file in a directory that does not match the file name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileNameConflictsWithDirectoryNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileNameConflictsWithDirectoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileNameConflictsWithDirectoryNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileNameConflictsWithDirectoryNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileNameConflictsWithDirectoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileNameConflictsWithDirectoryNameException")?;
        if let Some(inner_87) = &self.message {
            write!(f, ": {}", inner_87)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileNameConflictsWithDirectoryNameException {}
/// See [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException)
pub mod file_name_conflicts_with_directory_name_exception {
    /// A builder for [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException)
        pub fn build(self) -> crate::error::FileNameConflictsWithDirectoryNameException {
            crate::error::FileNameConflictsWithDirectoryNameException {
                message: self.message,
            }
        }
    }
}
impl FileNameConflictsWithDirectoryNameException {
    /// Creates a new builder-style object to manufacture [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException)
    pub fn builder() -> crate::error::file_name_conflicts_with_directory_name_exception::Builder {
        crate::error::file_name_conflicts_with_directory_name_exception::Builder::default()
    }
}

/// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and
/// the combined file content change size is 7 MB. Consider making these changes using a Git
/// client.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileContentSizeLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileContentSizeLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileContentSizeLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileContentSizeLimitExceededException")?;
        if let Some(inner_88) = &self.message {
            write!(f, ": {}", inner_88)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileContentSizeLimitExceededException {}
/// See [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException)
pub mod file_content_size_limit_exceeded_exception {
    /// A builder for [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException)
        pub fn build(self) -> crate::error::FileContentSizeLimitExceededException {
            crate::error::FileContentSizeLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl FileContentSizeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException)
    pub fn builder() -> crate::error::file_content_size_limit_exceeded_exception::Builder {
        crate::error::file_content_size_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileContentRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileContentRequiredException")?;
        if let Some(inner_89) = &self.message {
            write!(f, ": {}", inner_89)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileContentRequiredException {}
/// See [`FileContentRequiredException`](crate::error::FileContentRequiredException)
pub mod file_content_required_exception {
    /// A builder for [`FileContentRequiredException`](crate::error::FileContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileContentRequiredException`](crate::error::FileContentRequiredException)
        pub fn build(self) -> crate::error::FileContentRequiredException {
            crate::error::FileContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl FileContentRequiredException {
    /// Creates a new builder-style object to manufacture [`FileContentRequiredException`](crate::error::FileContentRequiredException)
    pub fn builder() -> crate::error::file_content_required_exception::Builder {
        crate::error::file_content_required_exception::Builder::default()
    }
}

/// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository.
/// Either provide a different name for the file, or specify a different path for the file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DirectoryNameConflictsWithFileNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DirectoryNameConflictsWithFileNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DirectoryNameConflictsWithFileNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DirectoryNameConflictsWithFileNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryNameConflictsWithFileNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryNameConflictsWithFileNameException")?;
        if let Some(inner_90) = &self.message {
            write!(f, ": {}", inner_90)?;
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryNameConflictsWithFileNameException {}
/// See [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException)
pub mod directory_name_conflicts_with_file_name_exception {
    /// A builder for [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException)
        pub fn build(self) -> crate::error::DirectoryNameConflictsWithFileNameException {
            crate::error::DirectoryNameConflictsWithFileNameException {
                message: self.message,
            }
        }
    }
}
impl DirectoryNameConflictsWithFileNameException {
    /// Creates a new builder-style object to manufacture [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException)
    pub fn builder() -> crate::error::directory_name_conflicts_with_file_name_exception::Builder {
        crate::error::directory_name_conflicts_with_file_name_exception::Builder::default()
    }
}

/// <p>The commit message is too long. Provide a shorter string. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitMessageLengthExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitMessageLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitMessageLengthExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitMessageLengthExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitMessageLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitMessageLengthExceededException")?;
        if let Some(inner_91) = &self.message {
            write!(f, ": {}", inner_91)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitMessageLengthExceededException {}
/// See [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException)
pub mod commit_message_length_exceeded_exception {
    /// A builder for [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException)
        pub fn build(self) -> crate::error::CommitMessageLengthExceededException {
            crate::error::CommitMessageLengthExceededException {
                message: self.message,
            }
        }
    }
}
impl CommitMessageLengthExceededException {
    /// Creates a new builder-style object to manufacture [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException)
    pub fn builder() -> crate::error::commit_message_length_exceeded_exception::Builder {
        crate::error::commit_message_length_exceeded_exception::Builder::default()
    }
}

/// <p>The specified branch name is not valid because it is a tag name. Enter the name of a
/// branch in the repository. For a list of valid branch names, use <a>ListBranches</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BranchNameIsTagNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BranchNameIsTagNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BranchNameIsTagNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BranchNameIsTagNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchNameIsTagNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchNameIsTagNameException")?;
        if let Some(inner_92) = &self.message {
            write!(f, ": {}", inner_92)?;
        }
        Ok(())
    }
}
impl std::error::Error for BranchNameIsTagNameException {}
/// See [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException)
pub mod branch_name_is_tag_name_exception {
    /// A builder for [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException)
        pub fn build(self) -> crate::error::BranchNameIsTagNameException {
            crate::error::BranchNameIsTagNameException {
                message: self.message,
            }
        }
    }
}
impl BranchNameIsTagNameException {
    /// Creates a new builder-style object to manufacture [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException)
    pub fn builder() -> crate::error::branch_name_is_tag_name_exception::Builder {
        crate::error::branch_name_is_tag_name_exception::Builder::default()
    }
}

/// <p>A reaction value is required. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReactionValueRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReactionValueRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReactionValueRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReactionValueRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReactionValueRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReactionValueRequiredException")?;
        if let Some(inner_93) = &self.message {
            write!(f, ": {}", inner_93)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReactionValueRequiredException {}
/// See [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException)
pub mod reaction_value_required_exception {
    /// A builder for [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException)
        pub fn build(self) -> crate::error::ReactionValueRequiredException {
            crate::error::ReactionValueRequiredException {
                message: self.message,
            }
        }
    }
}
impl ReactionValueRequiredException {
    /// Creates a new builder-style object to manufacture [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException)
    pub fn builder() -> crate::error::reaction_value_required_exception::Builder {
        crate::error::reaction_value_required_exception::Builder::default()
    }
}

/// <p>The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReactionLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReactionLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReactionLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReactionLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReactionLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReactionLimitExceededException")?;
        if let Some(inner_94) = &self.message {
            write!(f, ": {}", inner_94)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReactionLimitExceededException {}
/// See [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException)
pub mod reaction_limit_exceeded_exception {
    /// A builder for [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException)
        pub fn build(self) -> crate::error::ReactionLimitExceededException {
            crate::error::ReactionLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl ReactionLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException)
    pub fn builder() -> crate::error::reaction_limit_exceeded_exception::Builder {
        crate::error::reaction_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The value of the reaction is not valid. For more information, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReactionValueException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReactionValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReactionValueException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReactionValueException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReactionValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReactionValueException")?;
        if let Some(inner_95) = &self.message {
            write!(f, ": {}", inner_95)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReactionValueException {}
/// See [`InvalidReactionValueException`](crate::error::InvalidReactionValueException)
pub mod invalid_reaction_value_exception {
    /// A builder for [`InvalidReactionValueException`](crate::error::InvalidReactionValueException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReactionValueException`](crate::error::InvalidReactionValueException)
        pub fn build(self) -> crate::error::InvalidReactionValueException {
            crate::error::InvalidReactionValueException {
                message: self.message,
            }
        }
    }
}
impl InvalidReactionValueException {
    /// Creates a new builder-style object to manufacture [`InvalidReactionValueException`](crate::error::InvalidReactionValueException)
    pub fn builder() -> crate::error::invalid_reaction_value_exception::Builder {
        crate::error::invalid_reaction_value_exception::Builder::default()
    }
}

/// <p>The client request token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidClientRequestTokenException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidClientRequestTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidClientRequestTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidClientRequestTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClientRequestTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClientRequestTokenException")?;
        if let Some(inner_96) = &self.message {
            write!(f, ": {}", inner_96)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClientRequestTokenException {}
/// See [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException)
pub mod invalid_client_request_token_exception {
    /// A builder for [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException)
        pub fn build(self) -> crate::error::InvalidClientRequestTokenException {
            crate::error::InvalidClientRequestTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidClientRequestTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException)
    pub fn builder() -> crate::error::invalid_client_request_token_exception::Builder {
        crate::error::invalid_client_request_token_exception::Builder::default()
    }
}

/// <p>The client request token is not valid. Either the token is not in a valid format, or
/// the token has been used in a previous request and cannot be reused.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdempotencyParameterMismatchException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdempotencyParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdempotencyParameterMismatchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IdempotencyParameterMismatchException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotencyParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotencyParameterMismatchException")?;
        if let Some(inner_97) = &self.message {
            write!(f, ": {}", inner_97)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdempotencyParameterMismatchException {}
/// See [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException)
pub mod idempotency_parameter_mismatch_exception {
    /// A builder for [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException)
        pub fn build(self) -> crate::error::IdempotencyParameterMismatchException {
            crate::error::IdempotencyParameterMismatchException {
                message: self.message,
            }
        }
    }
}
impl IdempotencyParameterMismatchException {
    /// Creates a new builder-style object to manufacture [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException)
    pub fn builder() -> crate::error::idempotency_parameter_mismatch_exception::Builder {
        crate::error::idempotency_parameter_mismatch_exception::Builder::default()
    }
}

/// <p>A client request token is required. A client request token is an unique,
/// client-generated idempotency token that, when provided in a request, ensures the request
/// cannot be repeated with a changed parameter. If a request is received with the same
/// parameters and a token is included, the request returns information about the initial
/// request that used that token.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientRequestTokenRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientRequestTokenRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientRequestTokenRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClientRequestTokenRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClientRequestTokenRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClientRequestTokenRequiredException")?;
        if let Some(inner_98) = &self.message {
            write!(f, ": {}", inner_98)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClientRequestTokenRequiredException {}
/// See [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException)
pub mod client_request_token_required_exception {
    /// A builder for [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException)
        pub fn build(self) -> crate::error::ClientRequestTokenRequiredException {
            crate::error::ClientRequestTokenRequiredException {
                message: self.message,
            }
        }
    }
}
impl ClientRequestTokenRequiredException {
    /// Creates a new builder-style object to manufacture [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException)
    pub fn builder() -> crate::error::client_request_token_required_exception::Builder {
        crate::error::client_request_token_required_exception::Builder::default()
    }
}

/// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryNotAssociatedWithPullRequestException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryNotAssociatedWithPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryNotAssociatedWithPullRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryNotAssociatedWithPullRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNotAssociatedWithPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNotAssociatedWithPullRequestException")?;
        if let Some(inner_99) = &self.message {
            write!(f, ": {}", inner_99)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNotAssociatedWithPullRequestException {}
/// See [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException)
pub mod repository_not_associated_with_pull_request_exception {
    /// A builder for [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException)
        pub fn build(self) -> crate::error::RepositoryNotAssociatedWithPullRequestException {
            crate::error::RepositoryNotAssociatedWithPullRequestException {
                message: self.message,
            }
        }
    }
}
impl RepositoryNotAssociatedWithPullRequestException {
    /// Creates a new builder-style object to manufacture [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException)
    pub fn builder() -> crate::error::repository_not_associated_with_pull_request_exception::Builder
    {
        crate::error::repository_not_associated_with_pull_request_exception::Builder::default()
    }
}

/// <p>The specified path does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PathDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PathDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PathDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PathDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PathDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PathDoesNotExistException")?;
        if let Some(inner_100) = &self.message {
            write!(f, ": {}", inner_100)?;
        }
        Ok(())
    }
}
impl std::error::Error for PathDoesNotExistException {}
/// See [`PathDoesNotExistException`](crate::error::PathDoesNotExistException)
pub mod path_does_not_exist_exception {
    /// A builder for [`PathDoesNotExistException`](crate::error::PathDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PathDoesNotExistException`](crate::error::PathDoesNotExistException)
        pub fn build(self) -> crate::error::PathDoesNotExistException {
            crate::error::PathDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl PathDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`PathDoesNotExistException`](crate::error::PathDoesNotExistException)
    pub fn builder() -> crate::error::path_does_not_exist_exception::Builder {
        crate::error::path_does_not_exist_exception::Builder::default()
    }
}

/// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRelativeFileVersionEnumException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRelativeFileVersionEnumException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRelativeFileVersionEnumException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRelativeFileVersionEnumException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRelativeFileVersionEnumException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRelativeFileVersionEnumException")?;
        if let Some(inner_101) = &self.message {
            write!(f, ": {}", inner_101)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRelativeFileVersionEnumException {}
/// See [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException)
pub mod invalid_relative_file_version_enum_exception {
    /// A builder for [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException)
        pub fn build(self) -> crate::error::InvalidRelativeFileVersionEnumException {
            crate::error::InvalidRelativeFileVersionEnumException {
                message: self.message,
            }
        }
    }
}
impl InvalidRelativeFileVersionEnumException {
    /// Creates a new builder-style object to manufacture [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException)
    pub fn builder() -> crate::error::invalid_relative_file_version_enum_exception::Builder {
        crate::error::invalid_relative_file_version_enum_exception::Builder::default()
    }
}

/// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFilePositionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidFilePositionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFilePositionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidFilePositionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFilePositionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFilePositionException")?;
        if let Some(inner_102) = &self.message {
            write!(f, ": {}", inner_102)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFilePositionException {}
/// See [`InvalidFilePositionException`](crate::error::InvalidFilePositionException)
pub mod invalid_file_position_exception {
    /// A builder for [`InvalidFilePositionException`](crate::error::InvalidFilePositionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFilePositionException`](crate::error::InvalidFilePositionException)
        pub fn build(self) -> crate::error::InvalidFilePositionException {
            crate::error::InvalidFilePositionException {
                message: self.message,
            }
        }
    }
}
impl InvalidFilePositionException {
    /// Creates a new builder-style object to manufacture [`InvalidFilePositionException`](crate::error::InvalidFilePositionException)
    pub fn builder() -> crate::error::invalid_file_position_exception::Builder {
        crate::error::invalid_file_position_exception::Builder::default()
    }
}

/// <p>The location of the file is not valid. Make sure that you include the file name and
/// extension.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFileLocationException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidFileLocationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFileLocationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidFileLocationException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFileLocationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFileLocationException")?;
        if let Some(inner_103) = &self.message {
            write!(f, ": {}", inner_103)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFileLocationException {}
/// See [`InvalidFileLocationException`](crate::error::InvalidFileLocationException)
pub mod invalid_file_location_exception {
    /// A builder for [`InvalidFileLocationException`](crate::error::InvalidFileLocationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFileLocationException`](crate::error::InvalidFileLocationException)
        pub fn build(self) -> crate::error::InvalidFileLocationException {
            crate::error::InvalidFileLocationException {
                message: self.message,
            }
        }
    }
}
impl InvalidFileLocationException {
    /// Creates a new builder-style object to manufacture [`InvalidFileLocationException`](crate::error::InvalidFileLocationException)
    pub fn builder() -> crate::error::invalid_file_location_exception::Builder {
        crate::error::invalid_file_location_exception::Builder::default()
    }
}

/// <p>The specified commit ID is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCommitIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCommitIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCommitIdException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommitIdException")?;
        if let Some(inner_104) = &self.message {
            write!(f, ": {}", inner_104)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommitIdException {}
/// See [`InvalidCommitIdException`](crate::error::InvalidCommitIdException)
pub mod invalid_commit_id_exception {
    /// A builder for [`InvalidCommitIdException`](crate::error::InvalidCommitIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommitIdException`](crate::error::InvalidCommitIdException)
        pub fn build(self) -> crate::error::InvalidCommitIdException {
            crate::error::InvalidCommitIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidCommitIdException {
    /// Creates a new builder-style object to manufacture [`InvalidCommitIdException`](crate::error::InvalidCommitIdException)
    pub fn builder() -> crate::error::invalid_commit_id_exception::Builder {
        crate::error::invalid_commit_id_exception::Builder::default()
    }
}

/// <p>A commit ID was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitIdRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdRequiredException")?;
        if let Some(inner_105) = &self.message {
            write!(f, ": {}", inner_105)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdRequiredException {}
/// See [`CommitIdRequiredException`](crate::error::CommitIdRequiredException)
pub mod commit_id_required_exception {
    /// A builder for [`CommitIdRequiredException`](crate::error::CommitIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdRequiredException`](crate::error::CommitIdRequiredException)
        pub fn build(self) -> crate::error::CommitIdRequiredException {
            crate::error::CommitIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommitIdRequiredException {
    /// Creates a new builder-style object to manufacture [`CommitIdRequiredException`](crate::error::CommitIdRequiredException)
    pub fn builder() -> crate::error::commit_id_required_exception::Builder {
        crate::error::commit_id_required_exception::Builder::default()
    }
}

/// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitDoesNotExistException")?;
        if let Some(inner_106) = &self.message {
            write!(f, ": {}", inner_106)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitDoesNotExistException {}
/// See [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException)
pub mod commit_does_not_exist_exception {
    /// A builder for [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException)
        pub fn build(self) -> crate::error::CommitDoesNotExistException {
            crate::error::CommitDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl CommitDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException)
    pub fn builder() -> crate::error::commit_does_not_exist_exception::Builder {
        crate::error::commit_does_not_exist_exception::Builder::default()
    }
}

/// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BeforeCommitIdAndAfterCommitIdAreSameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BeforeCommitIdAndAfterCommitIdAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BeforeCommitIdAndAfterCommitIdAreSameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BeforeCommitIdAndAfterCommitIdAreSameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BeforeCommitIdAndAfterCommitIdAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BeforeCommitIdAndAfterCommitIdAreSameException")?;
        if let Some(inner_107) = &self.message {
            write!(f, ": {}", inner_107)?;
        }
        Ok(())
    }
}
impl std::error::Error for BeforeCommitIdAndAfterCommitIdAreSameException {}
/// See [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException)
pub mod before_commit_id_and_after_commit_id_are_same_exception {
    /// A builder for [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException)
        pub fn build(self) -> crate::error::BeforeCommitIdAndAfterCommitIdAreSameException {
            crate::error::BeforeCommitIdAndAfterCommitIdAreSameException {
                message: self.message,
            }
        }
    }
}
impl BeforeCommitIdAndAfterCommitIdAreSameException {
    /// Creates a new builder-style object to manufacture [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException)
    pub fn builder(
    ) -> crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder {
        crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder::default()
    }
}

/// <p>An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OverrideStatusRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OverrideStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OverrideStatusRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OverrideStatusRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OverrideStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OverrideStatusRequiredException")?;
        if let Some(inner_108) = &self.message {
            write!(f, ": {}", inner_108)?;
        }
        Ok(())
    }
}
impl std::error::Error for OverrideStatusRequiredException {}
/// See [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException)
pub mod override_status_required_exception {
    /// A builder for [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException)
        pub fn build(self) -> crate::error::OverrideStatusRequiredException {
            crate::error::OverrideStatusRequiredException {
                message: self.message,
            }
        }
    }
}
impl OverrideStatusRequiredException {
    /// Creates a new builder-style object to manufacture [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException)
    pub fn builder() -> crate::error::override_status_required_exception::Builder {
        crate::error::override_status_required_exception::Builder::default()
    }
}

/// <p>The pull request has already had its approval rules set to override.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OverrideAlreadySetException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OverrideAlreadySetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OverrideAlreadySetException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OverrideAlreadySetException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OverrideAlreadySetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OverrideAlreadySetException")?;
        if let Some(inner_109) = &self.message {
            write!(f, ": {}", inner_109)?;
        }
        Ok(())
    }
}
impl std::error::Error for OverrideAlreadySetException {}
/// See [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException)
pub mod override_already_set_exception {
    /// A builder for [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException)
        pub fn build(self) -> crate::error::OverrideAlreadySetException {
            crate::error::OverrideAlreadySetException {
                message: self.message,
            }
        }
    }
}
impl OverrideAlreadySetException {
    /// Creates a new builder-style object to manufacture [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException)
    pub fn builder() -> crate::error::override_already_set_exception::Builder {
        crate::error::override_already_set_exception::Builder::default()
    }
}

/// <p>The override status is not valid. Valid statuses are OVERRIDE and REVOKE.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOverrideStatusException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOverrideStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOverrideStatusException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOverrideStatusException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOverrideStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOverrideStatusException")?;
        if let Some(inner_110) = &self.message {
            write!(f, ": {}", inner_110)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOverrideStatusException {}
/// See [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException)
pub mod invalid_override_status_exception {
    /// A builder for [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException)
        pub fn build(self) -> crate::error::InvalidOverrideStatusException {
            crate::error::InvalidOverrideStatusException {
                message: self.message,
            }
        }
    }
}
impl InvalidOverrideStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException)
    pub fn builder() -> crate::error::invalid_override_status_exception::Builder {
        crate::error::invalid_override_status_exception::Builder::default()
    }
}

/// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be
/// any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TipsDivergenceExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TipsDivergenceExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TipsDivergenceExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TipsDivergenceExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TipsDivergenceExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TipsDivergenceExceededException")?;
        if let Some(inner_111) = &self.message {
            write!(f, ": {}", inner_111)?;
        }
        Ok(())
    }
}
impl std::error::Error for TipsDivergenceExceededException {}
/// See [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException)
pub mod tips_divergence_exceeded_exception {
    /// A builder for [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException)
        pub fn build(self) -> crate::error::TipsDivergenceExceededException {
            crate::error::TipsDivergenceExceededException {
                message: self.message,
            }
        }
    }
}
impl TipsDivergenceExceededException {
    /// Creates a new builder-style object to manufacture [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException)
    pub fn builder() -> crate::error::tips_divergence_exceeded_exception::Builder {
        crate::error::tips_divergence_exceeded_exception::Builder::default()
    }
}

/// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request.
/// The pull request might have been updated. Make sure that you have the latest changes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TipOfSourceReferenceIsDifferentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TipOfSourceReferenceIsDifferentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TipOfSourceReferenceIsDifferentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TipOfSourceReferenceIsDifferentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TipOfSourceReferenceIsDifferentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TipOfSourceReferenceIsDifferentException")?;
        if let Some(inner_112) = &self.message {
            write!(f, ": {}", inner_112)?;
        }
        Ok(())
    }
}
impl std::error::Error for TipOfSourceReferenceIsDifferentException {}
/// See [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException)
pub mod tip_of_source_reference_is_different_exception {
    /// A builder for [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException)
        pub fn build(self) -> crate::error::TipOfSourceReferenceIsDifferentException {
            crate::error::TipOfSourceReferenceIsDifferentException {
                message: self.message,
            }
        }
    }
}
impl TipOfSourceReferenceIsDifferentException {
    /// Creates a new builder-style object to manufacture [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException)
    pub fn builder() -> crate::error::tip_of_source_reference_is_different_exception::Builder {
        crate::error::tip_of_source_reference_is_different_exception::Builder::default()
    }
}

/// <p>A replacement type is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplacementTypeRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplacementTypeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplacementTypeRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplacementTypeRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplacementTypeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplacementTypeRequiredException")?;
        if let Some(inner_113) = &self.message {
            write!(f, ": {}", inner_113)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplacementTypeRequiredException {}
/// See [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException)
pub mod replacement_type_required_exception {
    /// A builder for [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException)
        pub fn build(self) -> crate::error::ReplacementTypeRequiredException {
            crate::error::ReplacementTypeRequiredException {
                message: self.message,
            }
        }
    }
}
impl ReplacementTypeRequiredException {
    /// Creates a new builder-style object to manufacture [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException)
    pub fn builder() -> crate::error::replacement_type_required_exception::Builder {
        crate::error::replacement_type_required_exception::Builder::default()
    }
}

/// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplacementContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplacementContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplacementContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplacementContentRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplacementContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplacementContentRequiredException")?;
        if let Some(inner_114) = &self.message {
            write!(f, ": {}", inner_114)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplacementContentRequiredException {}
/// See [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException)
pub mod replacement_content_required_exception {
    /// A builder for [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException)
        pub fn build(self) -> crate::error::ReplacementContentRequiredException {
            crate::error::ReplacementContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl ReplacementContentRequiredException {
    /// Creates a new builder-style object to manufacture [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException)
    pub fn builder() -> crate::error::replacement_content_required_exception::Builder {
        crate::error::replacement_content_required_exception::Builder::default()
    }
}

/// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestApprovalRulesNotSatisfiedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestApprovalRulesNotSatisfiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestApprovalRulesNotSatisfiedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestApprovalRulesNotSatisfiedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestApprovalRulesNotSatisfiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestApprovalRulesNotSatisfiedException")?;
        if let Some(inner_115) = &self.message {
            write!(f, ": {}", inner_115)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestApprovalRulesNotSatisfiedException {}
/// See [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException)
pub mod pull_request_approval_rules_not_satisfied_exception {
    /// A builder for [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException)
        pub fn build(self) -> crate::error::PullRequestApprovalRulesNotSatisfiedException {
            crate::error::PullRequestApprovalRulesNotSatisfiedException {
                message: self.message,
            }
        }
    }
}
impl PullRequestApprovalRulesNotSatisfiedException {
    /// Creates a new builder-style object to manufacture [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException)
    pub fn builder() -> crate::error::pull_request_approval_rules_not_satisfied_exception::Builder {
        crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default()
    }
}

/// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MultipleConflictResolutionEntriesException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MultipleConflictResolutionEntriesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MultipleConflictResolutionEntriesException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MultipleConflictResolutionEntriesException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MultipleConflictResolutionEntriesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MultipleConflictResolutionEntriesException")?;
        if let Some(inner_116) = &self.message {
            write!(f, ": {}", inner_116)?;
        }
        Ok(())
    }
}
impl std::error::Error for MultipleConflictResolutionEntriesException {}
/// See [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException)
pub mod multiple_conflict_resolution_entries_exception {
    /// A builder for [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException)
        pub fn build(self) -> crate::error::MultipleConflictResolutionEntriesException {
            crate::error::MultipleConflictResolutionEntriesException {
                message: self.message,
            }
        }
    }
}
impl MultipleConflictResolutionEntriesException {
    /// Creates a new builder-style object to manufacture [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException)
    pub fn builder() -> crate::error::multiple_conflict_resolution_entries_exception::Builder {
        crate::error::multiple_conflict_resolution_entries_exception::Builder::default()
    }
}

/// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumItemsToCompareExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumItemsToCompareExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumItemsToCompareExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumItemsToCompareExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumItemsToCompareExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumItemsToCompareExceededException")?;
        if let Some(inner_117) = &self.message {
            write!(f, ": {}", inner_117)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumItemsToCompareExceededException {}
/// See [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException)
pub mod maximum_items_to_compare_exceeded_exception {
    /// A builder for [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException)
        pub fn build(self) -> crate::error::MaximumItemsToCompareExceededException {
            crate::error::MaximumItemsToCompareExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumItemsToCompareExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException)
    pub fn builder() -> crate::error::maximum_items_to_compare_exceeded_exception::Builder {
        crate::error::maximum_items_to_compare_exceeded_exception::Builder::default()
    }
}

/// <p>The number of files to load exceeds the allowed limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumFileContentToLoadExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumFileContentToLoadExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumFileContentToLoadExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumFileContentToLoadExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumFileContentToLoadExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumFileContentToLoadExceededException")?;
        if let Some(inner_118) = &self.message {
            write!(f, ": {}", inner_118)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumFileContentToLoadExceededException {}
/// See [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException)
pub mod maximum_file_content_to_load_exceeded_exception {
    /// A builder for [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException)
        pub fn build(self) -> crate::error::MaximumFileContentToLoadExceededException {
            crate::error::MaximumFileContentToLoadExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumFileContentToLoadExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException)
    pub fn builder() -> crate::error::maximum_file_content_to_load_exceeded_exception::Builder {
        crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default()
    }
}

/// <p>The number of allowed conflict resolution entries was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumConflictResolutionEntriesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumConflictResolutionEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumConflictResolutionEntriesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumConflictResolutionEntriesExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumConflictResolutionEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumConflictResolutionEntriesExceededException")?;
        if let Some(inner_119) = &self.message {
            write!(f, ": {}", inner_119)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumConflictResolutionEntriesExceededException {}
/// See [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException)
pub mod maximum_conflict_resolution_entries_exceeded_exception {
    /// A builder for [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException)
        pub fn build(self) -> crate::error::MaximumConflictResolutionEntriesExceededException {
            crate::error::MaximumConflictResolutionEntriesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumConflictResolutionEntriesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException)
    pub fn builder() -> crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder
    {
        crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default()
    }
}

/// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManualMergeRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ManualMergeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManualMergeRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ManualMergeRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ManualMergeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ManualMergeRequiredException")?;
        if let Some(inner_120) = &self.message {
            write!(f, ": {}", inner_120)?;
        }
        Ok(())
    }
}
impl std::error::Error for ManualMergeRequiredException {}
/// See [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException)
pub mod manual_merge_required_exception {
    /// A builder for [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException)
        pub fn build(self) -> crate::error::ManualMergeRequiredException {
            crate::error::ManualMergeRequiredException {
                message: self.message,
            }
        }
    }
}
impl ManualMergeRequiredException {
    /// Creates a new builder-style object to manufacture [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException)
    pub fn builder() -> crate::error::manual_merge_required_exception::Builder {
        crate::error::manual_merge_required_exception::Builder::default()
    }
}

/// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReplacementTypeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReplacementTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReplacementTypeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReplacementTypeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReplacementTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReplacementTypeException")?;
        if let Some(inner_121) = &self.message {
            write!(f, ": {}", inner_121)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReplacementTypeException {}
/// See [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException)
pub mod invalid_replacement_type_exception {
    /// A builder for [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException)
        pub fn build(self) -> crate::error::InvalidReplacementTypeException {
            crate::error::InvalidReplacementTypeException {
                message: self.message,
            }
        }
    }
}
impl InvalidReplacementTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException)
    pub fn builder() -> crate::error::invalid_replacement_type_exception::Builder {
        crate::error::invalid_replacement_type_exception::Builder::default()
    }
}

/// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReplacementContentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReplacementContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReplacementContentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReplacementContentException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReplacementContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReplacementContentException")?;
        if let Some(inner_122) = &self.message {
            write!(f, ": {}", inner_122)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReplacementContentException {}
/// See [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException)
pub mod invalid_replacement_content_exception {
    /// A builder for [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException)
        pub fn build(self) -> crate::error::InvalidReplacementContentException {
            crate::error::InvalidReplacementContentException {
                message: self.message,
            }
        }
    }
}
impl InvalidReplacementContentException {
    /// Creates a new builder-style object to manufacture [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException)
    pub fn builder() -> crate::error::invalid_replacement_content_exception::Builder {
        crate::error::invalid_replacement_content_exception::Builder::default()
    }
}

/// <p>The specified conflict resolution strategy is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidConflictResolutionStrategyException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidConflictResolutionStrategyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidConflictResolutionStrategyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidConflictResolutionStrategyException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConflictResolutionStrategyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConflictResolutionStrategyException")?;
        if let Some(inner_123) = &self.message {
            write!(f, ": {}", inner_123)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConflictResolutionStrategyException {}
/// See [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException)
pub mod invalid_conflict_resolution_strategy_exception {
    /// A builder for [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException)
        pub fn build(self) -> crate::error::InvalidConflictResolutionStrategyException {
            crate::error::InvalidConflictResolutionStrategyException {
                message: self.message,
            }
        }
    }
}
impl InvalidConflictResolutionStrategyException {
    /// Creates a new builder-style object to manufacture [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException)
    pub fn builder() -> crate::error::invalid_conflict_resolution_strategy_exception::Builder {
        crate::error::invalid_conflict_resolution_strategy_exception::Builder::default()
    }
}

/// <p>The specified conflict resolution list is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidConflictResolutionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidConflictResolutionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidConflictResolutionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidConflictResolutionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConflictResolutionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConflictResolutionException")?;
        if let Some(inner_124) = &self.message {
            write!(f, ": {}", inner_124)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConflictResolutionException {}
/// See [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException)
pub mod invalid_conflict_resolution_exception {
    /// A builder for [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException)
        pub fn build(self) -> crate::error::InvalidConflictResolutionException {
            crate::error::InvalidConflictResolutionException {
                message: self.message,
            }
        }
    }
}
impl InvalidConflictResolutionException {
    /// Creates a new builder-style object to manufacture [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException)
    pub fn builder() -> crate::error::invalid_conflict_resolution_exception::Builder {
        crate::error::invalid_conflict_resolution_exception::Builder::default()
    }
}

/// <p>The specified conflict detail level is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidConflictDetailLevelException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidConflictDetailLevelException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidConflictDetailLevelException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidConflictDetailLevelException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConflictDetailLevelException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConflictDetailLevelException")?;
        if let Some(inner_125) = &self.message {
            write!(f, ": {}", inner_125)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConflictDetailLevelException {}
/// See [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException)
pub mod invalid_conflict_detail_level_exception {
    /// A builder for [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException)
        pub fn build(self) -> crate::error::InvalidConflictDetailLevelException {
            crate::error::InvalidConflictDetailLevelException {
                message: self.message,
            }
        }
    }
}
impl InvalidConflictDetailLevelException {
    /// Creates a new builder-style object to manufacture [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException)
    pub fn builder() -> crate::error::invalid_conflict_detail_level_exception::Builder {
        crate::error::invalid_conflict_detail_level_exception::Builder::default()
    }
}

/// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentReferenceUpdateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentReferenceUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentReferenceUpdateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentReferenceUpdateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentReferenceUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentReferenceUpdateException")?;
        if let Some(inner_126) = &self.message {
            write!(f, ": {}", inner_126)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentReferenceUpdateException {}
/// See [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException)
pub mod concurrent_reference_update_exception {
    /// A builder for [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException)
        pub fn build(self) -> crate::error::ConcurrentReferenceUpdateException {
            crate::error::ConcurrentReferenceUpdateException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentReferenceUpdateException {
    /// Creates a new builder-style object to manufacture [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException)
    pub fn builder() -> crate::error::concurrent_reference_update_exception::Builder {
        crate::error::concurrent_reference_update_exception::Builder::default()
    }
}

/// <p>The specified reference does not exist. You must provide a full commit ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReferenceDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReferenceDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReferenceDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReferenceDoesNotExistException")?;
        if let Some(inner_127) = &self.message {
            write!(f, ": {}", inner_127)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReferenceDoesNotExistException {}
/// See [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException)
pub mod reference_does_not_exist_exception {
    /// A builder for [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException)
        pub fn build(self) -> crate::error::ReferenceDoesNotExistException {
            crate::error::ReferenceDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ReferenceDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException)
    pub fn builder() -> crate::error::reference_does_not_exist_exception::Builder {
        crate::error::reference_does_not_exist_exception::Builder::default()
    }
}

/// <p>The specified target branch is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTargetBranchException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTargetBranchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTargetBranchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTargetBranchException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetBranchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetBranchException")?;
        if let Some(inner_128) = &self.message {
            write!(f, ": {}", inner_128)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetBranchException {}
/// See [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException)
pub mod invalid_target_branch_exception {
    /// A builder for [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException)
        pub fn build(self) -> crate::error::InvalidTargetBranchException {
            crate::error::InvalidTargetBranchException {
                message: self.message,
            }
        }
    }
}
impl InvalidTargetBranchException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException)
    pub fn builder() -> crate::error::invalid_target_branch_exception::Builder {
        crate::error::invalid_target_branch_exception::Builder::default()
    }
}

/// <p>The specified commit is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCommitException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCommitException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCommitException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCommitException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommitException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommitException")?;
        if let Some(inner_129) = &self.message {
            write!(f, ": {}", inner_129)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommitException {}
/// See [`InvalidCommitException`](crate::error::InvalidCommitException)
pub mod invalid_commit_exception {
    /// A builder for [`InvalidCommitException`](crate::error::InvalidCommitException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommitException`](crate::error::InvalidCommitException)
        pub fn build(self) -> crate::error::InvalidCommitException {
            crate::error::InvalidCommitException {
                message: self.message,
            }
        }
    }
}
impl InvalidCommitException {
    /// Creates a new builder-style object to manufacture [`InvalidCommitException`](crate::error::InvalidCommitException)
    pub fn builder() -> crate::error::invalid_commit_exception::Builder {
        crate::error::invalid_commit_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because no file mode has been specified. A file mode is
/// required to update mode permissions for a file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileModeRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileModeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileModeRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileModeRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileModeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileModeRequiredException")?;
        if let Some(inner_130) = &self.message {
            write!(f, ": {}", inner_130)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileModeRequiredException {}
/// See [`FileModeRequiredException`](crate::error::FileModeRequiredException)
pub mod file_mode_required_exception {
    /// A builder for [`FileModeRequiredException`](crate::error::FileModeRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileModeRequiredException`](crate::error::FileModeRequiredException)
        pub fn build(self) -> crate::error::FileModeRequiredException {
            crate::error::FileModeRequiredException {
                message: self.message,
            }
        }
    }
}
impl FileModeRequiredException {
    /// Creates a new builder-style object to manufacture [`FileModeRequiredException`](crate::error::FileModeRequiredException)
    pub fn builder() -> crate::error::file_mode_required_exception::Builder {
        crate::error::file_mode_required_exception::Builder::default()
    }
}

/// <p>A commit was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitRequiredException")?;
        if let Some(inner_131) = &self.message {
            write!(f, ": {}", inner_131)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitRequiredException {}
/// See [`CommitRequiredException`](crate::error::CommitRequiredException)
pub mod commit_required_exception {
    /// A builder for [`CommitRequiredException`](crate::error::CommitRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitRequiredException`](crate::error::CommitRequiredException)
        pub fn build(self) -> crate::error::CommitRequiredException {
            crate::error::CommitRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommitRequiredException {
    /// Creates a new builder-style object to manufacture [`CommitRequiredException`](crate::error::CommitRequiredException)
    pub fn builder() -> crate::error::commit_required_exception::Builder {
        crate::error::commit_required_exception::Builder::default()
    }
}

/// <p>The specified number of maximum results is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMaxResultsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMaxResultsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMaxResultsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMaxResultsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxResultsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxResultsException")?;
        if let Some(inner_132) = &self.message {
            write!(f, ": {}", inner_132)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxResultsException {}
/// See [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
pub mod invalid_max_results_exception {
    /// A builder for [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
        pub fn build(self) -> crate::error::InvalidMaxResultsException {
            crate::error::InvalidMaxResultsException {
                message: self.message,
            }
        }
    }
}
impl InvalidMaxResultsException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
    pub fn builder() -> crate::error::invalid_max_results_exception::Builder {
        crate::error::invalid_max_results_exception::Builder::default()
    }
}

/// <p>The specified continuation token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidContinuationTokenException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidContinuationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidContinuationTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidContinuationTokenException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidContinuationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidContinuationTokenException")?;
        if let Some(inner_133) = &self.message {
            write!(f, ": {}", inner_133)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidContinuationTokenException {}
/// See [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException)
pub mod invalid_continuation_token_exception {
    /// A builder for [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException)
        pub fn build(self) -> crate::error::InvalidContinuationTokenException {
            crate::error::InvalidContinuationTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidContinuationTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException)
    pub fn builder() -> crate::error::invalid_continuation_token_exception::Builder {
        crate::error::invalid_continuation_token_exception::Builder::default()
    }
}

/// <p>The specified sort by value is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSortByException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSortByException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSortByException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSortByException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSortByException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSortByException")?;
        if let Some(inner_134) = &self.message {
            write!(f, ": {}", inner_134)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSortByException {}
/// See [`InvalidSortByException`](crate::error::InvalidSortByException)
pub mod invalid_sort_by_exception {
    /// A builder for [`InvalidSortByException`](crate::error::InvalidSortByException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSortByException`](crate::error::InvalidSortByException)
        pub fn build(self) -> crate::error::InvalidSortByException {
            crate::error::InvalidSortByException {
                message: self.message,
            }
        }
    }
}
impl InvalidSortByException {
    /// Creates a new builder-style object to manufacture [`InvalidSortByException`](crate::error::InvalidSortByException)
    pub fn builder() -> crate::error::invalid_sort_by_exception::Builder {
        crate::error::invalid_sort_by_exception::Builder::default()
    }
}

/// <p>The specified sort order is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOrderException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOrderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOrderException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOrderException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOrderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOrderException")?;
        if let Some(inner_135) = &self.message {
            write!(f, ": {}", inner_135)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOrderException {}
/// See [`InvalidOrderException`](crate::error::InvalidOrderException)
pub mod invalid_order_exception {
    /// A builder for [`InvalidOrderException`](crate::error::InvalidOrderException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOrderException`](crate::error::InvalidOrderException)
        pub fn build(self) -> crate::error::InvalidOrderException {
            crate::error::InvalidOrderException {
                message: self.message,
            }
        }
    }
}
impl InvalidOrderException {
    /// Creates a new builder-style object to manufacture [`InvalidOrderException`](crate::error::InvalidOrderException)
    pub fn builder() -> crate::error::invalid_order_exception::Builder {
        crate::error::invalid_order_exception::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAuthorArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAuthorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAuthorArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAuthorArnException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAuthorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAuthorArnException")?;
        if let Some(inner_136) = &self.message {
            write!(f, ": {}", inner_136)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAuthorArnException {}
/// See [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException)
pub mod invalid_author_arn_exception {
    /// A builder for [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException)
        pub fn build(self) -> crate::error::InvalidAuthorArnException {
            crate::error::InvalidAuthorArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidAuthorArnException {
    /// Creates a new builder-style object to manufacture [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException)
    pub fn builder() -> crate::error::invalid_author_arn_exception::Builder {
        crate::error::invalid_author_arn_exception::Builder::default()
    }
}

/// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorDoesNotExistException")?;
        if let Some(inner_137) = &self.message {
            write!(f, ": {}", inner_137)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorDoesNotExistException {}
/// See [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException)
pub mod author_does_not_exist_exception {
    /// A builder for [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException)
        pub fn build(self) -> crate::error::AuthorDoesNotExistException {
            crate::error::AuthorDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl AuthorDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException)
    pub fn builder() -> crate::error::author_does_not_exist_exception::Builder {
        crate::error::author_does_not_exist_exception::Builder::default()
    }
}

/// <p>A merge option or stategy is required, and none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MergeOptionRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MergeOptionRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MergeOptionRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MergeOptionRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MergeOptionRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MergeOptionRequiredException")?;
        if let Some(inner_138) = &self.message {
            write!(f, ": {}", inner_138)?;
        }
        Ok(())
    }
}
impl std::error::Error for MergeOptionRequiredException {}
/// See [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException)
pub mod merge_option_required_exception {
    /// A builder for [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException)
        pub fn build(self) -> crate::error::MergeOptionRequiredException {
            crate::error::MergeOptionRequiredException {
                message: self.message,
            }
        }
    }
}
impl MergeOptionRequiredException {
    /// Creates a new builder-style object to manufacture [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException)
    pub fn builder() -> crate::error::merge_option_required_exception::Builder {
        crate::error::merge_option_required_exception::Builder::default()
    }
}

/// <p>The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSourceCommitSpecifierException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSourceCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSourceCommitSpecifierException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSourceCommitSpecifierException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSourceCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSourceCommitSpecifierException")?;
        if let Some(inner_139) = &self.message {
            write!(f, ": {}", inner_139)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSourceCommitSpecifierException {}
/// See [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException)
pub mod invalid_source_commit_specifier_exception {
    /// A builder for [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException)
        pub fn build(self) -> crate::error::InvalidSourceCommitSpecifierException {
            crate::error::InvalidSourceCommitSpecifierException {
                message: self.message,
            }
        }
    }
}
impl InvalidSourceCommitSpecifierException {
    /// Creates a new builder-style object to manufacture [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException)
    pub fn builder() -> crate::error::invalid_source_commit_specifier_exception::Builder {
        crate::error::invalid_source_commit_specifier_exception::Builder::default()
    }
}

/// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMergeOptionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMergeOptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMergeOptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMergeOptionException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMergeOptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMergeOptionException")?;
        if let Some(inner_140) = &self.message {
            write!(f, ": {}", inner_140)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMergeOptionException {}
/// See [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException)
pub mod invalid_merge_option_exception {
    /// A builder for [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException)
        pub fn build(self) -> crate::error::InvalidMergeOptionException {
            crate::error::InvalidMergeOptionException {
                message: self.message,
            }
        }
    }
}
impl InvalidMergeOptionException {
    /// Creates a new builder-style object to manufacture [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException)
    pub fn builder() -> crate::error::invalid_merge_option_exception::Builder {
        crate::error::invalid_merge_option_exception::Builder::default()
    }
}

/// <p>The specified value for the number of conflict files to return is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMaxConflictFilesException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMaxConflictFilesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMaxConflictFilesException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMaxConflictFilesException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxConflictFilesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxConflictFilesException")?;
        if let Some(inner_141) = &self.message {
            write!(f, ": {}", inner_141)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxConflictFilesException {}
/// See [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException)
pub mod invalid_max_conflict_files_exception {
    /// A builder for [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException)
        pub fn build(self) -> crate::error::InvalidMaxConflictFilesException {
            crate::error::InvalidMaxConflictFilesException {
                message: self.message,
            }
        }
    }
}
impl InvalidMaxConflictFilesException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException)
    pub fn builder() -> crate::error::invalid_max_conflict_files_exception::Builder {
        crate::error::invalid_max_conflict_files_exception::Builder::default()
    }
}

/// <p>The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDestinationCommitSpecifierException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDestinationCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDestinationCommitSpecifierException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDestinationCommitSpecifierException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDestinationCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDestinationCommitSpecifierException")?;
        if let Some(inner_142) = &self.message {
            write!(f, ": {}", inner_142)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDestinationCommitSpecifierException {}
/// See [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException)
pub mod invalid_destination_commit_specifier_exception {
    /// A builder for [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException)
        pub fn build(self) -> crate::error::InvalidDestinationCommitSpecifierException {
            crate::error::InvalidDestinationCommitSpecifierException {
                message: self.message,
            }
        }
    }
}
impl InvalidDestinationCommitSpecifierException {
    /// Creates a new builder-style object to manufacture [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException)
    pub fn builder() -> crate::error::invalid_destination_commit_specifier_exception::Builder {
        crate::error::invalid_destination_commit_specifier_exception::Builder::default()
    }
}

/// <p>The specified folder does not exist. Either the folder name is not correct, or you did
/// not enter the full path to the folder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FolderDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FolderDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FolderDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FolderDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FolderDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FolderDoesNotExistException")?;
        if let Some(inner_143) = &self.message {
            write!(f, ": {}", inner_143)?;
        }
        Ok(())
    }
}
impl std::error::Error for FolderDoesNotExistException {}
/// See [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException)
pub mod folder_does_not_exist_exception {
    /// A builder for [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException)
        pub fn build(self) -> crate::error::FolderDoesNotExistException {
            crate::error::FolderDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl FolderDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException)
    pub fn builder() -> crate::error::folder_does_not_exist_exception::Builder {
        crate::error::folder_does_not_exist_exception::Builder::default()
    }
}

/// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see
/// <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileTooLargeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileTooLargeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileTooLargeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileTooLargeException")?;
        if let Some(inner_144) = &self.message {
            write!(f, ": {}", inner_144)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileTooLargeException {}
/// See [`FileTooLargeException`](crate::error::FileTooLargeException)
pub mod file_too_large_exception {
    /// A builder for [`FileTooLargeException`](crate::error::FileTooLargeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileTooLargeException`](crate::error::FileTooLargeException)
        pub fn build(self) -> crate::error::FileTooLargeException {
            crate::error::FileTooLargeException {
                message: self.message,
            }
        }
    }
}
impl FileTooLargeException {
    /// Creates a new builder-style object to manufacture [`FileTooLargeException`](crate::error::FileTooLargeException)
    pub fn builder() -> crate::error::file_too_large_exception::Builder {
        crate::error::file_too_large_exception::Builder::default()
    }
}

/// <p>The specified file does not exist. Verify that you have used the correct file name,
/// full path, and extension.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileDoesNotExistException")?;
        if let Some(inner_145) = &self.message {
            write!(f, ": {}", inner_145)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileDoesNotExistException {}
/// See [`FileDoesNotExistException`](crate::error::FileDoesNotExistException)
pub mod file_does_not_exist_exception {
    /// A builder for [`FileDoesNotExistException`](crate::error::FileDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileDoesNotExistException`](crate::error::FileDoesNotExistException)
        pub fn build(self) -> crate::error::FileDoesNotExistException {
            crate::error::FileDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl FileDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`FileDoesNotExistException`](crate::error::FileDoesNotExistException)
    pub fn builder() -> crate::error::file_does_not_exist_exception::Builder {
        crate::error::file_does_not_exist_exception::Builder::default()
    }
}

/// <p>The specified commit ID does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitIdDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitIdDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitIdDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdDoesNotExistException")?;
        if let Some(inner_146) = &self.message {
            write!(f, ": {}", inner_146)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdDoesNotExistException {}
/// See [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException)
pub mod commit_id_does_not_exist_exception {
    /// A builder for [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException)
        pub fn build(self) -> crate::error::CommitIdDoesNotExistException {
            crate::error::CommitIdDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl CommitIdDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException)
    pub fn builder() -> crate::error::commit_id_does_not_exist_exception::Builder {
        crate::error::commit_id_does_not_exist_exception::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) of the user or identity is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReactionUserArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReactionUserArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReactionUserArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReactionUserArnException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReactionUserArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReactionUserArnException")?;
        if let Some(inner_147) = &self.message {
            write!(f, ": {}", inner_147)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReactionUserArnException {}
/// See [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException)
pub mod invalid_reaction_user_arn_exception {
    /// A builder for [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException)
        pub fn build(self) -> crate::error::InvalidReactionUserArnException {
            crate::error::InvalidReactionUserArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidReactionUserArnException {
    /// Creates a new builder-style object to manufacture [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException)
    pub fn builder() -> crate::error::invalid_reaction_user_arn_exception::Builder {
        crate::error::invalid_reaction_user_arn_exception::Builder::default()
    }
}

/// <p>The specified blob is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidBlobIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidBlobIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidBlobIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidBlobIdException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidBlobIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidBlobIdException")?;
        if let Some(inner_148) = &self.message {
            write!(f, ": {}", inner_148)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidBlobIdException {}
/// See [`InvalidBlobIdException`](crate::error::InvalidBlobIdException)
pub mod invalid_blob_id_exception {
    /// A builder for [`InvalidBlobIdException`](crate::error::InvalidBlobIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidBlobIdException`](crate::error::InvalidBlobIdException)
        pub fn build(self) -> crate::error::InvalidBlobIdException {
            crate::error::InvalidBlobIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidBlobIdException {
    /// Creates a new builder-style object to manufacture [`InvalidBlobIdException`](crate::error::InvalidBlobIdException)
    pub fn builder() -> crate::error::invalid_blob_id_exception::Builder {
        crate::error::invalid_blob_id_exception::Builder::default()
    }
}

/// <p>A blob ID is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlobIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BlobIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlobIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BlobIdRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BlobIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BlobIdRequiredException")?;
        if let Some(inner_149) = &self.message {
            write!(f, ": {}", inner_149)?;
        }
        Ok(())
    }
}
impl std::error::Error for BlobIdRequiredException {}
/// See [`BlobIdRequiredException`](crate::error::BlobIdRequiredException)
pub mod blob_id_required_exception {
    /// A builder for [`BlobIdRequiredException`](crate::error::BlobIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BlobIdRequiredException`](crate::error::BlobIdRequiredException)
        pub fn build(self) -> crate::error::BlobIdRequiredException {
            crate::error::BlobIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl BlobIdRequiredException {
    /// Creates a new builder-style object to manufacture [`BlobIdRequiredException`](crate::error::BlobIdRequiredException)
    pub fn builder() -> crate::error::blob_id_required_exception::Builder {
        crate::error::blob_id_required_exception::Builder::default()
    }
}

/// <p>The specified blob does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlobIdDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BlobIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlobIdDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BlobIdDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BlobIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BlobIdDoesNotExistException")?;
        if let Some(inner_150) = &self.message {
            write!(f, ": {}", inner_150)?;
        }
        Ok(())
    }
}
impl std::error::Error for BlobIdDoesNotExistException {}
/// See [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException)
pub mod blob_id_does_not_exist_exception {
    /// A builder for [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException)
        pub fn build(self) -> crate::error::BlobIdDoesNotExistException {
            crate::error::BlobIdDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl BlobIdDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException)
    pub fn builder() -> crate::error::blob_id_does_not_exist_exception::Builder {
        crate::error::blob_id_does_not_exist_exception::Builder::default()
    }
}

/// <p>The pull request event type is not valid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPullRequestEventTypeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPullRequestEventTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPullRequestEventTypeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPullRequestEventTypeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestEventTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestEventTypeException")?;
        if let Some(inner_151) = &self.message {
            write!(f, ": {}", inner_151)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestEventTypeException {}
/// See [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException)
pub mod invalid_pull_request_event_type_exception {
    /// A builder for [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException)
        pub fn build(self) -> crate::error::InvalidPullRequestEventTypeException {
            crate::error::InvalidPullRequestEventTypeException {
                message: self.message,
            }
        }
    }
}
impl InvalidPullRequestEventTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException)
    pub fn builder() -> crate::error::invalid_pull_request_event_type_exception::Builder {
        crate::error::invalid_pull_request_event_type_exception::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request,
/// and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidActorArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidActorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidActorArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidActorArnException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidActorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidActorArnException")?;
        if let Some(inner_152) = &self.message {
            write!(f, ": {}", inner_152)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidActorArnException {}
/// See [`InvalidActorArnException`](crate::error::InvalidActorArnException)
pub mod invalid_actor_arn_exception {
    /// A builder for [`InvalidActorArnException`](crate::error::InvalidActorArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidActorArnException`](crate::error::InvalidActorArnException)
        pub fn build(self) -> crate::error::InvalidActorArnException {
            crate::error::InvalidActorArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidActorArnException {
    /// Creates a new builder-style object to manufacture [`InvalidActorArnException`](crate::error::InvalidActorArnException)
    pub fn builder() -> crate::error::invalid_actor_arn_exception::Builder {
        crate::error::invalid_actor_arn_exception::Builder::default()
    }
}

/// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActorDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ActorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActorDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ActorDoesNotExistException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ActorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ActorDoesNotExistException")?;
        if let Some(inner_153) = &self.message {
            write!(f, ": {}", inner_153)?;
        }
        Ok(())
    }
}
impl std::error::Error for ActorDoesNotExistException {}
/// See [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException)
pub mod actor_does_not_exist_exception {
    /// A builder for [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException)
        pub fn build(self) -> crate::error::ActorDoesNotExistException {
            crate::error::ActorDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ActorDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException)
    pub fn builder() -> crate::error::actor_does_not_exist_exception::Builder {
        crate::error::actor_does_not_exist_exception::Builder::default()
    }
}

/// <p>The specified value for the number of merge hunks to return is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMaxMergeHunksException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMaxMergeHunksException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMaxMergeHunksException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMaxMergeHunksException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxMergeHunksException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxMergeHunksException")?;
        if let Some(inner_154) = &self.message {
            write!(f, ": {}", inner_154)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxMergeHunksException {}
/// See [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException)
pub mod invalid_max_merge_hunks_exception {
    /// A builder for [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException)
        pub fn build(self) -> crate::error::InvalidMaxMergeHunksException {
            crate::error::InvalidMaxMergeHunksException {
                message: self.message,
            }
        }
    }
}
impl InvalidMaxMergeHunksException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException)
    pub fn builder() -> crate::error::invalid_max_merge_hunks_exception::Builder {
        crate::error::invalid_max_merge_hunks_exception::Builder::default()
    }
}

/// <p>The approval rule cannot be deleted from the pull request because it was created by an
/// approval rule template and applied to the pull request automatically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CannotDeleteApprovalRuleFromTemplateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CannotDeleteApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CannotDeleteApprovalRuleFromTemplateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CannotDeleteApprovalRuleFromTemplateException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CannotDeleteApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CannotDeleteApprovalRuleFromTemplateException")?;
        if let Some(inner_155) = &self.message {
            write!(f, ": {}", inner_155)?;
        }
        Ok(())
    }
}
impl std::error::Error for CannotDeleteApprovalRuleFromTemplateException {}
/// See [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException)
pub mod cannot_delete_approval_rule_from_template_exception {
    /// A builder for [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException)
        pub fn build(self) -> crate::error::CannotDeleteApprovalRuleFromTemplateException {
            crate::error::CannotDeleteApprovalRuleFromTemplateException {
                message: self.message,
            }
        }
    }
}
impl CannotDeleteApprovalRuleFromTemplateException {
    /// Creates a new builder-style object to manufacture [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException)
    pub fn builder() -> crate::error::cannot_delete_approval_rule_from_template_exception::Builder {
        crate::error::cannot_delete_approval_rule_from_template_exception::Builder::default()
    }
}

/// <p>The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultBranchCannotBeDeletedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DefaultBranchCannotBeDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultBranchCannotBeDeletedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DefaultBranchCannotBeDeletedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DefaultBranchCannotBeDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DefaultBranchCannotBeDeletedException")?;
        if let Some(inner_156) = &self.message {
            write!(f, ": {}", inner_156)?;
        }
        Ok(())
    }
}
impl std::error::Error for DefaultBranchCannotBeDeletedException {}
/// See [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException)
pub mod default_branch_cannot_be_deleted_exception {
    /// A builder for [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException)
        pub fn build(self) -> crate::error::DefaultBranchCannotBeDeletedException {
            crate::error::DefaultBranchCannotBeDeletedException {
                message: self.message,
            }
        }
    }
}
impl DefaultBranchCannotBeDeletedException {
    /// Creates a new builder-style object to manufacture [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException)
    pub fn builder() -> crate::error::default_branch_cannot_be_deleted_exception::Builder {
        crate::error::default_branch_cannot_be_deleted_exception::Builder::default()
    }
}

/// <p>The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove
/// all associations, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateInUseException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateInUseException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateInUseException")?;
        if let Some(inner_157) = &self.message {
            write!(f, ": {}", inner_157)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateInUseException {}
/// See [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException)
pub mod approval_rule_template_in_use_exception {
    /// A builder for [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateInUseException {
            crate::error::ApprovalRuleTemplateInUseException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateInUseException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException)
    pub fn builder() -> crate::error::approval_rule_template_in_use_exception::Builder {
        crate::error::approval_rule_template_in_use_exception::Builder::default()
    }
}

/// <p>A repository resource limit was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryLimitExceededException")?;
        if let Some(inner_158) = &self.message {
            write!(f, ": {}", inner_158)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryLimitExceededException {}
/// See [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException)
pub mod repository_limit_exceeded_exception {
    /// A builder for [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException)
        pub fn build(self) -> crate::error::RepositoryLimitExceededException {
            crate::error::RepositoryLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl RepositoryLimitExceededException {
    /// Creates a new builder-style object to manufacture [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException)
    pub fn builder() -> crate::error::repository_limit_exceeded_exception::Builder {
        crate::error::repository_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NumberOfRulesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NumberOfRulesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NumberOfRulesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NumberOfRulesExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NumberOfRulesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NumberOfRulesExceededException")?;
        if let Some(inner_159) = &self.message {
            write!(f, ": {}", inner_159)?;
        }
        Ok(())
    }
}
impl std::error::Error for NumberOfRulesExceededException {}
/// See [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException)
pub mod number_of_rules_exceeded_exception {
    /// A builder for [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException)
        pub fn build(self) -> crate::error::NumberOfRulesExceededException {
            crate::error::NumberOfRulesExceededException {
                message: self.message,
            }
        }
    }
}
impl NumberOfRulesExceededException {
    /// Creates a new builder-style object to manufacture [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException)
    pub fn builder() -> crate::error::number_of_rules_exceeded_exception::Builder {
        crate::error::number_of_rules_exceeded_exception::Builder::default()
    }
}

/// <p>An approval rule with that name already exists. Approval rule names must be unique
/// within the scope of a pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleNameAlreadyExistsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleNameAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleNameAlreadyExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleNameAlreadyExistsException")?;
        if let Some(inner_160) = &self.message {
            write!(f, ": {}", inner_160)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleNameAlreadyExistsException {}
/// See [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException)
pub mod approval_rule_name_already_exists_exception {
    /// A builder for [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException)
        pub fn build(self) -> crate::error::ApprovalRuleNameAlreadyExistsException {
            crate::error::ApprovalRuleNameAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleNameAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException)
    pub fn builder() -> crate::error::approval_rule_name_already_exists_exception::Builder {
        crate::error::approval_rule_name_already_exists_exception::Builder::default()
    }
}

/// <p>An array of target objects is required. It cannot be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetsRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetsRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetsRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetsRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetsRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetsRequiredException")?;
        if let Some(inner_161) = &self.message {
            write!(f, ": {}", inner_161)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetsRequiredException {}
/// See [`TargetsRequiredException`](crate::error::TargetsRequiredException)
pub mod targets_required_exception {
    /// A builder for [`TargetsRequiredException`](crate::error::TargetsRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetsRequiredException`](crate::error::TargetsRequiredException)
        pub fn build(self) -> crate::error::TargetsRequiredException {
            crate::error::TargetsRequiredException {
                message: self.message,
            }
        }
    }
}
impl TargetsRequiredException {
    /// Creates a new builder-style object to manufacture [`TargetsRequiredException`](crate::error::TargetsRequiredException)
    pub fn builder() -> crate::error::targets_required_exception::Builder {
        crate::error::targets_required_exception::Builder::default()
    }
}

/// <p>A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetRequiredException")?;
        if let Some(inner_162) = &self.message {
            write!(f, ": {}", inner_162)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetRequiredException {}
/// See [`TargetRequiredException`](crate::error::TargetRequiredException)
pub mod target_required_exception {
    /// A builder for [`TargetRequiredException`](crate::error::TargetRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetRequiredException`](crate::error::TargetRequiredException)
        pub fn build(self) -> crate::error::TargetRequiredException {
            crate::error::TargetRequiredException {
                message: self.message,
            }
        }
    }
}
impl TargetRequiredException {
    /// Creates a new builder-style object to manufacture [`TargetRequiredException`](crate::error::TargetRequiredException)
    pub fn builder() -> crate::error::target_required_exception::Builder {
        crate::error::target_required_exception::Builder::default()
    }
}

/// <p>The source branch and destination branch for the pull request are the same. You must
/// specify different branches for the source and destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceAndDestinationAreSameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SourceAndDestinationAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceAndDestinationAreSameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SourceAndDestinationAreSameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceAndDestinationAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceAndDestinationAreSameException")?;
        if let Some(inner_163) = &self.message {
            write!(f, ": {}", inner_163)?;
        }
        Ok(())
    }
}
impl std::error::Error for SourceAndDestinationAreSameException {}
/// See [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException)
pub mod source_and_destination_are_same_exception {
    /// A builder for [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException)
        pub fn build(self) -> crate::error::SourceAndDestinationAreSameException {
            crate::error::SourceAndDestinationAreSameException {
                message: self.message,
            }
        }
    }
}
impl SourceAndDestinationAreSameException {
    /// Creates a new builder-style object to manufacture [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException)
    pub fn builder() -> crate::error::source_and_destination_are_same_exception::Builder {
        crate::error::source_and_destination_are_same_exception::Builder::default()
    }
}

/// <p>The specified reference is not a supported type. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceTypeNotSupportedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReferenceTypeNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceTypeNotSupportedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReferenceTypeNotSupportedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReferenceTypeNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReferenceTypeNotSupportedException")?;
        if let Some(inner_164) = &self.message {
            write!(f, ": {}", inner_164)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReferenceTypeNotSupportedException {}
/// See [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException)
pub mod reference_type_not_supported_exception {
    /// A builder for [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException)
        pub fn build(self) -> crate::error::ReferenceTypeNotSupportedException {
            crate::error::ReferenceTypeNotSupportedException {
                message: self.message,
            }
        }
    }
}
impl ReferenceTypeNotSupportedException {
    /// Creates a new builder-style object to manufacture [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException)
    pub fn builder() -> crate::error::reference_type_not_supported_exception::Builder {
        crate::error::reference_type_not_supported_exception::Builder::default()
    }
}

/// <p>A reference name is required, but none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReferenceNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReferenceNameRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReferenceNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReferenceNameRequiredException")?;
        if let Some(inner_165) = &self.message {
            write!(f, ": {}", inner_165)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReferenceNameRequiredException {}
/// See [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException)
pub mod reference_name_required_exception {
    /// A builder for [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException)
        pub fn build(self) -> crate::error::ReferenceNameRequiredException {
            crate::error::ReferenceNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl ReferenceNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException)
    pub fn builder() -> crate::error::reference_name_required_exception::Builder {
        crate::error::reference_name_required_exception::Builder::default()
    }
}

/// <p>You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MultipleRepositoriesInPullRequestException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MultipleRepositoriesInPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MultipleRepositoriesInPullRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MultipleRepositoriesInPullRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MultipleRepositoriesInPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MultipleRepositoriesInPullRequestException")?;
        if let Some(inner_166) = &self.message {
            write!(f, ": {}", inner_166)?;
        }
        Ok(())
    }
}
impl std::error::Error for MultipleRepositoriesInPullRequestException {}
/// See [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException)
pub mod multiple_repositories_in_pull_request_exception {
    /// A builder for [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException)
        pub fn build(self) -> crate::error::MultipleRepositoriesInPullRequestException {
            crate::error::MultipleRepositoriesInPullRequestException {
                message: self.message,
            }
        }
    }
}
impl MultipleRepositoriesInPullRequestException {
    /// Creates a new builder-style object to manufacture [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException)
    pub fn builder() -> crate::error::multiple_repositories_in_pull_request_exception::Builder {
        crate::error::multiple_repositories_in_pull_request_exception::Builder::default()
    }
}

/// <p>You cannot create the pull request because the repository has too many open pull requests.
/// The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumOpenPullRequestsExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumOpenPullRequestsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumOpenPullRequestsExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumOpenPullRequestsExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumOpenPullRequestsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumOpenPullRequestsExceededException")?;
        if let Some(inner_167) = &self.message {
            write!(f, ": {}", inner_167)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumOpenPullRequestsExceededException {}
/// See [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException)
pub mod maximum_open_pull_requests_exceeded_exception {
    /// A builder for [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException)
        pub fn build(self) -> crate::error::MaximumOpenPullRequestsExceededException {
            crate::error::MaximumOpenPullRequestsExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumOpenPullRequestsExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException)
    pub fn builder() -> crate::error::maximum_open_pull_requests_exceeded_exception::Builder {
        crate::error::maximum_open_pull_requests_exceeded_exception::Builder::default()
    }
}

/// <p>The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for
/// the repository name, source branch, and destination branch for a pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTargetsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTargetsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTargetsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTargetsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetsException")?;
        if let Some(inner_168) = &self.message {
            write!(f, ": {}", inner_168)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetsException {}
/// See [`InvalidTargetsException`](crate::error::InvalidTargetsException)
pub mod invalid_targets_exception {
    /// A builder for [`InvalidTargetsException`](crate::error::InvalidTargetsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetsException`](crate::error::InvalidTargetsException)
        pub fn build(self) -> crate::error::InvalidTargetsException {
            crate::error::InvalidTargetsException {
                message: self.message,
            }
        }
    }
}
impl InvalidTargetsException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetsException`](crate::error::InvalidTargetsException)
    pub fn builder() -> crate::error::invalid_targets_exception::Builder {
        crate::error::invalid_targets_exception::Builder::default()
    }
}

/// <p>The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTargetException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTargetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTargetException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTargetException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetException")?;
        if let Some(inner_169) = &self.message {
            write!(f, ": {}", inner_169)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetException {}
/// See [`InvalidTargetException`](crate::error::InvalidTargetException)
pub mod invalid_target_exception {
    /// A builder for [`InvalidTargetException`](crate::error::InvalidTargetException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetException`](crate::error::InvalidTargetException)
        pub fn build(self) -> crate::error::InvalidTargetException {
            crate::error::InvalidTargetException {
                message: self.message,
            }
        }
    }
}
impl InvalidTargetException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetException`](crate::error::InvalidTargetException)
    pub fn builder() -> crate::error::invalid_target_exception::Builder {
        crate::error::invalid_target_exception::Builder::default()
    }
}

/// <p>The specified reference name format is not valid. Reference names must conform to the
/// Git references format (for example, refs/heads/master). For more information, see <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">Git Internals -
/// Git References</a> or consult your Git documentation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReferenceNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReferenceNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReferenceNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReferenceNameException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReferenceNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReferenceNameException")?;
        if let Some(inner_170) = &self.message {
            write!(f, ": {}", inner_170)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReferenceNameException {}
/// See [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException)
pub mod invalid_reference_name_exception {
    /// A builder for [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException)
        pub fn build(self) -> crate::error::InvalidReferenceNameException {
            crate::error::InvalidReferenceNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidReferenceNameException {
    /// Creates a new builder-style object to manufacture [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException)
    pub fn builder() -> crate::error::invalid_reference_name_exception::Builder {
        crate::error::invalid_reference_name_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because no source files or file content have been specified for the commit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceFileOrContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SourceFileOrContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceFileOrContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SourceFileOrContentRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceFileOrContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceFileOrContentRequiredException")?;
        if let Some(inner_171) = &self.message {
            write!(f, ": {}", inner_171)?;
        }
        Ok(())
    }
}
impl std::error::Error for SourceFileOrContentRequiredException {}
/// See [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException)
pub mod source_file_or_content_required_exception {
    /// A builder for [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException)
        pub fn build(self) -> crate::error::SourceFileOrContentRequiredException {
            crate::error::SourceFileOrContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl SourceFileOrContentRequiredException {
    /// Creates a new builder-style object to manufacture [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException)
    pub fn builder() -> crate::error::source_file_or_content_required_exception::Builder {
        crate::error::source_file_or_content_required_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example,
/// you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same
/// file as part of the same commit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SamePathRequestException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SamePathRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SamePathRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SamePathRequestException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SamePathRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SamePathRequestException")?;
        if let Some(inner_172) = &self.message {
            write!(f, ": {}", inner_172)?;
        }
        Ok(())
    }
}
impl std::error::Error for SamePathRequestException {}
/// See [`SamePathRequestException`](crate::error::SamePathRequestException)
pub mod same_path_request_exception {
    /// A builder for [`SamePathRequestException`](crate::error::SamePathRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SamePathRequestException`](crate::error::SamePathRequestException)
        pub fn build(self) -> crate::error::SamePathRequestException {
            crate::error::SamePathRequestException {
                message: self.message,
            }
        }
    }
}
impl SamePathRequestException {
    /// Creates a new builder-style object to manufacture [`SamePathRequestException`](crate::error::SamePathRequestException)
    pub fn builder() -> crate::error::same_path_request_exception::Builder {
        crate::error::same_path_request_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RestrictedSourceFileException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RestrictedSourceFileException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestrictedSourceFileException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RestrictedSourceFileException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RestrictedSourceFileException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RestrictedSourceFileException")?;
        if let Some(inner_173) = &self.message {
            write!(f, ": {}", inner_173)?;
        }
        Ok(())
    }
}
impl std::error::Error for RestrictedSourceFileException {}
/// See [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException)
pub mod restricted_source_file_exception {
    /// A builder for [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException)
        pub fn build(self) -> crate::error::RestrictedSourceFileException {
            crate::error::RestrictedSourceFileException {
                message: self.message,
            }
        }
    }
}
impl RestrictedSourceFileException {
    /// Creates a new builder-style object to manufacture [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException)
    pub fn builder() -> crate::error::restricted_source_file_exception::Builder {
        crate::error::restricted_source_file_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because one or more files specified in the commit reference both a file and a folder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutFileEntryConflictException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutFileEntryConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutFileEntryConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PutFileEntryConflictException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PutFileEntryConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PutFileEntryConflictException")?;
        if let Some(inner_174) = &self.message {
            write!(f, ": {}", inner_174)?;
        }
        Ok(())
    }
}
impl std::error::Error for PutFileEntryConflictException {}
/// See [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException)
pub mod put_file_entry_conflict_exception {
    /// A builder for [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException)
        pub fn build(self) -> crate::error::PutFileEntryConflictException {
            crate::error::PutFileEntryConflictException {
                message: self.message,
            }
        }
    }
}
impl PutFileEntryConflictException {
    /// Creates a new builder-style object to manufacture [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException)
    pub fn builder() -> crate::error::put_file_entry_conflict_exception::Builder {
        crate::error::put_file_entry_conflict_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoChangeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoChangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoChangeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoChangeException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoChangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoChangeException")?;
        if let Some(inner_175) = &self.message {
            write!(f, ": {}", inner_175)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoChangeException {}
/// See [`NoChangeException`](crate::error::NoChangeException)
pub mod no_change_exception {
    /// A builder for [`NoChangeException`](crate::error::NoChangeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoChangeException`](crate::error::NoChangeException)
        pub fn build(self) -> crate::error::NoChangeException {
            crate::error::NoChangeException {
                message: self.message,
            }
        }
    }
}
impl NoChangeException {
    /// Creates a new builder-style object to manufacture [`NoChangeException`](crate::error::NoChangeException)
    pub fn builder() -> crate::error::no_change_exception::Builder {
        crate::error::no_change_exception::Builder::default()
    }
}

/// <p>The number of specified files to change as part of this commit exceeds the maximum number of files
/// that can be changed in a single commit. Consider using a Git client for these changes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumFileEntriesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumFileEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumFileEntriesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumFileEntriesExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumFileEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumFileEntriesExceededException")?;
        if let Some(inner_176) = &self.message {
            write!(f, ": {}", inner_176)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumFileEntriesExceededException {}
/// See [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException)
pub mod maximum_file_entries_exceeded_exception {
    /// A builder for [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException)
        pub fn build(self) -> crate::error::MaximumFileEntriesExceededException {
            crate::error::MaximumFileEntriesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumFileEntriesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException)
    pub fn builder() -> crate::error::maximum_file_entries_exceeded_exception::Builder {
        crate::error::maximum_file_entries_exceeded_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileEntryRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileEntryRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileEntryRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileEntryRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileEntryRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileEntryRequiredException")?;
        if let Some(inner_177) = &self.message {
            write!(f, ": {}", inner_177)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileEntryRequiredException {}
/// See [`FileEntryRequiredException`](crate::error::FileEntryRequiredException)
pub mod file_entry_required_exception {
    /// A builder for [`FileEntryRequiredException`](crate::error::FileEntryRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileEntryRequiredException`](crate::error::FileEntryRequiredException)
        pub fn build(self) -> crate::error::FileEntryRequiredException {
            crate::error::FileEntryRequiredException {
                message: self.message,
            }
        }
    }
}
impl FileEntryRequiredException {
    /// Creates a new builder-style object to manufacture [`FileEntryRequiredException`](crate::error::FileEntryRequiredException)
    pub fn builder() -> crate::error::file_entry_required_exception::Builder {
        crate::error::file_entry_required_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because both a source file and file content have been
/// specified for the same file. You cannot provide both. Either specify a source file or
/// provide the file content directly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileContentAndSourceFileSpecifiedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileContentAndSourceFileSpecifiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileContentAndSourceFileSpecifiedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileContentAndSourceFileSpecifiedException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileContentAndSourceFileSpecifiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileContentAndSourceFileSpecifiedException")?;
        if let Some(inner_178) = &self.message {
            write!(f, ": {}", inner_178)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileContentAndSourceFileSpecifiedException {}
/// See [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException)
pub mod file_content_and_source_file_specified_exception {
    /// A builder for [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException)
        pub fn build(self) -> crate::error::FileContentAndSourceFileSpecifiedException {
            crate::error::FileContentAndSourceFileSpecifiedException {
                message: self.message,
            }
        }
    }
}
impl FileContentAndSourceFileSpecifiedException {
    /// Creates a new builder-style object to manufacture [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException)
    pub fn builder() -> crate::error::file_content_and_source_file_specified_exception::Builder {
        crate::error::file_content_and_source_file_specified_exception::Builder::default()
    }
}

/// <p>Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name.
/// Branch names must be unique.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BranchNameExistsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BranchNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BranchNameExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BranchNameExistsException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchNameExistsException")?;
        if let Some(inner_179) = &self.message {
            write!(f, ": {}", inner_179)?;
        }
        Ok(())
    }
}
impl std::error::Error for BranchNameExistsException {}
/// See [`BranchNameExistsException`](crate::error::BranchNameExistsException)
pub mod branch_name_exists_exception {
    /// A builder for [`BranchNameExistsException`](crate::error::BranchNameExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BranchNameExistsException`](crate::error::BranchNameExistsException)
        pub fn build(self) -> crate::error::BranchNameExistsException {
            crate::error::BranchNameExistsException {
                message: self.message,
            }
        }
    }
}
impl BranchNameExistsException {
    /// Creates a new builder-style object to manufacture [`BranchNameExistsException`](crate::error::BranchNameExistsException)
    pub fn builder() -> crate::error::branch_name_exists_exception::Builder {
        crate::error::branch_name_exists_exception::Builder::default()
    }
}

/// <p>The maximum number of approval rule templates has been exceeded for this AWS Region. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NumberOfRuleTemplatesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NumberOfRuleTemplatesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NumberOfRuleTemplatesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NumberOfRuleTemplatesExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NumberOfRuleTemplatesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NumberOfRuleTemplatesExceededException")?;
        if let Some(inner_180) = &self.message {
            write!(f, ": {}", inner_180)?;
        }
        Ok(())
    }
}
impl std::error::Error for NumberOfRuleTemplatesExceededException {}
/// See [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException)
pub mod number_of_rule_templates_exceeded_exception {
    /// A builder for [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException)
        pub fn build(self) -> crate::error::NumberOfRuleTemplatesExceededException {
            crate::error::NumberOfRuleTemplatesExceededException {
                message: self.message,
            }
        }
    }
}
impl NumberOfRuleTemplatesExceededException {
    /// Creates a new builder-style object to manufacture [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException)
    pub fn builder() -> crate::error::number_of_rule_templates_exceeded_exception::Builder {
        crate::error::number_of_rule_templates_exceeded_exception::Builder::default()
    }
}

/// <p>At least one repository name object is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryNamesRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryNamesRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryNamesRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryNamesRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNamesRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNamesRequiredException")?;
        if let Some(inner_181) = &self.message {
            write!(f, ": {}", inner_181)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNamesRequiredException {}
/// See [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException)
pub mod repository_names_required_exception {
    /// A builder for [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException)
        pub fn build(self) -> crate::error::RepositoryNamesRequiredException {
            crate::error::RepositoryNamesRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryNamesRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException)
    pub fn builder() -> crate::error::repository_names_required_exception::Builder {
        crate::error::repository_names_required_exception::Builder::default()
    }
}

/// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumRepositoryNamesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumRepositoryNamesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumRepositoryNamesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumRepositoryNamesExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumRepositoryNamesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumRepositoryNamesExceededException")?;
        if let Some(inner_182) = &self.message {
            write!(f, ": {}", inner_182)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumRepositoryNamesExceededException {}
/// See [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException)
pub mod maximum_repository_names_exceeded_exception {
    /// A builder for [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException)
        pub fn build(self) -> crate::error::MaximumRepositoryNamesExceededException {
            crate::error::MaximumRepositoryNamesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumRepositoryNamesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException)
    pub fn builder() -> crate::error::maximum_repository_names_exceeded_exception::Builder {
        crate::error::maximum_repository_names_exceeded_exception::Builder::default()
    }
}

/// <p>A list of commit IDs is required, but was either not specified or the list was empty.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitIdsListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitIdsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitIdsListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitIdsListRequiredException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdsListRequiredException")?;
        if let Some(inner_183) = &self.message {
            write!(f, ": {}", inner_183)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdsListRequiredException {}
/// See [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException)
pub mod commit_ids_list_required_exception {
    /// A builder for [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException)
        pub fn build(self) -> crate::error::CommitIdsListRequiredException {
            crate::error::CommitIdsListRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommitIdsListRequiredException {
    /// Creates a new builder-style object to manufacture [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException)
    pub fn builder() -> crate::error::commit_ids_list_required_exception::Builder {
        crate::error::commit_ids_list_required_exception::Builder::default()
    }
}

/// <p>The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitIdsLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitIdsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitIdsLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitIdsLimitExceededException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdsLimitExceededException")?;
        if let Some(inner_184) = &self.message {
            write!(f, ": {}", inner_184)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdsLimitExceededException {}
/// See [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException)
pub mod commit_ids_limit_exceeded_exception {
    /// A builder for [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException)
        pub fn build(self) -> crate::error::CommitIdsLimitExceededException {
            crate::error::CommitIdsLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl CommitIdsLimitExceededException {
    /// Creates a new builder-style object to manufacture [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException)
    pub fn builder() -> crate::error::commit_ids_limit_exceeded_exception::Builder {
        crate::error::commit_ids_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25
/// approval rule templates with a repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumRuleTemplatesAssociatedWithRepositoryException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumRuleTemplatesAssociatedWithRepositoryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumRuleTemplatesAssociatedWithRepositoryException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumRuleTemplatesAssociatedWithRepositoryException {
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumRuleTemplatesAssociatedWithRepositoryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumRuleTemplatesAssociatedWithRepositoryException")?;
        if let Some(inner_185) = &self.message {
            write!(f, ": {}", inner_185)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumRuleTemplatesAssociatedWithRepositoryException {}
/// See [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException)
pub mod maximum_rule_templates_associated_with_repository_exception {
    /// A builder for [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException)
        pub fn build(self) -> crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException {
            crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException {
                message: self.message,
            }
        }
    }
}
impl MaximumRuleTemplatesAssociatedWithRepositoryException {
    /// Creates a new builder-style object to manufacture [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException)
    pub fn builder(
    ) -> crate::error::maximum_rule_templates_associated_with_repository_exception::Builder {
        crate::error::maximum_rule_templates_associated_with_repository_exception::Builder::default(
        )
    }
}
