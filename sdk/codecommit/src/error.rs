// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Error type for the `AssociateApprovalRuleTemplateWithRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct AssociateApprovalRuleTemplateWithRepositoryError {
    /// Kind of error that occurred.
    pub kind: AssociateApprovalRuleTemplateWithRepositoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `AssociateApprovalRuleTemplateWithRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateApprovalRuleTemplateWithRepositoryErrorKind {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25 approval rule templates with a repository.</p>
    MaximumRuleTemplatesAssociatedWithRepositoryException(
        crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException,
    ),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for AssociateApprovalRuleTemplateWithRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::MaximumRuleTemplatesAssociatedWithRepositoryException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for AssociateApprovalRuleTemplateWithRepositoryError
{
    fn code(&self) -> Option<&str> {
        AssociateApprovalRuleTemplateWithRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateApprovalRuleTemplateWithRepositoryError {
    /// Creates a new `AssociateApprovalRuleTemplateWithRepositoryError`.
    pub fn new(
        kind: AssociateApprovalRuleTemplateWithRepositoryErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `AssociateApprovalRuleTemplateWithRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: AssociateApprovalRuleTemplateWithRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `AssociateApprovalRuleTemplateWithRepositoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: AssociateApprovalRuleTemplateWithRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyUnavailableException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::MaximumRuleTemplatesAssociatedWithRepositoryException`.
    pub fn is_maximum_rule_templates_associated_with_repository_exception(&self) -> bool {
        matches!(&self.kind, AssociateApprovalRuleTemplateWithRepositoryErrorKind::MaximumRuleTemplatesAssociatedWithRepositoryException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryDoesNotExistException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryNameRequiredException(
                _
            )
        )
    }
}
impl std::error::Error for AssociateApprovalRuleTemplateWithRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::MaximumRuleTemplatesAssociatedWithRepositoryException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            AssociateApprovalRuleTemplateWithRepositoryErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `BatchAssociateApprovalRuleTemplateWithRepositories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    /// Kind of error that occurred.
    pub kind: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `BatchAssociateApprovalRuleTemplateWithRepositories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    /// <p>At least one repository name object is required, but was not specified.</p>
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for BatchAssociateApprovalRuleTemplateWithRepositoriesError
{
    fn code(&self) -> Option<&str> {
        BatchAssociateApprovalRuleTemplateWithRepositoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    /// Creates a new `BatchAssociateApprovalRuleTemplateWithRepositoriesError`.
    pub fn new(
        kind: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `BatchAssociateApprovalRuleTemplateWithRepositoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::Unhandled(
                err.into(),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `BatchAssociateApprovalRuleTemplateWithRepositoriesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::Unhandled(
                err.into(),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::MaximumRepositoryNamesExceededException`.
    pub fn is_maximum_repository_names_exceeded_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::RepositoryNamesRequiredException`.
    pub fn is_repository_names_required_exception(&self) -> bool {
        matches!(&self.kind, BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::RepositoryNamesRequiredException(_))
    }
}
impl std::error::Error for BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) =>
            Some(_inner)
            ,
            BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `BatchDescribeMergeConflicts` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDescribeMergeConflictsError {
    /// Kind of error that occurred.
    pub kind: BatchDescribeMergeConflictsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `BatchDescribeMergeConflicts` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDescribeMergeConflictsErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified value for the number of conflict files to return is not valid.</p>
    InvalidMaxConflictFilesException(crate::error::InvalidMaxConflictFilesException),
    /// <p>The specified value for the number of merge hunks to return is not valid.</p>
    InvalidMaxMergeHunksException(crate::error::InvalidMaxMergeHunksException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDescribeMergeConflictsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDescribeMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(
                _inner,
            ) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMaxConflictFilesException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(
                _inner,
            ) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(
                _inner,
            ) => _inner.fmt(f),
            BatchDescribeMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            BatchDescribeMergeConflictsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchDescribeMergeConflictsError {
    fn code(&self) -> Option<&str> {
        BatchDescribeMergeConflictsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDescribeMergeConflictsError {
    /// Creates a new `BatchDescribeMergeConflictsError`.
    pub fn new(kind: BatchDescribeMergeConflictsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `BatchDescribeMergeConflictsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDescribeMergeConflictsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `BatchDescribeMergeConflictsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDescribeMergeConflictsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::InvalidMaxConflictFilesException`.
    pub fn is_invalid_max_conflict_files_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidMaxConflictFilesException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException`.
    pub fn is_invalid_max_merge_hunks_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::InvalidMergeOptionException`.
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidMergeOptionException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::MergeOptionRequiredException`.
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::MergeOptionRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchDescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for BatchDescribeMergeConflictsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDescribeMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::CommitRequiredException(_inner) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidCommitException(_inner) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(
                _inner,
            ) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMaxConflictFilesException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(
                _inner,
            ) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(
                _inner,
            ) => Some(_inner),
            BatchDescribeMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => {
                Some(_inner)
            }
            BatchDescribeMergeConflictsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `BatchDisassociateApprovalRuleTemplateFromRepositories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    /// Kind of error that occurred.
    pub kind: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `BatchDisassociateApprovalRuleTemplateFromRepositories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    /// <p>At least one repository name object is required, but was not specified.</p>
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for BatchDisassociateApprovalRuleTemplateFromRepositoriesError
{
    fn code(&self) -> Option<&str> {
        BatchDisassociateApprovalRuleTemplateFromRepositoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    /// Creates a new `BatchDisassociateApprovalRuleTemplateFromRepositoriesError`.
    pub fn new(
        kind: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::Unhandled(
                err.into(),
            ),
            meta: Default::default(),
        }
    }

    /// Creates the `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::Unhandled(
                err.into(),
            ),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::MaximumRepositoryNamesExceededException`.
    pub fn is_maximum_repository_names_exceeded_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::RepositoryNamesRequiredException`.
    pub fn is_repository_names_required_exception(&self) -> bool {
        matches!(&self.kind, BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::RepositoryNamesRequiredException(_))
    }
}
impl std::error::Error for BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) =>
            Some(_inner)
            ,
            BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `BatchGetCommits` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetCommitsError {
    /// Kind of error that occurred.
    pub kind: BatchGetCommitsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `BatchGetCommits` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetCommitsErrorKind {
    /// <p>The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.</p>
    CommitIdsLimitExceededException(crate::error::CommitIdsLimitExceededException),
    /// <p>A list of commit IDs is required, but was either not specified or the list was empty.</p>
    CommitIdsListRequiredException(crate::error::CommitIdsListRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetCommitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetCommitsErrorKind::CommitIdsLimitExceededException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::CommitIdsListRequiredException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetCommitsErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            BatchGetCommitsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetCommitsError {
    fn code(&self) -> Option<&str> {
        BatchGetCommitsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetCommitsError {
    /// Creates a new `BatchGetCommitsError`.
    pub fn new(kind: BatchGetCommitsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `BatchGetCommitsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetCommitsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `BatchGetCommitsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetCommitsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::CommitIdsLimitExceededException`.
    pub fn is_commit_ids_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::CommitIdsLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::CommitIdsListRequiredException`.
    pub fn is_commit_ids_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::CommitIdsListRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetCommitsErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetCommitsErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for BatchGetCommitsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetCommitsErrorKind::CommitIdsLimitExceededException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::CommitIdsListRequiredException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            BatchGetCommitsErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            BatchGetCommitsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `BatchGetRepositories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct BatchGetRepositoriesError {
    /// Kind of error that occurred.
    pub kind: BatchGetRepositoriesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `BatchGetRepositories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetRepositoriesErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    /// <p>At least one repository name object is required, but was not specified.</p>
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for BatchGetRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            BatchGetRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            BatchGetRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            BatchGetRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            BatchGetRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) => {
                _inner.fmt(f)
            }
            BatchGetRepositoriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetRepositoriesError {
    fn code(&self) -> Option<&str> {
        BatchGetRepositoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetRepositoriesError {
    /// Creates a new `BatchGetRepositoriesError`.
    pub fn new(kind: BatchGetRepositoriesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `BatchGetRepositoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: BatchGetRepositoriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `BatchGetRepositoriesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: BatchGetRepositoriesErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesErrorKind::MaximumRepositoryNamesExceededException`.
    pub fn is_maximum_repository_names_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesErrorKind::RepositoryNamesRequiredException`.
    pub fn is_repository_names_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            BatchGetRepositoriesErrorKind::RepositoryNamesRequiredException(_)
        )
    }
}
impl std::error::Error for BatchGetRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            BatchGetRepositoriesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            BatchGetRepositoriesErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            BatchGetRepositoriesErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            BatchGetRepositoriesErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            BatchGetRepositoriesErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            BatchGetRepositoriesErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            BatchGetRepositoriesErrorKind::MaximumRepositoryNamesExceededException(_inner) => {
                Some(_inner)
            }
            BatchGetRepositoriesErrorKind::RepositoryNamesRequiredException(_inner) => Some(_inner),
            BatchGetRepositoriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateApprovalRuleTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateApprovalRuleTemplateError {
    /// Kind of error that occurred.
    pub kind: CreateApprovalRuleTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateApprovalRuleTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateApprovalRuleTemplateErrorKind {
    /// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
    ApprovalRuleTemplateContentRequiredException(
        crate::error::ApprovalRuleTemplateContentRequiredException,
    ),
    /// <p>You cannot create an approval rule template with that name because a template with that name already exists in this AWS Region for your AWS account. Approval rule template names must be unique.</p>
    ApprovalRuleTemplateNameAlreadyExistsException(
        crate::error::ApprovalRuleTemplateNameAlreadyExistsException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The content of the approval rule template is not valid.</p>
    InvalidApprovalRuleTemplateContentException(
        crate::error::InvalidApprovalRuleTemplateContentException,
    ),
    /// <p>The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateDescriptionException(
        crate::error::InvalidApprovalRuleTemplateDescriptionException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The maximum number of approval rule templates has been exceeded for this AWS Region. </p>
    NumberOfRuleTemplatesExceededException(crate::error::NumberOfRuleTemplatesExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateContentException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateDescriptionException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::NumberOfRuleTemplatesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateApprovalRuleTemplateErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        CreateApprovalRuleTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateApprovalRuleTemplateError {
    /// Creates a new `CreateApprovalRuleTemplateError`.
    pub fn new(kind: CreateApprovalRuleTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateApprovalRuleTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateApprovalRuleTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateApprovalRuleTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateApprovalRuleTemplateErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateContentRequiredException`.
    pub fn is_approval_rule_template_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameAlreadyExistsException`.
    pub fn is_approval_rule_template_name_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateContentException`.
    pub fn is_invalid_approval_rule_template_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateContentException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateDescriptionException`.
    pub fn is_invalid_approval_rule_template_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateDescriptionException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateErrorKind::NumberOfRuleTemplatesExceededException`.
    pub fn is_number_of_rule_templates_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateApprovalRuleTemplateErrorKind::NumberOfRuleTemplatesExceededException(_)
        )
    }
}
impl std::error::Error for CreateApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateContentRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateContentException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateDescriptionException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::NumberOfRuleTemplatesExceededException(_inner) =>
            Some(_inner)
            ,
            CreateApprovalRuleTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `CreateBranch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateBranchError {
    /// Kind of error that occurred.
    pub kind: CreateBranchErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateBranch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBranchErrorKind {
    /// <p>Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name. Branch names must be unique.</p>
    BranchNameExistsException(crate::error::BranchNameExistsException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateBranchErrorKind::BranchNameExistsException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::CommitIdRequiredException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreateBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            CreateBranchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateBranchError {
    fn code(&self) -> Option<&str> {
        CreateBranchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBranchError {
    /// Creates a new `CreateBranchError`.
    pub fn new(kind: CreateBranchErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateBranchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateBranchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateBranchError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateBranchErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::BranchNameExistsException`.
    pub fn is_branch_name_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::BranchNameExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::BranchNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::CommitIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::InvalidBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::InvalidCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateBranchErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateBranchErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for CreateBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateBranchErrorKind::BranchNameExistsException(_inner) => Some(_inner),
            CreateBranchErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            CreateBranchErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            CreateBranchErrorKind::CommitIdRequiredException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            CreateBranchErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            CreateBranchErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            CreateBranchErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            CreateBranchErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            CreateBranchErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            CreateBranchErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            CreateBranchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateCommitError {
    /// Kind of error that occurred.
    pub kind: CreateCommitErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCommitErrorKind {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
    DirectoryNameConflictsWithFileNameException(
        crate::error::DirectoryNameConflictsWithFileNameException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.</p>
    FileContentAndSourceFileSpecifiedException(
        crate::error::FileContentAndSourceFileSpecifiedException,
    ),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    /// <p>The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.</p>
    FileEntryRequiredException(crate::error::FileEntryRequiredException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::error::FileModeRequiredException),
    /// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
    FileNameConflictsWithDirectoryNameException(
        crate::error::FileNameConflictsWithDirectoryNameException,
    ),
    /// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
    FilePathConflictsWithSubmodulePathException(
        crate::error::FilePathConflictsWithSubmodulePathException,
    ),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified deletion parameter is not valid.</p>
    InvalidDeletionParameterException(crate::error::InvalidDeletionParameterException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.</p>
    MaximumFileEntriesExceededException(crate::error::MaximumFileEntriesExceededException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.</p>
    NoChangeException(crate::error::NoChangeException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The commit cannot be created because one or more files specified in the commit reference both a file and a folder.</p>
    PutFileEntryConflictException(crate::error::PutFileEntryConflictException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.</p>
    RestrictedSourceFileException(crate::error::RestrictedSourceFileException),
    /// <p>The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.</p>
    SamePathRequestException(crate::error::SamePathRequestException),
    /// <p>The commit cannot be created because no source files or file content have been specified for the commit.</p>
    SourceFileOrContentRequiredException(crate::error::SourceFileOrContentRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateCommitErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::DirectoryNameConflictsWithFileNameException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileContentAndSourceFileSpecifiedException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileDoesNotExistException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileEntryRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileModeRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::FileNameConflictsWithDirectoryNameException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::FilePathConflictsWithSubmodulePathException(_inner) => {
                _inner.fmt(f)
            }
            CreateCommitErrorKind::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidDeletionParameterException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidFileModeException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::MaximumFileEntriesExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::NoChangeException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::PutFileEntryConflictException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::RestrictedSourceFileException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::SamePathRequestException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::SourceFileOrContentRequiredException(_inner) => _inner.fmt(f),
            CreateCommitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCommitError {
    fn code(&self) -> Option<&str> {
        CreateCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCommitError {
    /// Creates a new `CreateCommitError`.
    pub fn new(kind: CreateCommitErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateCommitError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateCommitErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::BranchDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::BranchNameIsTagNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::BranchNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::DirectoryNameConflictsWithFileNameException`.
    pub fn is_directory_name_conflicts_with_file_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::DirectoryNameConflictsWithFileNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::FileContentAndSourceFileSpecifiedException`.
    pub fn is_file_content_and_source_file_specified_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileContentAndSourceFileSpecifiedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::FileEntryRequiredException`.
    pub fn is_file_entry_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileEntryRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::FileModeRequiredException`.
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileModeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::FileNameConflictsWithDirectoryNameException`.
    pub fn is_file_name_conflicts_with_directory_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FileNameConflictsWithDirectoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::FilePathConflictsWithSubmodulePathException`.
    pub fn is_file_path_conflicts_with_submodule_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FilePathConflictsWithSubmodulePathException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::InvalidDeletionParameterException`.
    pub fn is_invalid_deletion_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidDeletionParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(&self.kind, CreateCommitErrorKind::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidFileModeException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::InvalidParentCommitIdException`.
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidParentCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, CreateCommitErrorKind::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::MaximumFileEntriesExceededException`.
    pub fn is_maximum_file_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::MaximumFileEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::NameLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::NoChangeException`.
    pub fn is_no_change_exception(&self) -> bool {
        matches!(&self.kind, CreateCommitErrorKind::NoChangeException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::ParentCommitDoesNotExistException`.
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::ParentCommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::ParentCommitIdOutdatedException`.
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::ParentCommitIdOutdatedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::ParentCommitIdRequiredException`.
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::ParentCommitIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, CreateCommitErrorKind::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::PutFileEntryConflictException`.
    pub fn is_put_file_entry_conflict_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::PutFileEntryConflictException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::RestrictedSourceFileException`.
    pub fn is_restricted_source_file_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::RestrictedSourceFileException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::SamePathRequestException`.
    pub fn is_same_path_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::SamePathRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateCommitErrorKind::SourceFileOrContentRequiredException`.
    pub fn is_source_file_or_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateCommitErrorKind::SourceFileOrContentRequiredException(_)
        )
    }
}
impl std::error::Error for CreateCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateCommitErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            CreateCommitErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            CreateCommitErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::CommitMessageLengthExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::DirectoryNameConflictsWithFileNameException(_inner) => {
                Some(_inner)
            }
            CreateCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            CreateCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            CreateCommitErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            CreateCommitErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            CreateCommitErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileContentAndSourceFileSpecifiedException(_inner) => {
                Some(_inner)
            }
            CreateCommitErrorKind::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileDoesNotExistException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileEntryRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileModeRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::FileNameConflictsWithDirectoryNameException(_inner) => {
                Some(_inner)
            }
            CreateCommitErrorKind::FilePathConflictsWithSubmodulePathException(_inner) => {
                Some(_inner)
            }
            CreateCommitErrorKind::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidDeletionParameterException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidEmailException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidFileModeException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidParentCommitIdException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidPathException(_inner) => Some(_inner),
            CreateCommitErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            CreateCommitErrorKind::MaximumFileEntriesExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            CreateCommitErrorKind::NoChangeException(_inner) => Some(_inner),
            CreateCommitErrorKind::ParentCommitDoesNotExistException(_inner) => Some(_inner),
            CreateCommitErrorKind::ParentCommitIdOutdatedException(_inner) => Some(_inner),
            CreateCommitErrorKind::ParentCommitIdRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::PathRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::PutFileEntryConflictException(_inner) => Some(_inner),
            CreateCommitErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            CreateCommitErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::RestrictedSourceFileException(_inner) => Some(_inner),
            CreateCommitErrorKind::SamePathRequestException(_inner) => Some(_inner),
            CreateCommitErrorKind::SourceFileOrContentRequiredException(_inner) => Some(_inner),
            CreateCommitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreatePullRequest` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePullRequestError {
    /// Kind of error that occurred.
    pub kind: CreatePullRequestErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreatePullRequest` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePullRequestErrorKind {
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    /// <p>The pull request description is not valid. Descriptions cannot be more than 1,000 characters.</p>
    InvalidDescriptionException(crate::error::InvalidDescriptionException),
    /// <p>The specified reference name format is not valid. Reference names must conform to the Git references format (for example, refs/heads/master). For more information, see <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">Git Internals - Git References</a> or consult your Git documentation.</p>
    InvalidReferenceNameException(crate::error::InvalidReferenceNameException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
    InvalidTargetException(crate::error::InvalidTargetException),
    /// <p>The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for the repository name, source branch, and destination branch for a pull request.</p>
    InvalidTargetsException(crate::error::InvalidTargetsException),
    /// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
    InvalidTitleException(crate::error::InvalidTitleException),
    /// <p>You cannot create the pull request because the repository has too many open pull requests. The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.</p>
    MaximumOpenPullRequestsExceededException(
        crate::error::MaximumOpenPullRequestsExceededException,
    ),
    /// <p>You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.</p>
    MultipleRepositoriesInPullRequestException(
        crate::error::MultipleRepositoriesInPullRequestException,
    ),
    /// <p>The specified reference does not exist. You must provide a full commit ID.</p>
    ReferenceDoesNotExistException(crate::error::ReferenceDoesNotExistException),
    /// <p>A reference name is required, but none was provided.</p>
    ReferenceNameRequiredException(crate::error::ReferenceNameRequiredException),
    /// <p>The specified reference is not a supported type. </p>
    ReferenceTypeNotSupportedException(crate::error::ReferenceTypeNotSupportedException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The source branch and destination branch for the pull request are the same. You must specify different branches for the source and destination.</p>
    SourceAndDestinationAreSameException(crate::error::SourceAndDestinationAreSameException),
    /// <p>A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
    TargetRequiredException(crate::error::TargetRequiredException),
    /// <p>An array of target objects is required. It cannot be empty or null.</p>
    TargetsRequiredException(crate::error::TargetsRequiredException),
    /// <p>A pull request title is required. It cannot be empty or null.</p>
    TitleRequiredException(crate::error::TitleRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePullRequestErrorKind::ClientRequestTokenRequiredException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::IdempotencyParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::InvalidClientRequestTokenException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidDescriptionException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidReferenceNameException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidTargetException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidTargetsException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::InvalidTitleException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::MaximumOpenPullRequestsExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::MultipleRepositoriesInPullRequestException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::ReferenceDoesNotExistException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::ReferenceNameRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::ReferenceTypeNotSupportedException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::SourceAndDestinationAreSameException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestErrorKind::TargetRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::TargetsRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::TitleRequiredException(_inner) => _inner.fmt(f),
            CreatePullRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePullRequestError {
    fn code(&self) -> Option<&str> {
        CreatePullRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePullRequestError {
    /// Creates a new `CreatePullRequestError`.
    pub fn new(kind: CreatePullRequestErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreatePullRequestError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePullRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreatePullRequestError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePullRequestErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::ClientRequestTokenRequiredException`.
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::ClientRequestTokenRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::IdempotencyParameterMismatchException`.
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::IdempotencyParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::InvalidClientRequestTokenException`.
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidClientRequestTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::InvalidDescriptionException`.
    pub fn is_invalid_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidDescriptionException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::InvalidReferenceNameException`.
    pub fn is_invalid_reference_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidReferenceNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::InvalidTargetException`.
    pub fn is_invalid_target_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidTargetException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::InvalidTargetsException`.
    pub fn is_invalid_targets_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidTargetsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::InvalidTitleException`.
    pub fn is_invalid_title_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::InvalidTitleException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::MaximumOpenPullRequestsExceededException`.
    pub fn is_maximum_open_pull_requests_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::MaximumOpenPullRequestsExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::MultipleRepositoriesInPullRequestException`.
    pub fn is_multiple_repositories_in_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::MultipleRepositoriesInPullRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::ReferenceDoesNotExistException`.
    pub fn is_reference_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::ReferenceDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::ReferenceNameRequiredException`.
    pub fn is_reference_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::ReferenceNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::ReferenceTypeNotSupportedException`.
    pub fn is_reference_type_not_supported_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::ReferenceTypeNotSupportedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::SourceAndDestinationAreSameException`.
    pub fn is_source_and_destination_are_same_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::SourceAndDestinationAreSameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::TargetRequiredException`.
    pub fn is_target_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::TargetRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::TargetsRequiredException`.
    pub fn is_targets_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::TargetsRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestErrorKind::TitleRequiredException`.
    pub fn is_title_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestErrorKind::TitleRequiredException(_)
        )
    }
}
impl std::error::Error for CreatePullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePullRequestErrorKind::ClientRequestTokenRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::IdempotencyParameterMismatchException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::InvalidClientRequestTokenException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidDescriptionException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidReferenceNameException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidTargetException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidTargetsException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::InvalidTitleException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::MaximumOpenPullRequestsExceededException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::MultipleRepositoriesInPullRequestException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::ReferenceDoesNotExistException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::ReferenceNameRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::ReferenceTypeNotSupportedException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::SourceAndDestinationAreSameException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestErrorKind::TargetRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::TargetsRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::TitleRequiredException(_inner) => Some(_inner),
            CreatePullRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreatePullRequestApprovalRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreatePullRequestApprovalRuleError {
    /// Kind of error that occurred.
    pub kind: CreatePullRequestApprovalRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreatePullRequestApprovalRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePullRequestApprovalRuleErrorKind {
    /// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
    ApprovalRuleContentRequiredException(crate::error::ApprovalRuleContentRequiredException),
    /// <p>An approval rule with that name already exists. Approval rule names must be unique within the scope of a pull request.</p>
    ApprovalRuleNameAlreadyExistsException(crate::error::ApprovalRuleNameAlreadyExistsException),
    /// <p>An approval rule name is required, but was not specified.</p>
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The content for the approval rule is not valid.</p>
    InvalidApprovalRuleContentException(crate::error::InvalidApprovalRuleContentException),
    /// <p>The name for the approval rule is not valid.</p>
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.</p>
    NumberOfRulesExceededException(crate::error::NumberOfRulesExceededException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreatePullRequestApprovalRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleContentRequiredException(
                _inner,
            ) => _inner.fmt(f),
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameAlreadyExistsException(
                _inner,
            ) => _inner.fmt(f),
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleContentException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::NumberOfRulesExceededException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            CreatePullRequestApprovalRuleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePullRequestApprovalRuleError {
    fn code(&self) -> Option<&str> {
        CreatePullRequestApprovalRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePullRequestApprovalRuleError {
    /// Creates a new `CreatePullRequestApprovalRuleError`.
    pub fn new(
        kind: CreatePullRequestApprovalRuleErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreatePullRequestApprovalRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreatePullRequestApprovalRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreatePullRequestApprovalRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreatePullRequestApprovalRuleErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::ApprovalRuleContentRequiredException`.
    pub fn is_approval_rule_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameAlreadyExistsException`.
    pub fn is_approval_rule_name_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException`.
    pub fn is_approval_rule_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleContentException`.
    pub fn is_invalid_approval_rule_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleContentException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException`.
    pub fn is_invalid_approval_rule_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::NumberOfRulesExceededException`.
    pub fn is_number_of_rules_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::NumberOfRulesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreatePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for CreatePullRequestApprovalRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleContentRequiredException(
                _inner,
            ) => Some(_inner),
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameAlreadyExistsException(
                _inner,
            ) => Some(_inner),
            CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleContentException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::NumberOfRulesExceededException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            CreatePullRequestApprovalRuleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateRepositoryError {
    /// Kind of error that occurred.
    pub kind: CreateRepositoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRepositoryErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified repository description is not valid.</p>
    InvalidRepositoryDescriptionException(crate::error::InvalidRepositoryDescriptionException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    /// <p>The map of tags is not valid.</p>
    InvalidTagsMapException(crate::error::InvalidTagsMapException),
    /// <p>A repository resource limit was exceeded.</p>
    RepositoryLimitExceededException(crate::error::RepositoryLimitExceededException),
    /// <p>The specified repository name already exists.</p>
    RepositoryNameExistsException(crate::error::RepositoryNameExistsException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The tag policy is not valid.</p>
    TagPolicyException(crate::error::TagPolicyException),
    /// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            CreateRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::InvalidRepositoryDescriptionException(_inner) => {
                _inner.fmt(f)
            }
            CreateRepositoryErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::InvalidSystemTagUsageException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::InvalidTagsMapException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::RepositoryLimitExceededException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::RepositoryNameExistsException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::TagPolicyException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            CreateRepositoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRepositoryError {
    fn code(&self) -> Option<&str> {
        CreateRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRepositoryError {
    /// Creates a new `CreateRepositoryError`.
    pub fn new(kind: CreateRepositoryErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateRepositoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::InvalidRepositoryDescriptionException`.
    pub fn is_invalid_repository_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::InvalidRepositoryDescriptionException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::InvalidSystemTagUsageException`.
    pub fn is_invalid_system_tag_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::InvalidSystemTagUsageException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::InvalidTagsMapException`.
    pub fn is_invalid_tags_map_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::InvalidTagsMapException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::RepositoryLimitExceededException`.
    pub fn is_repository_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::RepositoryLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::RepositoryNameExistsException`.
    pub fn is_repository_name_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::RepositoryNameExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::TagPolicyException`.
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(&self.kind, CreateRepositoryErrorKind::TagPolicyException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryErrorKind::TooManyTagsException`.
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateRepositoryErrorKind::TooManyTagsException(_)
        )
    }
}
impl std::error::Error for CreateRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            CreateRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::InvalidRepositoryDescriptionException(_inner) => {
                Some(_inner)
            }
            CreateRepositoryErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::InvalidSystemTagUsageException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::InvalidTagsMapException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::RepositoryLimitExceededException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::RepositoryNameExistsException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::TagPolicyException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::TooManyTagsException(_inner) => Some(_inner),
            CreateRepositoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `CreateUnreferencedMergeCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct CreateUnreferencedMergeCommitError {
    /// Kind of error that occurred.
    pub kind: CreateUnreferencedMergeCommitErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `CreateUnreferencedMergeCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUnreferencedMergeCommitErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::error::FileModeRequiredException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for CreateUnreferencedMergeCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            CreateUnreferencedMergeCommitErrorKind::CommitDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::CommitMessageLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::CommitRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::FileContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::FileModeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidCommitException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictDetailLevelException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidEmailException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidFileModeException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidMergeOptionException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidPathException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementContentException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementTypeException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::ManualMergeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MergeOptionRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::NameLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::PathRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::ReplacementContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::ReplacementTypeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::TipsDivergenceExceededException(_inner) =>
            _inner.fmt(f)
            ,
            CreateUnreferencedMergeCommitErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateUnreferencedMergeCommitError {
    fn code(&self) -> Option<&str> {
        CreateUnreferencedMergeCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUnreferencedMergeCommitError {
    /// Creates a new `CreateUnreferencedMergeCommitError`.
    pub fn new(
        kind: CreateUnreferencedMergeCommitErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `CreateUnreferencedMergeCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: CreateUnreferencedMergeCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `CreateUnreferencedMergeCommitError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: CreateUnreferencedMergeCommitErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::FileModeRequiredException`.
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::FileModeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidEmailException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidFileModeException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidMergeOptionException`.
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidMergeOptionException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidPathException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementContentException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementTypeException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::ManualMergeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(&self.kind, CreateUnreferencedMergeCommitErrorKind::MaximumConflictResolutionEntriesExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::MergeOptionRequiredException`.
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::MergeOptionRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::NameLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::PathRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::ReplacementContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            CreateUnreferencedMergeCommitErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for CreateUnreferencedMergeCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            CreateUnreferencedMergeCommitErrorKind::CommitDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::CommitMessageLengthExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::CommitRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::FileContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::FileModeRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidCommitException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictDetailLevelException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidEmailException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidFileModeException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidMergeOptionException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidPathException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementContentException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidReplacementTypeException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::ManualMergeRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MergeOptionRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::NameLengthExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::PathRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::ReplacementContentRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::ReplacementTypeRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::TipsDivergenceExceededException(_inner) =>
            Some(_inner)
            ,
            CreateUnreferencedMergeCommitErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `DeleteApprovalRuleTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteApprovalRuleTemplateError {
    /// Kind of error that occurred.
    pub kind: DeleteApprovalRuleTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteApprovalRuleTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApprovalRuleTemplateErrorKind {
    /// <p>The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove all associations, and then try again.</p>
    ApprovalRuleTemplateInUseException(crate::error::ApprovalRuleTemplateInUseException),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateInUseException(_inner) => {
                _inner.fmt(f)
            }
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(
                _inner,
            ) => _inner.fmt(f),
            DeleteApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(
                _inner,
            ) => _inner.fmt(f),
            DeleteApprovalRuleTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        DeleteApprovalRuleTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApprovalRuleTemplateError {
    /// Creates a new `DeleteApprovalRuleTemplateError`.
    pub fn new(kind: DeleteApprovalRuleTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteApprovalRuleTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteApprovalRuleTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteApprovalRuleTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteApprovalRuleTemplateErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateInUseException`.
    pub fn is_approval_rule_template_in_use_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateInUseException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
}
impl std::error::Error for DeleteApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateInUseException(_inner) => {
                Some(_inner)
            }
            DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(
                _inner,
            ) => Some(_inner),
            DeleteApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(
                _inner,
            ) => Some(_inner),
            DeleteApprovalRuleTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteBranch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteBranchError {
    /// Kind of error that occurred.
    pub kind: DeleteBranchErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteBranch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBranchErrorKind {
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.</p>
    DefaultBranchCannotBeDeletedException(crate::error::DefaultBranchCannotBeDeletedException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteBranchErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::DefaultBranchCannotBeDeletedException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            DeleteBranchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteBranchError {
    fn code(&self) -> Option<&str> {
        DeleteBranchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBranchError {
    /// Creates a new `DeleteBranchError`.
    pub fn new(kind: DeleteBranchErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteBranchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteBranchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteBranchError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteBranchErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::BranchNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::DefaultBranchCannotBeDeletedException`.
    pub fn is_default_branch_cannot_be_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::DefaultBranchCannotBeDeletedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::InvalidBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteBranchErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteBranchErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for DeleteBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteBranchErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            DeleteBranchErrorKind::DefaultBranchCannotBeDeletedException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            DeleteBranchErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            DeleteBranchErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            DeleteBranchErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            DeleteBranchErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            DeleteBranchErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            DeleteBranchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteCommentContent` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteCommentContentError {
    /// Kind of error that occurred.
    pub kind: DeleteCommentContentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteCommentContent` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCommentContentErrorKind {
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteCommentContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteCommentContentErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            DeleteCommentContentErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteCommentContentErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            DeleteCommentContentErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            DeleteCommentContentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCommentContentError {
    fn code(&self) -> Option<&str> {
        DeleteCommentContentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCommentContentError {
    /// Creates a new `DeleteCommentContentError`.
    pub fn new(kind: DeleteCommentContentErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteCommentContentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteCommentContentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteCommentContentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteCommentContentErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteCommentContentErrorKind::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCommentContentErrorKind::CommentDeletedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCommentContentErrorKind::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCommentContentErrorKind::CommentDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCommentContentErrorKind::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCommentContentErrorKind::CommentIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteCommentContentErrorKind::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteCommentContentErrorKind::InvalidCommentIdException(_)
        )
    }
}
impl std::error::Error for DeleteCommentContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteCommentContentErrorKind::CommentDeletedException(_inner) => Some(_inner),
            DeleteCommentContentErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            DeleteCommentContentErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            DeleteCommentContentErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            DeleteCommentContentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeleteFile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteFileError {
    /// Kind of error that occurred.
    pub kind: DeleteFileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteFile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFileErrorKind {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteFileErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::FileDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            DeleteFileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFileError {
    fn code(&self) -> Option<&str> {
        DeleteFileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFileError {
    /// Creates a new `DeleteFileError`.
    pub fn new(kind: DeleteFileErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteFileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteFileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteFileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteFileErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::BranchDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::BranchNameIsTagNameException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::BranchNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::FileDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::InvalidBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(&self.kind, DeleteFileErrorKind::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::InvalidParentCommitIdException`.
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::InvalidParentCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, DeleteFileErrorKind::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::NameLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::ParentCommitDoesNotExistException`.
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::ParentCommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::ParentCommitIdOutdatedException`.
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::ParentCommitIdOutdatedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::ParentCommitIdRequiredException`.
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::ParentCommitIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, DeleteFileErrorKind::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteFileErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteFileErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for DeleteFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteFileErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            DeleteFileErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            DeleteFileErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            DeleteFileErrorKind::CommitMessageLengthExceededException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            DeleteFileErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            DeleteFileErrorKind::FileDoesNotExistException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidEmailException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidParentCommitIdException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidPathException(_inner) => Some(_inner),
            DeleteFileErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            DeleteFileErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            DeleteFileErrorKind::ParentCommitDoesNotExistException(_inner) => Some(_inner),
            DeleteFileErrorKind::ParentCommitIdOutdatedException(_inner) => Some(_inner),
            DeleteFileErrorKind::ParentCommitIdRequiredException(_inner) => Some(_inner),
            DeleteFileErrorKind::PathRequiredException(_inner) => Some(_inner),
            DeleteFileErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            DeleteFileErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            DeleteFileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DeletePullRequestApprovalRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeletePullRequestApprovalRuleError {
    /// Kind of error that occurred.
    pub kind: DeletePullRequestApprovalRuleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeletePullRequestApprovalRule` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePullRequestApprovalRuleErrorKind {
    /// <p>An approval rule name is required, but was not specified.</p>
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    /// <p>The approval rule cannot be deleted from the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
    CannotDeleteApprovalRuleFromTemplateException(
        crate::error::CannotDeleteApprovalRuleFromTemplateException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name for the approval rule is not valid.</p>
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeletePullRequestApprovalRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeletePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::CannotDeleteApprovalRuleFromTemplateException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            DeletePullRequestApprovalRuleErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePullRequestApprovalRuleError {
    fn code(&self) -> Option<&str> {
        DeletePullRequestApprovalRuleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePullRequestApprovalRuleError {
    /// Creates a new `DeletePullRequestApprovalRuleError`.
    pub fn new(
        kind: DeletePullRequestApprovalRuleErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeletePullRequestApprovalRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeletePullRequestApprovalRuleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeletePullRequestApprovalRuleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeletePullRequestApprovalRuleErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException`.
    pub fn is_approval_rule_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::CannotDeleteApprovalRuleFromTemplateException`.
    pub fn is_cannot_delete_approval_rule_from_template_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::CannotDeleteApprovalRuleFromTemplateException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException`.
    pub fn is_invalid_approval_rule_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeletePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for DeletePullRequestApprovalRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeletePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::CannotDeleteApprovalRuleFromTemplateException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            DeletePullRequestApprovalRuleErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `DeleteRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DeleteRepositoryError {
    /// Kind of error that occurred.
    pub kind: DeleteRepositoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DeleteRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRepositoryErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DeleteRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DeleteRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            DeleteRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            DeleteRepositoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRepositoryError {
    fn code(&self) -> Option<&str> {
        DeleteRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRepositoryError {
    /// Creates a new `DeleteRepositoryError`.
    pub fn new(kind: DeleteRepositoryErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DeleteRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DeleteRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DeleteRepositoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DeleteRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DeleteRepositoryErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRepositoryErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRepositoryErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRepositoryErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRepositoryErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRepositoryErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `DeleteRepositoryErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DeleteRepositoryErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for DeleteRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DeleteRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            DeleteRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            DeleteRepositoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribeMergeConflicts` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribeMergeConflictsError {
    /// Kind of error that occurred.
    pub kind: DescribeMergeConflictsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribeMergeConflicts` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMergeConflictsErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified value for the number of merge hunks to return is not valid.</p>
    InvalidMaxMergeHunksException(crate::error::InvalidMaxMergeHunksException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribeMergeConflictsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribeMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::FileDoesNotExistException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            DescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            DescribeMergeConflictsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeMergeConflictsError {
    fn code(&self) -> Option<&str> {
        DescribeMergeConflictsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMergeConflictsError {
    /// Creates a new `DescribeMergeConflictsError`.
    pub fn new(kind: DescribeMergeConflictsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribeMergeConflictsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribeMergeConflictsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribeMergeConflictsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribeMergeConflictsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::FileDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException`.
    pub fn is_invalid_max_merge_hunks_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::InvalidMergeOptionException`.
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidMergeOptionException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidPathException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::MergeOptionRequiredException`.
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::MergeOptionRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::PathRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for DescribeMergeConflictsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribeMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::CommitRequiredException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::FileDoesNotExistException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidCommitException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidPathException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::PathRequiredException(_inner) => Some(_inner),
            DescribeMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => {
                Some(_inner)
            }
            DescribeMergeConflictsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DescribePullRequestEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DescribePullRequestEventsError {
    /// Kind of error that occurred.
    pub kind: DescribePullRequestEventsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DescribePullRequestEvents` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePullRequestEventsErrorKind {
    /// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
    ActorDoesNotExistException(crate::error::ActorDoesNotExistException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request, and then try again.</p>
    InvalidActorArnException(crate::error::InvalidActorArnException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The pull request event type is not valid. </p>
    InvalidPullRequestEventTypeException(crate::error::InvalidPullRequestEventTypeException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DescribePullRequestEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DescribePullRequestEventsErrorKind::ActorDoesNotExistException(_inner) => _inner.fmt(f),
            DescribePullRequestEventsErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            DescribePullRequestEventsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::InvalidActorArnException(_inner) => _inner.fmt(f),
            DescribePullRequestEventsErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            DescribePullRequestEventsErrorKind::InvalidPullRequestEventTypeException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            DescribePullRequestEventsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribePullRequestEventsError {
    fn code(&self) -> Option<&str> {
        DescribePullRequestEventsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePullRequestEventsError {
    /// Creates a new `DescribePullRequestEventsError`.
    pub fn new(kind: DescribePullRequestEventsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DescribePullRequestEventsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DescribePullRequestEventsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DescribePullRequestEventsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DescribePullRequestEventsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::ActorDoesNotExistException`.
    pub fn is_actor_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::ActorDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::InvalidActorArnException`.
    pub fn is_invalid_actor_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidActorArnException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidMaxResultsException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::InvalidPullRequestEventTypeException`.
    pub fn is_invalid_pull_request_event_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidPullRequestEventTypeException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            DescribePullRequestEventsErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for DescribePullRequestEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DescribePullRequestEventsErrorKind::ActorDoesNotExistException(_inner) => Some(_inner),
            DescribePullRequestEventsErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            DescribePullRequestEventsErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::InvalidActorArnException(_inner) => Some(_inner),
            DescribePullRequestEventsErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            DescribePullRequestEventsErrorKind::InvalidPullRequestEventTypeException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            DescribePullRequestEventsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `DisassociateApprovalRuleTemplateFromRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct DisassociateApprovalRuleTemplateFromRepositoryError {
    /// Kind of error that occurred.
    pub kind: DisassociateApprovalRuleTemplateFromRepositoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `DisassociateApprovalRuleTemplateFromRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateApprovalRuleTemplateFromRepositoryErrorKind {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for DisassociateApprovalRuleTemplateFromRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for DisassociateApprovalRuleTemplateFromRepositoryError
{
    fn code(&self) -> Option<&str> {
        DisassociateApprovalRuleTemplateFromRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateApprovalRuleTemplateFromRepositoryError {
    /// Creates a new `DisassociateApprovalRuleTemplateFromRepositoryError`.
    pub fn new(
        kind: DisassociateApprovalRuleTemplateFromRepositoryErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `DisassociateApprovalRuleTemplateFromRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: DisassociateApprovalRuleTemplateFromRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `DisassociateApprovalRuleTemplateFromRepositoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: DisassociateApprovalRuleTemplateFromRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyDisabledException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyNotFoundException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidRepositoryNameException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(&self.kind, DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for DisassociateApprovalRuleTemplateFromRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            DisassociateApprovalRuleTemplateFromRepositoryErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `EvaluatePullRequestApprovalRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct EvaluatePullRequestApprovalRulesError {
    /// Kind of error that occurred.
    pub kind: EvaluatePullRequestApprovalRulesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `EvaluatePullRequestApprovalRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EvaluatePullRequestApprovalRulesErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for EvaluatePullRequestApprovalRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(
                _inner,
            ) => _inner.fmt(f),
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            EvaluatePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_inner) => {
                _inner.fmt(f)
            }
            EvaluatePullRequestApprovalRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for EvaluatePullRequestApprovalRulesError {
    fn code(&self) -> Option<&str> {
        EvaluatePullRequestApprovalRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl EvaluatePullRequestApprovalRulesError {
    /// Creates a new `EvaluatePullRequestApprovalRulesError`.
    pub fn new(
        kind: EvaluatePullRequestApprovalRulesErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `EvaluatePullRequestApprovalRulesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: EvaluatePullRequestApprovalRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `EvaluatePullRequestApprovalRulesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: EvaluatePullRequestApprovalRulesErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesErrorKind::RevisionNotCurrentException`.
    pub fn is_revision_not_current_exception(&self) -> bool {
        matches!(
            &self.kind,
            EvaluatePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_)
        )
    }
}
impl std::error::Error for EvaluatePullRequestApprovalRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(
                _inner,
            ) => Some(_inner),
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(
                _inner,
            ) => Some(_inner),
            EvaluatePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_inner) => {
                Some(_inner)
            }
            EvaluatePullRequestApprovalRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetApprovalRuleTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetApprovalRuleTemplateError {
    /// Kind of error that occurred.
    pub kind: GetApprovalRuleTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetApprovalRuleTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApprovalRuleTemplateErrorKind {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) => {
                _inner.fmt(f)
            }
            GetApprovalRuleTemplateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        GetApprovalRuleTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApprovalRuleTemplateError {
    /// Creates a new `GetApprovalRuleTemplateError`.
    pub fn new(kind: GetApprovalRuleTemplateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetApprovalRuleTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetApprovalRuleTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetApprovalRuleTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetApprovalRuleTemplateErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
}
impl std::error::Error for GetApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) => {
                Some(_inner)
            }
            GetApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) => {
                Some(_inner)
            }
            GetApprovalRuleTemplateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetBlob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBlobError {
    /// Kind of error that occurred.
    pub kind: GetBlobErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetBlob` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBlobErrorKind {
    /// <p>The specified blob does not exist.</p>
    BlobIdDoesNotExistException(crate::error::BlobIdDoesNotExistException),
    /// <p>A blob ID is required, but was not specified.</p>
    BlobIdRequiredException(crate::error::BlobIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    FileTooLargeException(crate::error::FileTooLargeException),
    /// <p>The specified blob is not valid.</p>
    InvalidBlobIdException(crate::error::InvalidBlobIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBlobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBlobErrorKind::BlobIdDoesNotExistException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::BlobIdRequiredException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::FileTooLargeException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::InvalidBlobIdException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetBlobErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetBlobError {
    fn code(&self) -> Option<&str> {
        GetBlobError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBlobError {
    /// Creates a new `GetBlobError`.
    pub fn new(kind: GetBlobErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetBlobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBlobErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetBlobError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBlobErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::BlobIdDoesNotExistException`.
    pub fn is_blob_id_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, GetBlobErrorKind::BlobIdDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::BlobIdRequiredException`.
    pub fn is_blob_id_required_exception(&self) -> bool {
        matches!(&self.kind, GetBlobErrorKind::BlobIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::FileTooLargeException`.
    pub fn is_file_too_large_exception(&self) -> bool {
        matches!(&self.kind, GetBlobErrorKind::FileTooLargeException(_))
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::InvalidBlobIdException`.
    pub fn is_invalid_blob_id_exception(&self) -> bool {
        matches!(&self.kind, GetBlobErrorKind::InvalidBlobIdException(_))
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBlobErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBlobErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetBlobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBlobErrorKind::BlobIdDoesNotExistException(_inner) => Some(_inner),
            GetBlobErrorKind::BlobIdRequiredException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetBlobErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetBlobErrorKind::FileTooLargeException(_inner) => Some(_inner),
            GetBlobErrorKind::InvalidBlobIdException(_inner) => Some(_inner),
            GetBlobErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetBlobErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetBlobErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetBlobErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetBranch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetBranchError {
    /// Kind of error that occurred.
    pub kind: GetBranchErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetBranch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBranchErrorKind {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetBranchErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetBranchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetBranchError {
    fn code(&self) -> Option<&str> {
        GetBranchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBranchError {
    /// Creates a new `GetBranchError`.
    pub fn new(kind: GetBranchErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetBranchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetBranchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetBranchError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetBranchErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::BranchDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::BranchNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::InvalidBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetBranchErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetBranchErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetBranchErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            GetBranchErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetBranchErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetBranchErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            GetBranchErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetBranchErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetBranchErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetBranchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetComment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommentError {
    /// Kind of error that occurred.
    pub kind: GetCommentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetComment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentErrorKind {
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommentErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            GetCommentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommentError {
    fn code(&self) -> Option<&str> {
        GetCommentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentError {
    /// Creates a new `GetCommentError`.
    pub fn new(kind: GetCommentErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCommentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCommentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommentErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCommentErrorKind::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(&self.kind, GetCommentErrorKind::CommentDeletedException(_))
    }
    /// Returns `true` if the error kind is `GetCommentErrorKind::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::CommentDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentErrorKind::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::CommentIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentErrorKind::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentErrorKind::InvalidCommentIdException(_)
        )
    }
}
impl std::error::Error for GetCommentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommentErrorKind::CommentDeletedException(_inner) => Some(_inner),
            GetCommentErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            GetCommentErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetCommentErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetCommentErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            GetCommentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCommentReactions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommentReactionsError {
    /// Kind of error that occurred.
    pub kind: GetCommentReactionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCommentReactions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentReactionsErrorKind {
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The Amazon Resource Name (ARN) of the user or identity is not valid.</p>
    InvalidReactionUserArnException(crate::error::InvalidReactionUserArnException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommentReactionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommentReactionsErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentReactionsErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::InvalidReactionUserArnException(_inner) => _inner.fmt(f),
            GetCommentReactionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommentReactionsError {
    fn code(&self) -> Option<&str> {
        GetCommentReactionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentReactionsError {
    /// Creates a new `GetCommentReactionsError`.
    pub fn new(kind: GetCommentReactionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCommentReactionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommentReactionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCommentReactionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommentReactionsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCommentReactionsErrorKind::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::CommentDeletedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentReactionsErrorKind::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::CommentDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentReactionsErrorKind::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::CommentIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentReactionsErrorKind::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::InvalidCommentIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentReactionsErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentReactionsErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::InvalidMaxResultsException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentReactionsErrorKind::InvalidReactionUserArnException`.
    pub fn is_invalid_reaction_user_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentReactionsErrorKind::InvalidReactionUserArnException(_)
        )
    }
}
impl std::error::Error for GetCommentReactionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommentReactionsErrorKind::CommentDeletedException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::InvalidReactionUserArnException(_inner) => Some(_inner),
            GetCommentReactionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCommentsForComparedCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommentsForComparedCommitError {
    /// Kind of error that occurred.
    pub kind: GetCommentsForComparedCommitErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCommentsForComparedCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentsForComparedCommitErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommentsForComparedCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommentsForComparedCommitErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::CommitIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            GetCommentsForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::InvalidCommitIdException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::InvalidMaxResultsException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForComparedCommitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommentsForComparedCommitError {
    fn code(&self) -> Option<&str> {
        GetCommentsForComparedCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentsForComparedCommitError {
    /// Creates a new `GetCommentsForComparedCommitError`.
    pub fn new(kind: GetCommentsForComparedCommitErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCommentsForComparedCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommentsForComparedCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCommentsForComparedCommitError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommentsForComparedCommitErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::CommitIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::InvalidCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::InvalidMaxResultsException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForComparedCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetCommentsForComparedCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommentsForComparedCommitErrorKind::CommitDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::CommitIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            GetCommentsForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            GetCommentsForComparedCommitErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::InvalidMaxResultsException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            GetCommentsForComparedCommitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCommentsForPullRequest` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommentsForPullRequestError {
    /// Kind of error that occurred.
    pub kind: GetCommentsForPullRequestErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCommentsForPullRequest` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentsForPullRequestErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommentsForPullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommentsForPullRequestErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::CommitIdRequiredException(_inner) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetCommentsForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _inner,
            ) => _inner.fmt(f),
            GetCommentsForPullRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommentsForPullRequestError {
    fn code(&self) -> Option<&str> {
        GetCommentsForPullRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentsForPullRequestError {
    /// Creates a new `GetCommentsForPullRequestError`.
    pub fn new(kind: GetCommentsForPullRequestErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCommentsForPullRequestError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommentsForPullRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCommentsForPullRequestError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommentsForPullRequestErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::CommitIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidMaxResultsException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommentsForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
}
impl std::error::Error for GetCommentsForPullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommentsForPullRequestErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetCommentsForPullRequestErrorKind::CommitIdRequiredException(_inner) => Some(_inner),
            GetCommentsForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            GetCommentsForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            GetCommentsForPullRequestErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            GetCommentsForPullRequestErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            GetCommentsForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _inner,
            ) => Some(_inner),
            GetCommentsForPullRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetCommitError {
    /// Kind of error that occurred.
    pub kind: GetCommitErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommitErrorKind {
    /// <p>The specified commit ID does not exist.</p>
    CommitIdDoesNotExistException(crate::error::CommitIdDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetCommitErrorKind::CommitIdDoesNotExistException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::CommitIdRequiredException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetCommitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommitError {
    fn code(&self) -> Option<&str> {
        GetCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommitError {
    /// Creates a new `GetCommitError`.
    pub fn new(kind: GetCommitErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetCommitError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetCommitErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::CommitIdDoesNotExistException`.
    pub fn is_commit_id_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::CommitIdDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(&self.kind, GetCommitErrorKind::CommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(&self.kind, GetCommitErrorKind::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetCommitErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetCommitErrorKind::CommitIdDoesNotExistException(_inner) => Some(_inner),
            GetCommitErrorKind::CommitIdRequiredException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetCommitErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetCommitErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            GetCommitErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetCommitErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetCommitErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetCommitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetDifferences` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetDifferencesError {
    /// Kind of error that occurred.
    pub kind: GetDifferencesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetDifferences` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDifferencesErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified path does not exist.</p>
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetDifferencesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetDifferencesErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetDifferencesErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::PathDoesNotExistException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetDifferencesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDifferencesError {
    fn code(&self) -> Option<&str> {
        GetDifferencesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDifferencesError {
    /// Creates a new `GetDifferencesError`.
    pub fn new(kind: GetDifferencesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetDifferencesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetDifferencesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetDifferencesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetDifferencesErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidMaxResultsException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, GetDifferencesErrorKind::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::PathDoesNotExistException`.
    pub fn is_path_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::PathDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetDifferencesErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetDifferencesErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetDifferencesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetDifferencesErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetDifferencesErrorKind::CommitRequiredException(_inner) => Some(_inner),
            GetDifferencesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetDifferencesErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetDifferencesErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetDifferencesErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetDifferencesErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidPathException(_inner) => Some(_inner),
            GetDifferencesErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetDifferencesErrorKind::PathDoesNotExistException(_inner) => Some(_inner),
            GetDifferencesErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetDifferencesErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetDifferencesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetFile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFileError {
    /// Kind of error that occurred.
    pub kind: GetFileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetFile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFileErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    /// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    FileTooLargeException(crate::error::FileTooLargeException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFileErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetFileErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetFileErrorKind::FileDoesNotExistException(_inner) => _inner.fmt(f),
            GetFileErrorKind::FileTooLargeException(_inner) => _inner.fmt(f),
            GetFileErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetFileErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            GetFileErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetFileErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            GetFileErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetFileErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetFileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFileError {
    fn code(&self) -> Option<&str> {
        GetFileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFileError {
    /// Creates a new `GetFileError`.
    pub fn new(kind: GetFileErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetFileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetFileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFileErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::FileDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::FileTooLargeException`.
    pub fn is_file_too_large_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::FileTooLargeException(_))
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, GetFileErrorKind::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFileErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFileErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFileErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetFileErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetFileErrorKind::FileDoesNotExistException(_inner) => Some(_inner),
            GetFileErrorKind::FileTooLargeException(_inner) => Some(_inner),
            GetFileErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetFileErrorKind::InvalidPathException(_inner) => Some(_inner),
            GetFileErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetFileErrorKind::PathRequiredException(_inner) => Some(_inner),
            GetFileErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetFileErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetFileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetFolder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetFolderError {
    /// Kind of error that occurred.
    pub kind: GetFolderErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetFolder` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFolderErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified folder does not exist. Either the folder name is not correct, or you did not enter the full path to the folder.</p>
    FolderDoesNotExistException(crate::error::FolderDoesNotExistException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetFolderErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::FolderDoesNotExistException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetFolderErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFolderError {
    fn code(&self) -> Option<&str> {
        GetFolderError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFolderError {
    /// Creates a new `GetFolderError`.
    pub fn new(kind: GetFolderErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetFolderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetFolderErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetFolderError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetFolderErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::FolderDoesNotExistException`.
    pub fn is_folder_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::FolderDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(&self.kind, GetFolderErrorKind::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, GetFolderErrorKind::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, GetFolderErrorKind::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetFolderErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetFolderErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetFolderErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetFolderErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetFolderErrorKind::FolderDoesNotExistException(_inner) => Some(_inner),
            GetFolderErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetFolderErrorKind::InvalidPathException(_inner) => Some(_inner),
            GetFolderErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetFolderErrorKind::PathRequiredException(_inner) => Some(_inner),
            GetFolderErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetFolderErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetFolderErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetMergeCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMergeCommitError {
    /// Kind of error that occurred.
    pub kind: GetMergeCommitErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetMergeCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMergeCommitErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMergeCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMergeCommitErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeCommitErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetMergeCommitErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMergeCommitError {
    fn code(&self) -> Option<&str> {
        GetMergeCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMergeCommitError {
    /// Creates a new `GetMergeCommitError`.
    pub fn new(kind: GetMergeCommitErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetMergeCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMergeCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetMergeCommitError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMergeCommitErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeCommitErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetMergeCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMergeCommitErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::CommitRequiredException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetMergeCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            GetMergeCommitErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetMergeCommitErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetMergeConflicts` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMergeConflictsError {
    /// Kind of error that occurred.
    pub kind: GetMergeConflictsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetMergeConflicts` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMergeConflictsErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID. </p>
    InvalidDestinationCommitSpecifierException(
        crate::error::InvalidDestinationCommitSpecifierException,
    ),
    /// <p>The specified value for the number of conflict files to return is not valid.</p>
    InvalidMaxConflictFilesException(crate::error::InvalidMaxConflictFilesException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.</p>
    InvalidSourceCommitSpecifierException(crate::error::InvalidSourceCommitSpecifierException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMergeConflictsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidDestinationCommitSpecifierException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::InvalidMaxConflictFilesException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::InvalidSourceCommitSpecifierException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            GetMergeConflictsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMergeConflictsError {
    fn code(&self) -> Option<&str> {
        GetMergeConflictsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMergeConflictsError {
    /// Creates a new `GetMergeConflictsError`.
    pub fn new(kind: GetMergeConflictsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetMergeConflictsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMergeConflictsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetMergeConflictsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMergeConflictsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::InvalidDestinationCommitSpecifierException`.
    pub fn is_invalid_destination_commit_specifier_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidDestinationCommitSpecifierException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::InvalidMaxConflictFilesException`.
    pub fn is_invalid_max_conflict_files_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidMaxConflictFilesException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::InvalidMergeOptionException`.
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidMergeOptionException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::InvalidSourceCommitSpecifierException`.
    pub fn is_invalid_source_commit_specifier_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::InvalidSourceCommitSpecifierException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::MergeOptionRequiredException`.
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::MergeOptionRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeConflictsErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeConflictsErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for GetMergeConflictsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMergeConflictsErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::CommitRequiredException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidDestinationCommitSpecifierException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::InvalidMaxConflictFilesException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidMergeOptionException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::InvalidSourceCommitSpecifierException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            GetMergeConflictsErrorKind::MergeOptionRequiredException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::TipsDivergenceExceededException(_inner) => Some(_inner),
            GetMergeConflictsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetMergeOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetMergeOptionsError {
    /// Kind of error that occurred.
    pub kind: GetMergeOptionsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetMergeOptions` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMergeOptionsErrorKind {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetMergeOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetMergeOptionsErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeOptionsErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeOptionsErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeOptionsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            GetMergeOptionsErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            GetMergeOptionsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMergeOptionsError {
    fn code(&self) -> Option<&str> {
        GetMergeOptionsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMergeOptionsError {
    /// Creates a new `GetMergeOptionsError`.
    pub fn new(kind: GetMergeOptionsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetMergeOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetMergeOptionsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetMergeOptionsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetMergeOptionsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetMergeOptionsErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetMergeOptionsErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for GetMergeOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetMergeOptionsErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::CommitRequiredException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetMergeOptionsErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::InvalidCommitException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            GetMergeOptionsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            GetMergeOptionsErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            GetMergeOptionsErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::TipsDivergenceExceededException(_inner) => Some(_inner),
            GetMergeOptionsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetPullRequest` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPullRequestError {
    /// Kind of error that occurred.
    pub kind: GetPullRequestErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetPullRequest` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPullRequestErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            GetPullRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPullRequestError {
    fn code(&self) -> Option<&str> {
        GetPullRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPullRequestError {
    /// Creates a new `GetPullRequestError`.
    pub fn new(kind: GetPullRequestErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPullRequestError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPullRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPullRequestError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPullRequestErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPullRequestErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for GetPullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetPullRequestErrorKind::InvalidPullRequestIdException(_inner) => Some(_inner),
            GetPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => Some(_inner),
            GetPullRequestErrorKind::PullRequestIdRequiredException(_inner) => Some(_inner),
            GetPullRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetPullRequestApprovalStates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPullRequestApprovalStatesError {
    /// Kind of error that occurred.
    pub kind: GetPullRequestApprovalStatesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetPullRequestApprovalStates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPullRequestApprovalStatesErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPullRequestApprovalStatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPullRequestApprovalStatesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::InvalidRevisionIdException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::RevisionIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestApprovalStatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPullRequestApprovalStatesError {
    fn code(&self) -> Option<&str> {
        GetPullRequestApprovalStatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPullRequestApprovalStatesError {
    /// Creates a new `GetPullRequestApprovalStatesError`.
    pub fn new(kind: GetPullRequestApprovalStatesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPullRequestApprovalStatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPullRequestApprovalStatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPullRequestApprovalStatesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPullRequestApprovalStatesErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::InvalidRevisionIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesErrorKind::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestApprovalStatesErrorKind::RevisionIdRequiredException(_)
        )
    }
}
impl std::error::Error for GetPullRequestApprovalStatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPullRequestApprovalStatesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::InvalidRevisionIdException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::RevisionIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetPullRequestApprovalStatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetPullRequestOverrideState` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetPullRequestOverrideStateError {
    /// Kind of error that occurred.
    pub kind: GetPullRequestOverrideStateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetPullRequestOverrideState` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPullRequestOverrideStateErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetPullRequestOverrideStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetPullRequestOverrideStateErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            GetPullRequestOverrideStateErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::InvalidRevisionIdException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::RevisionIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetPullRequestOverrideStateErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPullRequestOverrideStateError {
    fn code(&self) -> Option<&str> {
        GetPullRequestOverrideStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPullRequestOverrideStateError {
    /// Creates a new `GetPullRequestOverrideStateError`.
    pub fn new(kind: GetPullRequestOverrideStateErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetPullRequestOverrideStateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetPullRequestOverrideStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetPullRequestOverrideStateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetPullRequestOverrideStateErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::InvalidRevisionIdException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateErrorKind::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetPullRequestOverrideStateErrorKind::RevisionIdRequiredException(_)
        )
    }
}
impl std::error::Error for GetPullRequestOverrideStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetPullRequestOverrideStateErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            GetPullRequestOverrideStateErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::InvalidRevisionIdException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::RevisionIdRequiredException(_inner) => {
                Some(_inner)
            }
            GetPullRequestOverrideStateErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRepositoryError {
    /// Kind of error that occurred.
    pub kind: GetRepositoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRepositoryErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            GetRepositoryErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRepositoryError {
    fn code(&self) -> Option<&str> {
        GetRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRepositoryError {
    /// Creates a new `GetRepositoryError`.
    pub fn new(kind: GetRepositoryErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetRepositoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetRepositoryErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            GetRepositoryErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            GetRepositoryErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetRepositoryErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetRepositoryErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetRepositoryErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `GetRepositoryTriggers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct GetRepositoryTriggersError {
    /// Kind of error that occurred.
    pub kind: GetRepositoryTriggersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `GetRepositoryTriggers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRepositoryTriggersErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for GetRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            GetRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            GetRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            GetRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            GetRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            GetRepositoryTriggersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRepositoryTriggersError {
    fn code(&self) -> Option<&str> {
        GetRepositoryTriggersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRepositoryTriggersError {
    /// Creates a new `GetRepositoryTriggersError`.
    pub fn new(kind: GetRepositoryTriggersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `GetRepositoryTriggersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: GetRepositoryTriggersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `GetRepositoryTriggersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: GetRepositoryTriggersErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            GetRepositoryTriggersErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for GetRepositoryTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            GetRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            GetRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            GetRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            GetRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            GetRepositoryTriggersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListApprovalRuleTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListApprovalRuleTemplatesError {
    /// Kind of error that occurred.
    pub kind: ListApprovalRuleTemplatesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListApprovalRuleTemplates` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListApprovalRuleTemplatesErrorKind {
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListApprovalRuleTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListApprovalRuleTemplatesErrorKind::InvalidContinuationTokenException(_inner) => {
                _inner.fmt(f)
            }
            ListApprovalRuleTemplatesErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            ListApprovalRuleTemplatesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListApprovalRuleTemplatesError {
    fn code(&self) -> Option<&str> {
        ListApprovalRuleTemplatesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListApprovalRuleTemplatesError {
    /// Creates a new `ListApprovalRuleTemplatesError`.
    pub fn new(kind: ListApprovalRuleTemplatesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListApprovalRuleTemplatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListApprovalRuleTemplatesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListApprovalRuleTemplatesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListApprovalRuleTemplatesErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListApprovalRuleTemplatesErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApprovalRuleTemplatesErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListApprovalRuleTemplatesErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListApprovalRuleTemplatesErrorKind::InvalidMaxResultsException(_)
        )
    }
}
impl std::error::Error for ListApprovalRuleTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListApprovalRuleTemplatesErrorKind::InvalidContinuationTokenException(_inner) => {
                Some(_inner)
            }
            ListApprovalRuleTemplatesErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            ListApprovalRuleTemplatesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListAssociatedApprovalRuleTemplatesForRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListAssociatedApprovalRuleTemplatesForRepositoryError {
    /// Kind of error that occurred.
    pub kind: ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListAssociatedApprovalRuleTemplatesForRepository` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListAssociatedApprovalRuleTemplatesForRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidContinuationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidMaxResultsException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for ListAssociatedApprovalRuleTemplatesForRepositoryError
{
    fn code(&self) -> Option<&str> {
        ListAssociatedApprovalRuleTemplatesForRepositoryError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssociatedApprovalRuleTemplatesForRepositoryError {
    /// Creates a new `ListAssociatedApprovalRuleTemplatesForRepositoryError`.
    pub fn new(
        kind: ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListAssociatedApprovalRuleTemplatesForRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListAssociatedApprovalRuleTemplatesForRepositoryError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidMaxResultsException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(&self.kind, ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for ListAssociatedApprovalRuleTemplatesForRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidContinuationTokenException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidMaxResultsException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `ListBranches` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListBranchesError {
    /// Kind of error that occurred.
    pub kind: ListBranchesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListBranches` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBranchesErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListBranchesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListBranchesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            ListBranchesErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            ListBranchesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListBranchesError {
    fn code(&self) -> Option<&str> {
        ListBranchesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBranchesError {
    /// Creates a new `ListBranchesError`.
    pub fn new(kind: ListBranchesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListBranchesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListBranchesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListBranchesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListBranchesErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListBranchesErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBranchesErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBranchesErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBranchesErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBranchesErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBranchesErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBranchesErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBranchesErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `ListBranchesErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListBranchesErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for ListBranchesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListBranchesErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            ListBranchesErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            ListBranchesErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            ListBranchesErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            ListBranchesErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            ListBranchesErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            ListBranchesErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            ListBranchesErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            ListBranchesErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            ListBranchesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListPullRequests` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListPullRequestsError {
    /// Kind of error that occurred.
    pub kind: ListPullRequestsErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListPullRequests` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPullRequestsErrorKind {
    /// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
    AuthorDoesNotExistException(crate::error::AuthorDoesNotExistException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.</p>
    InvalidAuthorArnException(crate::error::InvalidAuthorArnException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
    InvalidPullRequestStatusException(crate::error::InvalidPullRequestStatusException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListPullRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListPullRequestsErrorKind::AuthorDoesNotExistException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            ListPullRequestsErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidAuthorArnException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidPullRequestStatusException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            ListPullRequestsErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPullRequestsError {
    fn code(&self) -> Option<&str> {
        ListPullRequestsError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPullRequestsError {
    /// Creates a new `ListPullRequestsError`.
    pub fn new(kind: ListPullRequestsErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListPullRequestsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListPullRequestsErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListPullRequestsError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListPullRequestsErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::AuthorDoesNotExistException`.
    pub fn is_author_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::AuthorDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::InvalidAuthorArnException`.
    pub fn is_invalid_author_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidAuthorArnException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidMaxResultsException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::InvalidPullRequestStatusException`.
    pub fn is_invalid_pull_request_status_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidPullRequestStatusException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `ListPullRequestsErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListPullRequestsErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for ListPullRequestsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListPullRequestsErrorKind::AuthorDoesNotExistException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            ListPullRequestsErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidAuthorArnException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidMaxResultsException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidPullRequestStatusException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            ListPullRequestsErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListRepositories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRepositoriesError {
    /// Kind of error that occurred.
    pub kind: ListRepositoriesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListRepositories` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRepositoriesErrorKind {
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified sort order is not valid.</p>
    InvalidOrderException(crate::error::InvalidOrderException),
    /// <p>The specified sort by value is not valid.</p>
    InvalidSortByException(crate::error::InvalidSortByException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRepositoriesErrorKind::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            ListRepositoriesErrorKind::InvalidOrderException(_inner) => _inner.fmt(f),
            ListRepositoriesErrorKind::InvalidSortByException(_inner) => _inner.fmt(f),
            ListRepositoriesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRepositoriesError {
    fn code(&self) -> Option<&str> {
        ListRepositoriesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRepositoriesError {
    /// Creates a new `ListRepositoriesError`.
    pub fn new(kind: ListRepositoriesErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListRepositoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRepositoriesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListRepositoriesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRepositoriesErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListRepositoriesErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRepositoriesErrorKind::InvalidOrderException`.
    pub fn is_invalid_order_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesErrorKind::InvalidOrderException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRepositoriesErrorKind::InvalidSortByException`.
    pub fn is_invalid_sort_by_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesErrorKind::InvalidSortByException(_)
        )
    }
}
impl std::error::Error for ListRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRepositoriesErrorKind::InvalidContinuationTokenException(_inner) => Some(_inner),
            ListRepositoriesErrorKind::InvalidOrderException(_inner) => Some(_inner),
            ListRepositoriesErrorKind::InvalidSortByException(_inner) => Some(_inner),
            ListRepositoriesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `ListRepositoriesForApprovalRuleTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListRepositoriesForApprovalRuleTemplateError {
    /// Kind of error that occurred.
    pub kind: ListRepositoriesForApprovalRuleTemplateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListRepositoriesForApprovalRuleTemplate` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRepositoriesForApprovalRuleTemplateErrorKind {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListRepositoriesForApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidContinuationTokenException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidMaxResultsException(_inner) =>
            _inner.fmt(f)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRepositoriesForApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        ListRepositoriesForApprovalRuleTemplateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRepositoriesForApprovalRuleTemplateError {
    /// Creates a new `ListRepositoriesForApprovalRuleTemplateError`.
    pub fn new(
        kind: ListRepositoriesForApprovalRuleTemplateErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListRepositoriesForApprovalRuleTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListRepositoriesForApprovalRuleTemplateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListRepositoriesForApprovalRuleTemplateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListRepositoriesForApprovalRuleTemplateErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(&self.kind, ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidContinuationTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidMaxResultsException(_)
        )
    }
}
impl std::error::Error for ListRepositoriesForApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidContinuationTokenException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidMaxResultsException(_inner) =>
            Some(_inner)
            ,
            ListRepositoriesForApprovalRuleTemplateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct ListTagsForResourceError {
    /// Kind of error that occurred.
    pub kind: ListTagsForResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `ListTagsForResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceErrorKind {
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            ListTagsForResourceErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::InvalidResourceArnException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            ListTagsForResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        ListTagsForResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates a new `ListTagsForResourceError`.
    pub fn new(kind: ListTagsForResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: ListTagsForResourceErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::InvalidResourceArnException`.
    pub fn is_invalid_resource_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::InvalidResourceArnException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `ListTagsForResourceErrorKind::ResourceArnRequiredException`.
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            ListTagsForResourceErrorKind::ResourceArnRequiredException(_)
        )
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            ListTagsForResourceErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::InvalidResourceArnException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::ResourceArnRequiredException(_inner) => Some(_inner),
            ListTagsForResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `MergeBranchesByFastForward` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergeBranchesByFastForwardError {
    /// Kind of error that occurred.
    pub kind: MergeBranchesByFastForwardErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `MergeBranchesByFastForward` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergeBranchesByFastForwardErrorKind {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified target branch is not valid.</p>
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergeBranchesByFastForwardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergeBranchesByFastForwardErrorKind::BranchDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::BranchNameIsTagNameException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::BranchNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByFastForwardErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::InvalidBranchNameException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            MergeBranchesByFastForwardErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::InvalidTargetBranchException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::ManualMergeRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByFastForwardErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergeBranchesByFastForwardError {
    fn code(&self) -> Option<&str> {
        MergeBranchesByFastForwardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergeBranchesByFastForwardError {
    /// Creates a new `MergeBranchesByFastForwardError`.
    pub fn new(kind: MergeBranchesByFastForwardErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `MergeBranchesByFastForwardError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergeBranchesByFastForwardErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `MergeBranchesByFastForwardError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergeBranchesByFastForwardErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::BranchDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::BranchNameIsTagNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::BranchNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::InvalidBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::InvalidTargetBranchException`.
    pub fn is_invalid_target_branch_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::InvalidTargetBranchException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::ManualMergeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByFastForwardErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergeBranchesByFastForwardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergeBranchesByFastForwardErrorKind::BranchDoesNotExistException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::BranchNameIsTagNameException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::BranchNameRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::CommitDoesNotExistException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::CommitRequiredException(_inner) => Some(_inner),
            MergeBranchesByFastForwardErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            MergeBranchesByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            MergeBranchesByFastForwardErrorKind::InvalidCommitException(_inner) => Some(_inner),
            MergeBranchesByFastForwardErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::InvalidTargetBranchException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::ManualMergeRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::TipsDivergenceExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByFastForwardErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `MergeBranchesBySquash` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergeBranchesBySquashError {
    /// Kind of error that occurred.
    pub kind: MergeBranchesBySquashErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `MergeBranchesBySquash` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergeBranchesBySquashErrorKind {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::error::FileModeRequiredException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified target branch is not valid.</p>
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergeBranchesBySquashError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergeBranchesBySquashErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::CommitMessageLengthExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::FileContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::FileModeRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::FolderContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidFileModeException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidReplacementContentException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidReplacementTypeException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::InvalidTargetBranchException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::MultipleConflictResolutionEntriesException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesBySquashErrorKind::ReplacementContentRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::ReplacementTypeRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesBySquashErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergeBranchesBySquashError {
    fn code(&self) -> Option<&str> {
        MergeBranchesBySquashError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergeBranchesBySquashError {
    /// Creates a new `MergeBranchesBySquashError`.
    pub fn new(kind: MergeBranchesBySquashErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `MergeBranchesBySquashError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergeBranchesBySquashErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `MergeBranchesBySquashError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergeBranchesBySquashErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::BranchDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::BranchNameIsTagNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::BranchNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::FileModeRequiredException`.
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::FileModeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidEmailException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidFileModeException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidPathException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidReplacementContentException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidReplacementTypeException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::InvalidTargetBranchException`.
    pub fn is_invalid_target_branch_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::InvalidTargetBranchException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::ManualMergeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::NameLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::PathRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::ReplacementContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesBySquashErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergeBranchesBySquashError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergeBranchesBySquashErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::CommitMessageLengthExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::CommitRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::FileContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::FileModeRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::FolderContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidCommitException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidConflictDetailLevelException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidConflictResolutionStrategyException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidEmailException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidFileModeException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidPathException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidReplacementContentException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::InvalidReplacementTypeException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::InvalidTargetBranchException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::ManualMergeRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(
                _inner,
            ) => Some(_inner),
            MergeBranchesBySquashErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::MultipleConflictResolutionEntriesException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::PathRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::ReplacementContentRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::ReplacementTypeRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesBySquashErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::TipsDivergenceExceededException(_inner) => Some(_inner),
            MergeBranchesBySquashErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `MergeBranchesByThreeWay` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergeBranchesByThreeWayError {
    /// Kind of error that occurred.
    pub kind: MergeBranchesByThreeWayErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `MergeBranchesByThreeWay` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergeBranchesByThreeWayErrorKind {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::error::FileModeRequiredException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified target branch is not valid.</p>
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergeBranchesByThreeWayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergeBranchesByThreeWayErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::CommitMessageLengthExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::CommitRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::FileContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::FileModeRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::FolderContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidCommitException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidConflictDetailLevelException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionStrategyException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidFileModeException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::InvalidReplacementContentException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidReplacementTypeException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::InvalidTargetBranchException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::MultipleConflictResolutionEntriesException(
                _inner,
            ) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            MergeBranchesByThreeWayErrorKind::ReplacementContentRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::ReplacementTypeRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::TipsDivergenceExceededException(_inner) => {
                _inner.fmt(f)
            }
            MergeBranchesByThreeWayErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergeBranchesByThreeWayError {
    fn code(&self) -> Option<&str> {
        MergeBranchesByThreeWayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergeBranchesByThreeWayError {
    /// Creates a new `MergeBranchesByThreeWayError`.
    pub fn new(kind: MergeBranchesByThreeWayErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `MergeBranchesByThreeWayError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergeBranchesByThreeWayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `MergeBranchesByThreeWayError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergeBranchesByThreeWayErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::BranchDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::BranchNameIsTagNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::BranchNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::CommitRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::FileModeRequiredException`.
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::FileModeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidCommitException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidEmailException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidFileModeException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidPathException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidReplacementContentException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidReplacementTypeException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::InvalidTargetBranchException`.
    pub fn is_invalid_target_branch_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::InvalidTargetBranchException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::ManualMergeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::NameLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::PathRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::ReplacementContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergeBranchesByThreeWayErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergeBranchesByThreeWayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergeBranchesByThreeWayErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::CommitMessageLengthExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::CommitRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::ConcurrentReferenceUpdateException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::FileContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::FileModeRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::FolderContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidCommitException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidConflictDetailLevelException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionStrategyException(
                _inner,
            ) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidEmailException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidFileModeException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidPathException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::InvalidReplacementContentException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidReplacementTypeException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::InvalidTargetBranchException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::ManualMergeRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(
                _inner,
            ) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::MaximumItemsToCompareExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::MultipleConflictResolutionEntriesException(
                _inner,
            ) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::PathRequiredException(_inner) => Some(_inner),
            MergeBranchesByThreeWayErrorKind::ReplacementContentRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::ReplacementTypeRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::TipsDivergenceExceededException(_inner) => {
                Some(_inner)
            }
            MergeBranchesByThreeWayErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `MergePullRequestByFastForward` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergePullRequestByFastForwardError {
    /// Kind of error that occurred.
    pub kind: MergePullRequestByFastForwardErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `MergePullRequestByFastForward` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestByFastForwardErrorKind {
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(
        crate::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>The specified reference does not exist. You must provide a full commit ID.</p>
    ReferenceDoesNotExistException(crate::error::ReferenceDoesNotExistException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(
        crate::error::TipOfSourceReferenceIsDifferentException,
    ),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergePullRequestByFastForwardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergePullRequestByFastForwardErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidCommitIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::ManualMergeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::ReferenceDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByFastForwardErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergePullRequestByFastForwardError {
    fn code(&self) -> Option<&str> {
        MergePullRequestByFastForwardError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestByFastForwardError {
    /// Creates a new `MergePullRequestByFastForwardError`.
    pub fn new(
        kind: MergePullRequestByFastForwardErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `MergePullRequestByFastForwardError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergePullRequestByFastForwardErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `MergePullRequestByFastForwardError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergePullRequestByFastForwardErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::InvalidCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::ManualMergeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::PullRequestApprovalRulesNotSatisfiedException`.
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::PullRequestApprovalRulesNotSatisfiedException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::ReferenceDoesNotExistException`.
    pub fn is_reference_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::ReferenceDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardErrorKind::TipOfSourceReferenceIsDifferentException`.
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByFastForwardErrorKind::TipOfSourceReferenceIsDifferentException(_)
        )
    }
}
impl std::error::Error for MergePullRequestByFastForwardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergePullRequestByFastForwardErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidCommitIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::ManualMergeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::ReferenceDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByFastForwardErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `MergePullRequestBySquash` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergePullRequestBySquashError {
    /// Kind of error that occurred.
    pub kind: MergePullRequestBySquashErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `MergePullRequestBySquash` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestBySquashErrorKind {
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(
        crate::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(
        crate::error::TipOfSourceReferenceIsDifferentException,
    ),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergePullRequestBySquashError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergePullRequestBySquashErrorKind::CommitMessageLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::FileContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidCommitIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictDetailLevelException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidEmailException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidFileModeException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidPathException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidReplacementContentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidReplacementTypeException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::ManualMergeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::NameLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PathRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::ReplacementContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::ReplacementTypeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::TipsDivergenceExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestBySquashErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergePullRequestBySquashError {
    fn code(&self) -> Option<&str> {
        MergePullRequestBySquashError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestBySquashError {
    /// Creates a new `MergePullRequestBySquashError`.
    pub fn new(kind: MergePullRequestBySquashErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `MergePullRequestBySquashError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergePullRequestBySquashErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `MergePullRequestBySquashError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergePullRequestBySquashErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidEmailException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidFileModeException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidPathException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidReplacementContentException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidReplacementTypeException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::ManualMergeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::NameLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PathRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::PullRequestApprovalRulesNotSatisfiedException`.
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PullRequestApprovalRulesNotSatisfiedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::ReplacementContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::TipOfSourceReferenceIsDifferentException`.
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::TipOfSourceReferenceIsDifferentException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestBySquashErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergePullRequestBySquashError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergePullRequestBySquashErrorKind::CommitMessageLengthExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::FileContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidCommitIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictDetailLevelException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidEmailException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidFileModeException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidPathException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidReplacementContentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidReplacementTypeException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::ManualMergeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::NameLengthExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PathRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::ReplacementContentRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::ReplacementTypeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::TipsDivergenceExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestBySquashErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `MergePullRequestByThreeWay` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct MergePullRequestByThreeWayError {
    /// Kind of error that occurred.
    pub kind: MergePullRequestByThreeWayErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `MergePullRequestByThreeWay` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestByThreeWayErrorKind {
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(
        crate::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(
        crate::error::TipOfSourceReferenceIsDifferentException,
    ),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for MergePullRequestByThreeWayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            MergePullRequestByThreeWayErrorKind::CommitMessageLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::FileContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidCommitIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictDetailLevelException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidEmailException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidFileModeException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidPathException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementContentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementTypeException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::ManualMergeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::NameLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PathRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::ReplacementContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::ReplacementTypeRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::TipsDivergenceExceededException(_inner) =>
            _inner.fmt(f)
            ,
            MergePullRequestByThreeWayErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergePullRequestByThreeWayError {
    fn code(&self) -> Option<&str> {
        MergePullRequestByThreeWayError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestByThreeWayError {
    /// Creates a new `MergePullRequestByThreeWayError`.
    pub fn new(kind: MergePullRequestByThreeWayErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `MergePullRequestByThreeWayError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: MergePullRequestByThreeWayErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `MergePullRequestByThreeWayError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: MergePullRequestByThreeWayErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::ConcurrentReferenceUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidConflictDetailLevelException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionStrategyException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidEmailException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidFileModeException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidPathException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementContentException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementTypeException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::ManualMergeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::MaximumItemsToCompareExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::MultipleConflictResolutionEntriesException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::NameLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PathRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::PullRequestApprovalRulesNotSatisfiedException`.
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PullRequestApprovalRulesNotSatisfiedException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::ReplacementContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::ReplacementTypeRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::TipOfSourceReferenceIsDifferentException`.
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::TipOfSourceReferenceIsDifferentException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayErrorKind::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            MergePullRequestByThreeWayErrorKind::TipsDivergenceExceededException(_)
        )
    }
}
impl std::error::Error for MergePullRequestByThreeWayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            MergePullRequestByThreeWayErrorKind::CommitMessageLengthExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::ConcurrentReferenceUpdateException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::FileContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::FolderContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidCommitIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictDetailLevelException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionStrategyException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidEmailException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidFileModeException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidPathException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementContentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidReplacementTypeException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::ManualMergeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumFileContentToLoadExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::MaximumItemsToCompareExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::MultipleConflictResolutionEntriesException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::NameLengthExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PathRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestApprovalRulesNotSatisfiedException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::ReplacementContentRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::ReplacementTypeRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::RepositoryNotAssociatedWithPullRequestException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::TipOfSourceReferenceIsDifferentException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::TipsDivergenceExceededException(_inner) =>
            Some(_inner)
            ,
            MergePullRequestByThreeWayErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `OverridePullRequestApprovalRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct OverridePullRequestApprovalRulesError {
    /// Kind of error that occurred.
    pub kind: OverridePullRequestApprovalRulesErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `OverridePullRequestApprovalRules` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum OverridePullRequestApprovalRulesErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The override status is not valid. Valid statuses are OVERRIDE and REVOKE.</p>
    InvalidOverrideStatusException(crate::error::InvalidOverrideStatusException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The pull request has already had its approval rules set to override.</p>
    OverrideAlreadySetException(crate::error::OverrideAlreadySetException),
    /// <p>An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.</p>
    OverrideStatusRequiredException(crate::error::OverrideStatusRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for OverridePullRequestApprovalRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            OverridePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(
                _inner,
            ) => _inner.fmt(f),
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(
                _inner,
            ) => _inner.fmt(f),
            OverridePullRequestApprovalRulesErrorKind::InvalidOverrideStatusException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::OverrideAlreadySetException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::OverrideStatusRequiredException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::PullRequestAlreadyClosedException(
                _inner,
            ) => _inner.fmt(f),
            OverridePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_inner) => {
                _inner.fmt(f)
            }
            OverridePullRequestApprovalRulesErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for OverridePullRequestApprovalRulesError {
    fn code(&self) -> Option<&str> {
        OverridePullRequestApprovalRulesError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl OverridePullRequestApprovalRulesError {
    /// Creates a new `OverridePullRequestApprovalRulesError`.
    pub fn new(
        kind: OverridePullRequestApprovalRulesErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `OverridePullRequestApprovalRulesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: OverridePullRequestApprovalRulesErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `OverridePullRequestApprovalRulesError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: OverridePullRequestApprovalRulesErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::InvalidOverrideStatusException`.
    pub fn is_invalid_override_status_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::InvalidOverrideStatusException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::OverrideAlreadySetException`.
    pub fn is_override_already_set_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::OverrideAlreadySetException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::OverrideStatusRequiredException`.
    pub fn is_override_status_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::OverrideStatusRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesErrorKind::RevisionNotCurrentException`.
    pub fn is_revision_not_current_exception(&self) -> bool {
        matches!(
            &self.kind,
            OverridePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_)
        )
    }
}
impl std::error::Error for OverridePullRequestApprovalRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            OverridePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException(
                _inner,
            ) => Some(_inner),
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException(
                _inner,
            ) => Some(_inner),
            OverridePullRequestApprovalRulesErrorKind::InvalidOverrideStatusException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::InvalidRevisionIdException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::OverrideAlreadySetException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::OverrideStatusRequiredException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::PullRequestAlreadyClosedException(
                _inner,
            ) => Some(_inner),
            OverridePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::RevisionIdRequiredException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::RevisionNotCurrentException(_inner) => {
                Some(_inner)
            }
            OverridePullRequestApprovalRulesErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PostCommentForComparedCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PostCommentForComparedCommitError {
    /// Kind of error that occurred.
    pub kind: PostCommentForComparedCommitErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PostCommentForComparedCommit` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PostCommentForComparedCommitErrorKind {
    /// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
    BeforeCommitIdAndAfterCommitIdAreSameException(
        crate::error::BeforeCommitIdAndAfterCommitIdAreSameException,
    ),
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The location of the file is not valid. Make sure that you include the file name and extension.</p>
    InvalidFileLocationException(crate::error::InvalidFileLocationException),
    /// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
    InvalidFilePositionException(crate::error::InvalidFilePositionException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
    InvalidRelativeFileVersionEnumException(crate::error::InvalidRelativeFileVersionEnumException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified path does not exist.</p>
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PostCommentForComparedCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PostCommentForComparedCommitErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::ClientRequestTokenRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::CommentContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::CommentContentSizeLimitExceededException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::CommitDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::CommitIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::IdempotencyParameterMismatchException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidClientRequestTokenException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidCommitIdException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidFileLocationException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidFilePositionException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidPathException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidRelativeFileVersionEnumException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::PathDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::PathRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            PostCommentForComparedCommitErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PostCommentForComparedCommitError {
    fn code(&self) -> Option<&str> {
        PostCommentForComparedCommitError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PostCommentForComparedCommitError {
    /// Creates a new `PostCommentForComparedCommitError`.
    pub fn new(kind: PostCommentForComparedCommitErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PostCommentForComparedCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PostCommentForComparedCommitErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PostCommentForComparedCommitError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PostCommentForComparedCommitErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException`.
    pub fn is_before_commit_id_and_after_commit_id_are_same_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::ClientRequestTokenRequiredException`.
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::ClientRequestTokenRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::CommentContentRequiredException`.
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::CommentContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::CommentContentSizeLimitExceededException`.
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::CommentContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::CommitIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::IdempotencyParameterMismatchException`.
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::IdempotencyParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::InvalidClientRequestTokenException`.
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidClientRequestTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::InvalidFileLocationException`.
    pub fn is_invalid_file_location_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidFileLocationException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::InvalidFilePositionException`.
    pub fn is_invalid_file_position_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidFilePositionException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidPathException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::InvalidRelativeFileVersionEnumException`.
    pub fn is_invalid_relative_file_version_enum_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidRelativeFileVersionEnumException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::PathDoesNotExistException`.
    pub fn is_path_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::PathDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::PathRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForComparedCommitErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for PostCommentForComparedCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PostCommentForComparedCommitErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::ClientRequestTokenRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::CommentContentRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::CommentContentSizeLimitExceededException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::CommitDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::CommitIdRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::IdempotencyParameterMismatchException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidClientRequestTokenException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidCommitIdException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidFileLocationException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidFilePositionException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidPathException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidRelativeFileVersionEnumException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::PathDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::PathRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            PostCommentForComparedCommitErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `PostCommentForPullRequest` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PostCommentForPullRequestError {
    /// Kind of error that occurred.
    pub kind: PostCommentForPullRequestErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PostCommentForPullRequest` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PostCommentForPullRequestErrorKind {
    /// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
    BeforeCommitIdAndAfterCommitIdAreSameException(
        crate::error::BeforeCommitIdAndAfterCommitIdAreSameException,
    ),
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The location of the file is not valid. Make sure that you include the file name and extension.</p>
    InvalidFileLocationException(crate::error::InvalidFileLocationException),
    /// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
    InvalidFilePositionException(crate::error::InvalidFilePositionException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
    InvalidRelativeFileVersionEnumException(crate::error::InvalidRelativeFileVersionEnumException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified path does not exist.</p>
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PostCommentForPullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PostCommentForPullRequestErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(
                _inner,
            ) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::ClientRequestTokenRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::CommentContentRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::CommentContentSizeLimitExceededException(
                _inner,
            ) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::CommitDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::CommitIdRequiredException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::IdempotencyParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidClientRequestTokenException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidCommitIdException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::InvalidFileLocationException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidFilePositionException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidRelativeFileVersionEnumException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::PathDoesNotExistException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _inner,
            ) => _inner.fmt(f),
            PostCommentForPullRequestErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PostCommentForPullRequestError {
    fn code(&self) -> Option<&str> {
        PostCommentForPullRequestError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PostCommentForPullRequestError {
    /// Creates a new `PostCommentForPullRequestError`.
    pub fn new(kind: PostCommentForPullRequestErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PostCommentForPullRequestError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PostCommentForPullRequestErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PostCommentForPullRequestError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PostCommentForPullRequestErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException`.
    pub fn is_before_commit_id_and_after_commit_id_are_same_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::ClientRequestTokenRequiredException`.
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::ClientRequestTokenRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::CommentContentRequiredException`.
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::CommentContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::CommentContentSizeLimitExceededException`.
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::CommentContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::CommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::CommitIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::IdempotencyParameterMismatchException`.
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::IdempotencyParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::InvalidClientRequestTokenException`.
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidClientRequestTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::InvalidFileLocationException`.
    pub fn is_invalid_file_location_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidFileLocationException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::InvalidFilePositionException`.
    pub fn is_invalid_file_position_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidFilePositionException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidPathException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::InvalidRelativeFileVersionEnumException`.
    pub fn is_invalid_relative_file_version_enum_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidRelativeFileVersionEnumException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::PathDoesNotExistException`.
    pub fn is_path_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::PathDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::PathRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
}
impl std::error::Error for PostCommentForPullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PostCommentForPullRequestErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException(
                _inner,
            ) => Some(_inner),
            PostCommentForPullRequestErrorKind::ClientRequestTokenRequiredException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::CommentContentRequiredException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::CommentContentSizeLimitExceededException(
                _inner,
            ) => Some(_inner),
            PostCommentForPullRequestErrorKind::CommitDoesNotExistException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::CommitIdRequiredException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            PostCommentForPullRequestErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::IdempotencyParameterMismatchException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidClientRequestTokenException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidCommitIdException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::InvalidFileLocationException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidFilePositionException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidPathException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidRelativeFileVersionEnumException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::PathDoesNotExistException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::PathRequiredException(_inner) => Some(_inner),
            PostCommentForPullRequestErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            PostCommentForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException(
                _inner,
            ) => Some(_inner),
            PostCommentForPullRequestErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PostCommentReply` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PostCommentReplyError {
    /// Kind of error that occurred.
    pub kind: PostCommentReplyErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PostCommentReply` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PostCommentReplyErrorKind {
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PostCommentReplyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PostCommentReplyErrorKind::ClientRequestTokenRequiredException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::CommentContentRequiredException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::CommentContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentReplyErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::IdempotencyParameterMismatchException(_inner) => {
                _inner.fmt(f)
            }
            PostCommentReplyErrorKind::InvalidClientRequestTokenException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            PostCommentReplyErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PostCommentReplyError {
    fn code(&self) -> Option<&str> {
        PostCommentReplyError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PostCommentReplyError {
    /// Creates a new `PostCommentReplyError`.
    pub fn new(kind: PostCommentReplyErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PostCommentReplyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PostCommentReplyErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PostCommentReplyError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PostCommentReplyErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PostCommentReplyErrorKind::ClientRequestTokenRequiredException`.
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::ClientRequestTokenRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentReplyErrorKind::CommentContentRequiredException`.
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::CommentContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentReplyErrorKind::CommentContentSizeLimitExceededException`.
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::CommentContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentReplyErrorKind::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::CommentDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentReplyErrorKind::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::CommentIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentReplyErrorKind::IdempotencyParameterMismatchException`.
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::IdempotencyParameterMismatchException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentReplyErrorKind::InvalidClientRequestTokenException`.
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::InvalidClientRequestTokenException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentReplyErrorKind::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PostCommentReplyErrorKind::InvalidCommentIdException(_)
        )
    }
}
impl std::error::Error for PostCommentReplyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PostCommentReplyErrorKind::ClientRequestTokenRequiredException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::CommentContentRequiredException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::CommentContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            PostCommentReplyErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::IdempotencyParameterMismatchException(_inner) => {
                Some(_inner)
            }
            PostCommentReplyErrorKind::InvalidClientRequestTokenException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            PostCommentReplyErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PutCommentReaction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutCommentReactionError {
    /// Kind of error that occurred.
    pub kind: PutCommentReactionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PutCommentReaction` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutCommentReactionErrorKind {
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// <p>The value of the reaction is not valid. For more information, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit User Guide</a>.</p>
    InvalidReactionValueException(crate::error::InvalidReactionValueException),
    /// <p>The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.</p>
    ReactionLimitExceededException(crate::error::ReactionLimitExceededException),
    /// <p>A reaction value is required. </p>
    ReactionValueRequiredException(crate::error::ReactionValueRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutCommentReactionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutCommentReactionErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::InvalidReactionValueException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::ReactionLimitExceededException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::ReactionValueRequiredException(_inner) => _inner.fmt(f),
            PutCommentReactionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutCommentReactionError {
    fn code(&self) -> Option<&str> {
        PutCommentReactionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutCommentReactionError {
    /// Creates a new `PutCommentReactionError`.
    pub fn new(kind: PutCommentReactionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutCommentReactionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutCommentReactionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PutCommentReactionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutCommentReactionErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutCommentReactionErrorKind::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::CommentDeletedException(_)
        )
    }
    /// Returns `true` if the error kind is `PutCommentReactionErrorKind::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::CommentDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PutCommentReactionErrorKind::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::CommentIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutCommentReactionErrorKind::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::InvalidCommentIdException(_)
        )
    }
    /// Returns `true` if the error kind is `PutCommentReactionErrorKind::InvalidReactionValueException`.
    pub fn is_invalid_reaction_value_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::InvalidReactionValueException(_)
        )
    }
    /// Returns `true` if the error kind is `PutCommentReactionErrorKind::ReactionLimitExceededException`.
    pub fn is_reaction_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::ReactionLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `PutCommentReactionErrorKind::ReactionValueRequiredException`.
    pub fn is_reaction_value_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutCommentReactionErrorKind::ReactionValueRequiredException(_)
        )
    }
}
impl std::error::Error for PutCommentReactionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutCommentReactionErrorKind::CommentDeletedException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::InvalidReactionValueException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::ReactionLimitExceededException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::ReactionValueRequiredException(_inner) => Some(_inner),
            PutCommentReactionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PutFile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutFileError {
    /// Kind of error that occurred.
    pub kind: PutFileErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PutFile` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFileErrorKind {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
    DirectoryNameConflictsWithFileNameException(
        crate::error::DirectoryNameConflictsWithFileNameException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.</p>
    FileContentRequiredException(crate::error::FileContentRequiredException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
    FileNameConflictsWithDirectoryNameException(
        crate::error::FileNameConflictsWithDirectoryNameException,
    ),
    /// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
    FilePathConflictsWithSubmodulePathException(
        crate::error::FilePathConflictsWithSubmodulePathException,
    ),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified deletion parameter is not valid.</p>
    InvalidDeletionParameterException(crate::error::InvalidDeletionParameterException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.</p>
    SameFileContentException(crate::error::SameFileContentException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutFileErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            PutFileErrorKind::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            PutFileErrorKind::DirectoryNameConflictsWithFileNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            PutFileErrorKind::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FileContentRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FileNameConflictsWithDirectoryNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FilePathConflictsWithSubmodulePathException(_inner) => _inner.fmt(f),
            PutFileErrorKind::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidDeletionParameterException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidEmailException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidFileModeException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidPathException(_inner) => _inner.fmt(f),
            PutFileErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            PutFileErrorKind::NameLengthExceededException(_inner) => _inner.fmt(f),
            PutFileErrorKind::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            PutFileErrorKind::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            PutFileErrorKind::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::PathRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            PutFileErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            PutFileErrorKind::SameFileContentException(_inner) => _inner.fmt(f),
            PutFileErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutFileError {
    fn code(&self) -> Option<&str> {
        PutFileError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutFileError {
    /// Creates a new `PutFileError`.
    pub fn new(kind: PutFileErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutFileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutFileErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PutFileError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutFileErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::BranchNameIsTagNameException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::CommitMessageLengthExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::DirectoryNameConflictsWithFileNameException`.
    pub fn is_directory_name_conflicts_with_file_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::DirectoryNameConflictsWithFileNameException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::FileContentRequiredException`.
    pub fn is_file_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FileContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FileContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::FileNameConflictsWithDirectoryNameException`.
    pub fn is_file_name_conflicts_with_directory_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FileNameConflictsWithDirectoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::FilePathConflictsWithSubmodulePathException`.
    pub fn is_file_path_conflicts_with_submodule_path_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FilePathConflictsWithSubmodulePathException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::FolderContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::InvalidDeletionParameterException`.
    pub fn is_invalid_deletion_parameter_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::InvalidDeletionParameterException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::InvalidParentCommitIdException`.
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::InvalidParentCommitIdException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::ParentCommitDoesNotExistException`.
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::ParentCommitDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::ParentCommitIdOutdatedException`.
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::ParentCommitIdOutdatedException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::ParentCommitIdRequiredException`.
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::ParentCommitIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutFileErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutFileErrorKind::SameFileContentException`.
    pub fn is_same_file_content_exception(&self) -> bool {
        matches!(&self.kind, PutFileErrorKind::SameFileContentException(_))
    }
}
impl std::error::Error for PutFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutFileErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            PutFileErrorKind::BranchNameIsTagNameException(_inner) => Some(_inner),
            PutFileErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::CommitMessageLengthExceededException(_inner) => Some(_inner),
            PutFileErrorKind::DirectoryNameConflictsWithFileNameException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            PutFileErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            PutFileErrorKind::FileContentRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            PutFileErrorKind::FileNameConflictsWithDirectoryNameException(_inner) => Some(_inner),
            PutFileErrorKind::FilePathConflictsWithSubmodulePathException(_inner) => Some(_inner),
            PutFileErrorKind::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidDeletionParameterException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidEmailException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidFileModeException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidParentCommitIdException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidPathException(_inner) => Some(_inner),
            PutFileErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            PutFileErrorKind::NameLengthExceededException(_inner) => Some(_inner),
            PutFileErrorKind::ParentCommitDoesNotExistException(_inner) => Some(_inner),
            PutFileErrorKind::ParentCommitIdOutdatedException(_inner) => Some(_inner),
            PutFileErrorKind::ParentCommitIdRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::PathRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            PutFileErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            PutFileErrorKind::SameFileContentException(_inner) => Some(_inner),
            PutFileErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `PutRepositoryTriggers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct PutRepositoryTriggersError {
    /// Kind of error that occurred.
    pub kind: PutRepositoryTriggersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `PutRepositoryTriggers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRepositoryTriggersErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>One or more branch names specified for the trigger is not valid.</p>
    InvalidRepositoryTriggerBranchNameException(
        crate::error::InvalidRepositoryTriggerBranchNameException,
    ),
    /// <p>The custom data provided for the trigger is not valid.</p>
    InvalidRepositoryTriggerCustomDataException(
        crate::error::InvalidRepositoryTriggerCustomDataException,
    ),
    /// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
    InvalidRepositoryTriggerDestinationArnException(
        crate::error::InvalidRepositoryTriggerDestinationArnException,
    ),
    /// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
    InvalidRepositoryTriggerEventsException(crate::error::InvalidRepositoryTriggerEventsException),
    /// <p>The name of the trigger is not valid.</p>
    InvalidRepositoryTriggerNameException(crate::error::InvalidRepositoryTriggerNameException),
    /// <p>The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.</p>
    InvalidRepositoryTriggerRegionException(crate::error::InvalidRepositoryTriggerRegionException),
    /// <p>The number of branches for the trigger was exceeded.</p>
    MaximumBranchesExceededException(crate::error::MaximumBranchesExceededException),
    /// <p>The number of triggers allowed for the repository was exceeded.</p>
    MaximumRepositoryTriggersExceededException(
        crate::error::MaximumRepositoryTriggersExceededException,
    ),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
    RepositoryTriggerBranchNameListRequiredException(
        crate::error::RepositoryTriggerBranchNameListRequiredException,
    ),
    /// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
    RepositoryTriggerDestinationArnRequiredException(
        crate::error::RepositoryTriggerDestinationArnRequiredException,
    ),
    /// <p>At least one event for the trigger is required, but was not specified.</p>
    RepositoryTriggerEventsListRequiredException(
        crate::error::RepositoryTriggerEventsListRequiredException,
    ),
    /// <p>A name for the trigger is required, but was not specified.</p>
    RepositoryTriggerNameRequiredException(crate::error::RepositoryTriggerNameRequiredException),
    /// <p>The list of triggers for the repository is required, but was not specified.</p>
    RepositoryTriggersListRequiredException(crate::error::RepositoryTriggersListRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for PutRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            PutRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(
                _inner,
            ) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::MaximumBranchesExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(
                _inner,
            ) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(
                _inner,
            ) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(
                _inner,
            ) => _inner.fmt(f),
            PutRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_inner) => {
                _inner.fmt(f)
            }
            PutRepositoryTriggersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutRepositoryTriggersError {
    fn code(&self) -> Option<&str> {
        PutRepositoryTriggersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRepositoryTriggersError {
    /// Creates a new `PutRepositoryTriggersError`.
    pub fn new(kind: PutRepositoryTriggersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `PutRepositoryTriggersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: PutRepositoryTriggersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `PutRepositoryTriggersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: PutRepositoryTriggersErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException`.
    pub fn is_invalid_repository_trigger_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException`.
    pub fn is_invalid_repository_trigger_custom_data_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException`.
    pub fn is_invalid_repository_trigger_destination_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException`.
    pub fn is_invalid_repository_trigger_events_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException`.
    pub fn is_invalid_repository_trigger_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException`.
    pub fn is_invalid_repository_trigger_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::MaximumBranchesExceededException`.
    pub fn is_maximum_branches_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::MaximumBranchesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException`.
    pub fn is_maximum_repository_triggers_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException`.
    pub fn is_repository_trigger_branch_name_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException`.
    pub fn is_repository_trigger_destination_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException`.
    pub fn is_repository_trigger_events_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException`.
    pub fn is_repository_trigger_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException`.
    pub fn is_repository_triggers_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            PutRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_)
        )
    }
}
impl std::error::Error for PutRepositoryTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            PutRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(
                _inner,
            ) => Some(_inner),
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::MaximumBranchesExceededException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(
                _inner,
            ) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(
                _inner,
            ) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(
                _inner,
            ) => Some(_inner),
            PutRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_inner) => {
                Some(_inner)
            }
            PutRepositoryTriggersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TagResourceError {
    /// Kind of error that occurred.
    pub kind: TagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceErrorKind {
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    /// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    /// <p>The map of tags is not valid.</p>
    InvalidTagsMapException(crate::error::InvalidTagsMapException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// <p>The tag policy is not valid.</p>
    TagPolicyException(crate::error::TagPolicyException),
    /// <p>A map of tags is required.</p>
    TagsMapRequiredException(crate::error::TagsMapRequiredException),
    /// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TagResourceErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidResourceArnException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidSystemTagUsageException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::InvalidTagsMapException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagPolicyException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TagsMapRequiredException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            TagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        TagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates a new `TagResourceError`.
    pub fn new(kind: TagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TagResourceErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InvalidResourceArnException`.
    pub fn is_invalid_resource_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidResourceArnException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InvalidSystemTagUsageException`.
    pub fn is_invalid_system_tag_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::InvalidSystemTagUsageException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::InvalidTagsMapException`.
    pub fn is_invalid_tags_map_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::InvalidTagsMapException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::ResourceArnRequiredException`.
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::ResourceArnRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::TagPolicyException`.
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TagPolicyException(_))
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::TagsMapRequiredException`.
    pub fn is_tags_map_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TagResourceErrorKind::TagsMapRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `TagResourceErrorKind::TooManyTagsException`.
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, TagResourceErrorKind::TooManyTagsException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TagResourceErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidResourceArnException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidSystemTagUsageException(_inner) => Some(_inner),
            TagResourceErrorKind::InvalidTagsMapException(_inner) => Some(_inner),
            TagResourceErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            TagResourceErrorKind::ResourceArnRequiredException(_inner) => Some(_inner),
            TagResourceErrorKind::TagPolicyException(_inner) => Some(_inner),
            TagResourceErrorKind::TagsMapRequiredException(_inner) => Some(_inner),
            TagResourceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            TagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `TestRepositoryTriggers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct TestRepositoryTriggersError {
    /// Kind of error that occurred.
    pub kind: TestRepositoryTriggersErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `TestRepositoryTriggers` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestRepositoryTriggersErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>One or more branch names specified for the trigger is not valid.</p>
    InvalidRepositoryTriggerBranchNameException(
        crate::error::InvalidRepositoryTriggerBranchNameException,
    ),
    /// <p>The custom data provided for the trigger is not valid.</p>
    InvalidRepositoryTriggerCustomDataException(
        crate::error::InvalidRepositoryTriggerCustomDataException,
    ),
    /// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
    InvalidRepositoryTriggerDestinationArnException(
        crate::error::InvalidRepositoryTriggerDestinationArnException,
    ),
    /// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
    InvalidRepositoryTriggerEventsException(crate::error::InvalidRepositoryTriggerEventsException),
    /// <p>The name of the trigger is not valid.</p>
    InvalidRepositoryTriggerNameException(crate::error::InvalidRepositoryTriggerNameException),
    /// <p>The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.</p>
    InvalidRepositoryTriggerRegionException(crate::error::InvalidRepositoryTriggerRegionException),
    /// <p>The number of branches for the trigger was exceeded.</p>
    MaximumBranchesExceededException(crate::error::MaximumBranchesExceededException),
    /// <p>The number of triggers allowed for the repository was exceeded.</p>
    MaximumRepositoryTriggersExceededException(
        crate::error::MaximumRepositoryTriggersExceededException,
    ),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
    RepositoryTriggerBranchNameListRequiredException(
        crate::error::RepositoryTriggerBranchNameListRequiredException,
    ),
    /// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
    RepositoryTriggerDestinationArnRequiredException(
        crate::error::RepositoryTriggerDestinationArnRequiredException,
    ),
    /// <p>At least one event for the trigger is required, but was not specified.</p>
    RepositoryTriggerEventsListRequiredException(
        crate::error::RepositoryTriggerEventsListRequiredException,
    ),
    /// <p>A name for the trigger is required, but was not specified.</p>
    RepositoryTriggerNameRequiredException(crate::error::RepositoryTriggerNameRequiredException),
    /// <p>The list of triggers for the repository is required, but was not specified.</p>
    RepositoryTriggersListRequiredException(crate::error::RepositoryTriggersListRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for TestRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            TestRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::MaximumBranchesExceededException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(
                _inner,
            ) => _inner.fmt(f),
            TestRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_inner) => {
                _inner.fmt(f)
            }
            TestRepositoryTriggersErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TestRepositoryTriggersError {
    fn code(&self) -> Option<&str> {
        TestRepositoryTriggersError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestRepositoryTriggersError {
    /// Creates a new `TestRepositoryTriggersError`.
    pub fn new(kind: TestRepositoryTriggersErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `TestRepositoryTriggersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: TestRepositoryTriggersErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `TestRepositoryTriggersError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: TestRepositoryTriggersErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException`.
    pub fn is_invalid_repository_trigger_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException`.
    pub fn is_invalid_repository_trigger_custom_data_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException`.
    pub fn is_invalid_repository_trigger_destination_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException`.
    pub fn is_invalid_repository_trigger_events_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException`.
    pub fn is_invalid_repository_trigger_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException`.
    pub fn is_invalid_repository_trigger_region_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::MaximumBranchesExceededException`.
    pub fn is_maximum_branches_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::MaximumBranchesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException`.
    pub fn is_maximum_repository_triggers_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException`.
    pub fn is_repository_trigger_branch_name_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException`.
    pub fn is_repository_trigger_destination_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException`.
    pub fn is_repository_trigger_events_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException`.
    pub fn is_repository_trigger_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException`.
    pub fn is_repository_triggers_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            TestRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_)
        )
    }
}
impl std::error::Error for TestRepositoryTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            TestRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            TestRepositoryTriggersErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            TestRepositoryTriggersErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::MaximumBranchesExceededException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException(
                _inner,
            ) => Some(_inner),
            TestRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException(_inner) => {
                Some(_inner)
            }
            TestRepositoryTriggersErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UntagResourceError {
    /// Kind of error that occurred.
    pub kind: UntagResourceErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UntagResource` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceErrorKind {
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    /// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    /// <p>The list of tags is not valid.</p>
    InvalidTagKeysListException(crate::error::InvalidTagKeysListException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// <p>A list of tag keys is required. The list cannot be empty or null.</p>
    TagKeysListRequiredException(crate::error::TagKeysListRequiredException),
    /// <p>The tag policy is not valid.</p>
    TagPolicyException(crate::error::TagPolicyException),
    /// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UntagResourceErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidResourceArnException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidSystemTagUsageException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::InvalidTagKeysListException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TagKeysListRequiredException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TagPolicyException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::TooManyTagsException(_inner) => _inner.fmt(f),
            UntagResourceErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        UntagResourceError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates a new `UntagResourceError`.
    pub fn new(kind: UntagResourceErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UntagResourceErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UntagResourceErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InvalidResourceArnException`.
    pub fn is_invalid_resource_arn_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidResourceArnException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InvalidSystemTagUsageException`.
    pub fn is_invalid_system_tag_usage_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidSystemTagUsageException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::InvalidTagKeysListException`.
    pub fn is_invalid_tag_keys_list_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::InvalidTagKeysListException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::ResourceArnRequiredException`.
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::ResourceArnRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::TagKeysListRequiredException`.
    pub fn is_tag_keys_list_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UntagResourceErrorKind::TagKeysListRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::TagPolicyException`.
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::TagPolicyException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceErrorKind::TooManyTagsException`.
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(&self.kind, UntagResourceErrorKind::TooManyTagsException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UntagResourceErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidResourceArnException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidSystemTagUsageException(_inner) => Some(_inner),
            UntagResourceErrorKind::InvalidTagKeysListException(_inner) => Some(_inner),
            UntagResourceErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            UntagResourceErrorKind::ResourceArnRequiredException(_inner) => Some(_inner),
            UntagResourceErrorKind::TagKeysListRequiredException(_inner) => Some(_inner),
            UntagResourceErrorKind::TagPolicyException(_inner) => Some(_inner),
            UntagResourceErrorKind::TooManyTagsException(_inner) => Some(_inner),
            UntagResourceErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateApprovalRuleTemplateContent` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApprovalRuleTemplateContentError {
    /// Kind of error that occurred.
    pub kind: UpdateApprovalRuleTemplateContentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateApprovalRuleTemplateContent` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApprovalRuleTemplateContentErrorKind {
    /// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
    ApprovalRuleTemplateContentRequiredException(
        crate::error::ApprovalRuleTemplateContentRequiredException,
    ),
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The content of the approval rule template is not valid.</p>
    InvalidApprovalRuleTemplateContentException(
        crate::error::InvalidApprovalRuleTemplateContentException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The SHA-256 hash signature for the rule content is not valid.</p>
    InvalidRuleContentSha256Exception(crate::error::InvalidRuleContentSha256Exception),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApprovalRuleTemplateContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateContentException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidRuleContentSha256Exception(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateApprovalRuleTemplateContentError {
    fn code(&self) -> Option<&str> {
        UpdateApprovalRuleTemplateContentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApprovalRuleTemplateContentError {
    /// Creates a new `UpdateApprovalRuleTemplateContentError`.
    pub fn new(
        kind: UpdateApprovalRuleTemplateContentErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateApprovalRuleTemplateContentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApprovalRuleTemplateContentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateApprovalRuleTemplateContentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApprovalRuleTemplateContentErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateContentRequiredException`.
    pub fn is_approval_rule_template_content_required_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateDoesNotExistException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateNameRequiredException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateContentException`.
    pub fn is_invalid_approval_rule_template_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateContentException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentErrorKind::InvalidRuleContentSha256Exception`.
    pub fn is_invalid_rule_content_sha256_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidRuleContentSha256Exception(_)
        )
    }
}
impl std::error::Error for UpdateApprovalRuleTemplateContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateContentRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateContentException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::InvalidRuleContentSha256Exception(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateContentErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `UpdateApprovalRuleTemplateDescription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApprovalRuleTemplateDescriptionError {
    /// Kind of error that occurred.
    pub kind: UpdateApprovalRuleTemplateDescriptionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateApprovalRuleTemplateDescription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApprovalRuleTemplateDescriptionErrorKind {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateDescriptionException(
        crate::error::InvalidApprovalRuleTemplateDescriptionException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApprovalRuleTemplateDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateDescriptionException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateApprovalRuleTemplateDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdateApprovalRuleTemplateDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApprovalRuleTemplateDescriptionError {
    /// Creates a new `UpdateApprovalRuleTemplateDescriptionError`.
    pub fn new(
        kind: UpdateApprovalRuleTemplateDescriptionErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateApprovalRuleTemplateDescriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApprovalRuleTemplateDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateApprovalRuleTemplateDescriptionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApprovalRuleTemplateDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateDescriptionException`.
    pub fn is_invalid_approval_rule_template_description_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateDescriptionException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(&self.kind, UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateNameException(_))
    }
}
impl std::error::Error for UpdateApprovalRuleTemplateDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateDescriptionException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateDescriptionErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `UpdateApprovalRuleTemplateName` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateApprovalRuleTemplateNameError {
    /// Kind of error that occurred.
    pub kind: UpdateApprovalRuleTemplateNameErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateApprovalRuleTemplateName` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApprovalRuleTemplateNameErrorKind {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>You cannot create an approval rule template with that name because a template with that name already exists in this AWS Region for your AWS account. Approval rule template names must be unique.</p>
    ApprovalRuleTemplateNameAlreadyExistsException(
        crate::error::ApprovalRuleTemplateNameAlreadyExistsException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateApprovalRuleTemplateNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            _inner.fmt(f)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateApprovalRuleTemplateNameError {
    fn code(&self) -> Option<&str> {
        UpdateApprovalRuleTemplateNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApprovalRuleTemplateNameError {
    /// Creates a new `UpdateApprovalRuleTemplateNameError`.
    pub fn new(
        kind: UpdateApprovalRuleTemplateNameErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateApprovalRuleTemplateNameError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateApprovalRuleTemplateNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateApprovalRuleTemplateNameError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateApprovalRuleTemplateNameErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameAlreadyExistsException`.
    pub fn is_approval_rule_template_name_already_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateNameErrorKind::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateApprovalRuleTemplateNameErrorKind::InvalidApprovalRuleTemplateNameException(_)
        )
    }
}
impl std::error::Error for UpdateApprovalRuleTemplateNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameAlreadyExistsException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::InvalidApprovalRuleTemplateNameException(_inner) =>
            Some(_inner)
            ,
            UpdateApprovalRuleTemplateNameErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `UpdateComment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateCommentError {
    /// Kind of error that occurred.
    pub kind: UpdateCommentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateComment` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCommentErrorKind {
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>You cannot modify or delete this comment. Only comment authors can modify or delete their comments.</p>
    CommentNotCreatedByCallerException(crate::error::CommentNotCreatedByCallerException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateCommentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateCommentErrorKind::CommentContentRequiredException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::CommentContentSizeLimitExceededException(_inner) => {
                _inner.fmt(f)
            }
            UpdateCommentErrorKind::CommentDeletedException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::CommentIdRequiredException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::CommentNotCreatedByCallerException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::InvalidCommentIdException(_inner) => _inner.fmt(f),
            UpdateCommentErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCommentError {
    fn code(&self) -> Option<&str> {
        UpdateCommentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCommentError {
    /// Creates a new `UpdateCommentError`.
    pub fn new(kind: UpdateCommentErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateCommentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateCommentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateCommentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateCommentErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateCommentErrorKind::CommentContentRequiredException`.
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCommentErrorKind::CommentContentSizeLimitExceededException`.
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentContentSizeLimitExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCommentErrorKind::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentDeletedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCommentErrorKind::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCommentErrorKind::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCommentErrorKind::CommentNotCreatedByCallerException`.
    pub fn is_comment_not_created_by_caller_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::CommentNotCreatedByCallerException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateCommentErrorKind::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateCommentErrorKind::InvalidCommentIdException(_)
        )
    }
}
impl std::error::Error for UpdateCommentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateCommentErrorKind::CommentContentRequiredException(_inner) => Some(_inner),
            UpdateCommentErrorKind::CommentContentSizeLimitExceededException(_inner) => {
                Some(_inner)
            }
            UpdateCommentErrorKind::CommentDeletedException(_inner) => Some(_inner),
            UpdateCommentErrorKind::CommentDoesNotExistException(_inner) => Some(_inner),
            UpdateCommentErrorKind::CommentIdRequiredException(_inner) => Some(_inner),
            UpdateCommentErrorKind::CommentNotCreatedByCallerException(_inner) => Some(_inner),
            UpdateCommentErrorKind::InvalidCommentIdException(_inner) => Some(_inner),
            UpdateCommentErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateDefaultBranch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateDefaultBranchError {
    /// Kind of error that occurred.
    pub kind: UpdateDefaultBranchErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateDefaultBranch` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDefaultBranchErrorKind {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateDefaultBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateDefaultBranchErrorKind::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::BranchNameRequiredException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDefaultBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDefaultBranchErrorKind::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateDefaultBranchErrorKind::InvalidBranchNameException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            UpdateDefaultBranchErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDefaultBranchError {
    fn code(&self) -> Option<&str> {
        UpdateDefaultBranchError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDefaultBranchError {
    /// Creates a new `UpdateDefaultBranchError`.
    pub fn new(kind: UpdateDefaultBranchErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateDefaultBranchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateDefaultBranchErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateDefaultBranchError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateDefaultBranchErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::BranchDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::BranchNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::InvalidBranchNameException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateDefaultBranchErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for UpdateDefaultBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateDefaultBranchErrorKind::BranchDoesNotExistException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::BranchNameRequiredException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            UpdateDefaultBranchErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateDefaultBranchErrorKind::EncryptionKeyDisabledException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::InvalidBranchNameException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            UpdateDefaultBranchErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdatePullRequestApprovalRuleContent` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestApprovalRuleContentError {
    /// Kind of error that occurred.
    pub kind: UpdatePullRequestApprovalRuleContentErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdatePullRequestApprovalRuleContent` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestApprovalRuleContentErrorKind {
    /// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
    ApprovalRuleContentRequiredException(crate::error::ApprovalRuleContentRequiredException),
    /// <p>The specified approval rule does not exist.</p>
    ApprovalRuleDoesNotExistException(crate::error::ApprovalRuleDoesNotExistException),
    /// <p>An approval rule name is required, but was not specified.</p>
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    /// <p>The approval rule cannot be modified for the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
    CannotModifyApprovalRuleFromTemplateException(
        crate::error::CannotModifyApprovalRuleFromTemplateException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The content for the approval rule is not valid.</p>
    InvalidApprovalRuleContentException(crate::error::InvalidApprovalRuleContentException),
    /// <p>The name for the approval rule is not valid.</p>
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The SHA-256 hash signature for the rule content is not valid.</p>
    InvalidRuleContentSha256Exception(crate::error::InvalidRuleContentSha256Exception),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestApprovalRuleContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleContentRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::CannotModifyApprovalRuleFromTemplateException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleContentException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleNameException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidRuleContentSha256Exception(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestApprovalRuleContentError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestApprovalRuleContentError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestApprovalRuleContentError {
    /// Creates a new `UpdatePullRequestApprovalRuleContentError`.
    pub fn new(
        kind: UpdatePullRequestApprovalRuleContentErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdatePullRequestApprovalRuleContentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestApprovalRuleContentErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdatePullRequestApprovalRuleContentError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestApprovalRuleContentErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleContentRequiredException`.
    pub fn is_approval_rule_content_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleContentRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleDoesNotExistException`.
    pub fn is_approval_rule_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleNameRequiredException`.
    pub fn is_approval_rule_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleNameRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::CannotModifyApprovalRuleFromTemplateException`.
    pub fn is_cannot_modify_approval_rule_from_template_exception(&self) -> bool {
        matches!(&self.kind, UpdatePullRequestApprovalRuleContentErrorKind::CannotModifyApprovalRuleFromTemplateException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionIntegrityChecksFailedException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleContentException`.
    pub fn is_invalid_approval_rule_content_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleContentException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleNameException`.
    pub fn is_invalid_approval_rule_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleNameException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::InvalidRuleContentSha256Exception`.
    pub fn is_invalid_rule_content_sha256_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidRuleContentSha256Exception(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestApprovalRuleContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleContentRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleNameRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::CannotModifyApprovalRuleFromTemplateException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleContentException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleNameException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::InvalidRuleContentSha256Exception(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalRuleContentErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `UpdatePullRequestApprovalState` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestApprovalStateError {
    /// Kind of error that occurred.
    pub kind: UpdatePullRequestApprovalStateErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdatePullRequestApprovalState` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestApprovalStateErrorKind {
    /// <p>An approval state is required, but was not specified.</p>
    ApprovalStateRequiredException(crate::error::ApprovalStateRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The state for the approval is not valid. Valid values include APPROVE and REVOKE. </p>
    InvalidApprovalStateException(crate::error::InvalidApprovalStateException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The number of approvals required for the approval rule exceeds the maximum number allowed.</p>
    MaximumNumberOfApprovalsExceededException(
        crate::error::MaximumNumberOfApprovalsExceededException,
    ),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull request that you created.</p>
    PullRequestCannotBeApprovedByAuthorException(
        crate::error::PullRequestCannotBeApprovedByAuthorException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestApprovalStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestApprovalStateErrorKind::ApprovalStateRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidApprovalStateException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidPullRequestIdException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidRevisionIdException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::MaximumNumberOfApprovalsExceededException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestAlreadyClosedException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestCannotBeApprovedByAuthorException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::RevisionIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::RevisionNotCurrentException(_inner) =>
            _inner.fmt(f)
            ,
            UpdatePullRequestApprovalStateErrorKind::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestApprovalStateError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestApprovalStateError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestApprovalStateError {
    /// Creates a new `UpdatePullRequestApprovalStateError`.
    pub fn new(
        kind: UpdatePullRequestApprovalStateErrorKind,
        meta: aws_smithy_types::Error,
    ) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdatePullRequestApprovalStateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestApprovalStateErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdatePullRequestApprovalStateError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestApprovalStateErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::ApprovalStateRequiredException`.
    pub fn is_approval_state_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::ApprovalStateRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::InvalidApprovalStateException`.
    pub fn is_invalid_approval_state_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::InvalidApprovalStateException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::InvalidRevisionIdException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::MaximumNumberOfApprovalsExceededException`.
    pub fn is_maximum_number_of_approvals_exceeded_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::MaximumNumberOfApprovalsExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::PullRequestCannotBeApprovedByAuthorException`.
    pub fn is_pull_request_cannot_be_approved_by_author_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::PullRequestCannotBeApprovedByAuthorException(
                _
            )
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::RevisionIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateErrorKind::RevisionNotCurrentException`.
    pub fn is_revision_not_current_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestApprovalStateErrorKind::RevisionNotCurrentException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestApprovalStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestApprovalStateErrorKind::ApprovalStateRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidApprovalStateException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidPullRequestIdException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::InvalidRevisionIdException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::MaximumNumberOfApprovalsExceededException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestAlreadyClosedException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestCannotBeApprovedByAuthorException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::PullRequestIdRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::RevisionIdRequiredException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::RevisionNotCurrentException(_inner) =>
            Some(_inner)
            ,
            UpdatePullRequestApprovalStateErrorKind::Unhandled(_inner) => {
                Some(_inner.as_ref())
            }
        }
    }
}

/// Error type for the `UpdatePullRequestDescription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestDescriptionError {
    /// Kind of error that occurred.
    pub kind: UpdatePullRequestDescriptionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdatePullRequestDescription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestDescriptionErrorKind {
    /// <p>The pull request description is not valid. Descriptions cannot be more than 1,000 characters.</p>
    InvalidDescriptionException(crate::error::InvalidDescriptionException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestDescriptionErrorKind::InvalidDescriptionException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestAlreadyClosedException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestDescriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestDescriptionError {
    /// Creates a new `UpdatePullRequestDescriptionError`.
    pub fn new(kind: UpdatePullRequestDescriptionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdatePullRequestDescriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdatePullRequestDescriptionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionErrorKind::InvalidDescriptionException`.
    pub fn is_invalid_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::InvalidDescriptionException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestDescriptionErrorKind::PullRequestIdRequiredException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestDescriptionErrorKind::InvalidDescriptionException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::InvalidPullRequestIdException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestAlreadyClosedException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestDescriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdatePullRequestStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestStatusError {
    /// Kind of error that occurred.
    pub kind: UpdatePullRequestStatusErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdatePullRequestStatus` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestStatusErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
    InvalidPullRequestStatusException(crate::error::InvalidPullRequestStatusException),
    /// <p>The pull request status update is not valid. The only valid update is from <code>OPEN</code> to <code>CLOSED</code>.</p>
    InvalidPullRequestStatusUpdateException(crate::error::InvalidPullRequestStatusUpdateException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A pull request status is required, but none was provided.</p>
    PullRequestStatusRequiredException(crate::error::PullRequestStatusRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestStatusErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestIdException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusUpdateException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::PullRequestStatusRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestStatusErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestStatusError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestStatusError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestStatusError {
    /// Creates a new `UpdatePullRequestStatusError`.
    pub fn new(kind: UpdatePullRequestStatusErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdatePullRequestStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestStatusErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdatePullRequestStatusError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestStatusErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusException`.
    pub fn is_invalid_pull_request_status_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusUpdateException`.
    pub fn is_invalid_pull_request_status_update_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusUpdateException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusErrorKind::PullRequestStatusRequiredException`.
    pub fn is_pull_request_status_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestStatusErrorKind::PullRequestStatusRequiredException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestStatusErrorKind::EncryptionIntegrityChecksFailedException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestIdException(_inner) => Some(_inner),
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusUpdateException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::PullRequestIdRequiredException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::PullRequestStatusRequiredException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestStatusErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdatePullRequestTitle` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdatePullRequestTitleError {
    /// Kind of error that occurred.
    pub kind: UpdatePullRequestTitleErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdatePullRequestTitle` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestTitleErrorKind {
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
    InvalidTitleException(crate::error::InvalidTitleException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A pull request title is required. It cannot be empty or null.</p>
    TitleRequiredException(crate::error::TitleRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdatePullRequestTitleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdatePullRequestTitleErrorKind::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            UpdatePullRequestTitleErrorKind::InvalidTitleException(_inner) => _inner.fmt(f),
            UpdatePullRequestTitleErrorKind::PullRequestAlreadyClosedException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestTitleErrorKind::PullRequestDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestTitleErrorKind::PullRequestIdRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdatePullRequestTitleErrorKind::TitleRequiredException(_inner) => _inner.fmt(f),
            UpdatePullRequestTitleErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestTitleError {
    fn code(&self) -> Option<&str> {
        UpdatePullRequestTitleError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestTitleError {
    /// Creates a new `UpdatePullRequestTitleError`.
    pub fn new(kind: UpdatePullRequestTitleErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdatePullRequestTitleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdatePullRequestTitleErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdatePullRequestTitleError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdatePullRequestTitleErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleErrorKind::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::InvalidPullRequestIdException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleErrorKind::InvalidTitleException`.
    pub fn is_invalid_title_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::InvalidTitleException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleErrorKind::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::PullRequestAlreadyClosedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleErrorKind::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::PullRequestDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleErrorKind::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::PullRequestIdRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleErrorKind::TitleRequiredException`.
    pub fn is_title_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdatePullRequestTitleErrorKind::TitleRequiredException(_)
        )
    }
}
impl std::error::Error for UpdatePullRequestTitleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdatePullRequestTitleErrorKind::InvalidPullRequestIdException(_inner) => Some(_inner),
            UpdatePullRequestTitleErrorKind::InvalidTitleException(_inner) => Some(_inner),
            UpdatePullRequestTitleErrorKind::PullRequestAlreadyClosedException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestTitleErrorKind::PullRequestDoesNotExistException(_inner) => {
                Some(_inner)
            }
            UpdatePullRequestTitleErrorKind::PullRequestIdRequiredException(_inner) => Some(_inner),
            UpdatePullRequestTitleErrorKind::TitleRequiredException(_inner) => Some(_inner),
            UpdatePullRequestTitleErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateRepositoryDescription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRepositoryDescriptionError {
    /// Kind of error that occurred.
    pub kind: UpdateRepositoryDescriptionErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateRepositoryDescription` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRepositoryDescriptionErrorKind {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified repository description is not valid.</p>
    InvalidRepositoryDescriptionException(crate::error::InvalidRepositoryDescriptionException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRepositoryDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRepositoryDescriptionErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => _inner.fmt(f),
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyDisabledException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyNotFoundException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyUnavailableException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryDescriptionException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryNameException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::RepositoryDoesNotExistException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::RepositoryNameRequiredException(_inner) => {
                _inner.fmt(f)
            }
            UpdateRepositoryDescriptionErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRepositoryDescriptionError {
    fn code(&self) -> Option<&str> {
        UpdateRepositoryDescriptionError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRepositoryDescriptionError {
    /// Creates a new `UpdateRepositoryDescriptionError`.
    pub fn new(kind: UpdateRepositoryDescriptionErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateRepositoryDescriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRepositoryDescriptionErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateRepositoryDescriptionError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRepositoryDescriptionErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionErrorKind::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionIntegrityChecksFailedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionErrorKind::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyAccessDeniedException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionErrorKind::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyDisabledException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionErrorKind::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyNotFoundException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionErrorKind::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyUnavailableException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionErrorKind::InvalidRepositoryDescriptionException`.
    pub fn is_invalid_repository_description_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryDescriptionException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryDescriptionErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for UpdateRepositoryDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRepositoryDescriptionErrorKind::EncryptionIntegrityChecksFailedException(
                _inner,
            ) => Some(_inner),
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyAccessDeniedException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyDisabledException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyNotFoundException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::EncryptionKeyUnavailableException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryDescriptionException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::InvalidRepositoryNameException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::RepositoryDoesNotExistException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::RepositoryNameRequiredException(_inner) => {
                Some(_inner)
            }
            UpdateRepositoryDescriptionErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// Error type for the `UpdateRepositoryName` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub struct UpdateRepositoryNameError {
    /// Kind of error that occurred.
    pub kind: UpdateRepositoryNameErrorKind,
    /// Additional metadata about the error, including error code, message, and request ID.
    pub(crate) meta: aws_smithy_types::Error,
}
/// Types of errors that can occur for the `UpdateRepositoryName` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRepositoryNameErrorKind {
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>The specified repository name already exists.</p>
    RepositoryNameExistsException(crate::error::RepositoryNameExistsException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error, e.g. invalid JSON returned by the service or an unknown error code
    Unhandled(Box<dyn std::error::Error + Send + Sync + 'static>),
}
impl std::fmt::Display for UpdateRepositoryNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.kind {
            UpdateRepositoryNameErrorKind::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            UpdateRepositoryNameErrorKind::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            UpdateRepositoryNameErrorKind::RepositoryNameExistsException(_inner) => _inner.fmt(f),
            UpdateRepositoryNameErrorKind::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            UpdateRepositoryNameErrorKind::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRepositoryNameError {
    fn code(&self) -> Option<&str> {
        UpdateRepositoryNameError::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRepositoryNameError {
    /// Creates a new `UpdateRepositoryNameError`.
    pub fn new(kind: UpdateRepositoryNameErrorKind, meta: aws_smithy_types::Error) -> Self {
        Self { kind, meta }
    }

    /// Creates the `UpdateRepositoryNameError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self {
            kind: UpdateRepositoryNameErrorKind::Unhandled(err.into()),
            meta: Default::default(),
        }
    }

    /// Creates the `UpdateRepositoryNameError::Unhandled` variant from a `aws_smithy_types::Error`.
    pub fn generic(err: aws_smithy_types::Error) -> Self {
        Self {
            meta: err.clone(),
            kind: UpdateRepositoryNameErrorKind::Unhandled(err.into()),
        }
    }

    /// Returns the error message if one is available.
    pub fn message(&self) -> Option<&str> {
        self.meta.message()
    }

    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    pub fn meta(&self) -> &aws_smithy_types::Error {
        &self.meta
    }

    /// Returns the request ID if it's available.
    pub fn request_id(&self) -> Option<&str> {
        self.meta.request_id()
    }

    /// Returns the error code if it's available.
    pub fn code(&self) -> Option<&str> {
        self.meta.code()
    }
    /// Returns `true` if the error kind is `UpdateRepositoryNameErrorKind::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryNameErrorKind::InvalidRepositoryNameException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryNameErrorKind::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryNameErrorKind::RepositoryDoesNotExistException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryNameErrorKind::RepositoryNameExistsException`.
    pub fn is_repository_name_exists_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryNameErrorKind::RepositoryNameExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateRepositoryNameErrorKind::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(
            &self.kind,
            UpdateRepositoryNameErrorKind::RepositoryNameRequiredException(_)
        )
    }
}
impl std::error::Error for UpdateRepositoryNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match &self.kind {
            UpdateRepositoryNameErrorKind::InvalidRepositoryNameException(_inner) => Some(_inner),
            UpdateRepositoryNameErrorKind::RepositoryDoesNotExistException(_inner) => Some(_inner),
            UpdateRepositoryNameErrorKind::RepositoryNameExistsException(_inner) => Some(_inner),
            UpdateRepositoryNameErrorKind::RepositoryNameRequiredException(_inner) => Some(_inner),
            UpdateRepositoryNameErrorKind::Unhandled(_inner) => Some(_inner.as_ref()),
        }
    }
}

/// <p>A repository name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNameRequiredException")?;
        if let Some(inner_1) = &self.message {
            write!(f, ": {}", inner_1)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNameRequiredException {}
/// See [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException)
pub mod repository_name_required_exception {
    /// A builder for [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException)
        pub fn build(self) -> crate::error::RepositoryNameRequiredException {
            crate::error::RepositoryNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryNameRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException)
    pub fn builder() -> crate::error::repository_name_required_exception::Builder {
        crate::error::repository_name_required_exception::Builder::default()
    }
}

/// <p>The specified repository name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryNameExistsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryNameExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryNameExistsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNameExistsException")?;
        if let Some(inner_2) = &self.message {
            write!(f, ": {}", inner_2)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNameExistsException {}
/// See [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException)
pub mod repository_name_exists_exception {
    /// A builder for [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException)
        pub fn build(self) -> crate::error::RepositoryNameExistsException {
            crate::error::RepositoryNameExistsException {
                message: self.message,
            }
        }
    }
}
impl RepositoryNameExistsException {
    /// Creates a new builder-style object to manufacture [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException)
    pub fn builder() -> crate::error::repository_name_exists_exception::Builder {
        crate::error::repository_name_exists_exception::Builder::default()
    }
}

/// <p>The specified repository does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryDoesNotExistException")?;
        if let Some(inner_3) = &self.message {
            write!(f, ": {}", inner_3)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryDoesNotExistException {}
/// See [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException)
pub mod repository_does_not_exist_exception {
    /// A builder for [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException)
        pub fn build(self) -> crate::error::RepositoryDoesNotExistException {
            crate::error::RepositoryDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl RepositoryDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException)
    pub fn builder() -> crate::error::repository_does_not_exist_exception::Builder {
        crate::error::repository_does_not_exist_exception::Builder::default()
    }
}

/// <p>A specified repository name is not valid.</p> <note>
/// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryNameException")?;
        if let Some(inner_4) = &self.message {
            write!(f, ": {}", inner_4)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryNameException {}
/// See [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException)
pub mod invalid_repository_name_exception {
    /// A builder for [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException)
        pub fn build(self) -> crate::error::InvalidRepositoryNameException {
            crate::error::InvalidRepositoryNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryNameException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException)
    pub fn builder() -> crate::error::invalid_repository_name_exception::Builder {
        crate::error::invalid_repository_name_exception::Builder::default()
    }
}

/// <p>The specified repository description is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryDescriptionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryDescriptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryDescriptionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryDescriptionException")?;
        if let Some(inner_5) = &self.message {
            write!(f, ": {}", inner_5)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryDescriptionException {}
/// See [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException)
pub mod invalid_repository_description_exception {
    /// A builder for [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException)
        pub fn build(self) -> crate::error::InvalidRepositoryDescriptionException {
            crate::error::InvalidRepositoryDescriptionException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryDescriptionException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException)
    pub fn builder() -> crate::error::invalid_repository_description_exception::Builder {
        crate::error::invalid_repository_description_exception::Builder::default()
    }
}

/// <p>The encryption key is not available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionKeyUnavailableException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionKeyUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionKeyUnavailableException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionKeyUnavailableException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyUnavailableException")?;
        if let Some(inner_6) = &self.message {
            write!(f, ": {}", inner_6)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyUnavailableException {}
/// See [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException)
pub mod encryption_key_unavailable_exception {
    /// A builder for [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException)
        pub fn build(self) -> crate::error::EncryptionKeyUnavailableException {
            crate::error::EncryptionKeyUnavailableException {
                message: self.message,
            }
        }
    }
}
impl EncryptionKeyUnavailableException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException)
    pub fn builder() -> crate::error::encryption_key_unavailable_exception::Builder {
        crate::error::encryption_key_unavailable_exception::Builder::default()
    }
}

/// <p>No encryption key was found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionKeyNotFoundException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionKeyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionKeyNotFoundException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionKeyNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyNotFoundException")?;
        if let Some(inner_7) = &self.message {
            write!(f, ": {}", inner_7)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyNotFoundException {}
/// See [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException)
pub mod encryption_key_not_found_exception {
    /// A builder for [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException)
        pub fn build(self) -> crate::error::EncryptionKeyNotFoundException {
            crate::error::EncryptionKeyNotFoundException {
                message: self.message,
            }
        }
    }
}
impl EncryptionKeyNotFoundException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException)
    pub fn builder() -> crate::error::encryption_key_not_found_exception::Builder {
        crate::error::encryption_key_not_found_exception::Builder::default()
    }
}

/// <p>The encryption key is disabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionKeyDisabledException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionKeyDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionKeyDisabledException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionKeyDisabledException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyDisabledException")?;
        if let Some(inner_8) = &self.message {
            write!(f, ": {}", inner_8)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyDisabledException {}
/// See [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException)
pub mod encryption_key_disabled_exception {
    /// A builder for [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException)
        pub fn build(self) -> crate::error::EncryptionKeyDisabledException {
            crate::error::EncryptionKeyDisabledException {
                message: self.message,
            }
        }
    }
}
impl EncryptionKeyDisabledException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException)
    pub fn builder() -> crate::error::encryption_key_disabled_exception::Builder {
        crate::error::encryption_key_disabled_exception::Builder::default()
    }
}

/// <p>An encryption key could not be accessed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionKeyAccessDeniedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionKeyAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionKeyAccessDeniedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionKeyAccessDeniedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyAccessDeniedException")?;
        if let Some(inner_9) = &self.message {
            write!(f, ": {}", inner_9)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyAccessDeniedException {}
/// See [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException)
pub mod encryption_key_access_denied_exception {
    /// A builder for [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException)
        pub fn build(self) -> crate::error::EncryptionKeyAccessDeniedException {
            crate::error::EncryptionKeyAccessDeniedException {
                message: self.message,
            }
        }
    }
}
impl EncryptionKeyAccessDeniedException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException)
    pub fn builder() -> crate::error::encryption_key_access_denied_exception::Builder {
        crate::error::encryption_key_access_denied_exception::Builder::default()
    }
}

/// <p>An encryption integrity check failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct EncryptionIntegrityChecksFailedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for EncryptionIntegrityChecksFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("EncryptionIntegrityChecksFailedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl EncryptionIntegrityChecksFailedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionIntegrityChecksFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionIntegrityChecksFailedException")?;
        if let Some(inner_10) = &self.message {
            write!(f, ": {}", inner_10)?;
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionIntegrityChecksFailedException {}
/// See [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException)
pub mod encryption_integrity_checks_failed_exception {
    /// A builder for [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException)
        pub fn build(self) -> crate::error::EncryptionIntegrityChecksFailedException {
            crate::error::EncryptionIntegrityChecksFailedException {
                message: self.message,
            }
        }
    }
}
impl EncryptionIntegrityChecksFailedException {
    /// Creates a new builder-style object to manufacture [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException)
    pub fn builder() -> crate::error::encryption_integrity_checks_failed_exception::Builder {
        crate::error::encryption_integrity_checks_failed_exception::Builder::default()
    }
}

/// <p>A pull request title is required. It cannot be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TitleRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TitleRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TitleRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TitleRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TitleRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TitleRequiredException")?;
        if let Some(inner_11) = &self.message {
            write!(f, ": {}", inner_11)?;
        }
        Ok(())
    }
}
impl std::error::Error for TitleRequiredException {}
/// See [`TitleRequiredException`](crate::error::TitleRequiredException)
pub mod title_required_exception {
    /// A builder for [`TitleRequiredException`](crate::error::TitleRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TitleRequiredException`](crate::error::TitleRequiredException)
        pub fn build(self) -> crate::error::TitleRequiredException {
            crate::error::TitleRequiredException {
                message: self.message,
            }
        }
    }
}
impl TitleRequiredException {
    /// Creates a new builder-style object to manufacture [`TitleRequiredException`](crate::error::TitleRequiredException)
    pub fn builder() -> crate::error::title_required_exception::Builder {
        crate::error::title_required_exception::Builder::default()
    }
}

/// <p>A pull request ID is required, but none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestIdRequiredException")?;
        if let Some(inner_12) = &self.message {
            write!(f, ": {}", inner_12)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestIdRequiredException {}
/// See [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException)
pub mod pull_request_id_required_exception {
    /// A builder for [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException)
        pub fn build(self) -> crate::error::PullRequestIdRequiredException {
            crate::error::PullRequestIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl PullRequestIdRequiredException {
    /// Creates a new builder-style object to manufacture [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException)
    pub fn builder() -> crate::error::pull_request_id_required_exception::Builder {
        crate::error::pull_request_id_required_exception::Builder::default()
    }
}

/// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestDoesNotExistException")?;
        if let Some(inner_13) = &self.message {
            write!(f, ": {}", inner_13)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestDoesNotExistException {}
/// See [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException)
pub mod pull_request_does_not_exist_exception {
    /// A builder for [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException)
        pub fn build(self) -> crate::error::PullRequestDoesNotExistException {
            crate::error::PullRequestDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl PullRequestDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException)
    pub fn builder() -> crate::error::pull_request_does_not_exist_exception::Builder {
        crate::error::pull_request_does_not_exist_exception::Builder::default()
    }
}

/// <p>The pull request status cannot be updated because it is already closed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestAlreadyClosedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestAlreadyClosedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestAlreadyClosedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestAlreadyClosedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestAlreadyClosedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestAlreadyClosedException")?;
        if let Some(inner_14) = &self.message {
            write!(f, ": {}", inner_14)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestAlreadyClosedException {}
/// See [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException)
pub mod pull_request_already_closed_exception {
    /// A builder for [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException)
        pub fn build(self) -> crate::error::PullRequestAlreadyClosedException {
            crate::error::PullRequestAlreadyClosedException {
                message: self.message,
            }
        }
    }
}
impl PullRequestAlreadyClosedException {
    /// Creates a new builder-style object to manufacture [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException)
    pub fn builder() -> crate::error::pull_request_already_closed_exception::Builder {
        crate::error::pull_request_already_closed_exception::Builder::default()
    }
}

/// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTitleException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTitleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTitleException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTitleException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTitleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTitleException")?;
        if let Some(inner_15) = &self.message {
            write!(f, ": {}", inner_15)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTitleException {}
/// See [`InvalidTitleException`](crate::error::InvalidTitleException)
pub mod invalid_title_exception {
    /// A builder for [`InvalidTitleException`](crate::error::InvalidTitleException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTitleException`](crate::error::InvalidTitleException)
        pub fn build(self) -> crate::error::InvalidTitleException {
            crate::error::InvalidTitleException {
                message: self.message,
            }
        }
    }
}
impl InvalidTitleException {
    /// Creates a new builder-style object to manufacture [`InvalidTitleException`](crate::error::InvalidTitleException)
    pub fn builder() -> crate::error::invalid_title_exception::Builder {
        crate::error::invalid_title_exception::Builder::default()
    }
}

/// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPullRequestIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPullRequestIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPullRequestIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPullRequestIdException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestIdException")?;
        if let Some(inner_16) = &self.message {
            write!(f, ": {}", inner_16)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestIdException {}
/// See [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException)
pub mod invalid_pull_request_id_exception {
    /// A builder for [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException)
        pub fn build(self) -> crate::error::InvalidPullRequestIdException {
            crate::error::InvalidPullRequestIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidPullRequestIdException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException)
    pub fn builder() -> crate::error::invalid_pull_request_id_exception::Builder {
        crate::error::invalid_pull_request_id_exception::Builder::default()
    }
}

/// <p>A pull request status is required, but none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestStatusRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestStatusRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestStatusRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestStatusRequiredException")?;
        if let Some(inner_17) = &self.message {
            write!(f, ": {}", inner_17)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestStatusRequiredException {}
/// See [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException)
pub mod pull_request_status_required_exception {
    /// A builder for [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException)
        pub fn build(self) -> crate::error::PullRequestStatusRequiredException {
            crate::error::PullRequestStatusRequiredException {
                message: self.message,
            }
        }
    }
}
impl PullRequestStatusRequiredException {
    /// Creates a new builder-style object to manufacture [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException)
    pub fn builder() -> crate::error::pull_request_status_required_exception::Builder {
        crate::error::pull_request_status_required_exception::Builder::default()
    }
}

/// <p>The pull request status update is not valid. The only valid update is from <code>OPEN</code> to <code>CLOSED</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPullRequestStatusUpdateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPullRequestStatusUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPullRequestStatusUpdateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPullRequestStatusUpdateException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestStatusUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestStatusUpdateException")?;
        if let Some(inner_18) = &self.message {
            write!(f, ": {}", inner_18)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestStatusUpdateException {}
/// See [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException)
pub mod invalid_pull_request_status_update_exception {
    /// A builder for [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException)
        pub fn build(self) -> crate::error::InvalidPullRequestStatusUpdateException {
            crate::error::InvalidPullRequestStatusUpdateException {
                message: self.message,
            }
        }
    }
}
impl InvalidPullRequestStatusUpdateException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException)
    pub fn builder() -> crate::error::invalid_pull_request_status_update_exception::Builder {
        crate::error::invalid_pull_request_status_update_exception::Builder::default()
    }
}

/// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPullRequestStatusException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPullRequestStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPullRequestStatusException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPullRequestStatusException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestStatusException")?;
        if let Some(inner_19) = &self.message {
            write!(f, ": {}", inner_19)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestStatusException {}
/// See [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException)
pub mod invalid_pull_request_status_exception {
    /// A builder for [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException)
        pub fn build(self) -> crate::error::InvalidPullRequestStatusException {
            crate::error::InvalidPullRequestStatusException {
                message: self.message,
            }
        }
    }
}
impl InvalidPullRequestStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException)
    pub fn builder() -> crate::error::invalid_pull_request_status_exception::Builder {
        crate::error::invalid_pull_request_status_exception::Builder::default()
    }
}

/// <p>The pull request description is not valid. Descriptions cannot be more than 1,000 characters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDescriptionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDescriptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDescriptionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDescriptionException")?;
        if let Some(inner_20) = &self.message {
            write!(f, ": {}", inner_20)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDescriptionException {}
/// See [`InvalidDescriptionException`](crate::error::InvalidDescriptionException)
pub mod invalid_description_exception {
    /// A builder for [`InvalidDescriptionException`](crate::error::InvalidDescriptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDescriptionException`](crate::error::InvalidDescriptionException)
        pub fn build(self) -> crate::error::InvalidDescriptionException {
            crate::error::InvalidDescriptionException {
                message: self.message,
            }
        }
    }
}
impl InvalidDescriptionException {
    /// Creates a new builder-style object to manufacture [`InvalidDescriptionException`](crate::error::InvalidDescriptionException)
    pub fn builder() -> crate::error::invalid_description_exception::Builder {
        crate::error::invalid_description_exception::Builder::default()
    }
}

/// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RevisionNotCurrentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RevisionNotCurrentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RevisionNotCurrentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RevisionNotCurrentException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RevisionNotCurrentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RevisionNotCurrentException")?;
        if let Some(inner_21) = &self.message {
            write!(f, ": {}", inner_21)?;
        }
        Ok(())
    }
}
impl std::error::Error for RevisionNotCurrentException {}
/// See [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException)
pub mod revision_not_current_exception {
    /// A builder for [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException)
        pub fn build(self) -> crate::error::RevisionNotCurrentException {
            crate::error::RevisionNotCurrentException {
                message: self.message,
            }
        }
    }
}
impl RevisionNotCurrentException {
    /// Creates a new builder-style object to manufacture [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException)
    pub fn builder() -> crate::error::revision_not_current_exception::Builder {
        crate::error::revision_not_current_exception::Builder::default()
    }
}

/// <p>A revision ID is required, but was not provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RevisionIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RevisionIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RevisionIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RevisionIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RevisionIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RevisionIdRequiredException")?;
        if let Some(inner_22) = &self.message {
            write!(f, ": {}", inner_22)?;
        }
        Ok(())
    }
}
impl std::error::Error for RevisionIdRequiredException {}
/// See [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException)
pub mod revision_id_required_exception {
    /// A builder for [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException)
        pub fn build(self) -> crate::error::RevisionIdRequiredException {
            crate::error::RevisionIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl RevisionIdRequiredException {
    /// Creates a new builder-style object to manufacture [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException)
    pub fn builder() -> crate::error::revision_id_required_exception::Builder {
        crate::error::revision_id_required_exception::Builder::default()
    }
}

/// <p>The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull request that you created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestCannotBeApprovedByAuthorException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestCannotBeApprovedByAuthorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestCannotBeApprovedByAuthorException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestCannotBeApprovedByAuthorException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestCannotBeApprovedByAuthorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestCannotBeApprovedByAuthorException")?;
        if let Some(inner_23) = &self.message {
            write!(f, ": {}", inner_23)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestCannotBeApprovedByAuthorException {}
/// See [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException)
pub mod pull_request_cannot_be_approved_by_author_exception {
    /// A builder for [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException)
        pub fn build(self) -> crate::error::PullRequestCannotBeApprovedByAuthorException {
            crate::error::PullRequestCannotBeApprovedByAuthorException {
                message: self.message,
            }
        }
    }
}
impl PullRequestCannotBeApprovedByAuthorException {
    /// Creates a new builder-style object to manufacture [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException)
    pub fn builder() -> crate::error::pull_request_cannot_be_approved_by_author_exception::Builder {
        crate::error::pull_request_cannot_be_approved_by_author_exception::Builder::default()
    }
}

/// <p>The number of approvals required for the approval rule exceeds the maximum number allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumNumberOfApprovalsExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumNumberOfApprovalsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumNumberOfApprovalsExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumNumberOfApprovalsExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumNumberOfApprovalsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumNumberOfApprovalsExceededException")?;
        if let Some(inner_24) = &self.message {
            write!(f, ": {}", inner_24)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumNumberOfApprovalsExceededException {}
/// See [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException)
pub mod maximum_number_of_approvals_exceeded_exception {
    /// A builder for [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException)
        pub fn build(self) -> crate::error::MaximumNumberOfApprovalsExceededException {
            crate::error::MaximumNumberOfApprovalsExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumNumberOfApprovalsExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException)
    pub fn builder() -> crate::error::maximum_number_of_approvals_exceeded_exception::Builder {
        crate::error::maximum_number_of_approvals_exceeded_exception::Builder::default()
    }
}

/// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRevisionIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRevisionIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRevisionIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRevisionIdException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRevisionIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRevisionIdException")?;
        if let Some(inner_25) = &self.message {
            write!(f, ": {}", inner_25)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRevisionIdException {}
/// See [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException)
pub mod invalid_revision_id_exception {
    /// A builder for [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException)
        pub fn build(self) -> crate::error::InvalidRevisionIdException {
            crate::error::InvalidRevisionIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidRevisionIdException {
    /// Creates a new builder-style object to manufacture [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException)
    pub fn builder() -> crate::error::invalid_revision_id_exception::Builder {
        crate::error::invalid_revision_id_exception::Builder::default()
    }
}

/// <p>The state for the approval is not valid. Valid values include APPROVE and REVOKE. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalStateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalStateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalStateException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalStateException")?;
        if let Some(inner_26) = &self.message {
            write!(f, ": {}", inner_26)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalStateException {}
/// See [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException)
pub mod invalid_approval_state_exception {
    /// A builder for [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException)
        pub fn build(self) -> crate::error::InvalidApprovalStateException {
            crate::error::InvalidApprovalStateException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalStateException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException)
    pub fn builder() -> crate::error::invalid_approval_state_exception::Builder {
        crate::error::invalid_approval_state_exception::Builder::default()
    }
}

/// <p>An approval state is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalStateRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalStateRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalStateRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalStateRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalStateRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalStateRequiredException")?;
        if let Some(inner_27) = &self.message {
            write!(f, ": {}", inner_27)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalStateRequiredException {}
/// See [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException)
pub mod approval_state_required_exception {
    /// A builder for [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException)
        pub fn build(self) -> crate::error::ApprovalStateRequiredException {
            crate::error::ApprovalStateRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalStateRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException)
    pub fn builder() -> crate::error::approval_state_required_exception::Builder {
        crate::error::approval_state_required_exception::Builder::default()
    }
}

/// <p>The SHA-256 hash signature for the rule content is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRuleContentSha256Exception {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRuleContentSha256Exception {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRuleContentSha256Exception");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRuleContentSha256Exception {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRuleContentSha256Exception {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRuleContentSha256Exception")?;
        if let Some(inner_28) = &self.message {
            write!(f, ": {}", inner_28)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRuleContentSha256Exception {}
/// See [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception)
pub mod invalid_rule_content_sha256_exception {
    /// A builder for [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception)
        pub fn build(self) -> crate::error::InvalidRuleContentSha256Exception {
            crate::error::InvalidRuleContentSha256Exception {
                message: self.message,
            }
        }
    }
}
impl InvalidRuleContentSha256Exception {
    /// Creates a new builder-style object to manufacture [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception)
    pub fn builder() -> crate::error::invalid_rule_content_sha256_exception::Builder {
        crate::error::invalid_rule_content_sha256_exception::Builder::default()
    }
}

/// <p>The name for the approval rule is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleNameException")?;
        if let Some(inner_29) = &self.message {
            write!(f, ": {}", inner_29)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleNameException {}
/// See [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException)
pub mod invalid_approval_rule_name_exception {
    /// A builder for [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleNameException {
            crate::error::InvalidApprovalRuleNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleNameException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException)
    pub fn builder() -> crate::error::invalid_approval_rule_name_exception::Builder {
        crate::error::invalid_approval_rule_name_exception::Builder::default()
    }
}

/// <p>The content for the approval rule is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleContentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleContentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleContentException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleContentException")?;
        if let Some(inner_30) = &self.message {
            write!(f, ": {}", inner_30)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleContentException {}
/// See [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException)
pub mod invalid_approval_rule_content_exception {
    /// A builder for [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleContentException {
            crate::error::InvalidApprovalRuleContentException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleContentException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException)
    pub fn builder() -> crate::error::invalid_approval_rule_content_exception::Builder {
        crate::error::invalid_approval_rule_content_exception::Builder::default()
    }
}

/// <p>The approval rule cannot be modified for the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CannotModifyApprovalRuleFromTemplateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CannotModifyApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CannotModifyApprovalRuleFromTemplateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CannotModifyApprovalRuleFromTemplateException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CannotModifyApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CannotModifyApprovalRuleFromTemplateException")?;
        if let Some(inner_31) = &self.message {
            write!(f, ": {}", inner_31)?;
        }
        Ok(())
    }
}
impl std::error::Error for CannotModifyApprovalRuleFromTemplateException {}
/// See [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException)
pub mod cannot_modify_approval_rule_from_template_exception {
    /// A builder for [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException)
        pub fn build(self) -> crate::error::CannotModifyApprovalRuleFromTemplateException {
            crate::error::CannotModifyApprovalRuleFromTemplateException {
                message: self.message,
            }
        }
    }
}
impl CannotModifyApprovalRuleFromTemplateException {
    /// Creates a new builder-style object to manufacture [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException)
    pub fn builder() -> crate::error::cannot_modify_approval_rule_from_template_exception::Builder {
        crate::error::cannot_modify_approval_rule_from_template_exception::Builder::default()
    }
}

/// <p>An approval rule name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleNameRequiredException")?;
        if let Some(inner_32) = &self.message {
            write!(f, ": {}", inner_32)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleNameRequiredException {}
/// See [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException)
pub mod approval_rule_name_required_exception {
    /// A builder for [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException)
        pub fn build(self) -> crate::error::ApprovalRuleNameRequiredException {
            crate::error::ApprovalRuleNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException)
    pub fn builder() -> crate::error::approval_rule_name_required_exception::Builder {
        crate::error::approval_rule_name_required_exception::Builder::default()
    }
}

/// <p>The specified approval rule does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleDoesNotExistException")?;
        if let Some(inner_33) = &self.message {
            write!(f, ": {}", inner_33)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleDoesNotExistException {}
/// See [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException)
pub mod approval_rule_does_not_exist_exception {
    /// A builder for [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException)
        pub fn build(self) -> crate::error::ApprovalRuleDoesNotExistException {
            crate::error::ApprovalRuleDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException)
    pub fn builder() -> crate::error::approval_rule_does_not_exist_exception::Builder {
        crate::error::approval_rule_does_not_exist_exception::Builder::default()
    }
}

/// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleContentRequiredException")?;
        if let Some(inner_34) = &self.message {
            write!(f, ": {}", inner_34)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleContentRequiredException {}
/// See [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException)
pub mod approval_rule_content_required_exception {
    /// A builder for [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException)
        pub fn build(self) -> crate::error::ApprovalRuleContentRequiredException {
            crate::error::ApprovalRuleContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleContentRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException)
    pub fn builder() -> crate::error::approval_rule_content_required_exception::Builder {
        crate::error::approval_rule_content_required_exception::Builder::default()
    }
}

/// <p>The specified reference name is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidBranchNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidBranchNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidBranchNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidBranchNameException")?;
        if let Some(inner_35) = &self.message {
            write!(f, ": {}", inner_35)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidBranchNameException {}
/// See [`InvalidBranchNameException`](crate::error::InvalidBranchNameException)
pub mod invalid_branch_name_exception {
    /// A builder for [`InvalidBranchNameException`](crate::error::InvalidBranchNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidBranchNameException`](crate::error::InvalidBranchNameException)
        pub fn build(self) -> crate::error::InvalidBranchNameException {
            crate::error::InvalidBranchNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidBranchNameException {
    /// Creates a new builder-style object to manufacture [`InvalidBranchNameException`](crate::error::InvalidBranchNameException)
    pub fn builder() -> crate::error::invalid_branch_name_exception::Builder {
        crate::error::invalid_branch_name_exception::Builder::default()
    }
}

/// <p>A branch name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BranchNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BranchNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BranchNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BranchNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchNameRequiredException")?;
        if let Some(inner_36) = &self.message {
            write!(f, ": {}", inner_36)?;
        }
        Ok(())
    }
}
impl std::error::Error for BranchNameRequiredException {}
/// See [`BranchNameRequiredException`](crate::error::BranchNameRequiredException)
pub mod branch_name_required_exception {
    /// A builder for [`BranchNameRequiredException`](crate::error::BranchNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BranchNameRequiredException`](crate::error::BranchNameRequiredException)
        pub fn build(self) -> crate::error::BranchNameRequiredException {
            crate::error::BranchNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl BranchNameRequiredException {
    /// Creates a new builder-style object to manufacture [`BranchNameRequiredException`](crate::error::BranchNameRequiredException)
    pub fn builder() -> crate::error::branch_name_required_exception::Builder {
        crate::error::branch_name_required_exception::Builder::default()
    }
}

/// <p>The specified branch does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BranchDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BranchDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BranchDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BranchDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchDoesNotExistException")?;
        if let Some(inner_37) = &self.message {
            write!(f, ": {}", inner_37)?;
        }
        Ok(())
    }
}
impl std::error::Error for BranchDoesNotExistException {}
/// See [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException)
pub mod branch_does_not_exist_exception {
    /// A builder for [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException)
        pub fn build(self) -> crate::error::BranchDoesNotExistException {
            crate::error::BranchDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl BranchDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException)
    pub fn builder() -> crate::error::branch_does_not_exist_exception::Builder {
        crate::error::branch_does_not_exist_exception::Builder::default()
    }
}

/// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCommentIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCommentIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCommentIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCommentIdException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommentIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommentIdException")?;
        if let Some(inner_38) = &self.message {
            write!(f, ": {}", inner_38)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommentIdException {}
/// See [`InvalidCommentIdException`](crate::error::InvalidCommentIdException)
pub mod invalid_comment_id_exception {
    /// A builder for [`InvalidCommentIdException`](crate::error::InvalidCommentIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommentIdException`](crate::error::InvalidCommentIdException)
        pub fn build(self) -> crate::error::InvalidCommentIdException {
            crate::error::InvalidCommentIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidCommentIdException {
    /// Creates a new builder-style object to manufacture [`InvalidCommentIdException`](crate::error::InvalidCommentIdException)
    pub fn builder() -> crate::error::invalid_comment_id_exception::Builder {
        crate::error::invalid_comment_id_exception::Builder::default()
    }
}

/// <p>You cannot modify or delete this comment. Only comment authors can modify or delete their comments.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentNotCreatedByCallerException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentNotCreatedByCallerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentNotCreatedByCallerException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentNotCreatedByCallerException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentNotCreatedByCallerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentNotCreatedByCallerException")?;
        if let Some(inner_39) = &self.message {
            write!(f, ": {}", inner_39)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentNotCreatedByCallerException {}
/// See [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException)
pub mod comment_not_created_by_caller_exception {
    /// A builder for [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException)
        pub fn build(self) -> crate::error::CommentNotCreatedByCallerException {
            crate::error::CommentNotCreatedByCallerException {
                message: self.message,
            }
        }
    }
}
impl CommentNotCreatedByCallerException {
    /// Creates a new builder-style object to manufacture [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException)
    pub fn builder() -> crate::error::comment_not_created_by_caller_exception::Builder {
        crate::error::comment_not_created_by_caller_exception::Builder::default()
    }
}

/// <p>The comment ID is missing or null. A comment ID is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentIdRequiredException")?;
        if let Some(inner_40) = &self.message {
            write!(f, ": {}", inner_40)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentIdRequiredException {}
/// See [`CommentIdRequiredException`](crate::error::CommentIdRequiredException)
pub mod comment_id_required_exception {
    /// A builder for [`CommentIdRequiredException`](crate::error::CommentIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentIdRequiredException`](crate::error::CommentIdRequiredException)
        pub fn build(self) -> crate::error::CommentIdRequiredException {
            crate::error::CommentIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommentIdRequiredException {
    /// Creates a new builder-style object to manufacture [`CommentIdRequiredException`](crate::error::CommentIdRequiredException)
    pub fn builder() -> crate::error::comment_id_required_exception::Builder {
        crate::error::comment_id_required_exception::Builder::default()
    }
}

/// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentDoesNotExistException")?;
        if let Some(inner_41) = &self.message {
            write!(f, ": {}", inner_41)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentDoesNotExistException {}
/// See [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException)
pub mod comment_does_not_exist_exception {
    /// A builder for [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException)
        pub fn build(self) -> crate::error::CommentDoesNotExistException {
            crate::error::CommentDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl CommentDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException)
    pub fn builder() -> crate::error::comment_does_not_exist_exception::Builder {
        crate::error::comment_does_not_exist_exception::Builder::default()
    }
}

/// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentDeletedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentDeletedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentDeletedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentDeletedException")?;
        if let Some(inner_42) = &self.message {
            write!(f, ": {}", inner_42)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentDeletedException {}
/// See [`CommentDeletedException`](crate::error::CommentDeletedException)
pub mod comment_deleted_exception {
    /// A builder for [`CommentDeletedException`](crate::error::CommentDeletedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentDeletedException`](crate::error::CommentDeletedException)
        pub fn build(self) -> crate::error::CommentDeletedException {
            crate::error::CommentDeletedException {
                message: self.message,
            }
        }
    }
}
impl CommentDeletedException {
    /// Creates a new builder-style object to manufacture [`CommentDeletedException`](crate::error::CommentDeletedException)
    pub fn builder() -> crate::error::comment_deleted_exception::Builder {
        crate::error::comment_deleted_exception::Builder::default()
    }
}

/// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentContentSizeLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentContentSizeLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentContentSizeLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentContentSizeLimitExceededException")?;
        if let Some(inner_43) = &self.message {
            write!(f, ": {}", inner_43)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentContentSizeLimitExceededException {}
/// See [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException)
pub mod comment_content_size_limit_exceeded_exception {
    /// A builder for [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException)
        pub fn build(self) -> crate::error::CommentContentSizeLimitExceededException {
            crate::error::CommentContentSizeLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl CommentContentSizeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException)
    pub fn builder() -> crate::error::comment_content_size_limit_exceeded_exception::Builder {
        crate::error::comment_content_size_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommentContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommentContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommentContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommentContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentContentRequiredException")?;
        if let Some(inner_44) = &self.message {
            write!(f, ": {}", inner_44)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommentContentRequiredException {}
/// See [`CommentContentRequiredException`](crate::error::CommentContentRequiredException)
pub mod comment_content_required_exception {
    /// A builder for [`CommentContentRequiredException`](crate::error::CommentContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommentContentRequiredException`](crate::error::CommentContentRequiredException)
        pub fn build(self) -> crate::error::CommentContentRequiredException {
            crate::error::CommentContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommentContentRequiredException {
    /// Creates a new builder-style object to manufacture [`CommentContentRequiredException`](crate::error::CommentContentRequiredException)
    pub fn builder() -> crate::error::comment_content_required_exception::Builder {
        crate::error::comment_content_required_exception::Builder::default()
    }
}

/// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleTemplateNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleTemplateNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleTemplateNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleTemplateNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleTemplateNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleTemplateNameException")?;
        if let Some(inner_45) = &self.message {
            write!(f, ": {}", inner_45)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleTemplateNameException {}
/// See [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException)
pub mod invalid_approval_rule_template_name_exception {
    /// A builder for [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleTemplateNameException {
            crate::error::InvalidApprovalRuleTemplateNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleTemplateNameException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException)
    pub fn builder() -> crate::error::invalid_approval_rule_template_name_exception::Builder {
        crate::error::invalid_approval_rule_template_name_exception::Builder::default()
    }
}

/// <p>An approval rule template name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateNameRequiredException")?;
        if let Some(inner_46) = &self.message {
            write!(f, ": {}", inner_46)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateNameRequiredException {}
/// See [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException)
pub mod approval_rule_template_name_required_exception {
    /// A builder for [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateNameRequiredException {
            crate::error::ApprovalRuleTemplateNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException)
    pub fn builder() -> crate::error::approval_rule_template_name_required_exception::Builder {
        crate::error::approval_rule_template_name_required_exception::Builder::default()
    }
}

/// <p>You cannot create an approval rule template with that name because a template with that name already exists in this AWS Region for your AWS account. Approval rule template names must be unique.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateNameAlreadyExistsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateNameAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateNameAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateNameAlreadyExistsException")?;
        if let Some(inner_47) = &self.message {
            write!(f, ": {}", inner_47)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateNameAlreadyExistsException {}
/// See [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException)
pub mod approval_rule_template_name_already_exists_exception {
    /// A builder for [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateNameAlreadyExistsException {
            crate::error::ApprovalRuleTemplateNameAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateNameAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException)
    pub fn builder() -> crate::error::approval_rule_template_name_already_exists_exception::Builder
    {
        crate::error::approval_rule_template_name_already_exists_exception::Builder::default()
    }
}

/// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateDoesNotExistException")?;
        if let Some(inner_48) = &self.message {
            write!(f, ": {}", inner_48)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateDoesNotExistException {}
/// See [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException)
pub mod approval_rule_template_does_not_exist_exception {
    /// A builder for [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateDoesNotExistException {
            crate::error::ApprovalRuleTemplateDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException)
    pub fn builder() -> crate::error::approval_rule_template_does_not_exist_exception::Builder {
        crate::error::approval_rule_template_does_not_exist_exception::Builder::default()
    }
}

/// <p>The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleTemplateDescriptionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleTemplateDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleTemplateDescriptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleTemplateDescriptionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleTemplateDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleTemplateDescriptionException")?;
        if let Some(inner_49) = &self.message {
            write!(f, ": {}", inner_49)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleTemplateDescriptionException {}
/// See [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException)
pub mod invalid_approval_rule_template_description_exception {
    /// A builder for [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleTemplateDescriptionException {
            crate::error::InvalidApprovalRuleTemplateDescriptionException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleTemplateDescriptionException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException)
    pub fn builder() -> crate::error::invalid_approval_rule_template_description_exception::Builder
    {
        crate::error::invalid_approval_rule_template_description_exception::Builder::default()
    }
}

/// <p>The content of the approval rule template is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidApprovalRuleTemplateContentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidApprovalRuleTemplateContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidApprovalRuleTemplateContentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidApprovalRuleTemplateContentException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleTemplateContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleTemplateContentException")?;
        if let Some(inner_50) = &self.message {
            write!(f, ": {}", inner_50)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleTemplateContentException {}
/// See [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException)
pub mod invalid_approval_rule_template_content_exception {
    /// A builder for [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException)
        pub fn build(self) -> crate::error::InvalidApprovalRuleTemplateContentException {
            crate::error::InvalidApprovalRuleTemplateContentException {
                message: self.message,
            }
        }
    }
}
impl InvalidApprovalRuleTemplateContentException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException)
    pub fn builder() -> crate::error::invalid_approval_rule_template_content_exception::Builder {
        crate::error::invalid_approval_rule_template_content_exception::Builder::default()
    }
}

/// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateContentRequiredException")?;
        if let Some(inner_51) = &self.message {
            write!(f, ": {}", inner_51)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateContentRequiredException {}
/// See [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException)
pub mod approval_rule_template_content_required_exception {
    /// A builder for [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateContentRequiredException {
            crate::error::ApprovalRuleTemplateContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateContentRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException)
    pub fn builder() -> crate::error::approval_rule_template_content_required_exception::Builder {
        crate::error::approval_rule_template_content_required_exception::Builder::default()
    }
}

/// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TooManyTagsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TooManyTagsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TooManyTagsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_52) = &self.message {
            write!(f, ": {}", inner_52)?;
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
/// See [`TooManyTagsException`](crate::error::TooManyTagsException)
pub mod too_many_tags_exception {
    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException)
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message,
            }
        }
    }
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException)
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}

/// <p>The tag policy is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagPolicyException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagPolicyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagPolicyException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagPolicyException")?;
        if let Some(inner_53) = &self.message {
            write!(f, ": {}", inner_53)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagPolicyException {}
/// See [`TagPolicyException`](crate::error::TagPolicyException)
pub mod tag_policy_exception {
    /// A builder for [`TagPolicyException`](crate::error::TagPolicyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagPolicyException`](crate::error::TagPolicyException)
        pub fn build(self) -> crate::error::TagPolicyException {
            crate::error::TagPolicyException {
                message: self.message,
            }
        }
    }
}
impl TagPolicyException {
    /// Creates a new builder-style object to manufacture [`TagPolicyException`](crate::error::TagPolicyException)
    pub fn builder() -> crate::error::tag_policy_exception::Builder {
        crate::error::tag_policy_exception::Builder::default()
    }
}

/// <p>A list of tag keys is required. The list cannot be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagKeysListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagKeysListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagKeysListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagKeysListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagKeysListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagKeysListRequiredException")?;
        if let Some(inner_54) = &self.message {
            write!(f, ": {}", inner_54)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagKeysListRequiredException {}
/// See [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException)
pub mod tag_keys_list_required_exception {
    /// A builder for [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException)
        pub fn build(self) -> crate::error::TagKeysListRequiredException {
            crate::error::TagKeysListRequiredException {
                message: self.message,
            }
        }
    }
}
impl TagKeysListRequiredException {
    /// Creates a new builder-style object to manufacture [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException)
    pub fn builder() -> crate::error::tag_keys_list_required_exception::Builder {
        crate::error::tag_keys_list_required_exception::Builder::default()
    }
}

/// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ResourceArnRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ResourceArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ResourceArnRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ResourceArnRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceArnRequiredException")?;
        if let Some(inner_55) = &self.message {
            write!(f, ": {}", inner_55)?;
        }
        Ok(())
    }
}
impl std::error::Error for ResourceArnRequiredException {}
/// See [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException)
pub mod resource_arn_required_exception {
    /// A builder for [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException)
        pub fn build(self) -> crate::error::ResourceArnRequiredException {
            crate::error::ResourceArnRequiredException {
                message: self.message,
            }
        }
    }
}
impl ResourceArnRequiredException {
    /// Creates a new builder-style object to manufacture [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException)
    pub fn builder() -> crate::error::resource_arn_required_exception::Builder {
        crate::error::resource_arn_required_exception::Builder::default()
    }
}

/// <p>The list of tags is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTagKeysListException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTagKeysListException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTagKeysListException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTagKeysListException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagKeysListException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagKeysListException")?;
        if let Some(inner_56) = &self.message {
            write!(f, ": {}", inner_56)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagKeysListException {}
/// See [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException)
pub mod invalid_tag_keys_list_exception {
    /// A builder for [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException)
        pub fn build(self) -> crate::error::InvalidTagKeysListException {
            crate::error::InvalidTagKeysListException {
                message: self.message,
            }
        }
    }
}
impl InvalidTagKeysListException {
    /// Creates a new builder-style object to manufacture [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException)
    pub fn builder() -> crate::error::invalid_tag_keys_list_exception::Builder {
        crate::error::invalid_tag_keys_list_exception::Builder::default()
    }
}

/// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSystemTagUsageException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSystemTagUsageException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSystemTagUsageException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSystemTagUsageException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSystemTagUsageException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSystemTagUsageException")?;
        if let Some(inner_57) = &self.message {
            write!(f, ": {}", inner_57)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSystemTagUsageException {}
/// See [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException)
pub mod invalid_system_tag_usage_exception {
    /// A builder for [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException)
        pub fn build(self) -> crate::error::InvalidSystemTagUsageException {
            crate::error::InvalidSystemTagUsageException {
                message: self.message,
            }
        }
    }
}
impl InvalidSystemTagUsageException {
    /// Creates a new builder-style object to manufacture [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException)
    pub fn builder() -> crate::error::invalid_system_tag_usage_exception::Builder {
        crate::error::invalid_system_tag_usage_exception::Builder::default()
    }
}

/// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidResourceArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidResourceArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidResourceArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidResourceArnException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResourceArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceArnException")?;
        if let Some(inner_58) = &self.message {
            write!(f, ": {}", inner_58)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResourceArnException {}
/// See [`InvalidResourceArnException`](crate::error::InvalidResourceArnException)
pub mod invalid_resource_arn_exception {
    /// A builder for [`InvalidResourceArnException`](crate::error::InvalidResourceArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResourceArnException`](crate::error::InvalidResourceArnException)
        pub fn build(self) -> crate::error::InvalidResourceArnException {
            crate::error::InvalidResourceArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidResourceArnException {
    /// Creates a new builder-style object to manufacture [`InvalidResourceArnException`](crate::error::InvalidResourceArnException)
    pub fn builder() -> crate::error::invalid_resource_arn_exception::Builder {
        crate::error::invalid_resource_arn_exception::Builder::default()
    }
}

/// <p>The list of triggers for the repository is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggersListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggersListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggersListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggersListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggersListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggersListRequiredException")?;
        if let Some(inner_59) = &self.message {
            write!(f, ": {}", inner_59)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggersListRequiredException {}
/// See [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException)
pub mod repository_triggers_list_required_exception {
    /// A builder for [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggersListRequiredException {
            crate::error::RepositoryTriggersListRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggersListRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException)
    pub fn builder() -> crate::error::repository_triggers_list_required_exception::Builder {
        crate::error::repository_triggers_list_required_exception::Builder::default()
    }
}

/// <p>A name for the trigger is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggerNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggerNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggerNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggerNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerNameRequiredException")?;
        if let Some(inner_60) = &self.message {
            write!(f, ": {}", inner_60)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerNameRequiredException {}
/// See [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException)
pub mod repository_trigger_name_required_exception {
    /// A builder for [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggerNameRequiredException {
            crate::error::RepositoryTriggerNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggerNameRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException)
    pub fn builder() -> crate::error::repository_trigger_name_required_exception::Builder {
        crate::error::repository_trigger_name_required_exception::Builder::default()
    }
}

/// <p>At least one event for the trigger is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggerEventsListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggerEventsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggerEventsListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggerEventsListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerEventsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerEventsListRequiredException")?;
        if let Some(inner_61) = &self.message {
            write!(f, ": {}", inner_61)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerEventsListRequiredException {}
/// See [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException)
pub mod repository_trigger_events_list_required_exception {
    /// A builder for [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggerEventsListRequiredException {
            crate::error::RepositoryTriggerEventsListRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggerEventsListRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException)
    pub fn builder() -> crate::error::repository_trigger_events_list_required_exception::Builder {
        crate::error::repository_trigger_events_list_required_exception::Builder::default()
    }
}

/// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggerDestinationArnRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggerDestinationArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggerDestinationArnRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggerDestinationArnRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerDestinationArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerDestinationArnRequiredException")?;
        if let Some(inner_62) = &self.message {
            write!(f, ": {}", inner_62)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerDestinationArnRequiredException {}
/// See [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException)
pub mod repository_trigger_destination_arn_required_exception {
    /// A builder for [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggerDestinationArnRequiredException {
            crate::error::RepositoryTriggerDestinationArnRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggerDestinationArnRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException)
    pub fn builder() -> crate::error::repository_trigger_destination_arn_required_exception::Builder
    {
        crate::error::repository_trigger_destination_arn_required_exception::Builder::default()
    }
}

/// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryTriggerBranchNameListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryTriggerBranchNameListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryTriggerBranchNameListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryTriggerBranchNameListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerBranchNameListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerBranchNameListRequiredException")?;
        if let Some(inner_63) = &self.message {
            write!(f, ": {}", inner_63)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerBranchNameListRequiredException {}
/// See [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException)
pub mod repository_trigger_branch_name_list_required_exception {
    /// A builder for [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException)
        pub fn build(self) -> crate::error::RepositoryTriggerBranchNameListRequiredException {
            crate::error::RepositoryTriggerBranchNameListRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryTriggerBranchNameListRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException)
    pub fn builder() -> crate::error::repository_trigger_branch_name_list_required_exception::Builder
    {
        crate::error::repository_trigger_branch_name_list_required_exception::Builder::default()
    }
}

/// <p>The number of triggers allowed for the repository was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumRepositoryTriggersExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumRepositoryTriggersExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumRepositoryTriggersExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumRepositoryTriggersExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumRepositoryTriggersExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumRepositoryTriggersExceededException")?;
        if let Some(inner_64) = &self.message {
            write!(f, ": {}", inner_64)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumRepositoryTriggersExceededException {}
/// See [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException)
pub mod maximum_repository_triggers_exceeded_exception {
    /// A builder for [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException)
        pub fn build(self) -> crate::error::MaximumRepositoryTriggersExceededException {
            crate::error::MaximumRepositoryTriggersExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumRepositoryTriggersExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException)
    pub fn builder() -> crate::error::maximum_repository_triggers_exceeded_exception::Builder {
        crate::error::maximum_repository_triggers_exceeded_exception::Builder::default()
    }
}

/// <p>The number of branches for the trigger was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumBranchesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumBranchesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumBranchesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumBranchesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumBranchesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumBranchesExceededException")?;
        if let Some(inner_65) = &self.message {
            write!(f, ": {}", inner_65)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumBranchesExceededException {}
/// See [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException)
pub mod maximum_branches_exceeded_exception {
    /// A builder for [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException)
        pub fn build(self) -> crate::error::MaximumBranchesExceededException {
            crate::error::MaximumBranchesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumBranchesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException)
    pub fn builder() -> crate::error::maximum_branches_exceeded_exception::Builder {
        crate::error::maximum_branches_exceeded_exception::Builder::default()
    }
}

/// <p>The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerRegionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerRegionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerRegionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerRegionException")?;
        if let Some(inner_66) = &self.message {
            write!(f, ": {}", inner_66)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerRegionException {}
/// See [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException)
pub mod invalid_repository_trigger_region_exception {
    /// A builder for [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerRegionException {
            crate::error::InvalidRepositoryTriggerRegionException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerRegionException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException)
    pub fn builder() -> crate::error::invalid_repository_trigger_region_exception::Builder {
        crate::error::invalid_repository_trigger_region_exception::Builder::default()
    }
}

/// <p>The name of the trigger is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerNameException")?;
        if let Some(inner_67) = &self.message {
            write!(f, ": {}", inner_67)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerNameException {}
/// See [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException)
pub mod invalid_repository_trigger_name_exception {
    /// A builder for [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerNameException {
            crate::error::InvalidRepositoryTriggerNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerNameException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException)
    pub fn builder() -> crate::error::invalid_repository_trigger_name_exception::Builder {
        crate::error::invalid_repository_trigger_name_exception::Builder::default()
    }
}

/// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerEventsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerEventsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerEventsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerEventsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerEventsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerEventsException")?;
        if let Some(inner_68) = &self.message {
            write!(f, ": {}", inner_68)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerEventsException {}
/// See [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException)
pub mod invalid_repository_trigger_events_exception {
    /// A builder for [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerEventsException {
            crate::error::InvalidRepositoryTriggerEventsException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerEventsException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException)
    pub fn builder() -> crate::error::invalid_repository_trigger_events_exception::Builder {
        crate::error::invalid_repository_trigger_events_exception::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerDestinationArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerDestinationArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerDestinationArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerDestinationArnException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerDestinationArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerDestinationArnException")?;
        if let Some(inner_69) = &self.message {
            write!(f, ": {}", inner_69)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerDestinationArnException {}
/// See [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException)
pub mod invalid_repository_trigger_destination_arn_exception {
    /// A builder for [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerDestinationArnException {
            crate::error::InvalidRepositoryTriggerDestinationArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerDestinationArnException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException)
    pub fn builder() -> crate::error::invalid_repository_trigger_destination_arn_exception::Builder
    {
        crate::error::invalid_repository_trigger_destination_arn_exception::Builder::default()
    }
}

/// <p>The custom data provided for the trigger is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerCustomDataException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerCustomDataException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerCustomDataException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerCustomDataException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerCustomDataException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerCustomDataException")?;
        if let Some(inner_70) = &self.message {
            write!(f, ": {}", inner_70)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerCustomDataException {}
/// See [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException)
pub mod invalid_repository_trigger_custom_data_exception {
    /// A builder for [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerCustomDataException {
            crate::error::InvalidRepositoryTriggerCustomDataException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerCustomDataException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException)
    pub fn builder() -> crate::error::invalid_repository_trigger_custom_data_exception::Builder {
        crate::error::invalid_repository_trigger_custom_data_exception::Builder::default()
    }
}

/// <p>One or more branch names specified for the trigger is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRepositoryTriggerBranchNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRepositoryTriggerBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRepositoryTriggerBranchNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRepositoryTriggerBranchNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerBranchNameException")?;
        if let Some(inner_71) = &self.message {
            write!(f, ": {}", inner_71)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerBranchNameException {}
/// See [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException)
pub mod invalid_repository_trigger_branch_name_exception {
    /// A builder for [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException)
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerBranchNameException {
            crate::error::InvalidRepositoryTriggerBranchNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidRepositoryTriggerBranchNameException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException)
    pub fn builder() -> crate::error::invalid_repository_trigger_branch_name_exception::Builder {
        crate::error::invalid_repository_trigger_branch_name_exception::Builder::default()
    }
}

/// <p>A map of tags is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TagsMapRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TagsMapRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TagsMapRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TagsMapRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagsMapRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagsMapRequiredException")?;
        if let Some(inner_72) = &self.message {
            write!(f, ": {}", inner_72)?;
        }
        Ok(())
    }
}
impl std::error::Error for TagsMapRequiredException {}
/// See [`TagsMapRequiredException`](crate::error::TagsMapRequiredException)
pub mod tags_map_required_exception {
    /// A builder for [`TagsMapRequiredException`](crate::error::TagsMapRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TagsMapRequiredException`](crate::error::TagsMapRequiredException)
        pub fn build(self) -> crate::error::TagsMapRequiredException {
            crate::error::TagsMapRequiredException {
                message: self.message,
            }
        }
    }
}
impl TagsMapRequiredException {
    /// Creates a new builder-style object to manufacture [`TagsMapRequiredException`](crate::error::TagsMapRequiredException)
    pub fn builder() -> crate::error::tags_map_required_exception::Builder {
        crate::error::tags_map_required_exception::Builder::default()
    }
}

/// <p>The map of tags is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTagsMapException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTagsMapException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTagsMapException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTagsMapException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagsMapException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagsMapException")?;
        if let Some(inner_73) = &self.message {
            write!(f, ": {}", inner_73)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagsMapException {}
/// See [`InvalidTagsMapException`](crate::error::InvalidTagsMapException)
pub mod invalid_tags_map_exception {
    /// A builder for [`InvalidTagsMapException`](crate::error::InvalidTagsMapException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagsMapException`](crate::error::InvalidTagsMapException)
        pub fn build(self) -> crate::error::InvalidTagsMapException {
            crate::error::InvalidTagsMapException {
                message: self.message,
            }
        }
    }
}
impl InvalidTagsMapException {
    /// Creates a new builder-style object to manufacture [`InvalidTagsMapException`](crate::error::InvalidTagsMapException)
    pub fn builder() -> crate::error::invalid_tags_map_exception::Builder {
        crate::error::invalid_tags_map_exception::Builder::default()
    }
}

/// <p>The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SameFileContentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SameFileContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SameFileContentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SameFileContentException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SameFileContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SameFileContentException")?;
        if let Some(inner_74) = &self.message {
            write!(f, ": {}", inner_74)?;
        }
        Ok(())
    }
}
impl std::error::Error for SameFileContentException {}
/// See [`SameFileContentException`](crate::error::SameFileContentException)
pub mod same_file_content_exception {
    /// A builder for [`SameFileContentException`](crate::error::SameFileContentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SameFileContentException`](crate::error::SameFileContentException)
        pub fn build(self) -> crate::error::SameFileContentException {
            crate::error::SameFileContentException {
                message: self.message,
            }
        }
    }
}
impl SameFileContentException {
    /// Creates a new builder-style object to manufacture [`SameFileContentException`](crate::error::SameFileContentException)
    pub fn builder() -> crate::error::same_file_content_exception::Builder {
        crate::error::same_file_content_exception::Builder::default()
    }
}

/// <p>The folderPath for a location cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PathRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PathRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PathRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PathRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PathRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PathRequiredException")?;
        if let Some(inner_75) = &self.message {
            write!(f, ": {}", inner_75)?;
        }
        Ok(())
    }
}
impl std::error::Error for PathRequiredException {}
/// See [`PathRequiredException`](crate::error::PathRequiredException)
pub mod path_required_exception {
    /// A builder for [`PathRequiredException`](crate::error::PathRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PathRequiredException`](crate::error::PathRequiredException)
        pub fn build(self) -> crate::error::PathRequiredException {
            crate::error::PathRequiredException {
                message: self.message,
            }
        }
    }
}
impl PathRequiredException {
    /// Creates a new builder-style object to manufacture [`PathRequiredException`](crate::error::PathRequiredException)
    pub fn builder() -> crate::error::path_required_exception::Builder {
        crate::error::path_required_exception::Builder::default()
    }
}

/// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParentCommitIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParentCommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParentCommitIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParentCommitIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParentCommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParentCommitIdRequiredException")?;
        if let Some(inner_76) = &self.message {
            write!(f, ": {}", inner_76)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParentCommitIdRequiredException {}
/// See [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException)
pub mod parent_commit_id_required_exception {
    /// A builder for [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException)
        pub fn build(self) -> crate::error::ParentCommitIdRequiredException {
            crate::error::ParentCommitIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl ParentCommitIdRequiredException {
    /// Creates a new builder-style object to manufacture [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException)
    pub fn builder() -> crate::error::parent_commit_id_required_exception::Builder {
        crate::error::parent_commit_id_required_exception::Builder::default()
    }
}

/// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParentCommitIdOutdatedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParentCommitIdOutdatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParentCommitIdOutdatedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParentCommitIdOutdatedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParentCommitIdOutdatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParentCommitIdOutdatedException")?;
        if let Some(inner_77) = &self.message {
            write!(f, ": {}", inner_77)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParentCommitIdOutdatedException {}
/// See [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException)
pub mod parent_commit_id_outdated_exception {
    /// A builder for [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException)
        pub fn build(self) -> crate::error::ParentCommitIdOutdatedException {
            crate::error::ParentCommitIdOutdatedException {
                message: self.message,
            }
        }
    }
}
impl ParentCommitIdOutdatedException {
    /// Creates a new builder-style object to manufacture [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException)
    pub fn builder() -> crate::error::parent_commit_id_outdated_exception::Builder {
        crate::error::parent_commit_id_outdated_exception::Builder::default()
    }
}

/// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ParentCommitDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ParentCommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ParentCommitDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ParentCommitDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParentCommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParentCommitDoesNotExistException")?;
        if let Some(inner_78) = &self.message {
            write!(f, ": {}", inner_78)?;
        }
        Ok(())
    }
}
impl std::error::Error for ParentCommitDoesNotExistException {}
/// See [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException)
pub mod parent_commit_does_not_exist_exception {
    /// A builder for [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException)
        pub fn build(self) -> crate::error::ParentCommitDoesNotExistException {
            crate::error::ParentCommitDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ParentCommitDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException)
    pub fn builder() -> crate::error::parent_commit_does_not_exist_exception::Builder {
        crate::error::parent_commit_does_not_exist_exception::Builder::default()
    }
}

/// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NameLengthExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NameLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NameLengthExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NameLengthExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NameLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NameLengthExceededException")?;
        if let Some(inner_79) = &self.message {
            write!(f, ": {}", inner_79)?;
        }
        Ok(())
    }
}
impl std::error::Error for NameLengthExceededException {}
/// See [`NameLengthExceededException`](crate::error::NameLengthExceededException)
pub mod name_length_exceeded_exception {
    /// A builder for [`NameLengthExceededException`](crate::error::NameLengthExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NameLengthExceededException`](crate::error::NameLengthExceededException)
        pub fn build(self) -> crate::error::NameLengthExceededException {
            crate::error::NameLengthExceededException {
                message: self.message,
            }
        }
    }
}
impl NameLengthExceededException {
    /// Creates a new builder-style object to manufacture [`NameLengthExceededException`](crate::error::NameLengthExceededException)
    pub fn builder() -> crate::error::name_length_exceeded_exception::Builder {
        crate::error::name_length_exceeded_exception::Builder::default()
    }
}

/// <p>The specified path is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPathException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPathException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPathException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPathException")?;
        if let Some(inner_80) = &self.message {
            write!(f, ": {}", inner_80)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPathException {}
/// See [`InvalidPathException`](crate::error::InvalidPathException)
pub mod invalid_path_exception {
    /// A builder for [`InvalidPathException`](crate::error::InvalidPathException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPathException`](crate::error::InvalidPathException)
        pub fn build(self) -> crate::error::InvalidPathException {
            crate::error::InvalidPathException {
                message: self.message,
            }
        }
    }
}
impl InvalidPathException {
    /// Creates a new builder-style object to manufacture [`InvalidPathException`](crate::error::InvalidPathException)
    pub fn builder() -> crate::error::invalid_path_exception::Builder {
        crate::error::invalid_path_exception::Builder::default()
    }
}

/// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidParentCommitIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidParentCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidParentCommitIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidParentCommitIdException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParentCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParentCommitIdException")?;
        if let Some(inner_81) = &self.message {
            write!(f, ": {}", inner_81)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParentCommitIdException {}
/// See [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException)
pub mod invalid_parent_commit_id_exception {
    /// A builder for [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException)
        pub fn build(self) -> crate::error::InvalidParentCommitIdException {
            crate::error::InvalidParentCommitIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidParentCommitIdException {
    /// Creates a new builder-style object to manufacture [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException)
    pub fn builder() -> crate::error::invalid_parent_commit_id_exception::Builder {
        crate::error::invalid_parent_commit_id_exception::Builder::default()
    }
}

/// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFileModeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidFileModeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFileModeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidFileModeException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFileModeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFileModeException")?;
        if let Some(inner_82) = &self.message {
            write!(f, ": {}", inner_82)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFileModeException {}
/// See [`InvalidFileModeException`](crate::error::InvalidFileModeException)
pub mod invalid_file_mode_exception {
    /// A builder for [`InvalidFileModeException`](crate::error::InvalidFileModeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFileModeException`](crate::error::InvalidFileModeException)
        pub fn build(self) -> crate::error::InvalidFileModeException {
            crate::error::InvalidFileModeException {
                message: self.message,
            }
        }
    }
}
impl InvalidFileModeException {
    /// Creates a new builder-style object to manufacture [`InvalidFileModeException`](crate::error::InvalidFileModeException)
    pub fn builder() -> crate::error::invalid_file_mode_exception::Builder {
        crate::error::invalid_file_mode_exception::Builder::default()
    }
}

/// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidEmailException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidEmailException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidEmailException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidEmailException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEmailException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEmailException")?;
        if let Some(inner_83) = &self.message {
            write!(f, ": {}", inner_83)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEmailException {}
/// See [`InvalidEmailException`](crate::error::InvalidEmailException)
pub mod invalid_email_exception {
    /// A builder for [`InvalidEmailException`](crate::error::InvalidEmailException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEmailException`](crate::error::InvalidEmailException)
        pub fn build(self) -> crate::error::InvalidEmailException {
            crate::error::InvalidEmailException {
                message: self.message,
            }
        }
    }
}
impl InvalidEmailException {
    /// Creates a new builder-style object to manufacture [`InvalidEmailException`](crate::error::InvalidEmailException)
    pub fn builder() -> crate::error::invalid_email_exception::Builder {
        crate::error::invalid_email_exception::Builder::default()
    }
}

/// <p>The specified deletion parameter is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDeletionParameterException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDeletionParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDeletionParameterException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDeletionParameterException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeletionParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeletionParameterException")?;
        if let Some(inner_84) = &self.message {
            write!(f, ": {}", inner_84)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeletionParameterException {}
/// See [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException)
pub mod invalid_deletion_parameter_exception {
    /// A builder for [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException)
        pub fn build(self) -> crate::error::InvalidDeletionParameterException {
            crate::error::InvalidDeletionParameterException {
                message: self.message,
            }
        }
    }
}
impl InvalidDeletionParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException)
    pub fn builder() -> crate::error::invalid_deletion_parameter_exception::Builder {
        crate::error::invalid_deletion_parameter_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FolderContentSizeLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FolderContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FolderContentSizeLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FolderContentSizeLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FolderContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FolderContentSizeLimitExceededException")?;
        if let Some(inner_85) = &self.message {
            write!(f, ": {}", inner_85)?;
        }
        Ok(())
    }
}
impl std::error::Error for FolderContentSizeLimitExceededException {}
/// See [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException)
pub mod folder_content_size_limit_exceeded_exception {
    /// A builder for [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException)
        pub fn build(self) -> crate::error::FolderContentSizeLimitExceededException {
            crate::error::FolderContentSizeLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl FolderContentSizeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException)
    pub fn builder() -> crate::error::folder_content_size_limit_exceeded_exception::Builder {
        crate::error::folder_content_size_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FilePathConflictsWithSubmodulePathException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FilePathConflictsWithSubmodulePathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FilePathConflictsWithSubmodulePathException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FilePathConflictsWithSubmodulePathException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FilePathConflictsWithSubmodulePathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FilePathConflictsWithSubmodulePathException")?;
        if let Some(inner_86) = &self.message {
            write!(f, ": {}", inner_86)?;
        }
        Ok(())
    }
}
impl std::error::Error for FilePathConflictsWithSubmodulePathException {}
/// See [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException)
pub mod file_path_conflicts_with_submodule_path_exception {
    /// A builder for [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException)
        pub fn build(self) -> crate::error::FilePathConflictsWithSubmodulePathException {
            crate::error::FilePathConflictsWithSubmodulePathException {
                message: self.message,
            }
        }
    }
}
impl FilePathConflictsWithSubmodulePathException {
    /// Creates a new builder-style object to manufacture [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException)
    pub fn builder() -> crate::error::file_path_conflicts_with_submodule_path_exception::Builder {
        crate::error::file_path_conflicts_with_submodule_path_exception::Builder::default()
    }
}

/// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileNameConflictsWithDirectoryNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileNameConflictsWithDirectoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileNameConflictsWithDirectoryNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileNameConflictsWithDirectoryNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileNameConflictsWithDirectoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileNameConflictsWithDirectoryNameException")?;
        if let Some(inner_87) = &self.message {
            write!(f, ": {}", inner_87)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileNameConflictsWithDirectoryNameException {}
/// See [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException)
pub mod file_name_conflicts_with_directory_name_exception {
    /// A builder for [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException)
        pub fn build(self) -> crate::error::FileNameConflictsWithDirectoryNameException {
            crate::error::FileNameConflictsWithDirectoryNameException {
                message: self.message,
            }
        }
    }
}
impl FileNameConflictsWithDirectoryNameException {
    /// Creates a new builder-style object to manufacture [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException)
    pub fn builder() -> crate::error::file_name_conflicts_with_directory_name_exception::Builder {
        crate::error::file_name_conflicts_with_directory_name_exception::Builder::default()
    }
}

/// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileContentSizeLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileContentSizeLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileContentSizeLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileContentSizeLimitExceededException")?;
        if let Some(inner_88) = &self.message {
            write!(f, ": {}", inner_88)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileContentSizeLimitExceededException {}
/// See [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException)
pub mod file_content_size_limit_exceeded_exception {
    /// A builder for [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException)
        pub fn build(self) -> crate::error::FileContentSizeLimitExceededException {
            crate::error::FileContentSizeLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl FileContentSizeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException)
    pub fn builder() -> crate::error::file_content_size_limit_exceeded_exception::Builder {
        crate::error::file_content_size_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileContentRequiredException")?;
        if let Some(inner_89) = &self.message {
            write!(f, ": {}", inner_89)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileContentRequiredException {}
/// See [`FileContentRequiredException`](crate::error::FileContentRequiredException)
pub mod file_content_required_exception {
    /// A builder for [`FileContentRequiredException`](crate::error::FileContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileContentRequiredException`](crate::error::FileContentRequiredException)
        pub fn build(self) -> crate::error::FileContentRequiredException {
            crate::error::FileContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl FileContentRequiredException {
    /// Creates a new builder-style object to manufacture [`FileContentRequiredException`](crate::error::FileContentRequiredException)
    pub fn builder() -> crate::error::file_content_required_exception::Builder {
        crate::error::file_content_required_exception::Builder::default()
    }
}

/// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DirectoryNameConflictsWithFileNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DirectoryNameConflictsWithFileNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DirectoryNameConflictsWithFileNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DirectoryNameConflictsWithFileNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryNameConflictsWithFileNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryNameConflictsWithFileNameException")?;
        if let Some(inner_90) = &self.message {
            write!(f, ": {}", inner_90)?;
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryNameConflictsWithFileNameException {}
/// See [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException)
pub mod directory_name_conflicts_with_file_name_exception {
    /// A builder for [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException)
        pub fn build(self) -> crate::error::DirectoryNameConflictsWithFileNameException {
            crate::error::DirectoryNameConflictsWithFileNameException {
                message: self.message,
            }
        }
    }
}
impl DirectoryNameConflictsWithFileNameException {
    /// Creates a new builder-style object to manufacture [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException)
    pub fn builder() -> crate::error::directory_name_conflicts_with_file_name_exception::Builder {
        crate::error::directory_name_conflicts_with_file_name_exception::Builder::default()
    }
}

/// <p>The commit message is too long. Provide a shorter string. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitMessageLengthExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitMessageLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitMessageLengthExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitMessageLengthExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitMessageLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitMessageLengthExceededException")?;
        if let Some(inner_91) = &self.message {
            write!(f, ": {}", inner_91)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitMessageLengthExceededException {}
/// See [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException)
pub mod commit_message_length_exceeded_exception {
    /// A builder for [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException)
        pub fn build(self) -> crate::error::CommitMessageLengthExceededException {
            crate::error::CommitMessageLengthExceededException {
                message: self.message,
            }
        }
    }
}
impl CommitMessageLengthExceededException {
    /// Creates a new builder-style object to manufacture [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException)
    pub fn builder() -> crate::error::commit_message_length_exceeded_exception::Builder {
        crate::error::commit_message_length_exceeded_exception::Builder::default()
    }
}

/// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BranchNameIsTagNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BranchNameIsTagNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BranchNameIsTagNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BranchNameIsTagNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchNameIsTagNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchNameIsTagNameException")?;
        if let Some(inner_92) = &self.message {
            write!(f, ": {}", inner_92)?;
        }
        Ok(())
    }
}
impl std::error::Error for BranchNameIsTagNameException {}
/// See [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException)
pub mod branch_name_is_tag_name_exception {
    /// A builder for [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException)
        pub fn build(self) -> crate::error::BranchNameIsTagNameException {
            crate::error::BranchNameIsTagNameException {
                message: self.message,
            }
        }
    }
}
impl BranchNameIsTagNameException {
    /// Creates a new builder-style object to manufacture [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException)
    pub fn builder() -> crate::error::branch_name_is_tag_name_exception::Builder {
        crate::error::branch_name_is_tag_name_exception::Builder::default()
    }
}

/// <p>A reaction value is required. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReactionValueRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReactionValueRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReactionValueRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReactionValueRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReactionValueRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReactionValueRequiredException")?;
        if let Some(inner_93) = &self.message {
            write!(f, ": {}", inner_93)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReactionValueRequiredException {}
/// See [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException)
pub mod reaction_value_required_exception {
    /// A builder for [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException)
        pub fn build(self) -> crate::error::ReactionValueRequiredException {
            crate::error::ReactionValueRequiredException {
                message: self.message,
            }
        }
    }
}
impl ReactionValueRequiredException {
    /// Creates a new builder-style object to manufacture [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException)
    pub fn builder() -> crate::error::reaction_value_required_exception::Builder {
        crate::error::reaction_value_required_exception::Builder::default()
    }
}

/// <p>The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReactionLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReactionLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReactionLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReactionLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReactionLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReactionLimitExceededException")?;
        if let Some(inner_94) = &self.message {
            write!(f, ": {}", inner_94)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReactionLimitExceededException {}
/// See [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException)
pub mod reaction_limit_exceeded_exception {
    /// A builder for [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException)
        pub fn build(self) -> crate::error::ReactionLimitExceededException {
            crate::error::ReactionLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl ReactionLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException)
    pub fn builder() -> crate::error::reaction_limit_exceeded_exception::Builder {
        crate::error::reaction_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The value of the reaction is not valid. For more information, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReactionValueException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReactionValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReactionValueException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReactionValueException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReactionValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReactionValueException")?;
        if let Some(inner_95) = &self.message {
            write!(f, ": {}", inner_95)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReactionValueException {}
/// See [`InvalidReactionValueException`](crate::error::InvalidReactionValueException)
pub mod invalid_reaction_value_exception {
    /// A builder for [`InvalidReactionValueException`](crate::error::InvalidReactionValueException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReactionValueException`](crate::error::InvalidReactionValueException)
        pub fn build(self) -> crate::error::InvalidReactionValueException {
            crate::error::InvalidReactionValueException {
                message: self.message,
            }
        }
    }
}
impl InvalidReactionValueException {
    /// Creates a new builder-style object to manufacture [`InvalidReactionValueException`](crate::error::InvalidReactionValueException)
    pub fn builder() -> crate::error::invalid_reaction_value_exception::Builder {
        crate::error::invalid_reaction_value_exception::Builder::default()
    }
}

/// <p>The client request token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidClientRequestTokenException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidClientRequestTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidClientRequestTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidClientRequestTokenException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClientRequestTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClientRequestTokenException")?;
        if let Some(inner_96) = &self.message {
            write!(f, ": {}", inner_96)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClientRequestTokenException {}
/// See [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException)
pub mod invalid_client_request_token_exception {
    /// A builder for [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException)
        pub fn build(self) -> crate::error::InvalidClientRequestTokenException {
            crate::error::InvalidClientRequestTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidClientRequestTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException)
    pub fn builder() -> crate::error::invalid_client_request_token_exception::Builder {
        crate::error::invalid_client_request_token_exception::Builder::default()
    }
}

/// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct IdempotencyParameterMismatchException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for IdempotencyParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("IdempotencyParameterMismatchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl IdempotencyParameterMismatchException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotencyParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotencyParameterMismatchException")?;
        if let Some(inner_97) = &self.message {
            write!(f, ": {}", inner_97)?;
        }
        Ok(())
    }
}
impl std::error::Error for IdempotencyParameterMismatchException {}
/// See [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException)
pub mod idempotency_parameter_mismatch_exception {
    /// A builder for [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException)
        pub fn build(self) -> crate::error::IdempotencyParameterMismatchException {
            crate::error::IdempotencyParameterMismatchException {
                message: self.message,
            }
        }
    }
}
impl IdempotencyParameterMismatchException {
    /// Creates a new builder-style object to manufacture [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException)
    pub fn builder() -> crate::error::idempotency_parameter_mismatch_exception::Builder {
        crate::error::idempotency_parameter_mismatch_exception::Builder::default()
    }
}

/// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ClientRequestTokenRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ClientRequestTokenRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ClientRequestTokenRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ClientRequestTokenRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClientRequestTokenRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClientRequestTokenRequiredException")?;
        if let Some(inner_98) = &self.message {
            write!(f, ": {}", inner_98)?;
        }
        Ok(())
    }
}
impl std::error::Error for ClientRequestTokenRequiredException {}
/// See [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException)
pub mod client_request_token_required_exception {
    /// A builder for [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException)
        pub fn build(self) -> crate::error::ClientRequestTokenRequiredException {
            crate::error::ClientRequestTokenRequiredException {
                message: self.message,
            }
        }
    }
}
impl ClientRequestTokenRequiredException {
    /// Creates a new builder-style object to manufacture [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException)
    pub fn builder() -> crate::error::client_request_token_required_exception::Builder {
        crate::error::client_request_token_required_exception::Builder::default()
    }
}

/// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryNotAssociatedWithPullRequestException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryNotAssociatedWithPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryNotAssociatedWithPullRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryNotAssociatedWithPullRequestException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNotAssociatedWithPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNotAssociatedWithPullRequestException")?;
        if let Some(inner_99) = &self.message {
            write!(f, ": {}", inner_99)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNotAssociatedWithPullRequestException {}
/// See [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException)
pub mod repository_not_associated_with_pull_request_exception {
    /// A builder for [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException)
        pub fn build(self) -> crate::error::RepositoryNotAssociatedWithPullRequestException {
            crate::error::RepositoryNotAssociatedWithPullRequestException {
                message: self.message,
            }
        }
    }
}
impl RepositoryNotAssociatedWithPullRequestException {
    /// Creates a new builder-style object to manufacture [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException)
    pub fn builder() -> crate::error::repository_not_associated_with_pull_request_exception::Builder
    {
        crate::error::repository_not_associated_with_pull_request_exception::Builder::default()
    }
}

/// <p>The specified path does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PathDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PathDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PathDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PathDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PathDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PathDoesNotExistException")?;
        if let Some(inner_100) = &self.message {
            write!(f, ": {}", inner_100)?;
        }
        Ok(())
    }
}
impl std::error::Error for PathDoesNotExistException {}
/// See [`PathDoesNotExistException`](crate::error::PathDoesNotExistException)
pub mod path_does_not_exist_exception {
    /// A builder for [`PathDoesNotExistException`](crate::error::PathDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PathDoesNotExistException`](crate::error::PathDoesNotExistException)
        pub fn build(self) -> crate::error::PathDoesNotExistException {
            crate::error::PathDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl PathDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`PathDoesNotExistException`](crate::error::PathDoesNotExistException)
    pub fn builder() -> crate::error::path_does_not_exist_exception::Builder {
        crate::error::path_does_not_exist_exception::Builder::default()
    }
}

/// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidRelativeFileVersionEnumException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidRelativeFileVersionEnumException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidRelativeFileVersionEnumException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidRelativeFileVersionEnumException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRelativeFileVersionEnumException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRelativeFileVersionEnumException")?;
        if let Some(inner_101) = &self.message {
            write!(f, ": {}", inner_101)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRelativeFileVersionEnumException {}
/// See [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException)
pub mod invalid_relative_file_version_enum_exception {
    /// A builder for [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException)
        pub fn build(self) -> crate::error::InvalidRelativeFileVersionEnumException {
            crate::error::InvalidRelativeFileVersionEnumException {
                message: self.message,
            }
        }
    }
}
impl InvalidRelativeFileVersionEnumException {
    /// Creates a new builder-style object to manufacture [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException)
    pub fn builder() -> crate::error::invalid_relative_file_version_enum_exception::Builder {
        crate::error::invalid_relative_file_version_enum_exception::Builder::default()
    }
}

/// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFilePositionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidFilePositionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFilePositionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidFilePositionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFilePositionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFilePositionException")?;
        if let Some(inner_102) = &self.message {
            write!(f, ": {}", inner_102)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFilePositionException {}
/// See [`InvalidFilePositionException`](crate::error::InvalidFilePositionException)
pub mod invalid_file_position_exception {
    /// A builder for [`InvalidFilePositionException`](crate::error::InvalidFilePositionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFilePositionException`](crate::error::InvalidFilePositionException)
        pub fn build(self) -> crate::error::InvalidFilePositionException {
            crate::error::InvalidFilePositionException {
                message: self.message,
            }
        }
    }
}
impl InvalidFilePositionException {
    /// Creates a new builder-style object to manufacture [`InvalidFilePositionException`](crate::error::InvalidFilePositionException)
    pub fn builder() -> crate::error::invalid_file_position_exception::Builder {
        crate::error::invalid_file_position_exception::Builder::default()
    }
}

/// <p>The location of the file is not valid. Make sure that you include the file name and extension.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidFileLocationException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidFileLocationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidFileLocationException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidFileLocationException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFileLocationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFileLocationException")?;
        if let Some(inner_103) = &self.message {
            write!(f, ": {}", inner_103)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFileLocationException {}
/// See [`InvalidFileLocationException`](crate::error::InvalidFileLocationException)
pub mod invalid_file_location_exception {
    /// A builder for [`InvalidFileLocationException`](crate::error::InvalidFileLocationException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFileLocationException`](crate::error::InvalidFileLocationException)
        pub fn build(self) -> crate::error::InvalidFileLocationException {
            crate::error::InvalidFileLocationException {
                message: self.message,
            }
        }
    }
}
impl InvalidFileLocationException {
    /// Creates a new builder-style object to manufacture [`InvalidFileLocationException`](crate::error::InvalidFileLocationException)
    pub fn builder() -> crate::error::invalid_file_location_exception::Builder {
        crate::error::invalid_file_location_exception::Builder::default()
    }
}

/// <p>The specified commit ID is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCommitIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCommitIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCommitIdException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommitIdException")?;
        if let Some(inner_104) = &self.message {
            write!(f, ": {}", inner_104)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommitIdException {}
/// See [`InvalidCommitIdException`](crate::error::InvalidCommitIdException)
pub mod invalid_commit_id_exception {
    /// A builder for [`InvalidCommitIdException`](crate::error::InvalidCommitIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommitIdException`](crate::error::InvalidCommitIdException)
        pub fn build(self) -> crate::error::InvalidCommitIdException {
            crate::error::InvalidCommitIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidCommitIdException {
    /// Creates a new builder-style object to manufacture [`InvalidCommitIdException`](crate::error::InvalidCommitIdException)
    pub fn builder() -> crate::error::invalid_commit_id_exception::Builder {
        crate::error::invalid_commit_id_exception::Builder::default()
    }
}

/// <p>A commit ID was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdRequiredException")?;
        if let Some(inner_105) = &self.message {
            write!(f, ": {}", inner_105)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdRequiredException {}
/// See [`CommitIdRequiredException`](crate::error::CommitIdRequiredException)
pub mod commit_id_required_exception {
    /// A builder for [`CommitIdRequiredException`](crate::error::CommitIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdRequiredException`](crate::error::CommitIdRequiredException)
        pub fn build(self) -> crate::error::CommitIdRequiredException {
            crate::error::CommitIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommitIdRequiredException {
    /// Creates a new builder-style object to manufacture [`CommitIdRequiredException`](crate::error::CommitIdRequiredException)
    pub fn builder() -> crate::error::commit_id_required_exception::Builder {
        crate::error::commit_id_required_exception::Builder::default()
    }
}

/// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitDoesNotExistException")?;
        if let Some(inner_106) = &self.message {
            write!(f, ": {}", inner_106)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitDoesNotExistException {}
/// See [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException)
pub mod commit_does_not_exist_exception {
    /// A builder for [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException)
        pub fn build(self) -> crate::error::CommitDoesNotExistException {
            crate::error::CommitDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl CommitDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException)
    pub fn builder() -> crate::error::commit_does_not_exist_exception::Builder {
        crate::error::commit_does_not_exist_exception::Builder::default()
    }
}

/// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BeforeCommitIdAndAfterCommitIdAreSameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BeforeCommitIdAndAfterCommitIdAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BeforeCommitIdAndAfterCommitIdAreSameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BeforeCommitIdAndAfterCommitIdAreSameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BeforeCommitIdAndAfterCommitIdAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BeforeCommitIdAndAfterCommitIdAreSameException")?;
        if let Some(inner_107) = &self.message {
            write!(f, ": {}", inner_107)?;
        }
        Ok(())
    }
}
impl std::error::Error for BeforeCommitIdAndAfterCommitIdAreSameException {}
/// See [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException)
pub mod before_commit_id_and_after_commit_id_are_same_exception {
    /// A builder for [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException)
        pub fn build(self) -> crate::error::BeforeCommitIdAndAfterCommitIdAreSameException {
            crate::error::BeforeCommitIdAndAfterCommitIdAreSameException {
                message: self.message,
            }
        }
    }
}
impl BeforeCommitIdAndAfterCommitIdAreSameException {
    /// Creates a new builder-style object to manufacture [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException)
    pub fn builder(
    ) -> crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder {
        crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder::default()
    }
}

/// <p>An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OverrideStatusRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OverrideStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OverrideStatusRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OverrideStatusRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OverrideStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OverrideStatusRequiredException")?;
        if let Some(inner_108) = &self.message {
            write!(f, ": {}", inner_108)?;
        }
        Ok(())
    }
}
impl std::error::Error for OverrideStatusRequiredException {}
/// See [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException)
pub mod override_status_required_exception {
    /// A builder for [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException)
        pub fn build(self) -> crate::error::OverrideStatusRequiredException {
            crate::error::OverrideStatusRequiredException {
                message: self.message,
            }
        }
    }
}
impl OverrideStatusRequiredException {
    /// Creates a new builder-style object to manufacture [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException)
    pub fn builder() -> crate::error::override_status_required_exception::Builder {
        crate::error::override_status_required_exception::Builder::default()
    }
}

/// <p>The pull request has already had its approval rules set to override.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct OverrideAlreadySetException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for OverrideAlreadySetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("OverrideAlreadySetException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl OverrideAlreadySetException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OverrideAlreadySetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OverrideAlreadySetException")?;
        if let Some(inner_109) = &self.message {
            write!(f, ": {}", inner_109)?;
        }
        Ok(())
    }
}
impl std::error::Error for OverrideAlreadySetException {}
/// See [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException)
pub mod override_already_set_exception {
    /// A builder for [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException)
        pub fn build(self) -> crate::error::OverrideAlreadySetException {
            crate::error::OverrideAlreadySetException {
                message: self.message,
            }
        }
    }
}
impl OverrideAlreadySetException {
    /// Creates a new builder-style object to manufacture [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException)
    pub fn builder() -> crate::error::override_already_set_exception::Builder {
        crate::error::override_already_set_exception::Builder::default()
    }
}

/// <p>The override status is not valid. Valid statuses are OVERRIDE and REVOKE.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOverrideStatusException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOverrideStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOverrideStatusException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOverrideStatusException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOverrideStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOverrideStatusException")?;
        if let Some(inner_110) = &self.message {
            write!(f, ": {}", inner_110)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOverrideStatusException {}
/// See [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException)
pub mod invalid_override_status_exception {
    /// A builder for [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException)
        pub fn build(self) -> crate::error::InvalidOverrideStatusException {
            crate::error::InvalidOverrideStatusException {
                message: self.message,
            }
        }
    }
}
impl InvalidOverrideStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException)
    pub fn builder() -> crate::error::invalid_override_status_exception::Builder {
        crate::error::invalid_override_status_exception::Builder::default()
    }
}

/// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TipsDivergenceExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TipsDivergenceExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TipsDivergenceExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TipsDivergenceExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TipsDivergenceExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TipsDivergenceExceededException")?;
        if let Some(inner_111) = &self.message {
            write!(f, ": {}", inner_111)?;
        }
        Ok(())
    }
}
impl std::error::Error for TipsDivergenceExceededException {}
/// See [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException)
pub mod tips_divergence_exceeded_exception {
    /// A builder for [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException)
        pub fn build(self) -> crate::error::TipsDivergenceExceededException {
            crate::error::TipsDivergenceExceededException {
                message: self.message,
            }
        }
    }
}
impl TipsDivergenceExceededException {
    /// Creates a new builder-style object to manufacture [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException)
    pub fn builder() -> crate::error::tips_divergence_exceeded_exception::Builder {
        crate::error::tips_divergence_exceeded_exception::Builder::default()
    }
}

/// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TipOfSourceReferenceIsDifferentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TipOfSourceReferenceIsDifferentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TipOfSourceReferenceIsDifferentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TipOfSourceReferenceIsDifferentException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TipOfSourceReferenceIsDifferentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TipOfSourceReferenceIsDifferentException")?;
        if let Some(inner_112) = &self.message {
            write!(f, ": {}", inner_112)?;
        }
        Ok(())
    }
}
impl std::error::Error for TipOfSourceReferenceIsDifferentException {}
/// See [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException)
pub mod tip_of_source_reference_is_different_exception {
    /// A builder for [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException)
        pub fn build(self) -> crate::error::TipOfSourceReferenceIsDifferentException {
            crate::error::TipOfSourceReferenceIsDifferentException {
                message: self.message,
            }
        }
    }
}
impl TipOfSourceReferenceIsDifferentException {
    /// Creates a new builder-style object to manufacture [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException)
    pub fn builder() -> crate::error::tip_of_source_reference_is_different_exception::Builder {
        crate::error::tip_of_source_reference_is_different_exception::Builder::default()
    }
}

/// <p>A replacement type is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplacementTypeRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplacementTypeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplacementTypeRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplacementTypeRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplacementTypeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplacementTypeRequiredException")?;
        if let Some(inner_113) = &self.message {
            write!(f, ": {}", inner_113)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplacementTypeRequiredException {}
/// See [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException)
pub mod replacement_type_required_exception {
    /// A builder for [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException)
        pub fn build(self) -> crate::error::ReplacementTypeRequiredException {
            crate::error::ReplacementTypeRequiredException {
                message: self.message,
            }
        }
    }
}
impl ReplacementTypeRequiredException {
    /// Creates a new builder-style object to manufacture [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException)
    pub fn builder() -> crate::error::replacement_type_required_exception::Builder {
        crate::error::replacement_type_required_exception::Builder::default()
    }
}

/// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReplacementContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReplacementContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReplacementContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReplacementContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplacementContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplacementContentRequiredException")?;
        if let Some(inner_114) = &self.message {
            write!(f, ": {}", inner_114)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReplacementContentRequiredException {}
/// See [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException)
pub mod replacement_content_required_exception {
    /// A builder for [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException)
        pub fn build(self) -> crate::error::ReplacementContentRequiredException {
            crate::error::ReplacementContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl ReplacementContentRequiredException {
    /// Creates a new builder-style object to manufacture [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException)
    pub fn builder() -> crate::error::replacement_content_required_exception::Builder {
        crate::error::replacement_content_required_exception::Builder::default()
    }
}

/// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PullRequestApprovalRulesNotSatisfiedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PullRequestApprovalRulesNotSatisfiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PullRequestApprovalRulesNotSatisfiedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PullRequestApprovalRulesNotSatisfiedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestApprovalRulesNotSatisfiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestApprovalRulesNotSatisfiedException")?;
        if let Some(inner_115) = &self.message {
            write!(f, ": {}", inner_115)?;
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestApprovalRulesNotSatisfiedException {}
/// See [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException)
pub mod pull_request_approval_rules_not_satisfied_exception {
    /// A builder for [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException)
        pub fn build(self) -> crate::error::PullRequestApprovalRulesNotSatisfiedException {
            crate::error::PullRequestApprovalRulesNotSatisfiedException {
                message: self.message,
            }
        }
    }
}
impl PullRequestApprovalRulesNotSatisfiedException {
    /// Creates a new builder-style object to manufacture [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException)
    pub fn builder() -> crate::error::pull_request_approval_rules_not_satisfied_exception::Builder {
        crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default()
    }
}

/// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MultipleConflictResolutionEntriesException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MultipleConflictResolutionEntriesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MultipleConflictResolutionEntriesException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MultipleConflictResolutionEntriesException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MultipleConflictResolutionEntriesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MultipleConflictResolutionEntriesException")?;
        if let Some(inner_116) = &self.message {
            write!(f, ": {}", inner_116)?;
        }
        Ok(())
    }
}
impl std::error::Error for MultipleConflictResolutionEntriesException {}
/// See [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException)
pub mod multiple_conflict_resolution_entries_exception {
    /// A builder for [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException)
        pub fn build(self) -> crate::error::MultipleConflictResolutionEntriesException {
            crate::error::MultipleConflictResolutionEntriesException {
                message: self.message,
            }
        }
    }
}
impl MultipleConflictResolutionEntriesException {
    /// Creates a new builder-style object to manufacture [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException)
    pub fn builder() -> crate::error::multiple_conflict_resolution_entries_exception::Builder {
        crate::error::multiple_conflict_resolution_entries_exception::Builder::default()
    }
}

/// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumItemsToCompareExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumItemsToCompareExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumItemsToCompareExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumItemsToCompareExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumItemsToCompareExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumItemsToCompareExceededException")?;
        if let Some(inner_117) = &self.message {
            write!(f, ": {}", inner_117)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumItemsToCompareExceededException {}
/// See [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException)
pub mod maximum_items_to_compare_exceeded_exception {
    /// A builder for [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException)
        pub fn build(self) -> crate::error::MaximumItemsToCompareExceededException {
            crate::error::MaximumItemsToCompareExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumItemsToCompareExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException)
    pub fn builder() -> crate::error::maximum_items_to_compare_exceeded_exception::Builder {
        crate::error::maximum_items_to_compare_exceeded_exception::Builder::default()
    }
}

/// <p>The number of files to load exceeds the allowed limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumFileContentToLoadExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumFileContentToLoadExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumFileContentToLoadExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumFileContentToLoadExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumFileContentToLoadExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumFileContentToLoadExceededException")?;
        if let Some(inner_118) = &self.message {
            write!(f, ": {}", inner_118)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumFileContentToLoadExceededException {}
/// See [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException)
pub mod maximum_file_content_to_load_exceeded_exception {
    /// A builder for [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException)
        pub fn build(self) -> crate::error::MaximumFileContentToLoadExceededException {
            crate::error::MaximumFileContentToLoadExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumFileContentToLoadExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException)
    pub fn builder() -> crate::error::maximum_file_content_to_load_exceeded_exception::Builder {
        crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default()
    }
}

/// <p>The number of allowed conflict resolution entries was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumConflictResolutionEntriesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumConflictResolutionEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumConflictResolutionEntriesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumConflictResolutionEntriesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumConflictResolutionEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumConflictResolutionEntriesExceededException")?;
        if let Some(inner_119) = &self.message {
            write!(f, ": {}", inner_119)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumConflictResolutionEntriesExceededException {}
/// See [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException)
pub mod maximum_conflict_resolution_entries_exceeded_exception {
    /// A builder for [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException)
        pub fn build(self) -> crate::error::MaximumConflictResolutionEntriesExceededException {
            crate::error::MaximumConflictResolutionEntriesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumConflictResolutionEntriesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException)
    pub fn builder() -> crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder
    {
        crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default()
    }
}

/// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ManualMergeRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ManualMergeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ManualMergeRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ManualMergeRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ManualMergeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ManualMergeRequiredException")?;
        if let Some(inner_120) = &self.message {
            write!(f, ": {}", inner_120)?;
        }
        Ok(())
    }
}
impl std::error::Error for ManualMergeRequiredException {}
/// See [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException)
pub mod manual_merge_required_exception {
    /// A builder for [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException)
        pub fn build(self) -> crate::error::ManualMergeRequiredException {
            crate::error::ManualMergeRequiredException {
                message: self.message,
            }
        }
    }
}
impl ManualMergeRequiredException {
    /// Creates a new builder-style object to manufacture [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException)
    pub fn builder() -> crate::error::manual_merge_required_exception::Builder {
        crate::error::manual_merge_required_exception::Builder::default()
    }
}

/// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReplacementTypeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReplacementTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReplacementTypeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReplacementTypeException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReplacementTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReplacementTypeException")?;
        if let Some(inner_121) = &self.message {
            write!(f, ": {}", inner_121)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReplacementTypeException {}
/// See [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException)
pub mod invalid_replacement_type_exception {
    /// A builder for [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException)
        pub fn build(self) -> crate::error::InvalidReplacementTypeException {
            crate::error::InvalidReplacementTypeException {
                message: self.message,
            }
        }
    }
}
impl InvalidReplacementTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException)
    pub fn builder() -> crate::error::invalid_replacement_type_exception::Builder {
        crate::error::invalid_replacement_type_exception::Builder::default()
    }
}

/// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReplacementContentException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReplacementContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReplacementContentException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReplacementContentException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReplacementContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReplacementContentException")?;
        if let Some(inner_122) = &self.message {
            write!(f, ": {}", inner_122)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReplacementContentException {}
/// See [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException)
pub mod invalid_replacement_content_exception {
    /// A builder for [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException)
        pub fn build(self) -> crate::error::InvalidReplacementContentException {
            crate::error::InvalidReplacementContentException {
                message: self.message,
            }
        }
    }
}
impl InvalidReplacementContentException {
    /// Creates a new builder-style object to manufacture [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException)
    pub fn builder() -> crate::error::invalid_replacement_content_exception::Builder {
        crate::error::invalid_replacement_content_exception::Builder::default()
    }
}

/// <p>The specified conflict resolution strategy is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidConflictResolutionStrategyException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidConflictResolutionStrategyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidConflictResolutionStrategyException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidConflictResolutionStrategyException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConflictResolutionStrategyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConflictResolutionStrategyException")?;
        if let Some(inner_123) = &self.message {
            write!(f, ": {}", inner_123)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConflictResolutionStrategyException {}
/// See [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException)
pub mod invalid_conflict_resolution_strategy_exception {
    /// A builder for [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException)
        pub fn build(self) -> crate::error::InvalidConflictResolutionStrategyException {
            crate::error::InvalidConflictResolutionStrategyException {
                message: self.message,
            }
        }
    }
}
impl InvalidConflictResolutionStrategyException {
    /// Creates a new builder-style object to manufacture [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException)
    pub fn builder() -> crate::error::invalid_conflict_resolution_strategy_exception::Builder {
        crate::error::invalid_conflict_resolution_strategy_exception::Builder::default()
    }
}

/// <p>The specified conflict resolution list is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidConflictResolutionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidConflictResolutionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidConflictResolutionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidConflictResolutionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConflictResolutionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConflictResolutionException")?;
        if let Some(inner_124) = &self.message {
            write!(f, ": {}", inner_124)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConflictResolutionException {}
/// See [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException)
pub mod invalid_conflict_resolution_exception {
    /// A builder for [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException)
        pub fn build(self) -> crate::error::InvalidConflictResolutionException {
            crate::error::InvalidConflictResolutionException {
                message: self.message,
            }
        }
    }
}
impl InvalidConflictResolutionException {
    /// Creates a new builder-style object to manufacture [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException)
    pub fn builder() -> crate::error::invalid_conflict_resolution_exception::Builder {
        crate::error::invalid_conflict_resolution_exception::Builder::default()
    }
}

/// <p>The specified conflict detail level is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidConflictDetailLevelException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidConflictDetailLevelException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidConflictDetailLevelException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidConflictDetailLevelException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConflictDetailLevelException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConflictDetailLevelException")?;
        if let Some(inner_125) = &self.message {
            write!(f, ": {}", inner_125)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConflictDetailLevelException {}
/// See [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException)
pub mod invalid_conflict_detail_level_exception {
    /// A builder for [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException)
        pub fn build(self) -> crate::error::InvalidConflictDetailLevelException {
            crate::error::InvalidConflictDetailLevelException {
                message: self.message,
            }
        }
    }
}
impl InvalidConflictDetailLevelException {
    /// Creates a new builder-style object to manufacture [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException)
    pub fn builder() -> crate::error::invalid_conflict_detail_level_exception::Builder {
        crate::error::invalid_conflict_detail_level_exception::Builder::default()
    }
}

/// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ConcurrentReferenceUpdateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ConcurrentReferenceUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ConcurrentReferenceUpdateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ConcurrentReferenceUpdateException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentReferenceUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentReferenceUpdateException")?;
        if let Some(inner_126) = &self.message {
            write!(f, ": {}", inner_126)?;
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentReferenceUpdateException {}
/// See [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException)
pub mod concurrent_reference_update_exception {
    /// A builder for [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException)
        pub fn build(self) -> crate::error::ConcurrentReferenceUpdateException {
            crate::error::ConcurrentReferenceUpdateException {
                message: self.message,
            }
        }
    }
}
impl ConcurrentReferenceUpdateException {
    /// Creates a new builder-style object to manufacture [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException)
    pub fn builder() -> crate::error::concurrent_reference_update_exception::Builder {
        crate::error::concurrent_reference_update_exception::Builder::default()
    }
}

/// <p>The specified reference does not exist. You must provide a full commit ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReferenceDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReferenceDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReferenceDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReferenceDoesNotExistException")?;
        if let Some(inner_127) = &self.message {
            write!(f, ": {}", inner_127)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReferenceDoesNotExistException {}
/// See [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException)
pub mod reference_does_not_exist_exception {
    /// A builder for [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException)
        pub fn build(self) -> crate::error::ReferenceDoesNotExistException {
            crate::error::ReferenceDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ReferenceDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException)
    pub fn builder() -> crate::error::reference_does_not_exist_exception::Builder {
        crate::error::reference_does_not_exist_exception::Builder::default()
    }
}

/// <p>The specified target branch is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTargetBranchException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTargetBranchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTargetBranchException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTargetBranchException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetBranchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetBranchException")?;
        if let Some(inner_128) = &self.message {
            write!(f, ": {}", inner_128)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetBranchException {}
/// See [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException)
pub mod invalid_target_branch_exception {
    /// A builder for [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException)
        pub fn build(self) -> crate::error::InvalidTargetBranchException {
            crate::error::InvalidTargetBranchException {
                message: self.message,
            }
        }
    }
}
impl InvalidTargetBranchException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException)
    pub fn builder() -> crate::error::invalid_target_branch_exception::Builder {
        crate::error::invalid_target_branch_exception::Builder::default()
    }
}

/// <p>The specified commit is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidCommitException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidCommitException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidCommitException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidCommitException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommitException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommitException")?;
        if let Some(inner_129) = &self.message {
            write!(f, ": {}", inner_129)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommitException {}
/// See [`InvalidCommitException`](crate::error::InvalidCommitException)
pub mod invalid_commit_exception {
    /// A builder for [`InvalidCommitException`](crate::error::InvalidCommitException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommitException`](crate::error::InvalidCommitException)
        pub fn build(self) -> crate::error::InvalidCommitException {
            crate::error::InvalidCommitException {
                message: self.message,
            }
        }
    }
}
impl InvalidCommitException {
    /// Creates a new builder-style object to manufacture [`InvalidCommitException`](crate::error::InvalidCommitException)
    pub fn builder() -> crate::error::invalid_commit_exception::Builder {
        crate::error::invalid_commit_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileModeRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileModeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileModeRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileModeRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileModeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileModeRequiredException")?;
        if let Some(inner_130) = &self.message {
            write!(f, ": {}", inner_130)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileModeRequiredException {}
/// See [`FileModeRequiredException`](crate::error::FileModeRequiredException)
pub mod file_mode_required_exception {
    /// A builder for [`FileModeRequiredException`](crate::error::FileModeRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileModeRequiredException`](crate::error::FileModeRequiredException)
        pub fn build(self) -> crate::error::FileModeRequiredException {
            crate::error::FileModeRequiredException {
                message: self.message,
            }
        }
    }
}
impl FileModeRequiredException {
    /// Creates a new builder-style object to manufacture [`FileModeRequiredException`](crate::error::FileModeRequiredException)
    pub fn builder() -> crate::error::file_mode_required_exception::Builder {
        crate::error::file_mode_required_exception::Builder::default()
    }
}

/// <p>A commit was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitRequiredException")?;
        if let Some(inner_131) = &self.message {
            write!(f, ": {}", inner_131)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitRequiredException {}
/// See [`CommitRequiredException`](crate::error::CommitRequiredException)
pub mod commit_required_exception {
    /// A builder for [`CommitRequiredException`](crate::error::CommitRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitRequiredException`](crate::error::CommitRequiredException)
        pub fn build(self) -> crate::error::CommitRequiredException {
            crate::error::CommitRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommitRequiredException {
    /// Creates a new builder-style object to manufacture [`CommitRequiredException`](crate::error::CommitRequiredException)
    pub fn builder() -> crate::error::commit_required_exception::Builder {
        crate::error::commit_required_exception::Builder::default()
    }
}

/// <p>The specified number of maximum results is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMaxResultsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMaxResultsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMaxResultsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMaxResultsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxResultsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxResultsException")?;
        if let Some(inner_132) = &self.message {
            write!(f, ": {}", inner_132)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxResultsException {}
/// See [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
pub mod invalid_max_results_exception {
    /// A builder for [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
        pub fn build(self) -> crate::error::InvalidMaxResultsException {
            crate::error::InvalidMaxResultsException {
                message: self.message,
            }
        }
    }
}
impl InvalidMaxResultsException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException)
    pub fn builder() -> crate::error::invalid_max_results_exception::Builder {
        crate::error::invalid_max_results_exception::Builder::default()
    }
}

/// <p>The specified continuation token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidContinuationTokenException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidContinuationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidContinuationTokenException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidContinuationTokenException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidContinuationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidContinuationTokenException")?;
        if let Some(inner_133) = &self.message {
            write!(f, ": {}", inner_133)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidContinuationTokenException {}
/// See [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException)
pub mod invalid_continuation_token_exception {
    /// A builder for [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException)
        pub fn build(self) -> crate::error::InvalidContinuationTokenException {
            crate::error::InvalidContinuationTokenException {
                message: self.message,
            }
        }
    }
}
impl InvalidContinuationTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException)
    pub fn builder() -> crate::error::invalid_continuation_token_exception::Builder {
        crate::error::invalid_continuation_token_exception::Builder::default()
    }
}

/// <p>The specified sort by value is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSortByException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSortByException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSortByException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSortByException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSortByException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSortByException")?;
        if let Some(inner_134) = &self.message {
            write!(f, ": {}", inner_134)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSortByException {}
/// See [`InvalidSortByException`](crate::error::InvalidSortByException)
pub mod invalid_sort_by_exception {
    /// A builder for [`InvalidSortByException`](crate::error::InvalidSortByException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSortByException`](crate::error::InvalidSortByException)
        pub fn build(self) -> crate::error::InvalidSortByException {
            crate::error::InvalidSortByException {
                message: self.message,
            }
        }
    }
}
impl InvalidSortByException {
    /// Creates a new builder-style object to manufacture [`InvalidSortByException`](crate::error::InvalidSortByException)
    pub fn builder() -> crate::error::invalid_sort_by_exception::Builder {
        crate::error::invalid_sort_by_exception::Builder::default()
    }
}

/// <p>The specified sort order is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidOrderException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidOrderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidOrderException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidOrderException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOrderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOrderException")?;
        if let Some(inner_135) = &self.message {
            write!(f, ": {}", inner_135)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOrderException {}
/// See [`InvalidOrderException`](crate::error::InvalidOrderException)
pub mod invalid_order_exception {
    /// A builder for [`InvalidOrderException`](crate::error::InvalidOrderException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOrderException`](crate::error::InvalidOrderException)
        pub fn build(self) -> crate::error::InvalidOrderException {
            crate::error::InvalidOrderException {
                message: self.message,
            }
        }
    }
}
impl InvalidOrderException {
    /// Creates a new builder-style object to manufacture [`InvalidOrderException`](crate::error::InvalidOrderException)
    pub fn builder() -> crate::error::invalid_order_exception::Builder {
        crate::error::invalid_order_exception::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidAuthorArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidAuthorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidAuthorArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidAuthorArnException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAuthorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAuthorArnException")?;
        if let Some(inner_136) = &self.message {
            write!(f, ": {}", inner_136)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAuthorArnException {}
/// See [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException)
pub mod invalid_author_arn_exception {
    /// A builder for [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException)
        pub fn build(self) -> crate::error::InvalidAuthorArnException {
            crate::error::InvalidAuthorArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidAuthorArnException {
    /// Creates a new builder-style object to manufacture [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException)
    pub fn builder() -> crate::error::invalid_author_arn_exception::Builder {
        crate::error::invalid_author_arn_exception::Builder::default()
    }
}

/// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct AuthorDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for AuthorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("AuthorDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl AuthorDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorDoesNotExistException")?;
        if let Some(inner_137) = &self.message {
            write!(f, ": {}", inner_137)?;
        }
        Ok(())
    }
}
impl std::error::Error for AuthorDoesNotExistException {}
/// See [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException)
pub mod author_does_not_exist_exception {
    /// A builder for [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException)
        pub fn build(self) -> crate::error::AuthorDoesNotExistException {
            crate::error::AuthorDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl AuthorDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException)
    pub fn builder() -> crate::error::author_does_not_exist_exception::Builder {
        crate::error::author_does_not_exist_exception::Builder::default()
    }
}

/// <p>A merge option or stategy is required, and none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MergeOptionRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MergeOptionRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MergeOptionRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MergeOptionRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MergeOptionRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MergeOptionRequiredException")?;
        if let Some(inner_138) = &self.message {
            write!(f, ": {}", inner_138)?;
        }
        Ok(())
    }
}
impl std::error::Error for MergeOptionRequiredException {}
/// See [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException)
pub mod merge_option_required_exception {
    /// A builder for [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException)
        pub fn build(self) -> crate::error::MergeOptionRequiredException {
            crate::error::MergeOptionRequiredException {
                message: self.message,
            }
        }
    }
}
impl MergeOptionRequiredException {
    /// Creates a new builder-style object to manufacture [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException)
    pub fn builder() -> crate::error::merge_option_required_exception::Builder {
        crate::error::merge_option_required_exception::Builder::default()
    }
}

/// <p>The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidSourceCommitSpecifierException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidSourceCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidSourceCommitSpecifierException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidSourceCommitSpecifierException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSourceCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSourceCommitSpecifierException")?;
        if let Some(inner_139) = &self.message {
            write!(f, ": {}", inner_139)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSourceCommitSpecifierException {}
/// See [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException)
pub mod invalid_source_commit_specifier_exception {
    /// A builder for [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException)
        pub fn build(self) -> crate::error::InvalidSourceCommitSpecifierException {
            crate::error::InvalidSourceCommitSpecifierException {
                message: self.message,
            }
        }
    }
}
impl InvalidSourceCommitSpecifierException {
    /// Creates a new builder-style object to manufacture [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException)
    pub fn builder() -> crate::error::invalid_source_commit_specifier_exception::Builder {
        crate::error::invalid_source_commit_specifier_exception::Builder::default()
    }
}

/// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMergeOptionException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMergeOptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMergeOptionException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMergeOptionException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMergeOptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMergeOptionException")?;
        if let Some(inner_140) = &self.message {
            write!(f, ": {}", inner_140)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMergeOptionException {}
/// See [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException)
pub mod invalid_merge_option_exception {
    /// A builder for [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException)
        pub fn build(self) -> crate::error::InvalidMergeOptionException {
            crate::error::InvalidMergeOptionException {
                message: self.message,
            }
        }
    }
}
impl InvalidMergeOptionException {
    /// Creates a new builder-style object to manufacture [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException)
    pub fn builder() -> crate::error::invalid_merge_option_exception::Builder {
        crate::error::invalid_merge_option_exception::Builder::default()
    }
}

/// <p>The specified value for the number of conflict files to return is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMaxConflictFilesException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMaxConflictFilesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMaxConflictFilesException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMaxConflictFilesException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxConflictFilesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxConflictFilesException")?;
        if let Some(inner_141) = &self.message {
            write!(f, ": {}", inner_141)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxConflictFilesException {}
/// See [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException)
pub mod invalid_max_conflict_files_exception {
    /// A builder for [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException)
        pub fn build(self) -> crate::error::InvalidMaxConflictFilesException {
            crate::error::InvalidMaxConflictFilesException {
                message: self.message,
            }
        }
    }
}
impl InvalidMaxConflictFilesException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException)
    pub fn builder() -> crate::error::invalid_max_conflict_files_exception::Builder {
        crate::error::invalid_max_conflict_files_exception::Builder::default()
    }
}

/// <p>The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidDestinationCommitSpecifierException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidDestinationCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidDestinationCommitSpecifierException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidDestinationCommitSpecifierException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDestinationCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDestinationCommitSpecifierException")?;
        if let Some(inner_142) = &self.message {
            write!(f, ": {}", inner_142)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDestinationCommitSpecifierException {}
/// See [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException)
pub mod invalid_destination_commit_specifier_exception {
    /// A builder for [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException)
        pub fn build(self) -> crate::error::InvalidDestinationCommitSpecifierException {
            crate::error::InvalidDestinationCommitSpecifierException {
                message: self.message,
            }
        }
    }
}
impl InvalidDestinationCommitSpecifierException {
    /// Creates a new builder-style object to manufacture [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException)
    pub fn builder() -> crate::error::invalid_destination_commit_specifier_exception::Builder {
        crate::error::invalid_destination_commit_specifier_exception::Builder::default()
    }
}

/// <p>The specified folder does not exist. Either the folder name is not correct, or you did not enter the full path to the folder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FolderDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FolderDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FolderDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FolderDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FolderDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FolderDoesNotExistException")?;
        if let Some(inner_143) = &self.message {
            write!(f, ": {}", inner_143)?;
        }
        Ok(())
    }
}
impl std::error::Error for FolderDoesNotExistException {}
/// See [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException)
pub mod folder_does_not_exist_exception {
    /// A builder for [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException)
        pub fn build(self) -> crate::error::FolderDoesNotExistException {
            crate::error::FolderDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl FolderDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException)
    pub fn builder() -> crate::error::folder_does_not_exist_exception::Builder {
        crate::error::folder_does_not_exist_exception::Builder::default()
    }
}

/// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileTooLargeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileTooLargeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileTooLargeException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileTooLargeException")?;
        if let Some(inner_144) = &self.message {
            write!(f, ": {}", inner_144)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileTooLargeException {}
/// See [`FileTooLargeException`](crate::error::FileTooLargeException)
pub mod file_too_large_exception {
    /// A builder for [`FileTooLargeException`](crate::error::FileTooLargeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileTooLargeException`](crate::error::FileTooLargeException)
        pub fn build(self) -> crate::error::FileTooLargeException {
            crate::error::FileTooLargeException {
                message: self.message,
            }
        }
    }
}
impl FileTooLargeException {
    /// Creates a new builder-style object to manufacture [`FileTooLargeException`](crate::error::FileTooLargeException)
    pub fn builder() -> crate::error::file_too_large_exception::Builder {
        crate::error::file_too_large_exception::Builder::default()
    }
}

/// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileDoesNotExistException")?;
        if let Some(inner_145) = &self.message {
            write!(f, ": {}", inner_145)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileDoesNotExistException {}
/// See [`FileDoesNotExistException`](crate::error::FileDoesNotExistException)
pub mod file_does_not_exist_exception {
    /// A builder for [`FileDoesNotExistException`](crate::error::FileDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileDoesNotExistException`](crate::error::FileDoesNotExistException)
        pub fn build(self) -> crate::error::FileDoesNotExistException {
            crate::error::FileDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl FileDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`FileDoesNotExistException`](crate::error::FileDoesNotExistException)
    pub fn builder() -> crate::error::file_does_not_exist_exception::Builder {
        crate::error::file_does_not_exist_exception::Builder::default()
    }
}

/// <p>The specified commit ID does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitIdDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitIdDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitIdDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdDoesNotExistException")?;
        if let Some(inner_146) = &self.message {
            write!(f, ": {}", inner_146)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdDoesNotExistException {}
/// See [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException)
pub mod commit_id_does_not_exist_exception {
    /// A builder for [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException)
        pub fn build(self) -> crate::error::CommitIdDoesNotExistException {
            crate::error::CommitIdDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl CommitIdDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException)
    pub fn builder() -> crate::error::commit_id_does_not_exist_exception::Builder {
        crate::error::commit_id_does_not_exist_exception::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) of the user or identity is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReactionUserArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReactionUserArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReactionUserArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReactionUserArnException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReactionUserArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReactionUserArnException")?;
        if let Some(inner_147) = &self.message {
            write!(f, ": {}", inner_147)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReactionUserArnException {}
/// See [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException)
pub mod invalid_reaction_user_arn_exception {
    /// A builder for [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException)
        pub fn build(self) -> crate::error::InvalidReactionUserArnException {
            crate::error::InvalidReactionUserArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidReactionUserArnException {
    /// Creates a new builder-style object to manufacture [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException)
    pub fn builder() -> crate::error::invalid_reaction_user_arn_exception::Builder {
        crate::error::invalid_reaction_user_arn_exception::Builder::default()
    }
}

/// <p>The specified blob is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidBlobIdException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidBlobIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidBlobIdException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidBlobIdException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidBlobIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidBlobIdException")?;
        if let Some(inner_148) = &self.message {
            write!(f, ": {}", inner_148)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidBlobIdException {}
/// See [`InvalidBlobIdException`](crate::error::InvalidBlobIdException)
pub mod invalid_blob_id_exception {
    /// A builder for [`InvalidBlobIdException`](crate::error::InvalidBlobIdException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidBlobIdException`](crate::error::InvalidBlobIdException)
        pub fn build(self) -> crate::error::InvalidBlobIdException {
            crate::error::InvalidBlobIdException {
                message: self.message,
            }
        }
    }
}
impl InvalidBlobIdException {
    /// Creates a new builder-style object to manufacture [`InvalidBlobIdException`](crate::error::InvalidBlobIdException)
    pub fn builder() -> crate::error::invalid_blob_id_exception::Builder {
        crate::error::invalid_blob_id_exception::Builder::default()
    }
}

/// <p>A blob ID is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlobIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BlobIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlobIdRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BlobIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BlobIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BlobIdRequiredException")?;
        if let Some(inner_149) = &self.message {
            write!(f, ": {}", inner_149)?;
        }
        Ok(())
    }
}
impl std::error::Error for BlobIdRequiredException {}
/// See [`BlobIdRequiredException`](crate::error::BlobIdRequiredException)
pub mod blob_id_required_exception {
    /// A builder for [`BlobIdRequiredException`](crate::error::BlobIdRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BlobIdRequiredException`](crate::error::BlobIdRequiredException)
        pub fn build(self) -> crate::error::BlobIdRequiredException {
            crate::error::BlobIdRequiredException {
                message: self.message,
            }
        }
    }
}
impl BlobIdRequiredException {
    /// Creates a new builder-style object to manufacture [`BlobIdRequiredException`](crate::error::BlobIdRequiredException)
    pub fn builder() -> crate::error::blob_id_required_exception::Builder {
        crate::error::blob_id_required_exception::Builder::default()
    }
}

/// <p>The specified blob does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BlobIdDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BlobIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BlobIdDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BlobIdDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BlobIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BlobIdDoesNotExistException")?;
        if let Some(inner_150) = &self.message {
            write!(f, ": {}", inner_150)?;
        }
        Ok(())
    }
}
impl std::error::Error for BlobIdDoesNotExistException {}
/// See [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException)
pub mod blob_id_does_not_exist_exception {
    /// A builder for [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException)
        pub fn build(self) -> crate::error::BlobIdDoesNotExistException {
            crate::error::BlobIdDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl BlobIdDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException)
    pub fn builder() -> crate::error::blob_id_does_not_exist_exception::Builder {
        crate::error::blob_id_does_not_exist_exception::Builder::default()
    }
}

/// <p>The pull request event type is not valid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidPullRequestEventTypeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidPullRequestEventTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidPullRequestEventTypeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidPullRequestEventTypeException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestEventTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestEventTypeException")?;
        if let Some(inner_151) = &self.message {
            write!(f, ": {}", inner_151)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestEventTypeException {}
/// See [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException)
pub mod invalid_pull_request_event_type_exception {
    /// A builder for [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException)
        pub fn build(self) -> crate::error::InvalidPullRequestEventTypeException {
            crate::error::InvalidPullRequestEventTypeException {
                message: self.message,
            }
        }
    }
}
impl InvalidPullRequestEventTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException)
    pub fn builder() -> crate::error::invalid_pull_request_event_type_exception::Builder {
        crate::error::invalid_pull_request_event_type_exception::Builder::default()
    }
}

/// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidActorArnException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidActorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidActorArnException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidActorArnException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidActorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidActorArnException")?;
        if let Some(inner_152) = &self.message {
            write!(f, ": {}", inner_152)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidActorArnException {}
/// See [`InvalidActorArnException`](crate::error::InvalidActorArnException)
pub mod invalid_actor_arn_exception {
    /// A builder for [`InvalidActorArnException`](crate::error::InvalidActorArnException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidActorArnException`](crate::error::InvalidActorArnException)
        pub fn build(self) -> crate::error::InvalidActorArnException {
            crate::error::InvalidActorArnException {
                message: self.message,
            }
        }
    }
}
impl InvalidActorArnException {
    /// Creates a new builder-style object to manufacture [`InvalidActorArnException`](crate::error::InvalidActorArnException)
    pub fn builder() -> crate::error::invalid_actor_arn_exception::Builder {
        crate::error::invalid_actor_arn_exception::Builder::default()
    }
}

/// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ActorDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ActorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ActorDoesNotExistException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ActorDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ActorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ActorDoesNotExistException")?;
        if let Some(inner_153) = &self.message {
            write!(f, ": {}", inner_153)?;
        }
        Ok(())
    }
}
impl std::error::Error for ActorDoesNotExistException {}
/// See [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException)
pub mod actor_does_not_exist_exception {
    /// A builder for [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException)
        pub fn build(self) -> crate::error::ActorDoesNotExistException {
            crate::error::ActorDoesNotExistException {
                message: self.message,
            }
        }
    }
}
impl ActorDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException)
    pub fn builder() -> crate::error::actor_does_not_exist_exception::Builder {
        crate::error::actor_does_not_exist_exception::Builder::default()
    }
}

/// <p>The specified value for the number of merge hunks to return is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidMaxMergeHunksException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidMaxMergeHunksException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidMaxMergeHunksException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidMaxMergeHunksException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxMergeHunksException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxMergeHunksException")?;
        if let Some(inner_154) = &self.message {
            write!(f, ": {}", inner_154)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxMergeHunksException {}
/// See [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException)
pub mod invalid_max_merge_hunks_exception {
    /// A builder for [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException)
        pub fn build(self) -> crate::error::InvalidMaxMergeHunksException {
            crate::error::InvalidMaxMergeHunksException {
                message: self.message,
            }
        }
    }
}
impl InvalidMaxMergeHunksException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException)
    pub fn builder() -> crate::error::invalid_max_merge_hunks_exception::Builder {
        crate::error::invalid_max_merge_hunks_exception::Builder::default()
    }
}

/// <p>The approval rule cannot be deleted from the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CannotDeleteApprovalRuleFromTemplateException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CannotDeleteApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CannotDeleteApprovalRuleFromTemplateException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CannotDeleteApprovalRuleFromTemplateException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CannotDeleteApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CannotDeleteApprovalRuleFromTemplateException")?;
        if let Some(inner_155) = &self.message {
            write!(f, ": {}", inner_155)?;
        }
        Ok(())
    }
}
impl std::error::Error for CannotDeleteApprovalRuleFromTemplateException {}
/// See [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException)
pub mod cannot_delete_approval_rule_from_template_exception {
    /// A builder for [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException)
        pub fn build(self) -> crate::error::CannotDeleteApprovalRuleFromTemplateException {
            crate::error::CannotDeleteApprovalRuleFromTemplateException {
                message: self.message,
            }
        }
    }
}
impl CannotDeleteApprovalRuleFromTemplateException {
    /// Creates a new builder-style object to manufacture [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException)
    pub fn builder() -> crate::error::cannot_delete_approval_rule_from_template_exception::Builder {
        crate::error::cannot_delete_approval_rule_from_template_exception::Builder::default()
    }
}

/// <p>The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct DefaultBranchCannotBeDeletedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for DefaultBranchCannotBeDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("DefaultBranchCannotBeDeletedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl DefaultBranchCannotBeDeletedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DefaultBranchCannotBeDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DefaultBranchCannotBeDeletedException")?;
        if let Some(inner_156) = &self.message {
            write!(f, ": {}", inner_156)?;
        }
        Ok(())
    }
}
impl std::error::Error for DefaultBranchCannotBeDeletedException {}
/// See [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException)
pub mod default_branch_cannot_be_deleted_exception {
    /// A builder for [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException)
        pub fn build(self) -> crate::error::DefaultBranchCannotBeDeletedException {
            crate::error::DefaultBranchCannotBeDeletedException {
                message: self.message,
            }
        }
    }
}
impl DefaultBranchCannotBeDeletedException {
    /// Creates a new builder-style object to manufacture [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException)
    pub fn builder() -> crate::error::default_branch_cannot_be_deleted_exception::Builder {
        crate::error::default_branch_cannot_be_deleted_exception::Builder::default()
    }
}

/// <p>The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove all associations, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleTemplateInUseException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleTemplateInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleTemplateInUseException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleTemplateInUseException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateInUseException")?;
        if let Some(inner_157) = &self.message {
            write!(f, ": {}", inner_157)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateInUseException {}
/// See [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException)
pub mod approval_rule_template_in_use_exception {
    /// A builder for [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException)
        pub fn build(self) -> crate::error::ApprovalRuleTemplateInUseException {
            crate::error::ApprovalRuleTemplateInUseException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleTemplateInUseException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException)
    pub fn builder() -> crate::error::approval_rule_template_in_use_exception::Builder {
        crate::error::approval_rule_template_in_use_exception::Builder::default()
    }
}

/// <p>A repository resource limit was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryLimitExceededException")?;
        if let Some(inner_158) = &self.message {
            write!(f, ": {}", inner_158)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryLimitExceededException {}
/// See [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException)
pub mod repository_limit_exceeded_exception {
    /// A builder for [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException)
        pub fn build(self) -> crate::error::RepositoryLimitExceededException {
            crate::error::RepositoryLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl RepositoryLimitExceededException {
    /// Creates a new builder-style object to manufacture [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException)
    pub fn builder() -> crate::error::repository_limit_exceeded_exception::Builder {
        crate::error::repository_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NumberOfRulesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NumberOfRulesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NumberOfRulesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NumberOfRulesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NumberOfRulesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NumberOfRulesExceededException")?;
        if let Some(inner_159) = &self.message {
            write!(f, ": {}", inner_159)?;
        }
        Ok(())
    }
}
impl std::error::Error for NumberOfRulesExceededException {}
/// See [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException)
pub mod number_of_rules_exceeded_exception {
    /// A builder for [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException)
        pub fn build(self) -> crate::error::NumberOfRulesExceededException {
            crate::error::NumberOfRulesExceededException {
                message: self.message,
            }
        }
    }
}
impl NumberOfRulesExceededException {
    /// Creates a new builder-style object to manufacture [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException)
    pub fn builder() -> crate::error::number_of_rules_exceeded_exception::Builder {
        crate::error::number_of_rules_exceeded_exception::Builder::default()
    }
}

/// <p>An approval rule with that name already exists. Approval rule names must be unique within the scope of a pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ApprovalRuleNameAlreadyExistsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ApprovalRuleNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ApprovalRuleNameAlreadyExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ApprovalRuleNameAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleNameAlreadyExistsException")?;
        if let Some(inner_160) = &self.message {
            write!(f, ": {}", inner_160)?;
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleNameAlreadyExistsException {}
/// See [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException)
pub mod approval_rule_name_already_exists_exception {
    /// A builder for [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException)
        pub fn build(self) -> crate::error::ApprovalRuleNameAlreadyExistsException {
            crate::error::ApprovalRuleNameAlreadyExistsException {
                message: self.message,
            }
        }
    }
}
impl ApprovalRuleNameAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException)
    pub fn builder() -> crate::error::approval_rule_name_already_exists_exception::Builder {
        crate::error::approval_rule_name_already_exists_exception::Builder::default()
    }
}

/// <p>An array of target objects is required. It cannot be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetsRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetsRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetsRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetsRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetsRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetsRequiredException")?;
        if let Some(inner_161) = &self.message {
            write!(f, ": {}", inner_161)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetsRequiredException {}
/// See [`TargetsRequiredException`](crate::error::TargetsRequiredException)
pub mod targets_required_exception {
    /// A builder for [`TargetsRequiredException`](crate::error::TargetsRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetsRequiredException`](crate::error::TargetsRequiredException)
        pub fn build(self) -> crate::error::TargetsRequiredException {
            crate::error::TargetsRequiredException {
                message: self.message,
            }
        }
    }
}
impl TargetsRequiredException {
    /// Creates a new builder-style object to manufacture [`TargetsRequiredException`](crate::error::TargetsRequiredException)
    pub fn builder() -> crate::error::targets_required_exception::Builder {
        crate::error::targets_required_exception::Builder::default()
    }
}

/// <p>A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct TargetRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for TargetRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("TargetRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl TargetRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetRequiredException")?;
        if let Some(inner_162) = &self.message {
            write!(f, ": {}", inner_162)?;
        }
        Ok(())
    }
}
impl std::error::Error for TargetRequiredException {}
/// See [`TargetRequiredException`](crate::error::TargetRequiredException)
pub mod target_required_exception {
    /// A builder for [`TargetRequiredException`](crate::error::TargetRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`TargetRequiredException`](crate::error::TargetRequiredException)
        pub fn build(self) -> crate::error::TargetRequiredException {
            crate::error::TargetRequiredException {
                message: self.message,
            }
        }
    }
}
impl TargetRequiredException {
    /// Creates a new builder-style object to manufacture [`TargetRequiredException`](crate::error::TargetRequiredException)
    pub fn builder() -> crate::error::target_required_exception::Builder {
        crate::error::target_required_exception::Builder::default()
    }
}

/// <p>The source branch and destination branch for the pull request are the same. You must specify different branches for the source and destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceAndDestinationAreSameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SourceAndDestinationAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceAndDestinationAreSameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SourceAndDestinationAreSameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceAndDestinationAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceAndDestinationAreSameException")?;
        if let Some(inner_163) = &self.message {
            write!(f, ": {}", inner_163)?;
        }
        Ok(())
    }
}
impl std::error::Error for SourceAndDestinationAreSameException {}
/// See [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException)
pub mod source_and_destination_are_same_exception {
    /// A builder for [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException)
        pub fn build(self) -> crate::error::SourceAndDestinationAreSameException {
            crate::error::SourceAndDestinationAreSameException {
                message: self.message,
            }
        }
    }
}
impl SourceAndDestinationAreSameException {
    /// Creates a new builder-style object to manufacture [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException)
    pub fn builder() -> crate::error::source_and_destination_are_same_exception::Builder {
        crate::error::source_and_destination_are_same_exception::Builder::default()
    }
}

/// <p>The specified reference is not a supported type. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceTypeNotSupportedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReferenceTypeNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceTypeNotSupportedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReferenceTypeNotSupportedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReferenceTypeNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReferenceTypeNotSupportedException")?;
        if let Some(inner_164) = &self.message {
            write!(f, ": {}", inner_164)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReferenceTypeNotSupportedException {}
/// See [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException)
pub mod reference_type_not_supported_exception {
    /// A builder for [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException)
        pub fn build(self) -> crate::error::ReferenceTypeNotSupportedException {
            crate::error::ReferenceTypeNotSupportedException {
                message: self.message,
            }
        }
    }
}
impl ReferenceTypeNotSupportedException {
    /// Creates a new builder-style object to manufacture [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException)
    pub fn builder() -> crate::error::reference_type_not_supported_exception::Builder {
        crate::error::reference_type_not_supported_exception::Builder::default()
    }
}

/// <p>A reference name is required, but none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct ReferenceNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for ReferenceNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("ReferenceNameRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl ReferenceNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReferenceNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReferenceNameRequiredException")?;
        if let Some(inner_165) = &self.message {
            write!(f, ": {}", inner_165)?;
        }
        Ok(())
    }
}
impl std::error::Error for ReferenceNameRequiredException {}
/// See [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException)
pub mod reference_name_required_exception {
    /// A builder for [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException)
        pub fn build(self) -> crate::error::ReferenceNameRequiredException {
            crate::error::ReferenceNameRequiredException {
                message: self.message,
            }
        }
    }
}
impl ReferenceNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException)
    pub fn builder() -> crate::error::reference_name_required_exception::Builder {
        crate::error::reference_name_required_exception::Builder::default()
    }
}

/// <p>You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MultipleRepositoriesInPullRequestException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MultipleRepositoriesInPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MultipleRepositoriesInPullRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MultipleRepositoriesInPullRequestException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MultipleRepositoriesInPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MultipleRepositoriesInPullRequestException")?;
        if let Some(inner_166) = &self.message {
            write!(f, ": {}", inner_166)?;
        }
        Ok(())
    }
}
impl std::error::Error for MultipleRepositoriesInPullRequestException {}
/// See [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException)
pub mod multiple_repositories_in_pull_request_exception {
    /// A builder for [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException)
        pub fn build(self) -> crate::error::MultipleRepositoriesInPullRequestException {
            crate::error::MultipleRepositoriesInPullRequestException {
                message: self.message,
            }
        }
    }
}
impl MultipleRepositoriesInPullRequestException {
    /// Creates a new builder-style object to manufacture [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException)
    pub fn builder() -> crate::error::multiple_repositories_in_pull_request_exception::Builder {
        crate::error::multiple_repositories_in_pull_request_exception::Builder::default()
    }
}

/// <p>You cannot create the pull request because the repository has too many open pull requests. The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumOpenPullRequestsExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumOpenPullRequestsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumOpenPullRequestsExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumOpenPullRequestsExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumOpenPullRequestsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumOpenPullRequestsExceededException")?;
        if let Some(inner_167) = &self.message {
            write!(f, ": {}", inner_167)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumOpenPullRequestsExceededException {}
/// See [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException)
pub mod maximum_open_pull_requests_exceeded_exception {
    /// A builder for [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException)
        pub fn build(self) -> crate::error::MaximumOpenPullRequestsExceededException {
            crate::error::MaximumOpenPullRequestsExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumOpenPullRequestsExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException)
    pub fn builder() -> crate::error::maximum_open_pull_requests_exceeded_exception::Builder {
        crate::error::maximum_open_pull_requests_exceeded_exception::Builder::default()
    }
}

/// <p>The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for the repository name, source branch, and destination branch for a pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTargetsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTargetsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTargetsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTargetsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetsException")?;
        if let Some(inner_168) = &self.message {
            write!(f, ": {}", inner_168)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetsException {}
/// See [`InvalidTargetsException`](crate::error::InvalidTargetsException)
pub mod invalid_targets_exception {
    /// A builder for [`InvalidTargetsException`](crate::error::InvalidTargetsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetsException`](crate::error::InvalidTargetsException)
        pub fn build(self) -> crate::error::InvalidTargetsException {
            crate::error::InvalidTargetsException {
                message: self.message,
            }
        }
    }
}
impl InvalidTargetsException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetsException`](crate::error::InvalidTargetsException)
    pub fn builder() -> crate::error::invalid_targets_exception::Builder {
        crate::error::invalid_targets_exception::Builder::default()
    }
}

/// <p>The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidTargetException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidTargetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidTargetException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidTargetException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetException")?;
        if let Some(inner_169) = &self.message {
            write!(f, ": {}", inner_169)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetException {}
/// See [`InvalidTargetException`](crate::error::InvalidTargetException)
pub mod invalid_target_exception {
    /// A builder for [`InvalidTargetException`](crate::error::InvalidTargetException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetException`](crate::error::InvalidTargetException)
        pub fn build(self) -> crate::error::InvalidTargetException {
            crate::error::InvalidTargetException {
                message: self.message,
            }
        }
    }
}
impl InvalidTargetException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetException`](crate::error::InvalidTargetException)
    pub fn builder() -> crate::error::invalid_target_exception::Builder {
        crate::error::invalid_target_exception::Builder::default()
    }
}

/// <p>The specified reference name format is not valid. Reference names must conform to the Git references format (for example, refs/heads/master). For more information, see <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">Git Internals - Git References</a> or consult your Git documentation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct InvalidReferenceNameException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for InvalidReferenceNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("InvalidReferenceNameException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl InvalidReferenceNameException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReferenceNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReferenceNameException")?;
        if let Some(inner_170) = &self.message {
            write!(f, ": {}", inner_170)?;
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReferenceNameException {}
/// See [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException)
pub mod invalid_reference_name_exception {
    /// A builder for [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException)
        pub fn build(self) -> crate::error::InvalidReferenceNameException {
            crate::error::InvalidReferenceNameException {
                message: self.message,
            }
        }
    }
}
impl InvalidReferenceNameException {
    /// Creates a new builder-style object to manufacture [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException)
    pub fn builder() -> crate::error::invalid_reference_name_exception::Builder {
        crate::error::invalid_reference_name_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because no source files or file content have been specified for the commit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SourceFileOrContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SourceFileOrContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SourceFileOrContentRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SourceFileOrContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceFileOrContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceFileOrContentRequiredException")?;
        if let Some(inner_171) = &self.message {
            write!(f, ": {}", inner_171)?;
        }
        Ok(())
    }
}
impl std::error::Error for SourceFileOrContentRequiredException {}
/// See [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException)
pub mod source_file_or_content_required_exception {
    /// A builder for [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException)
        pub fn build(self) -> crate::error::SourceFileOrContentRequiredException {
            crate::error::SourceFileOrContentRequiredException {
                message: self.message,
            }
        }
    }
}
impl SourceFileOrContentRequiredException {
    /// Creates a new builder-style object to manufacture [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException)
    pub fn builder() -> crate::error::source_file_or_content_required_exception::Builder {
        crate::error::source_file_or_content_required_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct SamePathRequestException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for SamePathRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("SamePathRequestException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl SamePathRequestException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SamePathRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SamePathRequestException")?;
        if let Some(inner_172) = &self.message {
            write!(f, ": {}", inner_172)?;
        }
        Ok(())
    }
}
impl std::error::Error for SamePathRequestException {}
/// See [`SamePathRequestException`](crate::error::SamePathRequestException)
pub mod same_path_request_exception {
    /// A builder for [`SamePathRequestException`](crate::error::SamePathRequestException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`SamePathRequestException`](crate::error::SamePathRequestException)
        pub fn build(self) -> crate::error::SamePathRequestException {
            crate::error::SamePathRequestException {
                message: self.message,
            }
        }
    }
}
impl SamePathRequestException {
    /// Creates a new builder-style object to manufacture [`SamePathRequestException`](crate::error::SamePathRequestException)
    pub fn builder() -> crate::error::same_path_request_exception::Builder {
        crate::error::same_path_request_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RestrictedSourceFileException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RestrictedSourceFileException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RestrictedSourceFileException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RestrictedSourceFileException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RestrictedSourceFileException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RestrictedSourceFileException")?;
        if let Some(inner_173) = &self.message {
            write!(f, ": {}", inner_173)?;
        }
        Ok(())
    }
}
impl std::error::Error for RestrictedSourceFileException {}
/// See [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException)
pub mod restricted_source_file_exception {
    /// A builder for [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException)
        pub fn build(self) -> crate::error::RestrictedSourceFileException {
            crate::error::RestrictedSourceFileException {
                message: self.message,
            }
        }
    }
}
impl RestrictedSourceFileException {
    /// Creates a new builder-style object to manufacture [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException)
    pub fn builder() -> crate::error::restricted_source_file_exception::Builder {
        crate::error::restricted_source_file_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because one or more files specified in the commit reference both a file and a folder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct PutFileEntryConflictException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for PutFileEntryConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("PutFileEntryConflictException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl PutFileEntryConflictException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PutFileEntryConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PutFileEntryConflictException")?;
        if let Some(inner_174) = &self.message {
            write!(f, ": {}", inner_174)?;
        }
        Ok(())
    }
}
impl std::error::Error for PutFileEntryConflictException {}
/// See [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException)
pub mod put_file_entry_conflict_exception {
    /// A builder for [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException)
        pub fn build(self) -> crate::error::PutFileEntryConflictException {
            crate::error::PutFileEntryConflictException {
                message: self.message,
            }
        }
    }
}
impl PutFileEntryConflictException {
    /// Creates a new builder-style object to manufacture [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException)
    pub fn builder() -> crate::error::put_file_entry_conflict_exception::Builder {
        crate::error::put_file_entry_conflict_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NoChangeException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NoChangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NoChangeException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NoChangeException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoChangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoChangeException")?;
        if let Some(inner_175) = &self.message {
            write!(f, ": {}", inner_175)?;
        }
        Ok(())
    }
}
impl std::error::Error for NoChangeException {}
/// See [`NoChangeException`](crate::error::NoChangeException)
pub mod no_change_exception {
    /// A builder for [`NoChangeException`](crate::error::NoChangeException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NoChangeException`](crate::error::NoChangeException)
        pub fn build(self) -> crate::error::NoChangeException {
            crate::error::NoChangeException {
                message: self.message,
            }
        }
    }
}
impl NoChangeException {
    /// Creates a new builder-style object to manufacture [`NoChangeException`](crate::error::NoChangeException)
    pub fn builder() -> crate::error::no_change_exception::Builder {
        crate::error::no_change_exception::Builder::default()
    }
}

/// <p>The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumFileEntriesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumFileEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumFileEntriesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumFileEntriesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumFileEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumFileEntriesExceededException")?;
        if let Some(inner_176) = &self.message {
            write!(f, ": {}", inner_176)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumFileEntriesExceededException {}
/// See [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException)
pub mod maximum_file_entries_exceeded_exception {
    /// A builder for [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException)
        pub fn build(self) -> crate::error::MaximumFileEntriesExceededException {
            crate::error::MaximumFileEntriesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumFileEntriesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException)
    pub fn builder() -> crate::error::maximum_file_entries_exceeded_exception::Builder {
        crate::error::maximum_file_entries_exceeded_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileEntryRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileEntryRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileEntryRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileEntryRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileEntryRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileEntryRequiredException")?;
        if let Some(inner_177) = &self.message {
            write!(f, ": {}", inner_177)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileEntryRequiredException {}
/// See [`FileEntryRequiredException`](crate::error::FileEntryRequiredException)
pub mod file_entry_required_exception {
    /// A builder for [`FileEntryRequiredException`](crate::error::FileEntryRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileEntryRequiredException`](crate::error::FileEntryRequiredException)
        pub fn build(self) -> crate::error::FileEntryRequiredException {
            crate::error::FileEntryRequiredException {
                message: self.message,
            }
        }
    }
}
impl FileEntryRequiredException {
    /// Creates a new builder-style object to manufacture [`FileEntryRequiredException`](crate::error::FileEntryRequiredException)
    pub fn builder() -> crate::error::file_entry_required_exception::Builder {
        crate::error::file_entry_required_exception::Builder::default()
    }
}

/// <p>The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct FileContentAndSourceFileSpecifiedException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for FileContentAndSourceFileSpecifiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("FileContentAndSourceFileSpecifiedException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl FileContentAndSourceFileSpecifiedException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileContentAndSourceFileSpecifiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileContentAndSourceFileSpecifiedException")?;
        if let Some(inner_178) = &self.message {
            write!(f, ": {}", inner_178)?;
        }
        Ok(())
    }
}
impl std::error::Error for FileContentAndSourceFileSpecifiedException {}
/// See [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException)
pub mod file_content_and_source_file_specified_exception {
    /// A builder for [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException)
        pub fn build(self) -> crate::error::FileContentAndSourceFileSpecifiedException {
            crate::error::FileContentAndSourceFileSpecifiedException {
                message: self.message,
            }
        }
    }
}
impl FileContentAndSourceFileSpecifiedException {
    /// Creates a new builder-style object to manufacture [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException)
    pub fn builder() -> crate::error::file_content_and_source_file_specified_exception::Builder {
        crate::error::file_content_and_source_file_specified_exception::Builder::default()
    }
}

/// <p>Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name. Branch names must be unique.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct BranchNameExistsException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for BranchNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("BranchNameExistsException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl BranchNameExistsException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchNameExistsException")?;
        if let Some(inner_179) = &self.message {
            write!(f, ": {}", inner_179)?;
        }
        Ok(())
    }
}
impl std::error::Error for BranchNameExistsException {}
/// See [`BranchNameExistsException`](crate::error::BranchNameExistsException)
pub mod branch_name_exists_exception {
    /// A builder for [`BranchNameExistsException`](crate::error::BranchNameExistsException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`BranchNameExistsException`](crate::error::BranchNameExistsException)
        pub fn build(self) -> crate::error::BranchNameExistsException {
            crate::error::BranchNameExistsException {
                message: self.message,
            }
        }
    }
}
impl BranchNameExistsException {
    /// Creates a new builder-style object to manufacture [`BranchNameExistsException`](crate::error::BranchNameExistsException)
    pub fn builder() -> crate::error::branch_name_exists_exception::Builder {
        crate::error::branch_name_exists_exception::Builder::default()
    }
}

/// <p>The maximum number of approval rule templates has been exceeded for this AWS Region. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct NumberOfRuleTemplatesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for NumberOfRuleTemplatesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("NumberOfRuleTemplatesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl NumberOfRuleTemplatesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NumberOfRuleTemplatesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NumberOfRuleTemplatesExceededException")?;
        if let Some(inner_180) = &self.message {
            write!(f, ": {}", inner_180)?;
        }
        Ok(())
    }
}
impl std::error::Error for NumberOfRuleTemplatesExceededException {}
/// See [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException)
pub mod number_of_rule_templates_exceeded_exception {
    /// A builder for [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException)
        pub fn build(self) -> crate::error::NumberOfRuleTemplatesExceededException {
            crate::error::NumberOfRuleTemplatesExceededException {
                message: self.message,
            }
        }
    }
}
impl NumberOfRuleTemplatesExceededException {
    /// Creates a new builder-style object to manufacture [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException)
    pub fn builder() -> crate::error::number_of_rule_templates_exceeded_exception::Builder {
        crate::error::number_of_rule_templates_exceeded_exception::Builder::default()
    }
}

/// <p>At least one repository name object is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct RepositoryNamesRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for RepositoryNamesRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("RepositoryNamesRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl RepositoryNamesRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNamesRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNamesRequiredException")?;
        if let Some(inner_181) = &self.message {
            write!(f, ": {}", inner_181)?;
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNamesRequiredException {}
/// See [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException)
pub mod repository_names_required_exception {
    /// A builder for [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException)
        pub fn build(self) -> crate::error::RepositoryNamesRequiredException {
            crate::error::RepositoryNamesRequiredException {
                message: self.message,
            }
        }
    }
}
impl RepositoryNamesRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException)
    pub fn builder() -> crate::error::repository_names_required_exception::Builder {
        crate::error::repository_names_required_exception::Builder::default()
    }
}

/// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumRepositoryNamesExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumRepositoryNamesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumRepositoryNamesExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumRepositoryNamesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumRepositoryNamesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumRepositoryNamesExceededException")?;
        if let Some(inner_182) = &self.message {
            write!(f, ": {}", inner_182)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumRepositoryNamesExceededException {}
/// See [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException)
pub mod maximum_repository_names_exceeded_exception {
    /// A builder for [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException)
        pub fn build(self) -> crate::error::MaximumRepositoryNamesExceededException {
            crate::error::MaximumRepositoryNamesExceededException {
                message: self.message,
            }
        }
    }
}
impl MaximumRepositoryNamesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException)
    pub fn builder() -> crate::error::maximum_repository_names_exceeded_exception::Builder {
        crate::error::maximum_repository_names_exceeded_exception::Builder::default()
    }
}

/// <p>A list of commit IDs is required, but was either not specified or the list was empty.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitIdsListRequiredException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitIdsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitIdsListRequiredException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitIdsListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdsListRequiredException")?;
        if let Some(inner_183) = &self.message {
            write!(f, ": {}", inner_183)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdsListRequiredException {}
/// See [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException)
pub mod commit_ids_list_required_exception {
    /// A builder for [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException)
        pub fn build(self) -> crate::error::CommitIdsListRequiredException {
            crate::error::CommitIdsListRequiredException {
                message: self.message,
            }
        }
    }
}
impl CommitIdsListRequiredException {
    /// Creates a new builder-style object to manufacture [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException)
    pub fn builder() -> crate::error::commit_ids_list_required_exception::Builder {
        crate::error::commit_ids_list_required_exception::Builder::default()
    }
}

/// <p>The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct CommitIdsLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for CommitIdsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("CommitIdsLimitExceededException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl CommitIdsLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdsLimitExceededException")?;
        if let Some(inner_184) = &self.message {
            write!(f, ": {}", inner_184)?;
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdsLimitExceededException {}
/// See [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException)
pub mod commit_ids_limit_exceeded_exception {
    /// A builder for [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException)
        pub fn build(self) -> crate::error::CommitIdsLimitExceededException {
            crate::error::CommitIdsLimitExceededException {
                message: self.message,
            }
        }
    }
}
impl CommitIdsLimitExceededException {
    /// Creates a new builder-style object to manufacture [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException)
    pub fn builder() -> crate::error::commit_ids_limit_exceeded_exception::Builder {
        crate::error::commit_ids_limit_exceeded_exception::Builder::default()
    }
}

/// <p>The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25 approval rule templates with a repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq)]
pub struct MaximumRuleTemplatesAssociatedWithRepositoryException {
    /// <p>Any message associated with the exception.</p>
    pub message: std::option::Option<std::string::String>,
}
impl std::fmt::Debug for MaximumRuleTemplatesAssociatedWithRepositoryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut formatter = f.debug_struct("MaximumRuleTemplatesAssociatedWithRepositoryException");
        formatter.field("message", &self.message);
        formatter.finish()
    }
}
impl MaximumRuleTemplatesAssociatedWithRepositoryException {
    /// Returns the error message.
    pub fn message(&self) -> Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumRuleTemplatesAssociatedWithRepositoryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumRuleTemplatesAssociatedWithRepositoryException")?;
        if let Some(inner_185) = &self.message {
            write!(f, ": {}", inner_185)?;
        }
        Ok(())
    }
}
impl std::error::Error for MaximumRuleTemplatesAssociatedWithRepositoryException {}
/// See [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException)
pub mod maximum_rule_templates_associated_with_repository_exception {
    /// A builder for [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException)
    #[non_exhaustive]
    #[derive(std::default::Default, std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Consumes the builder and constructs a [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException)
        pub fn build(self) -> crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException {
            crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException {
                message: self.message,
            }
        }
    }
}
impl MaximumRuleTemplatesAssociatedWithRepositoryException {
    /// Creates a new builder-style object to manufacture [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException)
    pub fn builder(
    ) -> crate::error::maximum_rule_templates_associated_with_repository_exception::Builder {
        crate::error::maximum_rule_templates_associated_with_repository_exception::Builder::default(
        )
    }
}
