// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateRepositoryNameErrorKind = UpdateRepositoryNameError;
/// Error type for the `UpdateRepositoryNameError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRepositoryNameError {
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>The specified repository name already exists.</p>
    RepositoryNameExistsException(crate::error::RepositoryNameExistsException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateRepositoryNameError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateRepositoryNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameExistsException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateRepositoryNameError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateRepositoryNameError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRepositoryNameError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRepositoryNameError {
    /// Creates the `UpdateRepositoryNameError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateRepositoryNameError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameExistsException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateRepositoryNameError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryNameError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryNameError::RepositoryNameExistsException`.
    pub fn is_repository_name_exists_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameExistsException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryNameError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for UpdateRepositoryNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameExistsException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A repository name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryNameRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException).
    pub fn builder() -> crate::error::repository_name_required_exception::Builder {
        crate::error::repository_name_required_exception::Builder::default()
    }
}
/// See [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException).
pub mod repository_name_required_exception {

    /// A builder for [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNameRequiredException`](crate::error::RepositoryNameRequiredException).
        pub fn build(self) -> crate::error::RepositoryNameRequiredException {
            crate::error::RepositoryNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNameRequiredException")?;
        if let Some(inner_1) = &self.message {
            {
                write!(f, ": {}", inner_1)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::RepositoryNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RepositoryNameRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified repository name already exists.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryNameExistsException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryNameExistsException {
    /// Creates a new builder-style object to manufacture [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException).
    pub fn builder() -> crate::error::repository_name_exists_exception::Builder {
        crate::error::repository_name_exists_exception::Builder::default()
    }
}
/// See [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException).
pub mod repository_name_exists_exception {

    /// A builder for [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNameExistsException`](crate::error::RepositoryNameExistsException).
        pub fn build(self) -> crate::error::RepositoryNameExistsException {
            crate::error::RepositoryNameExistsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryNameExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNameExistsException")?;
        if let Some(inner_2) = &self.message {
            {
                write!(f, ": {}", inner_2)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNameExistsException {}
impl aws_http::request_id::RequestId for crate::error::RepositoryNameExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RepositoryNameExistsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified repository does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException).
    pub fn builder() -> crate::error::repository_does_not_exist_exception::Builder {
        crate::error::repository_does_not_exist_exception::Builder::default()
    }
}
/// See [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException).
pub mod repository_does_not_exist_exception {

    /// A builder for [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryDoesNotExistException`](crate::error::RepositoryDoesNotExistException).
        pub fn build(self) -> crate::error::RepositoryDoesNotExistException {
            crate::error::RepositoryDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryDoesNotExistException")?;
        if let Some(inner_3) = &self.message {
            {
                write!(f, ": {}", inner_3)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::RepositoryDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RepositoryDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A specified repository name is not valid.</p> <note>
/// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
/// </note>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRepositoryNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRepositoryNameException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException).
    pub fn builder() -> crate::error::invalid_repository_name_exception::Builder {
        crate::error::invalid_repository_name_exception::Builder::default()
    }
}
/// See [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException).
pub mod invalid_repository_name_exception {

    /// A builder for [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryNameException`](crate::error::InvalidRepositoryNameException).
        pub fn build(self) -> crate::error::InvalidRepositoryNameException {
            crate::error::InvalidRepositoryNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRepositoryNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryNameException")?;
        if let Some(inner_4) = &self.message {
            {
                write!(f, ": {}", inner_4)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRepositoryNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRepositoryNameException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateRepositoryDescriptionErrorKind = UpdateRepositoryDescriptionError;
/// Error type for the `UpdateRepositoryDescriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateRepositoryDescriptionError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified repository description is not valid.</p>
    InvalidRepositoryDescriptionException(crate::error::InvalidRepositoryDescriptionException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateRepositoryDescriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateRepositoryDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryDescriptionException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateRepositoryDescriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryDescriptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateRepositoryDescriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateRepositoryDescriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateRepositoryDescriptionError {
    /// Creates the `UpdateRepositoryDescriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateRepositoryDescriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryDescriptionException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionError::InvalidRepositoryDescriptionException`.
    pub fn is_invalid_repository_description_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryDescriptionException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateRepositoryDescriptionError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for UpdateRepositoryDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryDescriptionException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified repository description is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRepositoryDescriptionException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRepositoryDescriptionException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException).
    pub fn builder() -> crate::error::invalid_repository_description_exception::Builder {
        crate::error::invalid_repository_description_exception::Builder::default()
    }
}
/// See [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException).
pub mod invalid_repository_description_exception {

    /// A builder for [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryDescriptionException`](crate::error::InvalidRepositoryDescriptionException).
        pub fn build(self) -> crate::error::InvalidRepositoryDescriptionException {
            crate::error::InvalidRepositoryDescriptionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRepositoryDescriptionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryDescriptionException")?;
        if let Some(inner_5) = &self.message {
            {
                write!(f, ": {}", inner_5)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryDescriptionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRepositoryDescriptionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidRepositoryDescriptionException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The encryption key is not available.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionKeyUnavailableException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EncryptionKeyUnavailableException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException).
    pub fn builder() -> crate::error::encryption_key_unavailable_exception::Builder {
        crate::error::encryption_key_unavailable_exception::Builder::default()
    }
}
/// See [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException).
pub mod encryption_key_unavailable_exception {

    /// A builder for [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyUnavailableException`](crate::error::EncryptionKeyUnavailableException).
        pub fn build(self) -> crate::error::EncryptionKeyUnavailableException {
            crate::error::EncryptionKeyUnavailableException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl EncryptionKeyUnavailableException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyUnavailableException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyUnavailableException")?;
        if let Some(inner_6) = &self.message {
            {
                write!(f, ": {}", inner_6)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyUnavailableException {}
impl aws_http::request_id::RequestId for crate::error::EncryptionKeyUnavailableException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EncryptionKeyUnavailableException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>No encryption key was found.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionKeyNotFoundException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EncryptionKeyNotFoundException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException).
    pub fn builder() -> crate::error::encryption_key_not_found_exception::Builder {
        crate::error::encryption_key_not_found_exception::Builder::default()
    }
}
/// See [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException).
pub mod encryption_key_not_found_exception {

    /// A builder for [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyNotFoundException`](crate::error::EncryptionKeyNotFoundException).
        pub fn build(self) -> crate::error::EncryptionKeyNotFoundException {
            crate::error::EncryptionKeyNotFoundException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl EncryptionKeyNotFoundException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyNotFoundException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyNotFoundException")?;
        if let Some(inner_7) = &self.message {
            {
                write!(f, ": {}", inner_7)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyNotFoundException {}
impl aws_http::request_id::RequestId for crate::error::EncryptionKeyNotFoundException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EncryptionKeyNotFoundException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The encryption key is disabled.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionKeyDisabledException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EncryptionKeyDisabledException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException).
    pub fn builder() -> crate::error::encryption_key_disabled_exception::Builder {
        crate::error::encryption_key_disabled_exception::Builder::default()
    }
}
/// See [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException).
pub mod encryption_key_disabled_exception {

    /// A builder for [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyDisabledException`](crate::error::EncryptionKeyDisabledException).
        pub fn build(self) -> crate::error::EncryptionKeyDisabledException {
            crate::error::EncryptionKeyDisabledException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl EncryptionKeyDisabledException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyDisabledException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyDisabledException")?;
        if let Some(inner_8) = &self.message {
            {
                write!(f, ": {}", inner_8)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyDisabledException {}
impl aws_http::request_id::RequestId for crate::error::EncryptionKeyDisabledException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for EncryptionKeyDisabledException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An encryption key could not be accessed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionKeyAccessDeniedException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EncryptionKeyAccessDeniedException {
    /// Creates a new builder-style object to manufacture [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException).
    pub fn builder() -> crate::error::encryption_key_access_denied_exception::Builder {
        crate::error::encryption_key_access_denied_exception::Builder::default()
    }
}
/// See [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException).
pub mod encryption_key_access_denied_exception {

    /// A builder for [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionKeyAccessDeniedException`](crate::error::EncryptionKeyAccessDeniedException).
        pub fn build(self) -> crate::error::EncryptionKeyAccessDeniedException {
            crate::error::EncryptionKeyAccessDeniedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl EncryptionKeyAccessDeniedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionKeyAccessDeniedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionKeyAccessDeniedException")?;
        if let Some(inner_9) = &self.message {
            {
                write!(f, ": {}", inner_9)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionKeyAccessDeniedException {}
impl aws_http::request_id::RequestId for crate::error::EncryptionKeyAccessDeniedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EncryptionKeyAccessDeniedException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An encryption integrity check failed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct EncryptionIntegrityChecksFailedException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl EncryptionIntegrityChecksFailedException {
    /// Creates a new builder-style object to manufacture [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException).
    pub fn builder() -> crate::error::encryption_integrity_checks_failed_exception::Builder {
        crate::error::encryption_integrity_checks_failed_exception::Builder::default()
    }
}
/// See [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException).
pub mod encryption_integrity_checks_failed_exception {

    /// A builder for [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`EncryptionIntegrityChecksFailedException`](crate::error::EncryptionIntegrityChecksFailedException).
        pub fn build(self) -> crate::error::EncryptionIntegrityChecksFailedException {
            crate::error::EncryptionIntegrityChecksFailedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl EncryptionIntegrityChecksFailedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for EncryptionIntegrityChecksFailedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "EncryptionIntegrityChecksFailedException")?;
        if let Some(inner_10) = &self.message {
            {
                write!(f, ": {}", inner_10)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for EncryptionIntegrityChecksFailedException {}
impl aws_http::request_id::RequestId for crate::error::EncryptionIntegrityChecksFailedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EncryptionIntegrityChecksFailedException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdatePullRequestTitleErrorKind = UpdatePullRequestTitleError;
/// Error type for the `UpdatePullRequestTitleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestTitleError {
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
    InvalidTitleException(crate::error::InvalidTitleException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A pull request title is required. It cannot be empty or null.</p>
    TitleRequiredException(crate::error::TitleRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePullRequestTitleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdatePullRequestTitleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidTitleException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::TitleRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdatePullRequestTitleError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTitleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TitleRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdatePullRequestTitleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestTitleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestTitleError {
    /// Creates the `UpdatePullRequestTitleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdatePullRequestTitleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidTitleException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::TitleRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleError::InvalidTitleException`.
    pub fn is_invalid_title_exception(&self) -> bool {
        matches!(self, Self::InvalidTitleException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestTitleError::TitleRequiredException`.
    pub fn is_title_required_exception(&self) -> bool {
        matches!(self, Self::TitleRequiredException(_))
    }
}
impl std::error::Error for UpdatePullRequestTitleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidTitleException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::TitleRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A pull request title is required. It cannot be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TitleRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TitleRequiredException {
    /// Creates a new builder-style object to manufacture [`TitleRequiredException`](crate::error::TitleRequiredException).
    pub fn builder() -> crate::error::title_required_exception::Builder {
        crate::error::title_required_exception::Builder::default()
    }
}
/// See [`TitleRequiredException`](crate::error::TitleRequiredException).
pub mod title_required_exception {

    /// A builder for [`TitleRequiredException`](crate::error::TitleRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TitleRequiredException`](crate::error::TitleRequiredException).
        pub fn build(self) -> crate::error::TitleRequiredException {
            crate::error::TitleRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TitleRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TitleRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TitleRequiredException")?;
        if let Some(inner_11) = &self.message {
            {
                write!(f, ": {}", inner_11)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TitleRequiredException {}
impl aws_http::request_id::RequestId for crate::error::TitleRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TitleRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A pull request ID is required, but none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PullRequestIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PullRequestIdRequiredException {
    /// Creates a new builder-style object to manufacture [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException).
    pub fn builder() -> crate::error::pull_request_id_required_exception::Builder {
        crate::error::pull_request_id_required_exception::Builder::default()
    }
}
/// See [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException).
pub mod pull_request_id_required_exception {

    /// A builder for [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestIdRequiredException`](crate::error::PullRequestIdRequiredException).
        pub fn build(self) -> crate::error::PullRequestIdRequiredException {
            crate::error::PullRequestIdRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PullRequestIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestIdRequiredException")?;
        if let Some(inner_12) = &self.message {
            {
                write!(f, ": {}", inner_12)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestIdRequiredException {}
impl aws_http::request_id::RequestId for crate::error::PullRequestIdRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PullRequestIdRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PullRequestDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PullRequestDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException).
    pub fn builder() -> crate::error::pull_request_does_not_exist_exception::Builder {
        crate::error::pull_request_does_not_exist_exception::Builder::default()
    }
}
/// See [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException).
pub mod pull_request_does_not_exist_exception {

    /// A builder for [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestDoesNotExistException`](crate::error::PullRequestDoesNotExistException).
        pub fn build(self) -> crate::error::PullRequestDoesNotExistException {
            crate::error::PullRequestDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PullRequestDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestDoesNotExistException")?;
        if let Some(inner_13) = &self.message {
            {
                write!(f, ": {}", inner_13)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::PullRequestDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PullRequestDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The pull request status cannot be updated because it is already closed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PullRequestAlreadyClosedException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PullRequestAlreadyClosedException {
    /// Creates a new builder-style object to manufacture [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException).
    pub fn builder() -> crate::error::pull_request_already_closed_exception::Builder {
        crate::error::pull_request_already_closed_exception::Builder::default()
    }
}
/// See [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException).
pub mod pull_request_already_closed_exception {

    /// A builder for [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestAlreadyClosedException`](crate::error::PullRequestAlreadyClosedException).
        pub fn build(self) -> crate::error::PullRequestAlreadyClosedException {
            crate::error::PullRequestAlreadyClosedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PullRequestAlreadyClosedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestAlreadyClosedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestAlreadyClosedException")?;
        if let Some(inner_14) = &self.message {
            {
                write!(f, ": {}", inner_14)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestAlreadyClosedException {}
impl aws_http::request_id::RequestId for crate::error::PullRequestAlreadyClosedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PullRequestAlreadyClosedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTitleException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTitleException {
    /// Creates a new builder-style object to manufacture [`InvalidTitleException`](crate::error::InvalidTitleException).
    pub fn builder() -> crate::error::invalid_title_exception::Builder {
        crate::error::invalid_title_exception::Builder::default()
    }
}
/// See [`InvalidTitleException`](crate::error::InvalidTitleException).
pub mod invalid_title_exception {

    /// A builder for [`InvalidTitleException`](crate::error::InvalidTitleException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTitleException`](crate::error::InvalidTitleException).
        pub fn build(self) -> crate::error::InvalidTitleException {
            crate::error::InvalidTitleException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidTitleException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTitleException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTitleException")?;
        if let Some(inner_15) = &self.message {
            {
                write!(f, ": {}", inner_15)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTitleException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTitleException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTitleException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPullRequestIdException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPullRequestIdException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException).
    pub fn builder() -> crate::error::invalid_pull_request_id_exception::Builder {
        crate::error::invalid_pull_request_id_exception::Builder::default()
    }
}
/// See [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException).
pub mod invalid_pull_request_id_exception {

    /// A builder for [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestIdException`](crate::error::InvalidPullRequestIdException).
        pub fn build(self) -> crate::error::InvalidPullRequestIdException {
            crate::error::InvalidPullRequestIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidPullRequestIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestIdException")?;
        if let Some(inner_16) = &self.message {
            {
                write!(f, ": {}", inner_16)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestIdException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPullRequestIdException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidPullRequestIdException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdatePullRequestStatusErrorKind = UpdatePullRequestStatusError;
/// Error type for the `UpdatePullRequestStatusError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestStatusError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
    InvalidPullRequestStatusException(crate::error::InvalidPullRequestStatusException),
    /// <p>The pull request status update is not valid. The only valid update is from <code>OPEN</code> to <code>CLOSED</code>.</p>
    InvalidPullRequestStatusUpdateException(crate::error::InvalidPullRequestStatusUpdateException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A pull request status is required, but none was provided.</p>
    PullRequestStatusRequiredException(crate::error::PullRequestStatusRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePullRequestStatusError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdatePullRequestStatusError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestStatusException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestStatusUpdateException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::PullRequestStatusRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdatePullRequestStatusError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestStatusUpdateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestStatusRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdatePullRequestStatusError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestStatusError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestStatusError {
    /// Creates the `UpdatePullRequestStatusError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdatePullRequestStatusError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidPullRequestStatusException(e) => e.meta(),
            Self::InvalidPullRequestStatusUpdateException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::PullRequestStatusRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::InvalidPullRequestStatusException`.
    pub fn is_invalid_pull_request_status_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestStatusException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::InvalidPullRequestStatusUpdateException`.
    pub fn is_invalid_pull_request_status_update_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestStatusUpdateException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestStatusError::PullRequestStatusRequiredException`.
    pub fn is_pull_request_status_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestStatusRequiredException(_))
    }
}
impl std::error::Error for UpdatePullRequestStatusError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidPullRequestStatusException(_inner) => Some(_inner),
            Self::InvalidPullRequestStatusUpdateException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::PullRequestStatusRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A pull request status is required, but none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PullRequestStatusRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PullRequestStatusRequiredException {
    /// Creates a new builder-style object to manufacture [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException).
    pub fn builder() -> crate::error::pull_request_status_required_exception::Builder {
        crate::error::pull_request_status_required_exception::Builder::default()
    }
}
/// See [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException).
pub mod pull_request_status_required_exception {

    /// A builder for [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestStatusRequiredException`](crate::error::PullRequestStatusRequiredException).
        pub fn build(self) -> crate::error::PullRequestStatusRequiredException {
            crate::error::PullRequestStatusRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PullRequestStatusRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestStatusRequiredException")?;
        if let Some(inner_17) = &self.message {
            {
                write!(f, ": {}", inner_17)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestStatusRequiredException {}
impl aws_http::request_id::RequestId for crate::error::PullRequestStatusRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for PullRequestStatusRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The pull request status update is not valid. The only valid update is from <code>OPEN</code> to <code>CLOSED</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPullRequestStatusUpdateException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPullRequestStatusUpdateException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException).
    pub fn builder() -> crate::error::invalid_pull_request_status_update_exception::Builder {
        crate::error::invalid_pull_request_status_update_exception::Builder::default()
    }
}
/// See [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException).
pub mod invalid_pull_request_status_update_exception {

    /// A builder for [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestStatusUpdateException`](crate::error::InvalidPullRequestStatusUpdateException).
        pub fn build(self) -> crate::error::InvalidPullRequestStatusUpdateException {
            crate::error::InvalidPullRequestStatusUpdateException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidPullRequestStatusUpdateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestStatusUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestStatusUpdateException")?;
        if let Some(inner_18) = &self.message {
            {
                write!(f, ": {}", inner_18)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestStatusUpdateException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPullRequestStatusUpdateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidPullRequestStatusUpdateException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPullRequestStatusException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPullRequestStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException).
    pub fn builder() -> crate::error::invalid_pull_request_status_exception::Builder {
        crate::error::invalid_pull_request_status_exception::Builder::default()
    }
}
/// See [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException).
pub mod invalid_pull_request_status_exception {

    /// A builder for [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestStatusException`](crate::error::InvalidPullRequestStatusException).
        pub fn build(self) -> crate::error::InvalidPullRequestStatusException {
            crate::error::InvalidPullRequestStatusException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidPullRequestStatusException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestStatusException")?;
        if let Some(inner_19) = &self.message {
            {
                write!(f, ": {}", inner_19)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestStatusException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPullRequestStatusException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidPullRequestStatusException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdatePullRequestDescriptionErrorKind = UpdatePullRequestDescriptionError;
/// Error type for the `UpdatePullRequestDescriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestDescriptionError {
    /// <p>The pull request description is not valid. Descriptions cannot be more than 1,000 characters.</p>
    InvalidDescriptionException(crate::error::InvalidDescriptionException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePullRequestDescriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdatePullRequestDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidDescriptionException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdatePullRequestDescriptionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidDescriptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdatePullRequestDescriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestDescriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestDescriptionError {
    /// Creates the `UpdatePullRequestDescriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdatePullRequestDescriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidDescriptionException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionError::InvalidDescriptionException`.
    pub fn is_invalid_description_exception(&self) -> bool {
        matches!(self, Self::InvalidDescriptionException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestDescriptionError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
}
impl std::error::Error for UpdatePullRequestDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidDescriptionException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The pull request description is not valid. Descriptions cannot be more than 1,000 characters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDescriptionException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDescriptionException {
    /// Creates a new builder-style object to manufacture [`InvalidDescriptionException`](crate::error::InvalidDescriptionException).
    pub fn builder() -> crate::error::invalid_description_exception::Builder {
        crate::error::invalid_description_exception::Builder::default()
    }
}
/// See [`InvalidDescriptionException`](crate::error::InvalidDescriptionException).
pub mod invalid_description_exception {

    /// A builder for [`InvalidDescriptionException`](crate::error::InvalidDescriptionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDescriptionException`](crate::error::InvalidDescriptionException).
        pub fn build(self) -> crate::error::InvalidDescriptionException {
            crate::error::InvalidDescriptionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDescriptionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDescriptionException")?;
        if let Some(inner_20) = &self.message {
            {
                write!(f, ": {}", inner_20)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDescriptionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDescriptionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDescriptionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdatePullRequestApprovalStateErrorKind = UpdatePullRequestApprovalStateError;
/// Error type for the `UpdatePullRequestApprovalStateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestApprovalStateError {
    /// <p>An approval state is required, but was not specified.</p>
    ApprovalStateRequiredException(crate::error::ApprovalStateRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The state for the approval is not valid. Valid values include APPROVE and REVOKE. </p>
    InvalidApprovalStateException(crate::error::InvalidApprovalStateException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The number of approvals required for the approval rule exceeds the maximum number allowed.</p>
    MaximumNumberOfApprovalsExceededException(
        crate::error::MaximumNumberOfApprovalsExceededException,
    ),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull request that you created.</p>
    PullRequestCannotBeApprovedByAuthorException(
        crate::error::PullRequestCannotBeApprovedByAuthorException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePullRequestApprovalStateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdatePullRequestApprovalStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalStateRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalStateException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionIdException(_inner) => _inner.fmt(f),
            Self::MaximumNumberOfApprovalsExceededException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestCannotBeApprovedByAuthorException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::RevisionIdRequiredException(_inner) => _inner.fmt(f),
            Self::RevisionNotCurrentException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdatePullRequestApprovalStateError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalStateRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalStateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRevisionIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumNumberOfApprovalsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestCannotBeApprovedByAuthorException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionNotCurrentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdatePullRequestApprovalStateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestApprovalStateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestApprovalStateError {
    /// Creates the `UpdatePullRequestApprovalStateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdatePullRequestApprovalStateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalStateRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidApprovalStateException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidRevisionIdException(e) => e.meta(),
            Self::MaximumNumberOfApprovalsExceededException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestCannotBeApprovedByAuthorException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::RevisionIdRequiredException(e) => e.meta(),
            Self::RevisionNotCurrentException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::ApprovalStateRequiredException`.
    pub fn is_approval_state_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalStateRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::InvalidApprovalStateException`.
    pub fn is_invalid_approval_state_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalStateException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionIdException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::MaximumNumberOfApprovalsExceededException`.
    pub fn is_maximum_number_of_approvals_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumNumberOfApprovalsExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::PullRequestCannotBeApprovedByAuthorException`.
    pub fn is_pull_request_cannot_be_approved_by_author_exception(&self) -> bool {
        matches!(self, Self::PullRequestCannotBeApprovedByAuthorException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(self, Self::RevisionIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalStateError::RevisionNotCurrentException`.
    pub fn is_revision_not_current_exception(&self) -> bool {
        matches!(self, Self::RevisionNotCurrentException(_))
    }
}
impl std::error::Error for UpdatePullRequestApprovalStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalStateRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidApprovalStateException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidRevisionIdException(_inner) => Some(_inner),
            Self::MaximumNumberOfApprovalsExceededException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestCannotBeApprovedByAuthorException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::RevisionIdRequiredException(_inner) => Some(_inner),
            Self::RevisionNotCurrentException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RevisionNotCurrentException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RevisionNotCurrentException {
    /// Creates a new builder-style object to manufacture [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException).
    pub fn builder() -> crate::error::revision_not_current_exception::Builder {
        crate::error::revision_not_current_exception::Builder::default()
    }
}
/// See [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException).
pub mod revision_not_current_exception {

    /// A builder for [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RevisionNotCurrentException`](crate::error::RevisionNotCurrentException).
        pub fn build(self) -> crate::error::RevisionNotCurrentException {
            crate::error::RevisionNotCurrentException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RevisionNotCurrentException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RevisionNotCurrentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RevisionNotCurrentException")?;
        if let Some(inner_21) = &self.message {
            {
                write!(f, ": {}", inner_21)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RevisionNotCurrentException {}
impl aws_http::request_id::RequestId for crate::error::RevisionNotCurrentException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RevisionNotCurrentException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A revision ID is required, but was not provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RevisionIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RevisionIdRequiredException {
    /// Creates a new builder-style object to manufacture [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException).
    pub fn builder() -> crate::error::revision_id_required_exception::Builder {
        crate::error::revision_id_required_exception::Builder::default()
    }
}
/// See [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException).
pub mod revision_id_required_exception {

    /// A builder for [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RevisionIdRequiredException`](crate::error::RevisionIdRequiredException).
        pub fn build(self) -> crate::error::RevisionIdRequiredException {
            crate::error::RevisionIdRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RevisionIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RevisionIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RevisionIdRequiredException")?;
        if let Some(inner_22) = &self.message {
            {
                write!(f, ": {}", inner_22)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RevisionIdRequiredException {}
impl aws_http::request_id::RequestId for crate::error::RevisionIdRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RevisionIdRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The approval cannot be applied because the user approving the pull request matches the user who created the pull request. You cannot approve a pull request that you created.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PullRequestCannotBeApprovedByAuthorException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PullRequestCannotBeApprovedByAuthorException {
    /// Creates a new builder-style object to manufacture [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException).
    pub fn builder() -> crate::error::pull_request_cannot_be_approved_by_author_exception::Builder {
        crate::error::pull_request_cannot_be_approved_by_author_exception::Builder::default()
    }
}
/// See [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException).
pub mod pull_request_cannot_be_approved_by_author_exception {

    /// A builder for [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestCannotBeApprovedByAuthorException`](crate::error::PullRequestCannotBeApprovedByAuthorException).
        pub fn build(self) -> crate::error::PullRequestCannotBeApprovedByAuthorException {
            crate::error::PullRequestCannotBeApprovedByAuthorException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PullRequestCannotBeApprovedByAuthorException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestCannotBeApprovedByAuthorException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestCannotBeApprovedByAuthorException")?;
        if let Some(inner_23) = &self.message {
            {
                write!(f, ": {}", inner_23)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestCannotBeApprovedByAuthorException {}
impl aws_http::request_id::RequestId
    for crate::error::PullRequestCannotBeApprovedByAuthorException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for PullRequestCannotBeApprovedByAuthorException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of approvals required for the approval rule exceeds the maximum number allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumNumberOfApprovalsExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumNumberOfApprovalsExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException).
    pub fn builder() -> crate::error::maximum_number_of_approvals_exceeded_exception::Builder {
        crate::error::maximum_number_of_approvals_exceeded_exception::Builder::default()
    }
}
/// See [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException).
pub mod maximum_number_of_approvals_exceeded_exception {

    /// A builder for [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumNumberOfApprovalsExceededException`](crate::error::MaximumNumberOfApprovalsExceededException).
        pub fn build(self) -> crate::error::MaximumNumberOfApprovalsExceededException {
            crate::error::MaximumNumberOfApprovalsExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumNumberOfApprovalsExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumNumberOfApprovalsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumNumberOfApprovalsExceededException")?;
        if let Some(inner_24) = &self.message {
            {
                write!(f, ": {}", inner_24)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumNumberOfApprovalsExceededException {}
impl aws_http::request_id::RequestId for crate::error::MaximumNumberOfApprovalsExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MaximumNumberOfApprovalsExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRevisionIdException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRevisionIdException {
    /// Creates a new builder-style object to manufacture [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException).
    pub fn builder() -> crate::error::invalid_revision_id_exception::Builder {
        crate::error::invalid_revision_id_exception::Builder::default()
    }
}
/// See [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException).
pub mod invalid_revision_id_exception {

    /// A builder for [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRevisionIdException`](crate::error::InvalidRevisionIdException).
        pub fn build(self) -> crate::error::InvalidRevisionIdException {
            crate::error::InvalidRevisionIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRevisionIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRevisionIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRevisionIdException")?;
        if let Some(inner_25) = &self.message {
            {
                write!(f, ": {}", inner_25)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRevisionIdException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRevisionIdException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRevisionIdException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The state for the approval is not valid. Valid values include APPROVE and REVOKE. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidApprovalStateException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidApprovalStateException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException).
    pub fn builder() -> crate::error::invalid_approval_state_exception::Builder {
        crate::error::invalid_approval_state_exception::Builder::default()
    }
}
/// See [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException).
pub mod invalid_approval_state_exception {

    /// A builder for [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalStateException`](crate::error::InvalidApprovalStateException).
        pub fn build(self) -> crate::error::InvalidApprovalStateException {
            crate::error::InvalidApprovalStateException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidApprovalStateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalStateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalStateException")?;
        if let Some(inner_26) = &self.message {
            {
                write!(f, ": {}", inner_26)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalStateException {}
impl aws_http::request_id::RequestId for crate::error::InvalidApprovalStateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidApprovalStateException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An approval state is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalStateRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalStateRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException).
    pub fn builder() -> crate::error::approval_state_required_exception::Builder {
        crate::error::approval_state_required_exception::Builder::default()
    }
}
/// See [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException).
pub mod approval_state_required_exception {

    /// A builder for [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalStateRequiredException`](crate::error::ApprovalStateRequiredException).
        pub fn build(self) -> crate::error::ApprovalStateRequiredException {
            crate::error::ApprovalStateRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalStateRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalStateRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalStateRequiredException")?;
        if let Some(inner_27) = &self.message {
            {
                write!(f, ": {}", inner_27)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalStateRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ApprovalStateRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ApprovalStateRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdatePullRequestApprovalRuleContentErrorKind = UpdatePullRequestApprovalRuleContentError;
/// Error type for the `UpdatePullRequestApprovalRuleContentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdatePullRequestApprovalRuleContentError {
    /// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
    ApprovalRuleContentRequiredException(crate::error::ApprovalRuleContentRequiredException),
    /// <p>The specified approval rule does not exist.</p>
    ApprovalRuleDoesNotExistException(crate::error::ApprovalRuleDoesNotExistException),
    /// <p>An approval rule name is required, but was not specified.</p>
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    /// <p>The approval rule cannot be modified for the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
    CannotModifyApprovalRuleFromTemplateException(
        crate::error::CannotModifyApprovalRuleFromTemplateException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The content for the approval rule is not valid.</p>
    InvalidApprovalRuleContentException(crate::error::InvalidApprovalRuleContentException),
    /// <p>The name for the approval rule is not valid.</p>
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The SHA-256 hash signature for the rule content is not valid.</p>
    InvalidRuleContentSha256Exception(crate::error::InvalidRuleContentSha256Exception),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdatePullRequestApprovalRuleContentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdatePullRequestApprovalRuleContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleContentRequiredException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleNameRequiredException(_inner) => _inner.fmt(f),
            Self::CannotModifyApprovalRuleFromTemplateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleContentException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleNameException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidRuleContentSha256Exception(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdatePullRequestApprovalRuleContentError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CannotModifyApprovalRuleFromTemplateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRuleContentSha256Exception(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdatePullRequestApprovalRuleContentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdatePullRequestApprovalRuleContentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdatePullRequestApprovalRuleContentError {
    /// Creates the `UpdatePullRequestApprovalRuleContentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdatePullRequestApprovalRuleContentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleContentRequiredException(e) => e.meta(),
            Self::ApprovalRuleDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleNameRequiredException(e) => e.meta(),
            Self::CannotModifyApprovalRuleFromTemplateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidApprovalRuleContentException(e) => e.meta(),
            Self::InvalidApprovalRuleNameException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidRuleContentSha256Exception(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::ApprovalRuleContentRequiredException`.
    pub fn is_approval_rule_content_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::ApprovalRuleDoesNotExistException`.
    pub fn is_approval_rule_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::ApprovalRuleNameRequiredException`.
    pub fn is_approval_rule_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::CannotModifyApprovalRuleFromTemplateException`.
    pub fn is_cannot_modify_approval_rule_from_template_exception(&self) -> bool {
        matches!(self, Self::CannotModifyApprovalRuleFromTemplateException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::InvalidApprovalRuleContentException`.
    pub fn is_invalid_approval_rule_content_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleContentException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::InvalidApprovalRuleNameException`.
    pub fn is_invalid_approval_rule_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleNameException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::InvalidRuleContentSha256Exception`.
    pub fn is_invalid_rule_content_sha256_exception(&self) -> bool {
        matches!(self, Self::InvalidRuleContentSha256Exception(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdatePullRequestApprovalRuleContentError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
}
impl std::error::Error for UpdatePullRequestApprovalRuleContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleContentRequiredException(_inner) => Some(_inner),
            Self::ApprovalRuleDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleNameRequiredException(_inner) => Some(_inner),
            Self::CannotModifyApprovalRuleFromTemplateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleContentException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleNameException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidRuleContentSha256Exception(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The SHA-256 hash signature for the rule content is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRuleContentSha256Exception {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRuleContentSha256Exception {
    /// Creates a new builder-style object to manufacture [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception).
    pub fn builder() -> crate::error::invalid_rule_content_sha256_exception::Builder {
        crate::error::invalid_rule_content_sha256_exception::Builder::default()
    }
}
/// See [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception).
pub mod invalid_rule_content_sha256_exception {

    /// A builder for [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRuleContentSha256Exception`](crate::error::InvalidRuleContentSha256Exception).
        pub fn build(self) -> crate::error::InvalidRuleContentSha256Exception {
            crate::error::InvalidRuleContentSha256Exception {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRuleContentSha256Exception {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRuleContentSha256Exception {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRuleContentSha256Exception")?;
        if let Some(inner_28) = &self.message {
            {
                write!(f, ": {}", inner_28)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRuleContentSha256Exception {}
impl aws_http::request_id::RequestId for crate::error::InvalidRuleContentSha256Exception {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidRuleContentSha256Exception {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The name for the approval rule is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidApprovalRuleNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidApprovalRuleNameException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException).
    pub fn builder() -> crate::error::invalid_approval_rule_name_exception::Builder {
        crate::error::invalid_approval_rule_name_exception::Builder::default()
    }
}
/// See [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException).
pub mod invalid_approval_rule_name_exception {

    /// A builder for [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleNameException`](crate::error::InvalidApprovalRuleNameException).
        pub fn build(self) -> crate::error::InvalidApprovalRuleNameException {
            crate::error::InvalidApprovalRuleNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidApprovalRuleNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleNameException")?;
        if let Some(inner_29) = &self.message {
            {
                write!(f, ": {}", inner_29)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidApprovalRuleNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidApprovalRuleNameException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The content for the approval rule is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidApprovalRuleContentException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidApprovalRuleContentException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException).
    pub fn builder() -> crate::error::invalid_approval_rule_content_exception::Builder {
        crate::error::invalid_approval_rule_content_exception::Builder::default()
    }
}
/// See [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException).
pub mod invalid_approval_rule_content_exception {

    /// A builder for [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleContentException`](crate::error::InvalidApprovalRuleContentException).
        pub fn build(self) -> crate::error::InvalidApprovalRuleContentException {
            crate::error::InvalidApprovalRuleContentException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidApprovalRuleContentException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleContentException")?;
        if let Some(inner_30) = &self.message {
            {
                write!(f, ": {}", inner_30)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleContentException {}
impl aws_http::request_id::RequestId for crate::error::InvalidApprovalRuleContentException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidApprovalRuleContentException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The approval rule cannot be modified for the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CannotModifyApprovalRuleFromTemplateException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CannotModifyApprovalRuleFromTemplateException {
    /// Creates a new builder-style object to manufacture [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException).
    pub fn builder() -> crate::error::cannot_modify_approval_rule_from_template_exception::Builder {
        crate::error::cannot_modify_approval_rule_from_template_exception::Builder::default()
    }
}
/// See [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException).
pub mod cannot_modify_approval_rule_from_template_exception {

    /// A builder for [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CannotModifyApprovalRuleFromTemplateException`](crate::error::CannotModifyApprovalRuleFromTemplateException).
        pub fn build(self) -> crate::error::CannotModifyApprovalRuleFromTemplateException {
            crate::error::CannotModifyApprovalRuleFromTemplateException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CannotModifyApprovalRuleFromTemplateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CannotModifyApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CannotModifyApprovalRuleFromTemplateException")?;
        if let Some(inner_31) = &self.message {
            {
                write!(f, ": {}", inner_31)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CannotModifyApprovalRuleFromTemplateException {}
impl aws_http::request_id::RequestId
    for crate::error::CannotModifyApprovalRuleFromTemplateException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CannotModifyApprovalRuleFromTemplateException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An approval rule name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalRuleNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException).
    pub fn builder() -> crate::error::approval_rule_name_required_exception::Builder {
        crate::error::approval_rule_name_required_exception::Builder::default()
    }
}
/// See [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException).
pub mod approval_rule_name_required_exception {

    /// A builder for [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleNameRequiredException`](crate::error::ApprovalRuleNameRequiredException).
        pub fn build(self) -> crate::error::ApprovalRuleNameRequiredException {
            crate::error::ApprovalRuleNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalRuleNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleNameRequiredException")?;
        if let Some(inner_32) = &self.message {
            {
                write!(f, ": {}", inner_32)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ApprovalRuleNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ApprovalRuleNameRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified approval rule does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalRuleDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException).
    pub fn builder() -> crate::error::approval_rule_does_not_exist_exception::Builder {
        crate::error::approval_rule_does_not_exist_exception::Builder::default()
    }
}
/// See [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException).
pub mod approval_rule_does_not_exist_exception {

    /// A builder for [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleDoesNotExistException`](crate::error::ApprovalRuleDoesNotExistException).
        pub fn build(self) -> crate::error::ApprovalRuleDoesNotExistException {
            crate::error::ApprovalRuleDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalRuleDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleDoesNotExistException")?;
        if let Some(inner_33) = &self.message {
            {
                write!(f, ": {}", inner_33)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::ApprovalRuleDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ApprovalRuleDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalRuleContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleContentRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException).
    pub fn builder() -> crate::error::approval_rule_content_required_exception::Builder {
        crate::error::approval_rule_content_required_exception::Builder::default()
    }
}
/// See [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException).
pub mod approval_rule_content_required_exception {

    /// A builder for [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleContentRequiredException`](crate::error::ApprovalRuleContentRequiredException).
        pub fn build(self) -> crate::error::ApprovalRuleContentRequiredException {
            crate::error::ApprovalRuleContentRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalRuleContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleContentRequiredException")?;
        if let Some(inner_34) = &self.message {
            {
                write!(f, ": {}", inner_34)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleContentRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ApprovalRuleContentRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ApprovalRuleContentRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateDefaultBranchErrorKind = UpdateDefaultBranchError;
/// Error type for the `UpdateDefaultBranchError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateDefaultBranchError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateDefaultBranchError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateDefaultBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateDefaultBranchError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateDefaultBranchError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateDefaultBranchError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateDefaultBranchError {
    /// Creates the `UpdateDefaultBranchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateDefaultBranchError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateDefaultBranchError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for UpdateDefaultBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => Some(_inner),
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified reference name is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidBranchNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidBranchNameException {
    /// Creates a new builder-style object to manufacture [`InvalidBranchNameException`](crate::error::InvalidBranchNameException).
    pub fn builder() -> crate::error::invalid_branch_name_exception::Builder {
        crate::error::invalid_branch_name_exception::Builder::default()
    }
}
/// See [`InvalidBranchNameException`](crate::error::InvalidBranchNameException).
pub mod invalid_branch_name_exception {

    /// A builder for [`InvalidBranchNameException`](crate::error::InvalidBranchNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidBranchNameException`](crate::error::InvalidBranchNameException).
        pub fn build(self) -> crate::error::InvalidBranchNameException {
            crate::error::InvalidBranchNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidBranchNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidBranchNameException")?;
        if let Some(inner_35) = &self.message {
            {
                write!(f, ": {}", inner_35)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidBranchNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidBranchNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidBranchNameException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A branch name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BranchNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BranchNameRequiredException {
    /// Creates a new builder-style object to manufacture [`BranchNameRequiredException`](crate::error::BranchNameRequiredException).
    pub fn builder() -> crate::error::branch_name_required_exception::Builder {
        crate::error::branch_name_required_exception::Builder::default()
    }
}
/// See [`BranchNameRequiredException`](crate::error::BranchNameRequiredException).
pub mod branch_name_required_exception {

    /// A builder for [`BranchNameRequiredException`](crate::error::BranchNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BranchNameRequiredException`](crate::error::BranchNameRequiredException).
        pub fn build(self) -> crate::error::BranchNameRequiredException {
            crate::error::BranchNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl BranchNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchNameRequiredException")?;
        if let Some(inner_36) = &self.message {
            {
                write!(f, ": {}", inner_36)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BranchNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::BranchNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BranchNameRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified branch does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BranchDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BranchDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException).
    pub fn builder() -> crate::error::branch_does_not_exist_exception::Builder {
        crate::error::branch_does_not_exist_exception::Builder::default()
    }
}
/// See [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException).
pub mod branch_does_not_exist_exception {

    /// A builder for [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BranchDoesNotExistException`](crate::error::BranchDoesNotExistException).
        pub fn build(self) -> crate::error::BranchDoesNotExistException {
            crate::error::BranchDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl BranchDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchDoesNotExistException")?;
        if let Some(inner_37) = &self.message {
            {
                write!(f, ": {}", inner_37)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BranchDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::BranchDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BranchDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateCommentErrorKind = UpdateCommentError;
/// Error type for the `UpdateCommentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateCommentError {
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>You cannot modify or delete this comment. Only comment authors can modify or delete their comments.</p>
    CommentNotCreatedByCallerException(crate::error::CommentNotCreatedByCallerException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateCommentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateCommentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommentContentRequiredException(_inner) => _inner.fmt(f),
            Self::CommentContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::CommentDeletedException(_inner) => _inner.fmt(f),
            Self::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommentIdRequiredException(_inner) => _inner.fmt(f),
            Self::CommentNotCreatedByCallerException(_inner) => _inner.fmt(f),
            Self::InvalidCommentIdException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UpdateCommentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommentContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentDeletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentNotCreatedByCallerException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateCommentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateCommentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateCommentError {
    /// Creates the `UpdateCommentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateCommentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommentContentRequiredException(e) => e.meta(),
            Self::CommentContentSizeLimitExceededException(e) => e.meta(),
            Self::CommentDeletedException(e) => e.meta(),
            Self::CommentDoesNotExistException(e) => e.meta(),
            Self::CommentIdRequiredException(e) => e.meta(),
            Self::CommentNotCreatedByCallerException(e) => e.meta(),
            Self::InvalidCommentIdException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateCommentError::CommentContentRequiredException`.
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(self, Self::CommentContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateCommentError::CommentContentSizeLimitExceededException`.
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommentContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `UpdateCommentError::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(self, Self::CommentDeletedException(_))
    }
    /// Returns `true` if the error kind is `UpdateCommentError::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateCommentError::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(self, Self::CommentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateCommentError::CommentNotCreatedByCallerException`.
    pub fn is_comment_not_created_by_caller_exception(&self) -> bool {
        matches!(self, Self::CommentNotCreatedByCallerException(_))
    }
    /// Returns `true` if the error kind is `UpdateCommentError::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommentIdException(_))
    }
}
impl std::error::Error for UpdateCommentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommentContentRequiredException(_inner) => Some(_inner),
            Self::CommentContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::CommentDeletedException(_inner) => Some(_inner),
            Self::CommentDoesNotExistException(_inner) => Some(_inner),
            Self::CommentIdRequiredException(_inner) => Some(_inner),
            Self::CommentNotCreatedByCallerException(_inner) => Some(_inner),
            Self::InvalidCommentIdException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidCommentIdException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidCommentIdException {
    /// Creates a new builder-style object to manufacture [`InvalidCommentIdException`](crate::error::InvalidCommentIdException).
    pub fn builder() -> crate::error::invalid_comment_id_exception::Builder {
        crate::error::invalid_comment_id_exception::Builder::default()
    }
}
/// See [`InvalidCommentIdException`](crate::error::InvalidCommentIdException).
pub mod invalid_comment_id_exception {

    /// A builder for [`InvalidCommentIdException`](crate::error::InvalidCommentIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommentIdException`](crate::error::InvalidCommentIdException).
        pub fn build(self) -> crate::error::InvalidCommentIdException {
            crate::error::InvalidCommentIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidCommentIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommentIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommentIdException")?;
        if let Some(inner_38) = &self.message {
            {
                write!(f, ": {}", inner_38)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommentIdException {}
impl aws_http::request_id::RequestId for crate::error::InvalidCommentIdException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidCommentIdException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot modify or delete this comment. Only comment authors can modify or delete their comments.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommentNotCreatedByCallerException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommentNotCreatedByCallerException {
    /// Creates a new builder-style object to manufacture [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException).
    pub fn builder() -> crate::error::comment_not_created_by_caller_exception::Builder {
        crate::error::comment_not_created_by_caller_exception::Builder::default()
    }
}
/// See [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException).
pub mod comment_not_created_by_caller_exception {

    /// A builder for [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommentNotCreatedByCallerException`](crate::error::CommentNotCreatedByCallerException).
        pub fn build(self) -> crate::error::CommentNotCreatedByCallerException {
            crate::error::CommentNotCreatedByCallerException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommentNotCreatedByCallerException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentNotCreatedByCallerException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentNotCreatedByCallerException")?;
        if let Some(inner_39) = &self.message {
            {
                write!(f, ": {}", inner_39)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommentNotCreatedByCallerException {}
impl aws_http::request_id::RequestId for crate::error::CommentNotCreatedByCallerException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CommentNotCreatedByCallerException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The comment ID is missing or null. A comment ID is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommentIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommentIdRequiredException {
    /// Creates a new builder-style object to manufacture [`CommentIdRequiredException`](crate::error::CommentIdRequiredException).
    pub fn builder() -> crate::error::comment_id_required_exception::Builder {
        crate::error::comment_id_required_exception::Builder::default()
    }
}
/// See [`CommentIdRequiredException`](crate::error::CommentIdRequiredException).
pub mod comment_id_required_exception {

    /// A builder for [`CommentIdRequiredException`](crate::error::CommentIdRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommentIdRequiredException`](crate::error::CommentIdRequiredException).
        pub fn build(self) -> crate::error::CommentIdRequiredException {
            crate::error::CommentIdRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommentIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentIdRequiredException")?;
        if let Some(inner_40) = &self.message {
            {
                write!(f, ": {}", inner_40)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommentIdRequiredException {}
impl aws_http::request_id::RequestId for crate::error::CommentIdRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommentIdRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommentDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommentDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException).
    pub fn builder() -> crate::error::comment_does_not_exist_exception::Builder {
        crate::error::comment_does_not_exist_exception::Builder::default()
    }
}
/// See [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException).
pub mod comment_does_not_exist_exception {

    /// A builder for [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommentDoesNotExistException`](crate::error::CommentDoesNotExistException).
        pub fn build(self) -> crate::error::CommentDoesNotExistException {
            crate::error::CommentDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommentDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentDoesNotExistException")?;
        if let Some(inner_41) = &self.message {
            {
                write!(f, ": {}", inner_41)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommentDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::CommentDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommentDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommentDeletedException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommentDeletedException {
    /// Creates a new builder-style object to manufacture [`CommentDeletedException`](crate::error::CommentDeletedException).
    pub fn builder() -> crate::error::comment_deleted_exception::Builder {
        crate::error::comment_deleted_exception::Builder::default()
    }
}
/// See [`CommentDeletedException`](crate::error::CommentDeletedException).
pub mod comment_deleted_exception {

    /// A builder for [`CommentDeletedException`](crate::error::CommentDeletedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommentDeletedException`](crate::error::CommentDeletedException).
        pub fn build(self) -> crate::error::CommentDeletedException {
            crate::error::CommentDeletedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommentDeletedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentDeletedException")?;
        if let Some(inner_42) = &self.message {
            {
                write!(f, ": {}", inner_42)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommentDeletedException {}
impl aws_http::request_id::RequestId for crate::error::CommentDeletedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommentDeletedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommentContentSizeLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommentContentSizeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException).
    pub fn builder() -> crate::error::comment_content_size_limit_exceeded_exception::Builder {
        crate::error::comment_content_size_limit_exceeded_exception::Builder::default()
    }
}
/// See [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException).
pub mod comment_content_size_limit_exceeded_exception {

    /// A builder for [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommentContentSizeLimitExceededException`](crate::error::CommentContentSizeLimitExceededException).
        pub fn build(self) -> crate::error::CommentContentSizeLimitExceededException {
            crate::error::CommentContentSizeLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommentContentSizeLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentContentSizeLimitExceededException")?;
        if let Some(inner_43) = &self.message {
            {
                write!(f, ": {}", inner_43)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommentContentSizeLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::CommentContentSizeLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CommentContentSizeLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommentContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommentContentRequiredException {
    /// Creates a new builder-style object to manufacture [`CommentContentRequiredException`](crate::error::CommentContentRequiredException).
    pub fn builder() -> crate::error::comment_content_required_exception::Builder {
        crate::error::comment_content_required_exception::Builder::default()
    }
}
/// See [`CommentContentRequiredException`](crate::error::CommentContentRequiredException).
pub mod comment_content_required_exception {

    /// A builder for [`CommentContentRequiredException`](crate::error::CommentContentRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommentContentRequiredException`](crate::error::CommentContentRequiredException).
        pub fn build(self) -> crate::error::CommentContentRequiredException {
            crate::error::CommentContentRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommentContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommentContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommentContentRequiredException")?;
        if let Some(inner_44) = &self.message {
            {
                write!(f, ": {}", inner_44)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommentContentRequiredException {}
impl aws_http::request_id::RequestId for crate::error::CommentContentRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommentContentRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateApprovalRuleTemplateNameErrorKind = UpdateApprovalRuleTemplateNameError;
/// Error type for the `UpdateApprovalRuleTemplateNameError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApprovalRuleTemplateNameError {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>You cannot create an approval rule template with that name because a template with that name already exists in this AWS Region for your AWS account. Approval rule template names must be unique.</p>
    ApprovalRuleTemplateNameAlreadyExistsException(
        crate::error::ApprovalRuleTemplateNameAlreadyExistsException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateApprovalRuleTemplateNameError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateApprovalRuleTemplateNameError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateApprovalRuleTemplateNameError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateApprovalRuleTemplateNameError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateApprovalRuleTemplateNameError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApprovalRuleTemplateNameError {
    /// Creates the `UpdateApprovalRuleTemplateNameError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateApprovalRuleTemplateNameError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameAlreadyExistsException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateNameAlreadyExistsException`.
    pub fn is_approval_rule_template_name_already_exists_exception(&self) -> bool {
        matches!(
            self,
            Self::ApprovalRuleTemplateNameAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateNameError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
}
impl std::error::Error for UpdateApprovalRuleTemplateNameError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameAlreadyExistsException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidApprovalRuleTemplateNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidApprovalRuleTemplateNameException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException).
    pub fn builder() -> crate::error::invalid_approval_rule_template_name_exception::Builder {
        crate::error::invalid_approval_rule_template_name_exception::Builder::default()
    }
}
/// See [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException).
pub mod invalid_approval_rule_template_name_exception {

    /// A builder for [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleTemplateNameException`](crate::error::InvalidApprovalRuleTemplateNameException).
        pub fn build(self) -> crate::error::InvalidApprovalRuleTemplateNameException {
            crate::error::InvalidApprovalRuleTemplateNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidApprovalRuleTemplateNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleTemplateNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleTemplateNameException")?;
        if let Some(inner_45) = &self.message {
            {
                write!(f, ": {}", inner_45)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleTemplateNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidApprovalRuleTemplateNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidApprovalRuleTemplateNameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An approval rule template name is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalRuleTemplateNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleTemplateNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException).
    pub fn builder() -> crate::error::approval_rule_template_name_required_exception::Builder {
        crate::error::approval_rule_template_name_required_exception::Builder::default()
    }
}
/// See [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException).
pub mod approval_rule_template_name_required_exception {

    /// A builder for [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateNameRequiredException`](crate::error::ApprovalRuleTemplateNameRequiredException).
        pub fn build(self) -> crate::error::ApprovalRuleTemplateNameRequiredException {
            crate::error::ApprovalRuleTemplateNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalRuleTemplateNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateNameRequiredException")?;
        if let Some(inner_46) = &self.message {
            {
                write!(f, ": {}", inner_46)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ApprovalRuleTemplateNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ApprovalRuleTemplateNameRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot create an approval rule template with that name because a template with that name already exists in this AWS Region for your AWS account. Approval rule template names must be unique.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalRuleTemplateNameAlreadyExistsException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleTemplateNameAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException).
    pub fn builder() -> crate::error::approval_rule_template_name_already_exists_exception::Builder
    {
        crate::error::approval_rule_template_name_already_exists_exception::Builder::default()
    }
}
/// See [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException).
pub mod approval_rule_template_name_already_exists_exception {

    /// A builder for [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateNameAlreadyExistsException`](crate::error::ApprovalRuleTemplateNameAlreadyExistsException).
        pub fn build(self) -> crate::error::ApprovalRuleTemplateNameAlreadyExistsException {
            crate::error::ApprovalRuleTemplateNameAlreadyExistsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalRuleTemplateNameAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateNameAlreadyExistsException")?;
        if let Some(inner_47) = &self.message {
            {
                write!(f, ": {}", inner_47)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateNameAlreadyExistsException {}
impl aws_http::request_id::RequestId
    for crate::error::ApprovalRuleTemplateNameAlreadyExistsException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ApprovalRuleTemplateNameAlreadyExistsException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalRuleTemplateDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleTemplateDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException).
    pub fn builder() -> crate::error::approval_rule_template_does_not_exist_exception::Builder {
        crate::error::approval_rule_template_does_not_exist_exception::Builder::default()
    }
}
/// See [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException).
pub mod approval_rule_template_does_not_exist_exception {

    /// A builder for [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateDoesNotExistException`](crate::error::ApprovalRuleTemplateDoesNotExistException).
        pub fn build(self) -> crate::error::ApprovalRuleTemplateDoesNotExistException {
            crate::error::ApprovalRuleTemplateDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalRuleTemplateDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateDoesNotExistException")?;
        if let Some(inner_48) = &self.message {
            {
                write!(f, ": {}", inner_48)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::ApprovalRuleTemplateDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ApprovalRuleTemplateDoesNotExistException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateApprovalRuleTemplateDescriptionErrorKind =
    UpdateApprovalRuleTemplateDescriptionError;
/// Error type for the `UpdateApprovalRuleTemplateDescriptionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApprovalRuleTemplateDescriptionError {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateDescriptionException(
        crate::error::InvalidApprovalRuleTemplateDescriptionException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateApprovalRuleTemplateDescriptionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateApprovalRuleTemplateDescriptionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateDescriptionException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateApprovalRuleTemplateDescriptionError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateDescriptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateApprovalRuleTemplateDescriptionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateApprovalRuleTemplateDescriptionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApprovalRuleTemplateDescriptionError {
    /// Creates the `UpdateApprovalRuleTemplateDescriptionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateApprovalRuleTemplateDescriptionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateDescriptionException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateDescriptionError::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateDescriptionError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateDescriptionError::InvalidApprovalRuleTemplateDescriptionException`.
    pub fn is_invalid_approval_rule_template_description_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidApprovalRuleTemplateDescriptionException(_)
        )
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateDescriptionError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
}
impl std::error::Error for UpdateApprovalRuleTemplateDescriptionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateDescriptionException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidApprovalRuleTemplateDescriptionException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidApprovalRuleTemplateDescriptionException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException).
    pub fn builder() -> crate::error::invalid_approval_rule_template_description_exception::Builder
    {
        crate::error::invalid_approval_rule_template_description_exception::Builder::default()
    }
}
/// See [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException).
pub mod invalid_approval_rule_template_description_exception {

    /// A builder for [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleTemplateDescriptionException`](crate::error::InvalidApprovalRuleTemplateDescriptionException).
        pub fn build(self) -> crate::error::InvalidApprovalRuleTemplateDescriptionException {
            crate::error::InvalidApprovalRuleTemplateDescriptionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidApprovalRuleTemplateDescriptionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleTemplateDescriptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleTemplateDescriptionException")?;
        if let Some(inner_49) = &self.message {
            {
                write!(f, ": {}", inner_49)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleTemplateDescriptionException {}
impl aws_http::request_id::RequestId
    for crate::error::InvalidApprovalRuleTemplateDescriptionException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidApprovalRuleTemplateDescriptionException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UpdateApprovalRuleTemplateContentErrorKind = UpdateApprovalRuleTemplateContentError;
/// Error type for the `UpdateApprovalRuleTemplateContentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UpdateApprovalRuleTemplateContentError {
    /// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
    ApprovalRuleTemplateContentRequiredException(
        crate::error::ApprovalRuleTemplateContentRequiredException,
    ),
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The content of the approval rule template is not valid.</p>
    InvalidApprovalRuleTemplateContentException(
        crate::error::InvalidApprovalRuleTemplateContentException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The SHA-256 hash signature for the rule content is not valid.</p>
    InvalidRuleContentSha256Exception(crate::error::InvalidRuleContentSha256Exception),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UpdateApprovalRuleTemplateContentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UpdateApprovalRuleTemplateContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateContentRequiredException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateContentException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::InvalidRuleContentSha256Exception(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for UpdateApprovalRuleTemplateContentError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRuleContentSha256Exception(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UpdateApprovalRuleTemplateContentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UpdateApprovalRuleTemplateContentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UpdateApprovalRuleTemplateContentError {
    /// Creates the `UpdateApprovalRuleTemplateContentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UpdateApprovalRuleTemplateContentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateContentRequiredException(e) => e.meta(),
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateContentException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::InvalidRuleContentSha256Exception(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateContentRequiredException`.
    pub fn is_approval_rule_template_content_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentError::InvalidApprovalRuleTemplateContentException`.
    pub fn is_invalid_approval_rule_template_content_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateContentException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `UpdateApprovalRuleTemplateContentError::InvalidRuleContentSha256Exception`.
    pub fn is_invalid_rule_content_sha256_exception(&self) -> bool {
        matches!(self, Self::InvalidRuleContentSha256Exception(_))
    }
}
impl std::error::Error for UpdateApprovalRuleTemplateContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateContentRequiredException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateContentException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::InvalidRuleContentSha256Exception(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The content of the approval rule template is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidApprovalRuleTemplateContentException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidApprovalRuleTemplateContentException {
    /// Creates a new builder-style object to manufacture [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException).
    pub fn builder() -> crate::error::invalid_approval_rule_template_content_exception::Builder {
        crate::error::invalid_approval_rule_template_content_exception::Builder::default()
    }
}
/// See [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException).
pub mod invalid_approval_rule_template_content_exception {

    /// A builder for [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidApprovalRuleTemplateContentException`](crate::error::InvalidApprovalRuleTemplateContentException).
        pub fn build(self) -> crate::error::InvalidApprovalRuleTemplateContentException {
            crate::error::InvalidApprovalRuleTemplateContentException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidApprovalRuleTemplateContentException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidApprovalRuleTemplateContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidApprovalRuleTemplateContentException")?;
        if let Some(inner_50) = &self.message {
            {
                write!(f, ": {}", inner_50)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidApprovalRuleTemplateContentException {}
impl aws_http::request_id::RequestId for crate::error::InvalidApprovalRuleTemplateContentException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidApprovalRuleTemplateContentException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalRuleTemplateContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleTemplateContentRequiredException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException).
    pub fn builder() -> crate::error::approval_rule_template_content_required_exception::Builder {
        crate::error::approval_rule_template_content_required_exception::Builder::default()
    }
}
/// See [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException).
pub mod approval_rule_template_content_required_exception {

    /// A builder for [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateContentRequiredException`](crate::error::ApprovalRuleTemplateContentRequiredException).
        pub fn build(self) -> crate::error::ApprovalRuleTemplateContentRequiredException {
            crate::error::ApprovalRuleTemplateContentRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalRuleTemplateContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateContentRequiredException")?;
        if let Some(inner_51) = &self.message {
            {
                write!(f, ": {}", inner_51)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateContentRequiredException {}
impl aws_http::request_id::RequestId
    for crate::error::ApprovalRuleTemplateContentRequiredException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ApprovalRuleTemplateContentRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type UntagResourceErrorKind = UntagResourceError;
/// Error type for the `UntagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum UntagResourceError {
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    /// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    /// <p>The list of tags is not valid.</p>
    InvalidTagKeysListException(crate::error::InvalidTagKeysListException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// <p>A list of tag keys is required. The list cannot be empty or null.</p>
    TagKeysListRequiredException(crate::error::TagKeysListRequiredException),
    /// <p>The tag policy is not valid.</p>
    TagPolicyException(crate::error::TagPolicyException),
    /// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for UntagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for UntagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidResourceArnException(_inner) => _inner.fmt(f),
            Self::InvalidSystemTagUsageException(_inner) => _inner.fmt(f),
            Self::InvalidTagKeysListException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            Self::TagKeysListRequiredException(_inner) => _inner.fmt(f),
            Self::TagPolicyException(_inner) => _inner.fmt(f),
            Self::TooManyTagsException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for UntagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidResourceArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSystemTagUsageException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagKeysListException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagKeysListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagPolicyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTagsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::UntagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for UntagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl UntagResourceError {
    /// Creates the `UntagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `UntagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidResourceArnException(e) => e.meta(),
            Self::InvalidSystemTagUsageException(e) => e.meta(),
            Self::InvalidTagKeysListException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::ResourceArnRequiredException(e) => e.meta(),
            Self::TagKeysListRequiredException(e) => e.meta(),
            Self::TagPolicyException(e) => e.meta(),
            Self::TooManyTagsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidResourceArnException`.
    pub fn is_invalid_resource_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidResourceArnException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidSystemTagUsageException`.
    pub fn is_invalid_system_tag_usage_exception(&self) -> bool {
        matches!(self, Self::InvalidSystemTagUsageException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::InvalidTagKeysListException`.
    pub fn is_invalid_tag_keys_list_exception(&self) -> bool {
        matches!(self, Self::InvalidTagKeysListException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::ResourceArnRequiredException`.
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(self, Self::ResourceArnRequiredException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::TagKeysListRequiredException`.
    pub fn is_tag_keys_list_required_exception(&self) -> bool {
        matches!(self, Self::TagKeysListRequiredException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::TagPolicyException`.
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(self, Self::TagPolicyException(_))
    }
    /// Returns `true` if the error kind is `UntagResourceError::TooManyTagsException`.
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(self, Self::TooManyTagsException(_))
    }
}
impl std::error::Error for UntagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidResourceArnException(_inner) => Some(_inner),
            Self::InvalidSystemTagUsageException(_inner) => Some(_inner),
            Self::InvalidTagKeysListException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::ResourceArnRequiredException(_inner) => Some(_inner),
            Self::TagKeysListRequiredException(_inner) => Some(_inner),
            Self::TagPolicyException(_inner) => Some(_inner),
            Self::TooManyTagsException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TooManyTagsException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TooManyTagsException {
    /// Creates a new builder-style object to manufacture [`TooManyTagsException`](crate::error::TooManyTagsException).
    pub fn builder() -> crate::error::too_many_tags_exception::Builder {
        crate::error::too_many_tags_exception::Builder::default()
    }
}
/// See [`TooManyTagsException`](crate::error::TooManyTagsException).
pub mod too_many_tags_exception {

    /// A builder for [`TooManyTagsException`](crate::error::TooManyTagsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TooManyTagsException`](crate::error::TooManyTagsException).
        pub fn build(self) -> crate::error::TooManyTagsException {
            crate::error::TooManyTagsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TooManyTagsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TooManyTagsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TooManyTagsException")?;
        if let Some(inner_52) = &self.message {
            {
                write!(f, ": {}", inner_52)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TooManyTagsException {}
impl aws_http::request_id::RequestId for crate::error::TooManyTagsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TooManyTagsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The tag policy is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagPolicyException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagPolicyException {
    /// Creates a new builder-style object to manufacture [`TagPolicyException`](crate::error::TagPolicyException).
    pub fn builder() -> crate::error::tag_policy_exception::Builder {
        crate::error::tag_policy_exception::Builder::default()
    }
}
/// See [`TagPolicyException`](crate::error::TagPolicyException).
pub mod tag_policy_exception {

    /// A builder for [`TagPolicyException`](crate::error::TagPolicyException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagPolicyException`](crate::error::TagPolicyException).
        pub fn build(self) -> crate::error::TagPolicyException {
            crate::error::TagPolicyException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TagPolicyException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagPolicyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagPolicyException")?;
        if let Some(inner_53) = &self.message {
            {
                write!(f, ": {}", inner_53)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagPolicyException {}
impl aws_http::request_id::RequestId for crate::error::TagPolicyException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagPolicyException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A list of tag keys is required. The list cannot be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagKeysListRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagKeysListRequiredException {
    /// Creates a new builder-style object to manufacture [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException).
    pub fn builder() -> crate::error::tag_keys_list_required_exception::Builder {
        crate::error::tag_keys_list_required_exception::Builder::default()
    }
}
/// See [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException).
pub mod tag_keys_list_required_exception {

    /// A builder for [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagKeysListRequiredException`](crate::error::TagKeysListRequiredException).
        pub fn build(self) -> crate::error::TagKeysListRequiredException {
            crate::error::TagKeysListRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TagKeysListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagKeysListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagKeysListRequiredException")?;
        if let Some(inner_54) = &self.message {
            {
                write!(f, ": {}", inner_54)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagKeysListRequiredException {}
impl aws_http::request_id::RequestId for crate::error::TagKeysListRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagKeysListRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ResourceArnRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ResourceArnRequiredException {
    /// Creates a new builder-style object to manufacture [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException).
    pub fn builder() -> crate::error::resource_arn_required_exception::Builder {
        crate::error::resource_arn_required_exception::Builder::default()
    }
}
/// See [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException).
pub mod resource_arn_required_exception {

    /// A builder for [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ResourceArnRequiredException`](crate::error::ResourceArnRequiredException).
        pub fn build(self) -> crate::error::ResourceArnRequiredException {
            crate::error::ResourceArnRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ResourceArnRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ResourceArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ResourceArnRequiredException")?;
        if let Some(inner_55) = &self.message {
            {
                write!(f, ": {}", inner_55)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ResourceArnRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ResourceArnRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ResourceArnRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The list of tags is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTagKeysListException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTagKeysListException {
    /// Creates a new builder-style object to manufacture [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException).
    pub fn builder() -> crate::error::invalid_tag_keys_list_exception::Builder {
        crate::error::invalid_tag_keys_list_exception::Builder::default()
    }
}
/// See [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException).
pub mod invalid_tag_keys_list_exception {

    /// A builder for [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagKeysListException`](crate::error::InvalidTagKeysListException).
        pub fn build(self) -> crate::error::InvalidTagKeysListException {
            crate::error::InvalidTagKeysListException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidTagKeysListException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagKeysListException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagKeysListException")?;
        if let Some(inner_56) = &self.message {
            {
                write!(f, ": {}", inner_56)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagKeysListException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTagKeysListException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTagKeysListException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSystemTagUsageException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSystemTagUsageException {
    /// Creates a new builder-style object to manufacture [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException).
    pub fn builder() -> crate::error::invalid_system_tag_usage_exception::Builder {
        crate::error::invalid_system_tag_usage_exception::Builder::default()
    }
}
/// See [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException).
pub mod invalid_system_tag_usage_exception {

    /// A builder for [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSystemTagUsageException`](crate::error::InvalidSystemTagUsageException).
        pub fn build(self) -> crate::error::InvalidSystemTagUsageException {
            crate::error::InvalidSystemTagUsageException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidSystemTagUsageException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSystemTagUsageException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSystemTagUsageException")?;
        if let Some(inner_57) = &self.message {
            {
                write!(f, ": {}", inner_57)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSystemTagUsageException {}
impl aws_http::request_id::RequestId for crate::error::InvalidSystemTagUsageException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSystemTagUsageException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidResourceArnException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidResourceArnException {
    /// Creates a new builder-style object to manufacture [`InvalidResourceArnException`](crate::error::InvalidResourceArnException).
    pub fn builder() -> crate::error::invalid_resource_arn_exception::Builder {
        crate::error::invalid_resource_arn_exception::Builder::default()
    }
}
/// See [`InvalidResourceArnException`](crate::error::InvalidResourceArnException).
pub mod invalid_resource_arn_exception {

    /// A builder for [`InvalidResourceArnException`](crate::error::InvalidResourceArnException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidResourceArnException`](crate::error::InvalidResourceArnException).
        pub fn build(self) -> crate::error::InvalidResourceArnException {
            crate::error::InvalidResourceArnException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidResourceArnException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidResourceArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidResourceArnException")?;
        if let Some(inner_58) = &self.message {
            {
                write!(f, ": {}", inner_58)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidResourceArnException {}
impl aws_http::request_id::RequestId for crate::error::InvalidResourceArnException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidResourceArnException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type TestRepositoryTriggersErrorKind = TestRepositoryTriggersError;
/// Error type for the `TestRepositoryTriggersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TestRepositoryTriggersError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>One or more branch names specified for the trigger is not valid.</p>
    InvalidRepositoryTriggerBranchNameException(
        crate::error::InvalidRepositoryTriggerBranchNameException,
    ),
    /// <p>The custom data provided for the trigger is not valid.</p>
    InvalidRepositoryTriggerCustomDataException(
        crate::error::InvalidRepositoryTriggerCustomDataException,
    ),
    /// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
    InvalidRepositoryTriggerDestinationArnException(
        crate::error::InvalidRepositoryTriggerDestinationArnException,
    ),
    /// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
    InvalidRepositoryTriggerEventsException(crate::error::InvalidRepositoryTriggerEventsException),
    /// <p>The name of the trigger is not valid.</p>
    InvalidRepositoryTriggerNameException(crate::error::InvalidRepositoryTriggerNameException),
    /// <p>The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.</p>
    InvalidRepositoryTriggerRegionException(crate::error::InvalidRepositoryTriggerRegionException),
    /// <p>The number of branches for the trigger was exceeded.</p>
    MaximumBranchesExceededException(crate::error::MaximumBranchesExceededException),
    /// <p>The number of triggers allowed for the repository was exceeded.</p>
    MaximumRepositoryTriggersExceededException(
        crate::error::MaximumRepositoryTriggersExceededException,
    ),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
    RepositoryTriggerBranchNameListRequiredException(
        crate::error::RepositoryTriggerBranchNameListRequiredException,
    ),
    /// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
    RepositoryTriggerDestinationArnRequiredException(
        crate::error::RepositoryTriggerDestinationArnRequiredException,
    ),
    /// <p>At least one event for the trigger is required, but was not specified.</p>
    RepositoryTriggerEventsListRequiredException(
        crate::error::RepositoryTriggerEventsListRequiredException,
    ),
    /// <p>A name for the trigger is required, but was not specified.</p>
    RepositoryTriggerNameRequiredException(crate::error::RepositoryTriggerNameRequiredException),
    /// <p>The list of triggers for the repository is required, but was not specified.</p>
    RepositoryTriggersListRequiredException(crate::error::RepositoryTriggersListRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TestRepositoryTriggersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for TestRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerEventsException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerRegionException(_inner) => _inner.fmt(f),
            Self::MaximumBranchesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumRepositoryTriggersExceededException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerEventsListRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggersListRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TestRepositoryTriggersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerEventsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerRegionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumBranchesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumRepositoryTriggersExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerEventsListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggersListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TestRepositoryTriggersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TestRepositoryTriggersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TestRepositoryTriggersError {
    /// Creates the `TestRepositoryTriggersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `TestRepositoryTriggersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidRepositoryTriggerBranchNameException(e) => e.meta(),
            Self::InvalidRepositoryTriggerCustomDataException(e) => e.meta(),
            Self::InvalidRepositoryTriggerDestinationArnException(e) => e.meta(),
            Self::InvalidRepositoryTriggerEventsException(e) => e.meta(),
            Self::InvalidRepositoryTriggerNameException(e) => e.meta(),
            Self::InvalidRepositoryTriggerRegionException(e) => e.meta(),
            Self::MaximumBranchesExceededException(e) => e.meta(),
            Self::MaximumRepositoryTriggersExceededException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryTriggerBranchNameListRequiredException(e) => e.meta(),
            Self::RepositoryTriggerDestinationArnRequiredException(e) => e.meta(),
            Self::RepositoryTriggerEventsListRequiredException(e) => e.meta(),
            Self::RepositoryTriggerNameRequiredException(e) => e.meta(),
            Self::RepositoryTriggersListRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException`.
    pub fn is_invalid_repository_trigger_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerBranchNameException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException`.
    pub fn is_invalid_repository_trigger_custom_data_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerCustomDataException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException`.
    pub fn is_invalid_repository_trigger_destination_arn_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidRepositoryTriggerDestinationArnException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::InvalidRepositoryTriggerEventsException`.
    pub fn is_invalid_repository_trigger_events_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerEventsException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::InvalidRepositoryTriggerNameException`.
    pub fn is_invalid_repository_trigger_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerNameException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::InvalidRepositoryTriggerRegionException`.
    pub fn is_invalid_repository_trigger_region_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerRegionException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::MaximumBranchesExceededException`.
    pub fn is_maximum_branches_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumBranchesExceededException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::MaximumRepositoryTriggersExceededException`.
    pub fn is_maximum_repository_triggers_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumRepositoryTriggersExceededException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException`.
    pub fn is_repository_trigger_branch_name_list_required_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryTriggerBranchNameListRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException`.
    pub fn is_repository_trigger_destination_arn_required_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryTriggerDestinationArnRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::RepositoryTriggerEventsListRequiredException`.
    pub fn is_repository_trigger_events_list_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerEventsListRequiredException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::RepositoryTriggerNameRequiredException`.
    pub fn is_repository_trigger_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `TestRepositoryTriggersError::RepositoryTriggersListRequiredException`.
    pub fn is_repository_triggers_list_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggersListRequiredException(_))
    }
}
impl std::error::Error for TestRepositoryTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerEventsException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerRegionException(_inner) => Some(_inner),
            Self::MaximumBranchesExceededException(_inner) => Some(_inner),
            Self::MaximumRepositoryTriggersExceededException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerEventsListRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggersListRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The list of triggers for the repository is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryTriggersListRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryTriggersListRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException).
    pub fn builder() -> crate::error::repository_triggers_list_required_exception::Builder {
        crate::error::repository_triggers_list_required_exception::Builder::default()
    }
}
/// See [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException).
pub mod repository_triggers_list_required_exception {

    /// A builder for [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggersListRequiredException`](crate::error::RepositoryTriggersListRequiredException).
        pub fn build(self) -> crate::error::RepositoryTriggersListRequiredException {
            crate::error::RepositoryTriggersListRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryTriggersListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggersListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggersListRequiredException")?;
        if let Some(inner_59) = &self.message {
            {
                write!(f, ": {}", inner_59)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggersListRequiredException {}
impl aws_http::request_id::RequestId for crate::error::RepositoryTriggersListRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RepositoryTriggersListRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A name for the trigger is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryTriggerNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryTriggerNameRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException).
    pub fn builder() -> crate::error::repository_trigger_name_required_exception::Builder {
        crate::error::repository_trigger_name_required_exception::Builder::default()
    }
}
/// See [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException).
pub mod repository_trigger_name_required_exception {

    /// A builder for [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerNameRequiredException`](crate::error::RepositoryTriggerNameRequiredException).
        pub fn build(self) -> crate::error::RepositoryTriggerNameRequiredException {
            crate::error::RepositoryTriggerNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryTriggerNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerNameRequiredException")?;
        if let Some(inner_60) = &self.message {
            {
                write!(f, ": {}", inner_60)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::RepositoryTriggerNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RepositoryTriggerNameRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>At least one event for the trigger is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryTriggerEventsListRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryTriggerEventsListRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException).
    pub fn builder() -> crate::error::repository_trigger_events_list_required_exception::Builder {
        crate::error::repository_trigger_events_list_required_exception::Builder::default()
    }
}
/// See [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException).
pub mod repository_trigger_events_list_required_exception {

    /// A builder for [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerEventsListRequiredException`](crate::error::RepositoryTriggerEventsListRequiredException).
        pub fn build(self) -> crate::error::RepositoryTriggerEventsListRequiredException {
            crate::error::RepositoryTriggerEventsListRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryTriggerEventsListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerEventsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerEventsListRequiredException")?;
        if let Some(inner_61) = &self.message {
            {
                write!(f, ": {}", inner_61)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerEventsListRequiredException {}
impl aws_http::request_id::RequestId
    for crate::error::RepositoryTriggerEventsListRequiredException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RepositoryTriggerEventsListRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryTriggerDestinationArnRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryTriggerDestinationArnRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException).
    pub fn builder() -> crate::error::repository_trigger_destination_arn_required_exception::Builder
    {
        crate::error::repository_trigger_destination_arn_required_exception::Builder::default()
    }
}
/// See [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException).
pub mod repository_trigger_destination_arn_required_exception {

    /// A builder for [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerDestinationArnRequiredException`](crate::error::RepositoryTriggerDestinationArnRequiredException).
        pub fn build(self) -> crate::error::RepositoryTriggerDestinationArnRequiredException {
            crate::error::RepositoryTriggerDestinationArnRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryTriggerDestinationArnRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerDestinationArnRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerDestinationArnRequiredException")?;
        if let Some(inner_62) = &self.message {
            {
                write!(f, ": {}", inner_62)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerDestinationArnRequiredException {}
impl aws_http::request_id::RequestId
    for crate::error::RepositoryTriggerDestinationArnRequiredException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RepositoryTriggerDestinationArnRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryTriggerBranchNameListRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryTriggerBranchNameListRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException).
    pub fn builder() -> crate::error::repository_trigger_branch_name_list_required_exception::Builder
    {
        crate::error::repository_trigger_branch_name_list_required_exception::Builder::default()
    }
}
/// See [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException).
pub mod repository_trigger_branch_name_list_required_exception {

    /// A builder for [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryTriggerBranchNameListRequiredException`](crate::error::RepositoryTriggerBranchNameListRequiredException).
        pub fn build(self) -> crate::error::RepositoryTriggerBranchNameListRequiredException {
            crate::error::RepositoryTriggerBranchNameListRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryTriggerBranchNameListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryTriggerBranchNameListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryTriggerBranchNameListRequiredException")?;
        if let Some(inner_63) = &self.message {
            {
                write!(f, ": {}", inner_63)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryTriggerBranchNameListRequiredException {}
impl aws_http::request_id::RequestId
    for crate::error::RepositoryTriggerBranchNameListRequiredException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RepositoryTriggerBranchNameListRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of triggers allowed for the repository was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumRepositoryTriggersExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumRepositoryTriggersExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException).
    pub fn builder() -> crate::error::maximum_repository_triggers_exceeded_exception::Builder {
        crate::error::maximum_repository_triggers_exceeded_exception::Builder::default()
    }
}
/// See [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException).
pub mod maximum_repository_triggers_exceeded_exception {

    /// A builder for [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumRepositoryTriggersExceededException`](crate::error::MaximumRepositoryTriggersExceededException).
        pub fn build(self) -> crate::error::MaximumRepositoryTriggersExceededException {
            crate::error::MaximumRepositoryTriggersExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumRepositoryTriggersExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumRepositoryTriggersExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumRepositoryTriggersExceededException")?;
        if let Some(inner_64) = &self.message {
            {
                write!(f, ": {}", inner_64)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumRepositoryTriggersExceededException {}
impl aws_http::request_id::RequestId for crate::error::MaximumRepositoryTriggersExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MaximumRepositoryTriggersExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of branches for the trigger was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumBranchesExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumBranchesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException).
    pub fn builder() -> crate::error::maximum_branches_exceeded_exception::Builder {
        crate::error::maximum_branches_exceeded_exception::Builder::default()
    }
}
/// See [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException).
pub mod maximum_branches_exceeded_exception {

    /// A builder for [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumBranchesExceededException`](crate::error::MaximumBranchesExceededException).
        pub fn build(self) -> crate::error::MaximumBranchesExceededException {
            crate::error::MaximumBranchesExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumBranchesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumBranchesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumBranchesExceededException")?;
        if let Some(inner_65) = &self.message {
            {
                write!(f, ": {}", inner_65)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumBranchesExceededException {}
impl aws_http::request_id::RequestId for crate::error::MaximumBranchesExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MaximumBranchesExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRepositoryTriggerRegionException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRepositoryTriggerRegionException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException).
    pub fn builder() -> crate::error::invalid_repository_trigger_region_exception::Builder {
        crate::error::invalid_repository_trigger_region_exception::Builder::default()
    }
}
/// See [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException).
pub mod invalid_repository_trigger_region_exception {

    /// A builder for [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerRegionException`](crate::error::InvalidRepositoryTriggerRegionException).
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerRegionException {
            crate::error::InvalidRepositoryTriggerRegionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRepositoryTriggerRegionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerRegionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerRegionException")?;
        if let Some(inner_66) = &self.message {
            {
                write!(f, ": {}", inner_66)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerRegionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRepositoryTriggerRegionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidRepositoryTriggerRegionException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The name of the trigger is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRepositoryTriggerNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRepositoryTriggerNameException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException).
    pub fn builder() -> crate::error::invalid_repository_trigger_name_exception::Builder {
        crate::error::invalid_repository_trigger_name_exception::Builder::default()
    }
}
/// See [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException).
pub mod invalid_repository_trigger_name_exception {

    /// A builder for [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerNameException`](crate::error::InvalidRepositoryTriggerNameException).
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerNameException {
            crate::error::InvalidRepositoryTriggerNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRepositoryTriggerNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerNameException")?;
        if let Some(inner_67) = &self.message {
            {
                write!(f, ": {}", inner_67)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRepositoryTriggerNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidRepositoryTriggerNameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRepositoryTriggerEventsException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRepositoryTriggerEventsException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException).
    pub fn builder() -> crate::error::invalid_repository_trigger_events_exception::Builder {
        crate::error::invalid_repository_trigger_events_exception::Builder::default()
    }
}
/// See [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException).
pub mod invalid_repository_trigger_events_exception {

    /// A builder for [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerEventsException`](crate::error::InvalidRepositoryTriggerEventsException).
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerEventsException {
            crate::error::InvalidRepositoryTriggerEventsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRepositoryTriggerEventsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerEventsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerEventsException")?;
        if let Some(inner_68) = &self.message {
            {
                write!(f, ": {}", inner_68)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerEventsException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRepositoryTriggerEventsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidRepositoryTriggerEventsException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRepositoryTriggerDestinationArnException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRepositoryTriggerDestinationArnException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException).
    pub fn builder() -> crate::error::invalid_repository_trigger_destination_arn_exception::Builder
    {
        crate::error::invalid_repository_trigger_destination_arn_exception::Builder::default()
    }
}
/// See [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException).
pub mod invalid_repository_trigger_destination_arn_exception {

    /// A builder for [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerDestinationArnException`](crate::error::InvalidRepositoryTriggerDestinationArnException).
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerDestinationArnException {
            crate::error::InvalidRepositoryTriggerDestinationArnException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRepositoryTriggerDestinationArnException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerDestinationArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerDestinationArnException")?;
        if let Some(inner_69) = &self.message {
            {
                write!(f, ": {}", inner_69)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerDestinationArnException {}
impl aws_http::request_id::RequestId
    for crate::error::InvalidRepositoryTriggerDestinationArnException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidRepositoryTriggerDestinationArnException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The custom data provided for the trigger is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRepositoryTriggerCustomDataException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRepositoryTriggerCustomDataException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException).
    pub fn builder() -> crate::error::invalid_repository_trigger_custom_data_exception::Builder {
        crate::error::invalid_repository_trigger_custom_data_exception::Builder::default()
    }
}
/// See [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException).
pub mod invalid_repository_trigger_custom_data_exception {

    /// A builder for [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerCustomDataException`](crate::error::InvalidRepositoryTriggerCustomDataException).
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerCustomDataException {
            crate::error::InvalidRepositoryTriggerCustomDataException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRepositoryTriggerCustomDataException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerCustomDataException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerCustomDataException")?;
        if let Some(inner_70) = &self.message {
            {
                write!(f, ": {}", inner_70)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerCustomDataException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRepositoryTriggerCustomDataException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidRepositoryTriggerCustomDataException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>One or more branch names specified for the trigger is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRepositoryTriggerBranchNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRepositoryTriggerBranchNameException {
    /// Creates a new builder-style object to manufacture [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException).
    pub fn builder() -> crate::error::invalid_repository_trigger_branch_name_exception::Builder {
        crate::error::invalid_repository_trigger_branch_name_exception::Builder::default()
    }
}
/// See [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException).
pub mod invalid_repository_trigger_branch_name_exception {

    /// A builder for [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRepositoryTriggerBranchNameException`](crate::error::InvalidRepositoryTriggerBranchNameException).
        pub fn build(self) -> crate::error::InvalidRepositoryTriggerBranchNameException {
            crate::error::InvalidRepositoryTriggerBranchNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRepositoryTriggerBranchNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRepositoryTriggerBranchNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRepositoryTriggerBranchNameException")?;
        if let Some(inner_71) = &self.message {
            {
                write!(f, ": {}", inner_71)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRepositoryTriggerBranchNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRepositoryTriggerBranchNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidRepositoryTriggerBranchNameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type TagResourceErrorKind = TagResourceError;
/// Error type for the `TagResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum TagResourceError {
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    /// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    /// <p>The map of tags is not valid.</p>
    InvalidTagsMapException(crate::error::InvalidTagsMapException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// <p>The tag policy is not valid.</p>
    TagPolicyException(crate::error::TagPolicyException),
    /// <p>A map of tags is required.</p>
    TagsMapRequiredException(crate::error::TagsMapRequiredException),
    /// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for TagResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for TagResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidResourceArnException(_inner) => _inner.fmt(f),
            Self::InvalidSystemTagUsageException(_inner) => _inner.fmt(f),
            Self::InvalidTagsMapException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            Self::TagPolicyException(_inner) => _inner.fmt(f),
            Self::TagsMapRequiredException(_inner) => _inner.fmt(f),
            Self::TooManyTagsException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidResourceArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSystemTagUsageException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagsMapException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagPolicyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagsMapRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTagsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::TagResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for TagResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl TagResourceError {
    /// Creates the `TagResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `TagResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidResourceArnException(e) => e.meta(),
            Self::InvalidSystemTagUsageException(e) => e.meta(),
            Self::InvalidTagsMapException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::ResourceArnRequiredException(e) => e.meta(),
            Self::TagPolicyException(e) => e.meta(),
            Self::TagsMapRequiredException(e) => e.meta(),
            Self::TooManyTagsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidResourceArnException`.
    pub fn is_invalid_resource_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidResourceArnException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidSystemTagUsageException`.
    pub fn is_invalid_system_tag_usage_exception(&self) -> bool {
        matches!(self, Self::InvalidSystemTagUsageException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::InvalidTagsMapException`.
    pub fn is_invalid_tags_map_exception(&self) -> bool {
        matches!(self, Self::InvalidTagsMapException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::ResourceArnRequiredException`.
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(self, Self::ResourceArnRequiredException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::TagPolicyException`.
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(self, Self::TagPolicyException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::TagsMapRequiredException`.
    pub fn is_tags_map_required_exception(&self) -> bool {
        matches!(self, Self::TagsMapRequiredException(_))
    }
    /// Returns `true` if the error kind is `TagResourceError::TooManyTagsException`.
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(self, Self::TooManyTagsException(_))
    }
}
impl std::error::Error for TagResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidResourceArnException(_inner) => Some(_inner),
            Self::InvalidSystemTagUsageException(_inner) => Some(_inner),
            Self::InvalidTagsMapException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::ResourceArnRequiredException(_inner) => Some(_inner),
            Self::TagPolicyException(_inner) => Some(_inner),
            Self::TagsMapRequiredException(_inner) => Some(_inner),
            Self::TooManyTagsException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A map of tags is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TagsMapRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TagsMapRequiredException {
    /// Creates a new builder-style object to manufacture [`TagsMapRequiredException`](crate::error::TagsMapRequiredException).
    pub fn builder() -> crate::error::tags_map_required_exception::Builder {
        crate::error::tags_map_required_exception::Builder::default()
    }
}
/// See [`TagsMapRequiredException`](crate::error::TagsMapRequiredException).
pub mod tags_map_required_exception {

    /// A builder for [`TagsMapRequiredException`](crate::error::TagsMapRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TagsMapRequiredException`](crate::error::TagsMapRequiredException).
        pub fn build(self) -> crate::error::TagsMapRequiredException {
            crate::error::TagsMapRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TagsMapRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TagsMapRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TagsMapRequiredException")?;
        if let Some(inner_72) = &self.message {
            {
                write!(f, ": {}", inner_72)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TagsMapRequiredException {}
impl aws_http::request_id::RequestId for crate::error::TagsMapRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TagsMapRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The map of tags is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTagsMapException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTagsMapException {
    /// Creates a new builder-style object to manufacture [`InvalidTagsMapException`](crate::error::InvalidTagsMapException).
    pub fn builder() -> crate::error::invalid_tags_map_exception::Builder {
        crate::error::invalid_tags_map_exception::Builder::default()
    }
}
/// See [`InvalidTagsMapException`](crate::error::InvalidTagsMapException).
pub mod invalid_tags_map_exception {

    /// A builder for [`InvalidTagsMapException`](crate::error::InvalidTagsMapException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTagsMapException`](crate::error::InvalidTagsMapException).
        pub fn build(self) -> crate::error::InvalidTagsMapException {
            crate::error::InvalidTagsMapException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidTagsMapException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTagsMapException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTagsMapException")?;
        if let Some(inner_73) = &self.message {
            {
                write!(f, ": {}", inner_73)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTagsMapException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTagsMapException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTagsMapException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PutRepositoryTriggersErrorKind = PutRepositoryTriggersError;
/// Error type for the `PutRepositoryTriggersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRepositoryTriggersError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>One or more branch names specified for the trigger is not valid.</p>
    InvalidRepositoryTriggerBranchNameException(
        crate::error::InvalidRepositoryTriggerBranchNameException,
    ),
    /// <p>The custom data provided for the trigger is not valid.</p>
    InvalidRepositoryTriggerCustomDataException(
        crate::error::InvalidRepositoryTriggerCustomDataException,
    ),
    /// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
    InvalidRepositoryTriggerDestinationArnException(
        crate::error::InvalidRepositoryTriggerDestinationArnException,
    ),
    /// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
    InvalidRepositoryTriggerEventsException(crate::error::InvalidRepositoryTriggerEventsException),
    /// <p>The name of the trigger is not valid.</p>
    InvalidRepositoryTriggerNameException(crate::error::InvalidRepositoryTriggerNameException),
    /// <p>The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.</p>
    InvalidRepositoryTriggerRegionException(crate::error::InvalidRepositoryTriggerRegionException),
    /// <p>The number of branches for the trigger was exceeded.</p>
    MaximumBranchesExceededException(crate::error::MaximumBranchesExceededException),
    /// <p>The number of triggers allowed for the repository was exceeded.</p>
    MaximumRepositoryTriggersExceededException(
        crate::error::MaximumRepositoryTriggersExceededException,
    ),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
    RepositoryTriggerBranchNameListRequiredException(
        crate::error::RepositoryTriggerBranchNameListRequiredException,
    ),
    /// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
    RepositoryTriggerDestinationArnRequiredException(
        crate::error::RepositoryTriggerDestinationArnRequiredException,
    ),
    /// <p>At least one event for the trigger is required, but was not specified.</p>
    RepositoryTriggerEventsListRequiredException(
        crate::error::RepositoryTriggerEventsListRequiredException,
    ),
    /// <p>A name for the trigger is required, but was not specified.</p>
    RepositoryTriggerNameRequiredException(crate::error::RepositoryTriggerNameRequiredException),
    /// <p>The list of triggers for the repository is required, but was not specified.</p>
    RepositoryTriggersListRequiredException(crate::error::RepositoryTriggersListRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PutRepositoryTriggersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PutRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerEventsException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerRegionException(_inner) => _inner.fmt(f),
            Self::MaximumBranchesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumRepositoryTriggersExceededException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerEventsListRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggersListRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PutRepositoryTriggersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerEventsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerRegionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumBranchesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumRepositoryTriggersExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerEventsListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggersListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PutRepositoryTriggersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutRepositoryTriggersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRepositoryTriggersError {
    /// Creates the `PutRepositoryTriggersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PutRepositoryTriggersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidRepositoryTriggerBranchNameException(e) => e.meta(),
            Self::InvalidRepositoryTriggerCustomDataException(e) => e.meta(),
            Self::InvalidRepositoryTriggerDestinationArnException(e) => e.meta(),
            Self::InvalidRepositoryTriggerEventsException(e) => e.meta(),
            Self::InvalidRepositoryTriggerNameException(e) => e.meta(),
            Self::InvalidRepositoryTriggerRegionException(e) => e.meta(),
            Self::MaximumBranchesExceededException(e) => e.meta(),
            Self::MaximumRepositoryTriggersExceededException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryTriggerBranchNameListRequiredException(e) => e.meta(),
            Self::RepositoryTriggerDestinationArnRequiredException(e) => e.meta(),
            Self::RepositoryTriggerEventsListRequiredException(e) => e.meta(),
            Self::RepositoryTriggerNameRequiredException(e) => e.meta(),
            Self::RepositoryTriggersListRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException`.
    pub fn is_invalid_repository_trigger_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerBranchNameException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException`.
    pub fn is_invalid_repository_trigger_custom_data_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerCustomDataException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException`.
    pub fn is_invalid_repository_trigger_destination_arn_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidRepositoryTriggerDestinationArnException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerEventsException`.
    pub fn is_invalid_repository_trigger_events_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerEventsException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerNameException`.
    pub fn is_invalid_repository_trigger_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerNameException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerRegionException`.
    pub fn is_invalid_repository_trigger_region_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerRegionException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::MaximumBranchesExceededException`.
    pub fn is_maximum_branches_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumBranchesExceededException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::MaximumRepositoryTriggersExceededException`.
    pub fn is_maximum_repository_triggers_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumRepositoryTriggersExceededException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException`.
    pub fn is_repository_trigger_branch_name_list_required_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryTriggerBranchNameListRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException`.
    pub fn is_repository_trigger_destination_arn_required_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryTriggerDestinationArnRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerEventsListRequiredException`.
    pub fn is_repository_trigger_events_list_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerEventsListRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerNameRequiredException`.
    pub fn is_repository_trigger_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggersListRequiredException`.
    pub fn is_repository_triggers_list_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggersListRequiredException(_))
    }
}
impl std::error::Error for PutRepositoryTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerEventsException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerRegionException(_inner) => Some(_inner),
            Self::MaximumBranchesExceededException(_inner) => Some(_inner),
            Self::MaximumRepositoryTriggersExceededException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerEventsListRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggersListRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PutFileErrorKind = PutFileError;
/// Error type for the `PutFileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutFileError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
    DirectoryNameConflictsWithFileNameException(
        crate::error::DirectoryNameConflictsWithFileNameException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.</p>
    FileContentRequiredException(crate::error::FileContentRequiredException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
    FileNameConflictsWithDirectoryNameException(
        crate::error::FileNameConflictsWithDirectoryNameException,
    ),
    /// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
    FilePathConflictsWithSubmodulePathException(
        crate::error::FilePathConflictsWithSubmodulePathException,
    ),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified deletion parameter is not valid.</p>
    InvalidDeletionParameterException(crate::error::InvalidDeletionParameterException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.</p>
    SameFileContentException(crate::error::SameFileContentException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PutFileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PutFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentRequiredException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => _inner.fmt(f),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeletionParameterException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::SameFileContentException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PutFileError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameIsTagNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitMessageLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryNameConflictsWithFileNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileNameConflictsWithDirectoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FilePathConflictsWithSubmodulePathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FolderContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeletionParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEmailException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileModeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParentCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NameLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParentCommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParentCommitIdOutdatedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParentCommitIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SameFileContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PutFileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutFileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutFileError {
    /// Creates the `PutFileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PutFileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameIsTagNameException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::DirectoryNameConflictsWithFileNameException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentRequiredException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FileNameConflictsWithDirectoryNameException(e) => e.meta(),
            Self::FilePathConflictsWithSubmodulePathException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidDeletionParameterException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidParentCommitIdException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::ParentCommitDoesNotExistException(e) => e.meta(),
            Self::ParentCommitIdOutdatedException(e) => e.meta(),
            Self::ParentCommitIdRequiredException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::SameFileContentException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PutFileError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(self, Self::BranchNameIsTagNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::DirectoryNameConflictsWithFileNameException`.
    pub fn is_directory_name_conflicts_with_file_name_exception(&self) -> bool {
        matches!(self, Self::DirectoryNameConflictsWithFileNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FileContentRequiredException`.
    pub fn is_file_content_required_exception(&self) -> bool {
        matches!(self, Self::FileContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FileNameConflictsWithDirectoryNameException`.
    pub fn is_file_name_conflicts_with_directory_name_exception(&self) -> bool {
        matches!(self, Self::FileNameConflictsWithDirectoryNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FilePathConflictsWithSubmodulePathException`.
    pub fn is_file_path_conflicts_with_submodule_path_exception(&self) -> bool {
        matches!(self, Self::FilePathConflictsWithSubmodulePathException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidDeletionParameterException`.
    pub fn is_invalid_deletion_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidDeletionParameterException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidParentCommitIdException`.
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidParentCommitIdException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::ParentCommitDoesNotExistException`.
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ParentCommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::ParentCommitIdOutdatedException`.
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdOutdatedException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::ParentCommitIdRequiredException`.
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::SameFileContentException`.
    pub fn is_same_file_content_exception(&self) -> bool {
        matches!(self, Self::SameFileContentException(_))
    }
}
impl std::error::Error for PutFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => Some(_inner),
            Self::BranchNameIsTagNameException(_inner) => Some(_inner),
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::CommitMessageLengthExceededException(_inner) => Some(_inner),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileContentRequiredException(_inner) => Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => Some(_inner),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidDeletionParameterException(_inner) => Some(_inner),
            Self::InvalidEmailException(_inner) => Some(_inner),
            Self::InvalidFileModeException(_inner) => Some(_inner),
            Self::InvalidParentCommitIdException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::NameLengthExceededException(_inner) => Some(_inner),
            Self::ParentCommitDoesNotExistException(_inner) => Some(_inner),
            Self::ParentCommitIdOutdatedException(_inner) => Some(_inner),
            Self::ParentCommitIdRequiredException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::SameFileContentException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SameFileContentException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SameFileContentException {
    /// Creates a new builder-style object to manufacture [`SameFileContentException`](crate::error::SameFileContentException).
    pub fn builder() -> crate::error::same_file_content_exception::Builder {
        crate::error::same_file_content_exception::Builder::default()
    }
}
/// See [`SameFileContentException`](crate::error::SameFileContentException).
pub mod same_file_content_exception {

    /// A builder for [`SameFileContentException`](crate::error::SameFileContentException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SameFileContentException`](crate::error::SameFileContentException).
        pub fn build(self) -> crate::error::SameFileContentException {
            crate::error::SameFileContentException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SameFileContentException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SameFileContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SameFileContentException")?;
        if let Some(inner_74) = &self.message {
            {
                write!(f, ": {}", inner_74)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SameFileContentException {}
impl aws_http::request_id::RequestId for crate::error::SameFileContentException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SameFileContentException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The folderPath for a location cannot be null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PathRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PathRequiredException {
    /// Creates a new builder-style object to manufacture [`PathRequiredException`](crate::error::PathRequiredException).
    pub fn builder() -> crate::error::path_required_exception::Builder {
        crate::error::path_required_exception::Builder::default()
    }
}
/// See [`PathRequiredException`](crate::error::PathRequiredException).
pub mod path_required_exception {

    /// A builder for [`PathRequiredException`](crate::error::PathRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PathRequiredException`](crate::error::PathRequiredException).
        pub fn build(self) -> crate::error::PathRequiredException {
            crate::error::PathRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PathRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PathRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PathRequiredException")?;
        if let Some(inner_75) = &self.message {
            {
                write!(f, ": {}", inner_75)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PathRequiredException {}
impl aws_http::request_id::RequestId for crate::error::PathRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PathRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParentCommitIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ParentCommitIdRequiredException {
    /// Creates a new builder-style object to manufacture [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException).
    pub fn builder() -> crate::error::parent_commit_id_required_exception::Builder {
        crate::error::parent_commit_id_required_exception::Builder::default()
    }
}
/// See [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException).
pub mod parent_commit_id_required_exception {

    /// A builder for [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ParentCommitIdRequiredException`](crate::error::ParentCommitIdRequiredException).
        pub fn build(self) -> crate::error::ParentCommitIdRequiredException {
            crate::error::ParentCommitIdRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ParentCommitIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParentCommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParentCommitIdRequiredException")?;
        if let Some(inner_76) = &self.message {
            {
                write!(f, ": {}", inner_76)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ParentCommitIdRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ParentCommitIdRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ParentCommitIdRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParentCommitIdOutdatedException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ParentCommitIdOutdatedException {
    /// Creates a new builder-style object to manufacture [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException).
    pub fn builder() -> crate::error::parent_commit_id_outdated_exception::Builder {
        crate::error::parent_commit_id_outdated_exception::Builder::default()
    }
}
/// See [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException).
pub mod parent_commit_id_outdated_exception {

    /// A builder for [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ParentCommitIdOutdatedException`](crate::error::ParentCommitIdOutdatedException).
        pub fn build(self) -> crate::error::ParentCommitIdOutdatedException {
            crate::error::ParentCommitIdOutdatedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ParentCommitIdOutdatedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParentCommitIdOutdatedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParentCommitIdOutdatedException")?;
        if let Some(inner_77) = &self.message {
            {
                write!(f, ": {}", inner_77)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ParentCommitIdOutdatedException {}
impl aws_http::request_id::RequestId for crate::error::ParentCommitIdOutdatedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ParentCommitIdOutdatedException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ParentCommitDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ParentCommitDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException).
    pub fn builder() -> crate::error::parent_commit_does_not_exist_exception::Builder {
        crate::error::parent_commit_does_not_exist_exception::Builder::default()
    }
}
/// See [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException).
pub mod parent_commit_does_not_exist_exception {

    /// A builder for [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ParentCommitDoesNotExistException`](crate::error::ParentCommitDoesNotExistException).
        pub fn build(self) -> crate::error::ParentCommitDoesNotExistException {
            crate::error::ParentCommitDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ParentCommitDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ParentCommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ParentCommitDoesNotExistException")?;
        if let Some(inner_78) = &self.message {
            {
                write!(f, ": {}", inner_78)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ParentCommitDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::ParentCommitDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ParentCommitDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NameLengthExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NameLengthExceededException {
    /// Creates a new builder-style object to manufacture [`NameLengthExceededException`](crate::error::NameLengthExceededException).
    pub fn builder() -> crate::error::name_length_exceeded_exception::Builder {
        crate::error::name_length_exceeded_exception::Builder::default()
    }
}
/// See [`NameLengthExceededException`](crate::error::NameLengthExceededException).
pub mod name_length_exceeded_exception {

    /// A builder for [`NameLengthExceededException`](crate::error::NameLengthExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NameLengthExceededException`](crate::error::NameLengthExceededException).
        pub fn build(self) -> crate::error::NameLengthExceededException {
            crate::error::NameLengthExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NameLengthExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NameLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NameLengthExceededException")?;
        if let Some(inner_79) = &self.message {
            {
                write!(f, ": {}", inner_79)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NameLengthExceededException {}
impl aws_http::request_id::RequestId for crate::error::NameLengthExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NameLengthExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified path is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPathException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPathException {
    /// Creates a new builder-style object to manufacture [`InvalidPathException`](crate::error::InvalidPathException).
    pub fn builder() -> crate::error::invalid_path_exception::Builder {
        crate::error::invalid_path_exception::Builder::default()
    }
}
/// See [`InvalidPathException`](crate::error::InvalidPathException).
pub mod invalid_path_exception {

    /// A builder for [`InvalidPathException`](crate::error::InvalidPathException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPathException`](crate::error::InvalidPathException).
        pub fn build(self) -> crate::error::InvalidPathException {
            crate::error::InvalidPathException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidPathException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPathException")?;
        if let Some(inner_80) = &self.message {
            {
                write!(f, ": {}", inner_80)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPathException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPathException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidPathException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidParentCommitIdException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidParentCommitIdException {
    /// Creates a new builder-style object to manufacture [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException).
    pub fn builder() -> crate::error::invalid_parent_commit_id_exception::Builder {
        crate::error::invalid_parent_commit_id_exception::Builder::default()
    }
}
/// See [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException).
pub mod invalid_parent_commit_id_exception {

    /// A builder for [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidParentCommitIdException`](crate::error::InvalidParentCommitIdException).
        pub fn build(self) -> crate::error::InvalidParentCommitIdException {
            crate::error::InvalidParentCommitIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidParentCommitIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidParentCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidParentCommitIdException")?;
        if let Some(inner_81) = &self.message {
            {
                write!(f, ": {}", inner_81)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidParentCommitIdException {}
impl aws_http::request_id::RequestId for crate::error::InvalidParentCommitIdException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidParentCommitIdException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidFileModeException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidFileModeException {
    /// Creates a new builder-style object to manufacture [`InvalidFileModeException`](crate::error::InvalidFileModeException).
    pub fn builder() -> crate::error::invalid_file_mode_exception::Builder {
        crate::error::invalid_file_mode_exception::Builder::default()
    }
}
/// See [`InvalidFileModeException`](crate::error::InvalidFileModeException).
pub mod invalid_file_mode_exception {

    /// A builder for [`InvalidFileModeException`](crate::error::InvalidFileModeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFileModeException`](crate::error::InvalidFileModeException).
        pub fn build(self) -> crate::error::InvalidFileModeException {
            crate::error::InvalidFileModeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidFileModeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFileModeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFileModeException")?;
        if let Some(inner_82) = &self.message {
            {
                write!(f, ": {}", inner_82)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFileModeException {}
impl aws_http::request_id::RequestId for crate::error::InvalidFileModeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidFileModeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidEmailException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidEmailException {
    /// Creates a new builder-style object to manufacture [`InvalidEmailException`](crate::error::InvalidEmailException).
    pub fn builder() -> crate::error::invalid_email_exception::Builder {
        crate::error::invalid_email_exception::Builder::default()
    }
}
/// See [`InvalidEmailException`](crate::error::InvalidEmailException).
pub mod invalid_email_exception {

    /// A builder for [`InvalidEmailException`](crate::error::InvalidEmailException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidEmailException`](crate::error::InvalidEmailException).
        pub fn build(self) -> crate::error::InvalidEmailException {
            crate::error::InvalidEmailException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidEmailException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidEmailException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidEmailException")?;
        if let Some(inner_83) = &self.message {
            {
                write!(f, ": {}", inner_83)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidEmailException {}
impl aws_http::request_id::RequestId for crate::error::InvalidEmailException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidEmailException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified deletion parameter is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDeletionParameterException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDeletionParameterException {
    /// Creates a new builder-style object to manufacture [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException).
    pub fn builder() -> crate::error::invalid_deletion_parameter_exception::Builder {
        crate::error::invalid_deletion_parameter_exception::Builder::default()
    }
}
/// See [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException).
pub mod invalid_deletion_parameter_exception {

    /// A builder for [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDeletionParameterException`](crate::error::InvalidDeletionParameterException).
        pub fn build(self) -> crate::error::InvalidDeletionParameterException {
            crate::error::InvalidDeletionParameterException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDeletionParameterException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDeletionParameterException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDeletionParameterException")?;
        if let Some(inner_84) = &self.message {
            {
                write!(f, ": {}", inner_84)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDeletionParameterException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDeletionParameterException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidDeletionParameterException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FolderContentSizeLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FolderContentSizeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException).
    pub fn builder() -> crate::error::folder_content_size_limit_exceeded_exception::Builder {
        crate::error::folder_content_size_limit_exceeded_exception::Builder::default()
    }
}
/// See [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException).
pub mod folder_content_size_limit_exceeded_exception {

    /// A builder for [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FolderContentSizeLimitExceededException`](crate::error::FolderContentSizeLimitExceededException).
        pub fn build(self) -> crate::error::FolderContentSizeLimitExceededException {
            crate::error::FolderContentSizeLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FolderContentSizeLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FolderContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FolderContentSizeLimitExceededException")?;
        if let Some(inner_85) = &self.message {
            {
                write!(f, ": {}", inner_85)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FolderContentSizeLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::FolderContentSizeLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for FolderContentSizeLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FilePathConflictsWithSubmodulePathException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FilePathConflictsWithSubmodulePathException {
    /// Creates a new builder-style object to manufacture [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException).
    pub fn builder() -> crate::error::file_path_conflicts_with_submodule_path_exception::Builder {
        crate::error::file_path_conflicts_with_submodule_path_exception::Builder::default()
    }
}
/// See [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException).
pub mod file_path_conflicts_with_submodule_path_exception {

    /// A builder for [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FilePathConflictsWithSubmodulePathException`](crate::error::FilePathConflictsWithSubmodulePathException).
        pub fn build(self) -> crate::error::FilePathConflictsWithSubmodulePathException {
            crate::error::FilePathConflictsWithSubmodulePathException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FilePathConflictsWithSubmodulePathException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FilePathConflictsWithSubmodulePathException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FilePathConflictsWithSubmodulePathException")?;
        if let Some(inner_86) = &self.message {
            {
                write!(f, ": {}", inner_86)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FilePathConflictsWithSubmodulePathException {}
impl aws_http::request_id::RequestId for crate::error::FilePathConflictsWithSubmodulePathException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for FilePathConflictsWithSubmodulePathException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileNameConflictsWithDirectoryNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileNameConflictsWithDirectoryNameException {
    /// Creates a new builder-style object to manufacture [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException).
    pub fn builder() -> crate::error::file_name_conflicts_with_directory_name_exception::Builder {
        crate::error::file_name_conflicts_with_directory_name_exception::Builder::default()
    }
}
/// See [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException).
pub mod file_name_conflicts_with_directory_name_exception {

    /// A builder for [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileNameConflictsWithDirectoryNameException`](crate::error::FileNameConflictsWithDirectoryNameException).
        pub fn build(self) -> crate::error::FileNameConflictsWithDirectoryNameException {
            crate::error::FileNameConflictsWithDirectoryNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FileNameConflictsWithDirectoryNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileNameConflictsWithDirectoryNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileNameConflictsWithDirectoryNameException")?;
        if let Some(inner_87) = &self.message {
            {
                write!(f, ": {}", inner_87)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileNameConflictsWithDirectoryNameException {}
impl aws_http::request_id::RequestId for crate::error::FileNameConflictsWithDirectoryNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for FileNameConflictsWithDirectoryNameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileContentSizeLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileContentSizeLimitExceededException {
    /// Creates a new builder-style object to manufacture [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException).
    pub fn builder() -> crate::error::file_content_size_limit_exceeded_exception::Builder {
        crate::error::file_content_size_limit_exceeded_exception::Builder::default()
    }
}
/// See [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException).
pub mod file_content_size_limit_exceeded_exception {

    /// A builder for [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileContentSizeLimitExceededException`](crate::error::FileContentSizeLimitExceededException).
        pub fn build(self) -> crate::error::FileContentSizeLimitExceededException {
            crate::error::FileContentSizeLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FileContentSizeLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileContentSizeLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileContentSizeLimitExceededException")?;
        if let Some(inner_88) = &self.message {
            {
                write!(f, ": {}", inner_88)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileContentSizeLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::FileContentSizeLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for FileContentSizeLimitExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileContentRequiredException {
    /// Creates a new builder-style object to manufacture [`FileContentRequiredException`](crate::error::FileContentRequiredException).
    pub fn builder() -> crate::error::file_content_required_exception::Builder {
        crate::error::file_content_required_exception::Builder::default()
    }
}
/// See [`FileContentRequiredException`](crate::error::FileContentRequiredException).
pub mod file_content_required_exception {

    /// A builder for [`FileContentRequiredException`](crate::error::FileContentRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileContentRequiredException`](crate::error::FileContentRequiredException).
        pub fn build(self) -> crate::error::FileContentRequiredException {
            crate::error::FileContentRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FileContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileContentRequiredException")?;
        if let Some(inner_89) = &self.message {
            {
                write!(f, ": {}", inner_89)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileContentRequiredException {}
impl aws_http::request_id::RequestId for crate::error::FileContentRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FileContentRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DirectoryNameConflictsWithFileNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DirectoryNameConflictsWithFileNameException {
    /// Creates a new builder-style object to manufacture [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException).
    pub fn builder() -> crate::error::directory_name_conflicts_with_file_name_exception::Builder {
        crate::error::directory_name_conflicts_with_file_name_exception::Builder::default()
    }
}
/// See [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException).
pub mod directory_name_conflicts_with_file_name_exception {

    /// A builder for [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DirectoryNameConflictsWithFileNameException`](crate::error::DirectoryNameConflictsWithFileNameException).
        pub fn build(self) -> crate::error::DirectoryNameConflictsWithFileNameException {
            crate::error::DirectoryNameConflictsWithFileNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DirectoryNameConflictsWithFileNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DirectoryNameConflictsWithFileNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DirectoryNameConflictsWithFileNameException")?;
        if let Some(inner_90) = &self.message {
            {
                write!(f, ": {}", inner_90)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DirectoryNameConflictsWithFileNameException {}
impl aws_http::request_id::RequestId for crate::error::DirectoryNameConflictsWithFileNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DirectoryNameConflictsWithFileNameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit message is too long. Provide a shorter string. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommitMessageLengthExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommitMessageLengthExceededException {
    /// Creates a new builder-style object to manufacture [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException).
    pub fn builder() -> crate::error::commit_message_length_exceeded_exception::Builder {
        crate::error::commit_message_length_exceeded_exception::Builder::default()
    }
}
/// See [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException).
pub mod commit_message_length_exceeded_exception {

    /// A builder for [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommitMessageLengthExceededException`](crate::error::CommitMessageLengthExceededException).
        pub fn build(self) -> crate::error::CommitMessageLengthExceededException {
            crate::error::CommitMessageLengthExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommitMessageLengthExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitMessageLengthExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitMessageLengthExceededException")?;
        if let Some(inner_91) = &self.message {
            {
                write!(f, ": {}", inner_91)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommitMessageLengthExceededException {}
impl aws_http::request_id::RequestId for crate::error::CommitMessageLengthExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CommitMessageLengthExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BranchNameIsTagNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BranchNameIsTagNameException {
    /// Creates a new builder-style object to manufacture [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException).
    pub fn builder() -> crate::error::branch_name_is_tag_name_exception::Builder {
        crate::error::branch_name_is_tag_name_exception::Builder::default()
    }
}
/// See [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException).
pub mod branch_name_is_tag_name_exception {

    /// A builder for [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BranchNameIsTagNameException`](crate::error::BranchNameIsTagNameException).
        pub fn build(self) -> crate::error::BranchNameIsTagNameException {
            crate::error::BranchNameIsTagNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl BranchNameIsTagNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchNameIsTagNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchNameIsTagNameException")?;
        if let Some(inner_92) = &self.message {
            {
                write!(f, ": {}", inner_92)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BranchNameIsTagNameException {}
impl aws_http::request_id::RequestId for crate::error::BranchNameIsTagNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BranchNameIsTagNameException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PutCommentReactionErrorKind = PutCommentReactionError;
/// Error type for the `PutCommentReactionError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutCommentReactionError {
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// <p>The value of the reaction is not valid. For more information, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit User Guide</a>.</p>
    InvalidReactionValueException(crate::error::InvalidReactionValueException),
    /// <p>The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.</p>
    ReactionLimitExceededException(crate::error::ReactionLimitExceededException),
    /// <p>A reaction value is required. </p>
    ReactionValueRequiredException(crate::error::ReactionValueRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PutCommentReactionError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PutCommentReactionError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommentDeletedException(_inner) => _inner.fmt(f),
            Self::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommentIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidCommentIdException(_inner) => _inner.fmt(f),
            Self::InvalidReactionValueException(_inner) => _inner.fmt(f),
            Self::ReactionLimitExceededException(_inner) => _inner.fmt(f),
            Self::ReactionValueRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PutCommentReactionError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommentDeletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReactionValueException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReactionLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReactionValueRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PutCommentReactionError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutCommentReactionError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutCommentReactionError {
    /// Creates the `PutCommentReactionError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PutCommentReactionError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommentDeletedException(e) => e.meta(),
            Self::CommentDoesNotExistException(e) => e.meta(),
            Self::CommentIdRequiredException(e) => e.meta(),
            Self::InvalidCommentIdException(e) => e.meta(),
            Self::InvalidReactionValueException(e) => e.meta(),
            Self::ReactionLimitExceededException(e) => e.meta(),
            Self::ReactionValueRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PutCommentReactionError::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(self, Self::CommentDeletedException(_))
    }
    /// Returns `true` if the error kind is `PutCommentReactionError::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutCommentReactionError::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(self, Self::CommentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutCommentReactionError::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommentIdException(_))
    }
    /// Returns `true` if the error kind is `PutCommentReactionError::InvalidReactionValueException`.
    pub fn is_invalid_reaction_value_exception(&self) -> bool {
        matches!(self, Self::InvalidReactionValueException(_))
    }
    /// Returns `true` if the error kind is `PutCommentReactionError::ReactionLimitExceededException`.
    pub fn is_reaction_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::ReactionLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `PutCommentReactionError::ReactionValueRequiredException`.
    pub fn is_reaction_value_required_exception(&self) -> bool {
        matches!(self, Self::ReactionValueRequiredException(_))
    }
}
impl std::error::Error for PutCommentReactionError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommentDeletedException(_inner) => Some(_inner),
            Self::CommentDoesNotExistException(_inner) => Some(_inner),
            Self::CommentIdRequiredException(_inner) => Some(_inner),
            Self::InvalidCommentIdException(_inner) => Some(_inner),
            Self::InvalidReactionValueException(_inner) => Some(_inner),
            Self::ReactionLimitExceededException(_inner) => Some(_inner),
            Self::ReactionValueRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A reaction value is required. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReactionValueRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReactionValueRequiredException {
    /// Creates a new builder-style object to manufacture [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException).
    pub fn builder() -> crate::error::reaction_value_required_exception::Builder {
        crate::error::reaction_value_required_exception::Builder::default()
    }
}
/// See [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException).
pub mod reaction_value_required_exception {

    /// A builder for [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReactionValueRequiredException`](crate::error::ReactionValueRequiredException).
        pub fn build(self) -> crate::error::ReactionValueRequiredException {
            crate::error::ReactionValueRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ReactionValueRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReactionValueRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReactionValueRequiredException")?;
        if let Some(inner_93) = &self.message {
            {
                write!(f, ": {}", inner_93)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReactionValueRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ReactionValueRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReactionValueRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of reactions has been exceeded. Reactions are limited to one reaction per user for each individual comment ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReactionLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReactionLimitExceededException {
    /// Creates a new builder-style object to manufacture [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException).
    pub fn builder() -> crate::error::reaction_limit_exceeded_exception::Builder {
        crate::error::reaction_limit_exceeded_exception::Builder::default()
    }
}
/// See [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException).
pub mod reaction_limit_exceeded_exception {

    /// A builder for [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReactionLimitExceededException`](crate::error::ReactionLimitExceededException).
        pub fn build(self) -> crate::error::ReactionLimitExceededException {
            crate::error::ReactionLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ReactionLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReactionLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReactionLimitExceededException")?;
        if let Some(inner_94) = &self.message {
            {
                write!(f, ": {}", inner_94)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReactionLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::ReactionLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReactionLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The value of the reaction is not valid. For more information, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidReactionValueException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidReactionValueException {
    /// Creates a new builder-style object to manufacture [`InvalidReactionValueException`](crate::error::InvalidReactionValueException).
    pub fn builder() -> crate::error::invalid_reaction_value_exception::Builder {
        crate::error::invalid_reaction_value_exception::Builder::default()
    }
}
/// See [`InvalidReactionValueException`](crate::error::InvalidReactionValueException).
pub mod invalid_reaction_value_exception {

    /// A builder for [`InvalidReactionValueException`](crate::error::InvalidReactionValueException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReactionValueException`](crate::error::InvalidReactionValueException).
        pub fn build(self) -> crate::error::InvalidReactionValueException {
            crate::error::InvalidReactionValueException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidReactionValueException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReactionValueException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReactionValueException")?;
        if let Some(inner_95) = &self.message {
            {
                write!(f, ": {}", inner_95)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReactionValueException {}
impl aws_http::request_id::RequestId for crate::error::InvalidReactionValueException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidReactionValueException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PostCommentReplyErrorKind = PostCommentReplyError;
/// Error type for the `PostCommentReplyError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PostCommentReplyError {
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PostCommentReplyError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PostCommentReplyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientRequestTokenRequiredException(_inner) => _inner.fmt(f),
            Self::CommentContentRequiredException(_inner) => _inner.fmt(f),
            Self::CommentContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommentIdRequiredException(_inner) => _inner.fmt(f),
            Self::IdempotencyParameterMismatchException(_inner) => _inner.fmt(f),
            Self::InvalidClientRequestTokenException(_inner) => _inner.fmt(f),
            Self::InvalidCommentIdException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PostCommentReplyError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientRequestTokenRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IdempotencyParameterMismatchException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClientRequestTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PostCommentReplyError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PostCommentReplyError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PostCommentReplyError {
    /// Creates the `PostCommentReplyError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PostCommentReplyError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientRequestTokenRequiredException(e) => e.meta(),
            Self::CommentContentRequiredException(e) => e.meta(),
            Self::CommentContentSizeLimitExceededException(e) => e.meta(),
            Self::CommentDoesNotExistException(e) => e.meta(),
            Self::CommentIdRequiredException(e) => e.meta(),
            Self::IdempotencyParameterMismatchException(e) => e.meta(),
            Self::InvalidClientRequestTokenException(e) => e.meta(),
            Self::InvalidCommentIdException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PostCommentReplyError::ClientRequestTokenRequiredException`.
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(self, Self::ClientRequestTokenRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentReplyError::CommentContentRequiredException`.
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(self, Self::CommentContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentReplyError::CommentContentSizeLimitExceededException`.
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommentContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `PostCommentReplyError::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PostCommentReplyError::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(self, Self::CommentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentReplyError::IdempotencyParameterMismatchException`.
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(self, Self::IdempotencyParameterMismatchException(_))
    }
    /// Returns `true` if the error kind is `PostCommentReplyError::InvalidClientRequestTokenException`.
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(self, Self::InvalidClientRequestTokenException(_))
    }
    /// Returns `true` if the error kind is `PostCommentReplyError::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommentIdException(_))
    }
}
impl std::error::Error for PostCommentReplyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientRequestTokenRequiredException(_inner) => Some(_inner),
            Self::CommentContentRequiredException(_inner) => Some(_inner),
            Self::CommentContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::CommentDoesNotExistException(_inner) => Some(_inner),
            Self::CommentIdRequiredException(_inner) => Some(_inner),
            Self::IdempotencyParameterMismatchException(_inner) => Some(_inner),
            Self::InvalidClientRequestTokenException(_inner) => Some(_inner),
            Self::InvalidCommentIdException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The client request token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidClientRequestTokenException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidClientRequestTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException).
    pub fn builder() -> crate::error::invalid_client_request_token_exception::Builder {
        crate::error::invalid_client_request_token_exception::Builder::default()
    }
}
/// See [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException).
pub mod invalid_client_request_token_exception {

    /// A builder for [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidClientRequestTokenException`](crate::error::InvalidClientRequestTokenException).
        pub fn build(self) -> crate::error::InvalidClientRequestTokenException {
            crate::error::InvalidClientRequestTokenException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidClientRequestTokenException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidClientRequestTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidClientRequestTokenException")?;
        if let Some(inner_96) = &self.message {
            {
                write!(f, ": {}", inner_96)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidClientRequestTokenException {}
impl aws_http::request_id::RequestId for crate::error::InvalidClientRequestTokenException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidClientRequestTokenException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct IdempotencyParameterMismatchException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl IdempotencyParameterMismatchException {
    /// Creates a new builder-style object to manufacture [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException).
    pub fn builder() -> crate::error::idempotency_parameter_mismatch_exception::Builder {
        crate::error::idempotency_parameter_mismatch_exception::Builder::default()
    }
}
/// See [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException).
pub mod idempotency_parameter_mismatch_exception {

    /// A builder for [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`IdempotencyParameterMismatchException`](crate::error::IdempotencyParameterMismatchException).
        pub fn build(self) -> crate::error::IdempotencyParameterMismatchException {
            crate::error::IdempotencyParameterMismatchException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl IdempotencyParameterMismatchException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for IdempotencyParameterMismatchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "IdempotencyParameterMismatchException")?;
        if let Some(inner_97) = &self.message {
            {
                write!(f, ": {}", inner_97)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for IdempotencyParameterMismatchException {}
impl aws_http::request_id::RequestId for crate::error::IdempotencyParameterMismatchException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for IdempotencyParameterMismatchException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ClientRequestTokenRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ClientRequestTokenRequiredException {
    /// Creates a new builder-style object to manufacture [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException).
    pub fn builder() -> crate::error::client_request_token_required_exception::Builder {
        crate::error::client_request_token_required_exception::Builder::default()
    }
}
/// See [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException).
pub mod client_request_token_required_exception {

    /// A builder for [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ClientRequestTokenRequiredException`](crate::error::ClientRequestTokenRequiredException).
        pub fn build(self) -> crate::error::ClientRequestTokenRequiredException {
            crate::error::ClientRequestTokenRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ClientRequestTokenRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ClientRequestTokenRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ClientRequestTokenRequiredException")?;
        if let Some(inner_98) = &self.message {
            {
                write!(f, ": {}", inner_98)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ClientRequestTokenRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ClientRequestTokenRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ClientRequestTokenRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PostCommentForPullRequestErrorKind = PostCommentForPullRequestError;
/// Error type for the `PostCommentForPullRequestError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PostCommentForPullRequestError {
    /// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
    BeforeCommitIdAndAfterCommitIdAreSameException(
        crate::error::BeforeCommitIdAndAfterCommitIdAreSameException,
    ),
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The location of the file is not valid. Make sure that you include the file name and extension.</p>
    InvalidFileLocationException(crate::error::InvalidFileLocationException),
    /// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
    InvalidFilePositionException(crate::error::InvalidFilePositionException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
    InvalidRelativeFileVersionEnumException(crate::error::InvalidRelativeFileVersionEnumException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified path does not exist.</p>
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PostCommentForPullRequestError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PostCommentForPullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) => _inner.fmt(f),
            Self::ClientRequestTokenRequiredException(_inner) => _inner.fmt(f),
            Self::CommentContentRequiredException(_inner) => _inner.fmt(f),
            Self::CommentContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::IdempotencyParameterMismatchException(_inner) => _inner.fmt(f),
            Self::InvalidClientRequestTokenException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidFileLocationException(_inner) => _inner.fmt(f),
            Self::InvalidFilePositionException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidRelativeFileVersionEnumException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::PathDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PostCommentForPullRequestError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientRequestTokenRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IdempotencyParameterMismatchException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClientRequestTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileLocationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFilePositionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRelativeFileVersionEnumException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PostCommentForPullRequestError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PostCommentForPullRequestError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PostCommentForPullRequestError {
    /// Creates the `PostCommentForPullRequestError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PostCommentForPullRequestError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(e) => e.meta(),
            Self::ClientRequestTokenRequiredException(e) => e.meta(),
            Self::CommentContentRequiredException(e) => e.meta(),
            Self::CommentContentSizeLimitExceededException(e) => e.meta(),
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitIdRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::IdempotencyParameterMismatchException(e) => e.meta(),
            Self::InvalidClientRequestTokenException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidFileLocationException(e) => e.meta(),
            Self::InvalidFilePositionException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidRelativeFileVersionEnumException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::PathDoesNotExistException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryNotAssociatedWithPullRequestException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::BeforeCommitIdAndAfterCommitIdAreSameException`.
    pub fn is_before_commit_id_and_after_commit_id_are_same_exception(&self) -> bool {
        matches!(
            self,
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::ClientRequestTokenRequiredException`.
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(self, Self::ClientRequestTokenRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::CommentContentRequiredException`.
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(self, Self::CommentContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::CommentContentSizeLimitExceededException`.
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommentContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::CommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::IdempotencyParameterMismatchException`.
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(self, Self::IdempotencyParameterMismatchException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::InvalidClientRequestTokenException`.
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(self, Self::InvalidClientRequestTokenException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::InvalidFileLocationException`.
    pub fn is_invalid_file_location_exception(&self) -> bool {
        matches!(self, Self::InvalidFileLocationException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::InvalidFilePositionException`.
    pub fn is_invalid_file_position_exception(&self) -> bool {
        matches!(self, Self::InvalidFilePositionException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::InvalidRelativeFileVersionEnumException`.
    pub fn is_invalid_relative_file_version_enum_exception(&self) -> bool {
        matches!(self, Self::InvalidRelativeFileVersionEnumException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::PathDoesNotExistException`.
    pub fn is_path_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PathDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForPullRequestError::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
}
impl std::error::Error for PostCommentForPullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) => Some(_inner),
            Self::ClientRequestTokenRequiredException(_inner) => Some(_inner),
            Self::CommentContentRequiredException(_inner) => Some(_inner),
            Self::CommentContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitIdRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::IdempotencyParameterMismatchException(_inner) => Some(_inner),
            Self::InvalidClientRequestTokenException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidFileLocationException(_inner) => Some(_inner),
            Self::InvalidFilePositionException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidRelativeFileVersionEnumException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::PathDoesNotExistException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryNotAssociatedWithPullRequestException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryNotAssociatedWithPullRequestException {
    /// Creates a new builder-style object to manufacture [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException).
    pub fn builder() -> crate::error::repository_not_associated_with_pull_request_exception::Builder
    {
        crate::error::repository_not_associated_with_pull_request_exception::Builder::default()
    }
}
/// See [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException).
pub mod repository_not_associated_with_pull_request_exception {

    /// A builder for [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNotAssociatedWithPullRequestException`](crate::error::RepositoryNotAssociatedWithPullRequestException).
        pub fn build(self) -> crate::error::RepositoryNotAssociatedWithPullRequestException {
            crate::error::RepositoryNotAssociatedWithPullRequestException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryNotAssociatedWithPullRequestException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNotAssociatedWithPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNotAssociatedWithPullRequestException")?;
        if let Some(inner_99) = &self.message {
            {
                write!(f, ": {}", inner_99)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNotAssociatedWithPullRequestException {}
impl aws_http::request_id::RequestId
    for crate::error::RepositoryNotAssociatedWithPullRequestException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for RepositoryNotAssociatedWithPullRequestException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified path does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PathDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PathDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`PathDoesNotExistException`](crate::error::PathDoesNotExistException).
    pub fn builder() -> crate::error::path_does_not_exist_exception::Builder {
        crate::error::path_does_not_exist_exception::Builder::default()
    }
}
/// See [`PathDoesNotExistException`](crate::error::PathDoesNotExistException).
pub mod path_does_not_exist_exception {

    /// A builder for [`PathDoesNotExistException`](crate::error::PathDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PathDoesNotExistException`](crate::error::PathDoesNotExistException).
        pub fn build(self) -> crate::error::PathDoesNotExistException {
            crate::error::PathDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PathDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PathDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PathDoesNotExistException")?;
        if let Some(inner_100) = &self.message {
            {
                write!(f, ": {}", inner_100)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PathDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::PathDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PathDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidRelativeFileVersionEnumException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidRelativeFileVersionEnumException {
    /// Creates a new builder-style object to manufacture [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException).
    pub fn builder() -> crate::error::invalid_relative_file_version_enum_exception::Builder {
        crate::error::invalid_relative_file_version_enum_exception::Builder::default()
    }
}
/// See [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException).
pub mod invalid_relative_file_version_enum_exception {

    /// A builder for [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidRelativeFileVersionEnumException`](crate::error::InvalidRelativeFileVersionEnumException).
        pub fn build(self) -> crate::error::InvalidRelativeFileVersionEnumException {
            crate::error::InvalidRelativeFileVersionEnumException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidRelativeFileVersionEnumException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidRelativeFileVersionEnumException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidRelativeFileVersionEnumException")?;
        if let Some(inner_101) = &self.message {
            {
                write!(f, ": {}", inner_101)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidRelativeFileVersionEnumException {}
impl aws_http::request_id::RequestId for crate::error::InvalidRelativeFileVersionEnumException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidRelativeFileVersionEnumException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidFilePositionException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidFilePositionException {
    /// Creates a new builder-style object to manufacture [`InvalidFilePositionException`](crate::error::InvalidFilePositionException).
    pub fn builder() -> crate::error::invalid_file_position_exception::Builder {
        crate::error::invalid_file_position_exception::Builder::default()
    }
}
/// See [`InvalidFilePositionException`](crate::error::InvalidFilePositionException).
pub mod invalid_file_position_exception {

    /// A builder for [`InvalidFilePositionException`](crate::error::InvalidFilePositionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFilePositionException`](crate::error::InvalidFilePositionException).
        pub fn build(self) -> crate::error::InvalidFilePositionException {
            crate::error::InvalidFilePositionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidFilePositionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFilePositionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFilePositionException")?;
        if let Some(inner_102) = &self.message {
            {
                write!(f, ": {}", inner_102)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFilePositionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidFilePositionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidFilePositionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The location of the file is not valid. Make sure that you include the file name and extension.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidFileLocationException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidFileLocationException {
    /// Creates a new builder-style object to manufacture [`InvalidFileLocationException`](crate::error::InvalidFileLocationException).
    pub fn builder() -> crate::error::invalid_file_location_exception::Builder {
        crate::error::invalid_file_location_exception::Builder::default()
    }
}
/// See [`InvalidFileLocationException`](crate::error::InvalidFileLocationException).
pub mod invalid_file_location_exception {

    /// A builder for [`InvalidFileLocationException`](crate::error::InvalidFileLocationException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidFileLocationException`](crate::error::InvalidFileLocationException).
        pub fn build(self) -> crate::error::InvalidFileLocationException {
            crate::error::InvalidFileLocationException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidFileLocationException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidFileLocationException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidFileLocationException")?;
        if let Some(inner_103) = &self.message {
            {
                write!(f, ": {}", inner_103)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidFileLocationException {}
impl aws_http::request_id::RequestId for crate::error::InvalidFileLocationException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidFileLocationException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified commit ID is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidCommitIdException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidCommitIdException {
    /// Creates a new builder-style object to manufacture [`InvalidCommitIdException`](crate::error::InvalidCommitIdException).
    pub fn builder() -> crate::error::invalid_commit_id_exception::Builder {
        crate::error::invalid_commit_id_exception::Builder::default()
    }
}
/// See [`InvalidCommitIdException`](crate::error::InvalidCommitIdException).
pub mod invalid_commit_id_exception {

    /// A builder for [`InvalidCommitIdException`](crate::error::InvalidCommitIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommitIdException`](crate::error::InvalidCommitIdException).
        pub fn build(self) -> crate::error::InvalidCommitIdException {
            crate::error::InvalidCommitIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidCommitIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommitIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommitIdException")?;
        if let Some(inner_104) = &self.message {
            {
                write!(f, ": {}", inner_104)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommitIdException {}
impl aws_http::request_id::RequestId for crate::error::InvalidCommitIdException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidCommitIdException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A commit ID was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommitIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommitIdRequiredException {
    /// Creates a new builder-style object to manufacture [`CommitIdRequiredException`](crate::error::CommitIdRequiredException).
    pub fn builder() -> crate::error::commit_id_required_exception::Builder {
        crate::error::commit_id_required_exception::Builder::default()
    }
}
/// See [`CommitIdRequiredException`](crate::error::CommitIdRequiredException).
pub mod commit_id_required_exception {

    /// A builder for [`CommitIdRequiredException`](crate::error::CommitIdRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdRequiredException`](crate::error::CommitIdRequiredException).
        pub fn build(self) -> crate::error::CommitIdRequiredException {
            crate::error::CommitIdRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommitIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdRequiredException")?;
        if let Some(inner_105) = &self.message {
            {
                write!(f, ": {}", inner_105)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdRequiredException {}
impl aws_http::request_id::RequestId for crate::error::CommitIdRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommitIdRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommitDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommitDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException).
    pub fn builder() -> crate::error::commit_does_not_exist_exception::Builder {
        crate::error::commit_does_not_exist_exception::Builder::default()
    }
}
/// See [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException).
pub mod commit_does_not_exist_exception {

    /// A builder for [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommitDoesNotExistException`](crate::error::CommitDoesNotExistException).
        pub fn build(self) -> crate::error::CommitDoesNotExistException {
            crate::error::CommitDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommitDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitDoesNotExistException")?;
        if let Some(inner_106) = &self.message {
            {
                write!(f, ": {}", inner_106)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommitDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::CommitDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommitDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BeforeCommitIdAndAfterCommitIdAreSameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BeforeCommitIdAndAfterCommitIdAreSameException {
    /// Creates a new builder-style object to manufacture [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException).
    pub fn builder(
    ) -> crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder {
        crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder::default()
    }
}
/// See [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException).
pub mod before_commit_id_and_after_commit_id_are_same_exception {

    /// A builder for [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BeforeCommitIdAndAfterCommitIdAreSameException`](crate::error::BeforeCommitIdAndAfterCommitIdAreSameException).
        pub fn build(self) -> crate::error::BeforeCommitIdAndAfterCommitIdAreSameException {
            crate::error::BeforeCommitIdAndAfterCommitIdAreSameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl BeforeCommitIdAndAfterCommitIdAreSameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BeforeCommitIdAndAfterCommitIdAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BeforeCommitIdAndAfterCommitIdAreSameException")?;
        if let Some(inner_107) = &self.message {
            {
                write!(f, ": {}", inner_107)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BeforeCommitIdAndAfterCommitIdAreSameException {}
impl aws_http::request_id::RequestId
    for crate::error::BeforeCommitIdAndAfterCommitIdAreSameException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for BeforeCommitIdAndAfterCommitIdAreSameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PostCommentForComparedCommitErrorKind = PostCommentForComparedCommitError;
/// Error type for the `PostCommentForComparedCommitError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PostCommentForComparedCommitError {
    /// <p>The before commit ID and the after commit ID are the same, which is not valid. The before commit ID and the after commit ID must be different commit IDs.</p>
    BeforeCommitIdAndAfterCommitIdAreSameException(
        crate::error::BeforeCommitIdAndAfterCommitIdAreSameException,
    ),
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    /// <p>The comment is empty. You must provide some content for a comment. The content cannot be null.</p>
    CommentContentRequiredException(crate::error::CommentContentRequiredException),
    /// <p>The comment is too large. Comments are limited to 1,000 characters.</p>
    CommentContentSizeLimitExceededException(
        crate::error::CommentContentSizeLimitExceededException,
    ),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The location of the file is not valid. Make sure that you include the file name and extension.</p>
    InvalidFileLocationException(crate::error::InvalidFileLocationException),
    /// <p>The position is not valid. Make sure that the line number exists in the version of the file you want to comment on.</p>
    InvalidFilePositionException(crate::error::InvalidFilePositionException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>Either the enum is not in a valid format, or the specified file version enum is not valid in respect to the current file version.</p>
    InvalidRelativeFileVersionEnumException(crate::error::InvalidRelativeFileVersionEnumException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified path does not exist.</p>
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PostCommentForComparedCommitError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PostCommentForComparedCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) => _inner.fmt(f),
            Self::ClientRequestTokenRequiredException(_inner) => _inner.fmt(f),
            Self::CommentContentRequiredException(_inner) => _inner.fmt(f),
            Self::CommentContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::IdempotencyParameterMismatchException(_inner) => _inner.fmt(f),
            Self::InvalidClientRequestTokenException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidFileLocationException(_inner) => _inner.fmt(f),
            Self::InvalidFilePositionException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRelativeFileVersionEnumException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::PathDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PostCommentForComparedCommitError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ClientRequestTokenRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IdempotencyParameterMismatchException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClientRequestTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileLocationException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFilePositionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRelativeFileVersionEnumException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::PostCommentForComparedCommitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PostCommentForComparedCommitError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PostCommentForComparedCommitError {
    /// Creates the `PostCommentForComparedCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PostCommentForComparedCommitError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(e) => e.meta(),
            Self::ClientRequestTokenRequiredException(e) => e.meta(),
            Self::CommentContentRequiredException(e) => e.meta(),
            Self::CommentContentSizeLimitExceededException(e) => e.meta(),
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitIdRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::IdempotencyParameterMismatchException(e) => e.meta(),
            Self::InvalidClientRequestTokenException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidFileLocationException(e) => e.meta(),
            Self::InvalidFilePositionException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRelativeFileVersionEnumException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::PathDoesNotExistException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::BeforeCommitIdAndAfterCommitIdAreSameException`.
    pub fn is_before_commit_id_and_after_commit_id_are_same_exception(&self) -> bool {
        matches!(
            self,
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(_)
        )
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::ClientRequestTokenRequiredException`.
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(self, Self::ClientRequestTokenRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::CommentContentRequiredException`.
    pub fn is_comment_content_required_exception(&self) -> bool {
        matches!(self, Self::CommentContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::CommentContentSizeLimitExceededException`.
    pub fn is_comment_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommentContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::CommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::IdempotencyParameterMismatchException`.
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(self, Self::IdempotencyParameterMismatchException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::InvalidClientRequestTokenException`.
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(self, Self::InvalidClientRequestTokenException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::InvalidFileLocationException`.
    pub fn is_invalid_file_location_exception(&self) -> bool {
        matches!(self, Self::InvalidFileLocationException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::InvalidFilePositionException`.
    pub fn is_invalid_file_position_exception(&self) -> bool {
        matches!(self, Self::InvalidFilePositionException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::InvalidRelativeFileVersionEnumException`.
    pub fn is_invalid_relative_file_version_enum_exception(&self) -> bool {
        matches!(self, Self::InvalidRelativeFileVersionEnumException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::PathDoesNotExistException`.
    pub fn is_path_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PathDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PostCommentForComparedCommitError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for PostCommentForComparedCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BeforeCommitIdAndAfterCommitIdAreSameException(_inner) => Some(_inner),
            Self::ClientRequestTokenRequiredException(_inner) => Some(_inner),
            Self::CommentContentRequiredException(_inner) => Some(_inner),
            Self::CommentContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitIdRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::IdempotencyParameterMismatchException(_inner) => Some(_inner),
            Self::InvalidClientRequestTokenException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidFileLocationException(_inner) => Some(_inner),
            Self::InvalidFilePositionException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidRelativeFileVersionEnumException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::PathDoesNotExistException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type OverridePullRequestApprovalRulesErrorKind = OverridePullRequestApprovalRulesError;
/// Error type for the `OverridePullRequestApprovalRulesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum OverridePullRequestApprovalRulesError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The override status is not valid. Valid statuses are OVERRIDE and REVOKE.</p>
    InvalidOverrideStatusException(crate::error::InvalidOverrideStatusException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The pull request has already had its approval rules set to override.</p>
    OverrideAlreadySetException(crate::error::OverrideAlreadySetException),
    /// <p>An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.</p>
    OverrideStatusRequiredException(crate::error::OverrideStatusRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for OverridePullRequestApprovalRulesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for OverridePullRequestApprovalRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidOverrideStatusException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionIdException(_inner) => _inner.fmt(f),
            Self::OverrideAlreadySetException(_inner) => _inner.fmt(f),
            Self::OverrideStatusRequiredException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::RevisionIdRequiredException(_inner) => _inner.fmt(f),
            Self::RevisionNotCurrentException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for OverridePullRequestApprovalRulesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOverrideStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRevisionIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OverrideAlreadySetException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::OverrideStatusRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionNotCurrentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::OverridePullRequestApprovalRulesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for OverridePullRequestApprovalRulesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl OverridePullRequestApprovalRulesError {
    /// Creates the `OverridePullRequestApprovalRulesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `OverridePullRequestApprovalRulesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidOverrideStatusException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidRevisionIdException(e) => e.meta(),
            Self::OverrideAlreadySetException(e) => e.meta(),
            Self::OverrideStatusRequiredException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::RevisionIdRequiredException(e) => e.meta(),
            Self::RevisionNotCurrentException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::InvalidOverrideStatusException`.
    pub fn is_invalid_override_status_exception(&self) -> bool {
        matches!(self, Self::InvalidOverrideStatusException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionIdException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::OverrideAlreadySetException`.
    pub fn is_override_already_set_exception(&self) -> bool {
        matches!(self, Self::OverrideAlreadySetException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::OverrideStatusRequiredException`.
    pub fn is_override_status_required_exception(&self) -> bool {
        matches!(self, Self::OverrideStatusRequiredException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(self, Self::RevisionIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `OverridePullRequestApprovalRulesError::RevisionNotCurrentException`.
    pub fn is_revision_not_current_exception(&self) -> bool {
        matches!(self, Self::RevisionNotCurrentException(_))
    }
}
impl std::error::Error for OverridePullRequestApprovalRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidOverrideStatusException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidRevisionIdException(_inner) => Some(_inner),
            Self::OverrideAlreadySetException(_inner) => Some(_inner),
            Self::OverrideStatusRequiredException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::RevisionIdRequiredException(_inner) => Some(_inner),
            Self::RevisionNotCurrentException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An override status is required, but no value was provided. Valid values include OVERRIDE and REVOKE.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OverrideStatusRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OverrideStatusRequiredException {
    /// Creates a new builder-style object to manufacture [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException).
    pub fn builder() -> crate::error::override_status_required_exception::Builder {
        crate::error::override_status_required_exception::Builder::default()
    }
}
/// See [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException).
pub mod override_status_required_exception {

    /// A builder for [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`OverrideStatusRequiredException`](crate::error::OverrideStatusRequiredException).
        pub fn build(self) -> crate::error::OverrideStatusRequiredException {
            crate::error::OverrideStatusRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl OverrideStatusRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OverrideStatusRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OverrideStatusRequiredException")?;
        if let Some(inner_108) = &self.message {
            {
                write!(f, ": {}", inner_108)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OverrideStatusRequiredException {}
impl aws_http::request_id::RequestId for crate::error::OverrideStatusRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OverrideStatusRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The pull request has already had its approval rules set to override.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct OverrideAlreadySetException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl OverrideAlreadySetException {
    /// Creates a new builder-style object to manufacture [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException).
    pub fn builder() -> crate::error::override_already_set_exception::Builder {
        crate::error::override_already_set_exception::Builder::default()
    }
}
/// See [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException).
pub mod override_already_set_exception {

    /// A builder for [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`OverrideAlreadySetException`](crate::error::OverrideAlreadySetException).
        pub fn build(self) -> crate::error::OverrideAlreadySetException {
            crate::error::OverrideAlreadySetException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl OverrideAlreadySetException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for OverrideAlreadySetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "OverrideAlreadySetException")?;
        if let Some(inner_109) = &self.message {
            {
                write!(f, ": {}", inner_109)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for OverrideAlreadySetException {}
impl aws_http::request_id::RequestId for crate::error::OverrideAlreadySetException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for OverrideAlreadySetException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The override status is not valid. Valid statuses are OVERRIDE and REVOKE.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOverrideStatusException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOverrideStatusException {
    /// Creates a new builder-style object to manufacture [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException).
    pub fn builder() -> crate::error::invalid_override_status_exception::Builder {
        crate::error::invalid_override_status_exception::Builder::default()
    }
}
/// See [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException).
pub mod invalid_override_status_exception {

    /// A builder for [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOverrideStatusException`](crate::error::InvalidOverrideStatusException).
        pub fn build(self) -> crate::error::InvalidOverrideStatusException {
            crate::error::InvalidOverrideStatusException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidOverrideStatusException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOverrideStatusException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOverrideStatusException")?;
        if let Some(inner_110) = &self.message {
            {
                write!(f, ": {}", inner_110)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOverrideStatusException {}
impl aws_http::request_id::RequestId for crate::error::InvalidOverrideStatusException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidOverrideStatusException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type MergePullRequestByThreeWayErrorKind = MergePullRequestByThreeWayError;
/// Error type for the `MergePullRequestByThreeWayError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestByThreeWayError {
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(
        crate::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(
        crate::error::TipOfSourceReferenceIsDifferentException,
    ),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for MergePullRequestByThreeWayError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for MergePullRequestByThreeWayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::ConcurrentReferenceUpdateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementContentException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementTypeException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MultipleConflictResolutionEntriesException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementContentRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementTypeRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => _inner.fmt(f),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MergePullRequestByThreeWayError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConcurrentReferenceUpdateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FolderContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEmailException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileModeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ManualMergeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MultipleConflictResolutionEntriesException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NameLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementTypeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipOfSourceReferenceIsDifferentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::MergePullRequestByThreeWayError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergePullRequestByThreeWayError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestByThreeWayError {
    /// Creates the `MergePullRequestByThreeWayError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `MergePullRequestByThreeWayError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::ConcurrentReferenceUpdateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidReplacementContentException(e) => e.meta(),
            Self::InvalidReplacementTypeException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::ManualMergeRequiredException(e) => e.meta(),
            Self::MaximumConflictResolutionEntriesExceededException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MultipleConflictResolutionEntriesException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestApprovalRulesNotSatisfiedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::ReplacementContentRequiredException(e) => e.meta(),
            Self::ReplacementTypeRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryNotAssociatedWithPullRequestException(e) => e.meta(),
            Self::TipOfSourceReferenceIsDifferentException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(self, Self::ConcurrentReferenceUpdateException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementContentException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementTypeException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(self, Self::ManualMergeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            self,
            Self::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(self, Self::MultipleConflictResolutionEntriesException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PullRequestApprovalRulesNotSatisfiedException`.
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(self, Self::PullRequestApprovalRulesNotSatisfiedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementTypeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::TipOfSourceReferenceIsDifferentException`.
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(self, Self::TipOfSourceReferenceIsDifferentException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for MergePullRequestByThreeWayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => Some(_inner),
            Self::ConcurrentReferenceUpdateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidEmailException(_inner) => Some(_inner),
            Self::InvalidFileModeException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidReplacementContentException(_inner) => Some(_inner),
            Self::InvalidReplacementTypeException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::ManualMergeRequiredException(_inner) => Some(_inner),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::MultipleConflictResolutionEntriesException(_inner) => Some(_inner),
            Self::NameLengthExceededException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::ReplacementContentRequiredException(_inner) => Some(_inner),
            Self::ReplacementTypeRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => Some(_inner),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TipsDivergenceExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TipsDivergenceExceededException {
    /// Creates a new builder-style object to manufacture [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException).
    pub fn builder() -> crate::error::tips_divergence_exceeded_exception::Builder {
        crate::error::tips_divergence_exceeded_exception::Builder::default()
    }
}
/// See [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException).
pub mod tips_divergence_exceeded_exception {

    /// A builder for [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TipsDivergenceExceededException`](crate::error::TipsDivergenceExceededException).
        pub fn build(self) -> crate::error::TipsDivergenceExceededException {
            crate::error::TipsDivergenceExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TipsDivergenceExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TipsDivergenceExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TipsDivergenceExceededException")?;
        if let Some(inner_111) = &self.message {
            {
                write!(f, ": {}", inner_111)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TipsDivergenceExceededException {}
impl aws_http::request_id::RequestId for crate::error::TipsDivergenceExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TipsDivergenceExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TipOfSourceReferenceIsDifferentException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TipOfSourceReferenceIsDifferentException {
    /// Creates a new builder-style object to manufacture [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException).
    pub fn builder() -> crate::error::tip_of_source_reference_is_different_exception::Builder {
        crate::error::tip_of_source_reference_is_different_exception::Builder::default()
    }
}
/// See [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException).
pub mod tip_of_source_reference_is_different_exception {

    /// A builder for [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TipOfSourceReferenceIsDifferentException`](crate::error::TipOfSourceReferenceIsDifferentException).
        pub fn build(self) -> crate::error::TipOfSourceReferenceIsDifferentException {
            crate::error::TipOfSourceReferenceIsDifferentException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TipOfSourceReferenceIsDifferentException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TipOfSourceReferenceIsDifferentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TipOfSourceReferenceIsDifferentException")?;
        if let Some(inner_112) = &self.message {
            {
                write!(f, ": {}", inner_112)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TipOfSourceReferenceIsDifferentException {}
impl aws_http::request_id::RequestId for crate::error::TipOfSourceReferenceIsDifferentException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for TipOfSourceReferenceIsDifferentException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A replacement type is required.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReplacementTypeRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReplacementTypeRequiredException {
    /// Creates a new builder-style object to manufacture [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException).
    pub fn builder() -> crate::error::replacement_type_required_exception::Builder {
        crate::error::replacement_type_required_exception::Builder::default()
    }
}
/// See [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException).
pub mod replacement_type_required_exception {

    /// A builder for [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReplacementTypeRequiredException`](crate::error::ReplacementTypeRequiredException).
        pub fn build(self) -> crate::error::ReplacementTypeRequiredException {
            crate::error::ReplacementTypeRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ReplacementTypeRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplacementTypeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplacementTypeRequiredException")?;
        if let Some(inner_113) = &self.message {
            {
                write!(f, ": {}", inner_113)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReplacementTypeRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ReplacementTypeRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReplacementTypeRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReplacementContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReplacementContentRequiredException {
    /// Creates a new builder-style object to manufacture [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException).
    pub fn builder() -> crate::error::replacement_content_required_exception::Builder {
        crate::error::replacement_content_required_exception::Builder::default()
    }
}
/// See [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException).
pub mod replacement_content_required_exception {

    /// A builder for [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReplacementContentRequiredException`](crate::error::ReplacementContentRequiredException).
        pub fn build(self) -> crate::error::ReplacementContentRequiredException {
            crate::error::ReplacementContentRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ReplacementContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReplacementContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReplacementContentRequiredException")?;
        if let Some(inner_114) = &self.message {
            {
                write!(f, ": {}", inner_114)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReplacementContentRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ReplacementContentRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ReplacementContentRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PullRequestApprovalRulesNotSatisfiedException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PullRequestApprovalRulesNotSatisfiedException {
    /// Creates a new builder-style object to manufacture [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException).
    pub fn builder() -> crate::error::pull_request_approval_rules_not_satisfied_exception::Builder {
        crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default()
    }
}
/// See [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException).
pub mod pull_request_approval_rules_not_satisfied_exception {

    /// A builder for [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PullRequestApprovalRulesNotSatisfiedException`](crate::error::PullRequestApprovalRulesNotSatisfiedException).
        pub fn build(self) -> crate::error::PullRequestApprovalRulesNotSatisfiedException {
            crate::error::PullRequestApprovalRulesNotSatisfiedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PullRequestApprovalRulesNotSatisfiedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PullRequestApprovalRulesNotSatisfiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PullRequestApprovalRulesNotSatisfiedException")?;
        if let Some(inner_115) = &self.message {
            {
                write!(f, ": {}", inner_115)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PullRequestApprovalRulesNotSatisfiedException {}
impl aws_http::request_id::RequestId
    for crate::error::PullRequestApprovalRulesNotSatisfiedException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for PullRequestApprovalRulesNotSatisfiedException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MultipleConflictResolutionEntriesException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MultipleConflictResolutionEntriesException {
    /// Creates a new builder-style object to manufacture [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException).
    pub fn builder() -> crate::error::multiple_conflict_resolution_entries_exception::Builder {
        crate::error::multiple_conflict_resolution_entries_exception::Builder::default()
    }
}
/// See [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException).
pub mod multiple_conflict_resolution_entries_exception {

    /// A builder for [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MultipleConflictResolutionEntriesException`](crate::error::MultipleConflictResolutionEntriesException).
        pub fn build(self) -> crate::error::MultipleConflictResolutionEntriesException {
            crate::error::MultipleConflictResolutionEntriesException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MultipleConflictResolutionEntriesException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MultipleConflictResolutionEntriesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MultipleConflictResolutionEntriesException")?;
        if let Some(inner_116) = &self.message {
            {
                write!(f, ": {}", inner_116)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MultipleConflictResolutionEntriesException {}
impl aws_http::request_id::RequestId for crate::error::MultipleConflictResolutionEntriesException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MultipleConflictResolutionEntriesException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumItemsToCompareExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumItemsToCompareExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException).
    pub fn builder() -> crate::error::maximum_items_to_compare_exceeded_exception::Builder {
        crate::error::maximum_items_to_compare_exceeded_exception::Builder::default()
    }
}
/// See [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException).
pub mod maximum_items_to_compare_exceeded_exception {

    /// A builder for [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumItemsToCompareExceededException`](crate::error::MaximumItemsToCompareExceededException).
        pub fn build(self) -> crate::error::MaximumItemsToCompareExceededException {
            crate::error::MaximumItemsToCompareExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumItemsToCompareExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumItemsToCompareExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumItemsToCompareExceededException")?;
        if let Some(inner_117) = &self.message {
            {
                write!(f, ": {}", inner_117)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumItemsToCompareExceededException {}
impl aws_http::request_id::RequestId for crate::error::MaximumItemsToCompareExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MaximumItemsToCompareExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of files to load exceeds the allowed limit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumFileContentToLoadExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumFileContentToLoadExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException).
    pub fn builder() -> crate::error::maximum_file_content_to_load_exceeded_exception::Builder {
        crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default()
    }
}
/// See [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException).
pub mod maximum_file_content_to_load_exceeded_exception {

    /// A builder for [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumFileContentToLoadExceededException`](crate::error::MaximumFileContentToLoadExceededException).
        pub fn build(self) -> crate::error::MaximumFileContentToLoadExceededException {
            crate::error::MaximumFileContentToLoadExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumFileContentToLoadExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumFileContentToLoadExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumFileContentToLoadExceededException")?;
        if let Some(inner_118) = &self.message {
            {
                write!(f, ": {}", inner_118)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumFileContentToLoadExceededException {}
impl aws_http::request_id::RequestId for crate::error::MaximumFileContentToLoadExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MaximumFileContentToLoadExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of allowed conflict resolution entries was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumConflictResolutionEntriesExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumConflictResolutionEntriesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException).
    pub fn builder() -> crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder
    {
        crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default()
    }
}
/// See [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException).
pub mod maximum_conflict_resolution_entries_exceeded_exception {

    /// A builder for [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumConflictResolutionEntriesExceededException`](crate::error::MaximumConflictResolutionEntriesExceededException).
        pub fn build(self) -> crate::error::MaximumConflictResolutionEntriesExceededException {
            crate::error::MaximumConflictResolutionEntriesExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumConflictResolutionEntriesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumConflictResolutionEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumConflictResolutionEntriesExceededException")?;
        if let Some(inner_119) = &self.message {
            {
                write!(f, ": {}", inner_119)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumConflictResolutionEntriesExceededException {}
impl aws_http::request_id::RequestId
    for crate::error::MaximumConflictResolutionEntriesExceededException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MaximumConflictResolutionEntriesExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ManualMergeRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ManualMergeRequiredException {
    /// Creates a new builder-style object to manufacture [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException).
    pub fn builder() -> crate::error::manual_merge_required_exception::Builder {
        crate::error::manual_merge_required_exception::Builder::default()
    }
}
/// See [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException).
pub mod manual_merge_required_exception {

    /// A builder for [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ManualMergeRequiredException`](crate::error::ManualMergeRequiredException).
        pub fn build(self) -> crate::error::ManualMergeRequiredException {
            crate::error::ManualMergeRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ManualMergeRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ManualMergeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ManualMergeRequiredException")?;
        if let Some(inner_120) = &self.message {
            {
                write!(f, ": {}", inner_120)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ManualMergeRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ManualMergeRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ManualMergeRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidReplacementTypeException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidReplacementTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException).
    pub fn builder() -> crate::error::invalid_replacement_type_exception::Builder {
        crate::error::invalid_replacement_type_exception::Builder::default()
    }
}
/// See [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException).
pub mod invalid_replacement_type_exception {

    /// A builder for [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReplacementTypeException`](crate::error::InvalidReplacementTypeException).
        pub fn build(self) -> crate::error::InvalidReplacementTypeException {
            crate::error::InvalidReplacementTypeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidReplacementTypeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReplacementTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReplacementTypeException")?;
        if let Some(inner_121) = &self.message {
            {
                write!(f, ": {}", inner_121)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReplacementTypeException {}
impl aws_http::request_id::RequestId for crate::error::InvalidReplacementTypeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidReplacementTypeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidReplacementContentException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidReplacementContentException {
    /// Creates a new builder-style object to manufacture [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException).
    pub fn builder() -> crate::error::invalid_replacement_content_exception::Builder {
        crate::error::invalid_replacement_content_exception::Builder::default()
    }
}
/// See [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException).
pub mod invalid_replacement_content_exception {

    /// A builder for [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReplacementContentException`](crate::error::InvalidReplacementContentException).
        pub fn build(self) -> crate::error::InvalidReplacementContentException {
            crate::error::InvalidReplacementContentException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidReplacementContentException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReplacementContentException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReplacementContentException")?;
        if let Some(inner_122) = &self.message {
            {
                write!(f, ": {}", inner_122)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReplacementContentException {}
impl aws_http::request_id::RequestId for crate::error::InvalidReplacementContentException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidReplacementContentException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified conflict resolution strategy is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidConflictResolutionStrategyException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidConflictResolutionStrategyException {
    /// Creates a new builder-style object to manufacture [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException).
    pub fn builder() -> crate::error::invalid_conflict_resolution_strategy_exception::Builder {
        crate::error::invalid_conflict_resolution_strategy_exception::Builder::default()
    }
}
/// See [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException).
pub mod invalid_conflict_resolution_strategy_exception {

    /// A builder for [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConflictResolutionStrategyException`](crate::error::InvalidConflictResolutionStrategyException).
        pub fn build(self) -> crate::error::InvalidConflictResolutionStrategyException {
            crate::error::InvalidConflictResolutionStrategyException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidConflictResolutionStrategyException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConflictResolutionStrategyException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConflictResolutionStrategyException")?;
        if let Some(inner_123) = &self.message {
            {
                write!(f, ": {}", inner_123)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConflictResolutionStrategyException {}
impl aws_http::request_id::RequestId for crate::error::InvalidConflictResolutionStrategyException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidConflictResolutionStrategyException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified conflict resolution list is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidConflictResolutionException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidConflictResolutionException {
    /// Creates a new builder-style object to manufacture [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException).
    pub fn builder() -> crate::error::invalid_conflict_resolution_exception::Builder {
        crate::error::invalid_conflict_resolution_exception::Builder::default()
    }
}
/// See [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException).
pub mod invalid_conflict_resolution_exception {

    /// A builder for [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConflictResolutionException`](crate::error::InvalidConflictResolutionException).
        pub fn build(self) -> crate::error::InvalidConflictResolutionException {
            crate::error::InvalidConflictResolutionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidConflictResolutionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConflictResolutionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConflictResolutionException")?;
        if let Some(inner_124) = &self.message {
            {
                write!(f, ": {}", inner_124)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConflictResolutionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidConflictResolutionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidConflictResolutionException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified conflict detail level is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidConflictDetailLevelException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidConflictDetailLevelException {
    /// Creates a new builder-style object to manufacture [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException).
    pub fn builder() -> crate::error::invalid_conflict_detail_level_exception::Builder {
        crate::error::invalid_conflict_detail_level_exception::Builder::default()
    }
}
/// See [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException).
pub mod invalid_conflict_detail_level_exception {

    /// A builder for [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidConflictDetailLevelException`](crate::error::InvalidConflictDetailLevelException).
        pub fn build(self) -> crate::error::InvalidConflictDetailLevelException {
            crate::error::InvalidConflictDetailLevelException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidConflictDetailLevelException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidConflictDetailLevelException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidConflictDetailLevelException")?;
        if let Some(inner_125) = &self.message {
            {
                write!(f, ": {}", inner_125)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidConflictDetailLevelException {}
impl aws_http::request_id::RequestId for crate::error::InvalidConflictDetailLevelException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidConflictDetailLevelException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConcurrentReferenceUpdateException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ConcurrentReferenceUpdateException {
    /// Creates a new builder-style object to manufacture [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException).
    pub fn builder() -> crate::error::concurrent_reference_update_exception::Builder {
        crate::error::concurrent_reference_update_exception::Builder::default()
    }
}
/// See [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException).
pub mod concurrent_reference_update_exception {

    /// A builder for [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ConcurrentReferenceUpdateException`](crate::error::ConcurrentReferenceUpdateException).
        pub fn build(self) -> crate::error::ConcurrentReferenceUpdateException {
            crate::error::ConcurrentReferenceUpdateException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ConcurrentReferenceUpdateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ConcurrentReferenceUpdateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ConcurrentReferenceUpdateException")?;
        if let Some(inner_126) = &self.message {
            {
                write!(f, ": {}", inner_126)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ConcurrentReferenceUpdateException {}
impl aws_http::request_id::RequestId for crate::error::ConcurrentReferenceUpdateException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ConcurrentReferenceUpdateException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type MergePullRequestBySquashErrorKind = MergePullRequestBySquashError;
/// Error type for the `MergePullRequestBySquashError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestBySquashError {
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(
        crate::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(
        crate::error::TipOfSourceReferenceIsDifferentException,
    ),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for MergePullRequestBySquashError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for MergePullRequestBySquashError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::ConcurrentReferenceUpdateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementContentException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementTypeException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MultipleConflictResolutionEntriesException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementContentRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementTypeRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => _inner.fmt(f),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MergePullRequestBySquashError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConcurrentReferenceUpdateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FolderContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEmailException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileModeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ManualMergeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MultipleConflictResolutionEntriesException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NameLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementTypeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipOfSourceReferenceIsDifferentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::MergePullRequestBySquashError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergePullRequestBySquashError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestBySquashError {
    /// Creates the `MergePullRequestBySquashError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `MergePullRequestBySquashError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::ConcurrentReferenceUpdateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidReplacementContentException(e) => e.meta(),
            Self::InvalidReplacementTypeException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::ManualMergeRequiredException(e) => e.meta(),
            Self::MaximumConflictResolutionEntriesExceededException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MultipleConflictResolutionEntriesException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestApprovalRulesNotSatisfiedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::ReplacementContentRequiredException(e) => e.meta(),
            Self::ReplacementTypeRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryNotAssociatedWithPullRequestException(e) => e.meta(),
            Self::TipOfSourceReferenceIsDifferentException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(self, Self::ConcurrentReferenceUpdateException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementContentException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementTypeException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(self, Self::ManualMergeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            self,
            Self::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(self, Self::MultipleConflictResolutionEntriesException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PullRequestApprovalRulesNotSatisfiedException`.
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(self, Self::PullRequestApprovalRulesNotSatisfiedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementTypeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::TipOfSourceReferenceIsDifferentException`.
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(self, Self::TipOfSourceReferenceIsDifferentException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for MergePullRequestBySquashError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => Some(_inner),
            Self::ConcurrentReferenceUpdateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidEmailException(_inner) => Some(_inner),
            Self::InvalidFileModeException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidReplacementContentException(_inner) => Some(_inner),
            Self::InvalidReplacementTypeException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::ManualMergeRequiredException(_inner) => Some(_inner),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::MultipleConflictResolutionEntriesException(_inner) => Some(_inner),
            Self::NameLengthExceededException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::ReplacementContentRequiredException(_inner) => Some(_inner),
            Self::ReplacementTypeRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => Some(_inner),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type MergePullRequestByFastForwardErrorKind = MergePullRequestByFastForwardError;
/// Error type for the `MergePullRequestByFastForwardError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestByFastForwardError {
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(
        crate::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>The specified reference does not exist. You must provide a full commit ID.</p>
    ReferenceDoesNotExistException(crate::error::ReferenceDoesNotExistException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(
        crate::error::TipOfSourceReferenceIsDifferentException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for MergePullRequestByFastForwardError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for MergePullRequestByFastForwardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ConcurrentReferenceUpdateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::ReferenceDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => _inner.fmt(f),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MergePullRequestByFastForwardError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ConcurrentReferenceUpdateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ManualMergeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReferenceDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipOfSourceReferenceIsDifferentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::MergePullRequestByFastForwardError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergePullRequestByFastForwardError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestByFastForwardError {
    /// Creates the `MergePullRequestByFastForwardError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `MergePullRequestByFastForwardError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ConcurrentReferenceUpdateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::ManualMergeRequiredException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestApprovalRulesNotSatisfiedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::ReferenceDoesNotExistException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryNotAssociatedWithPullRequestException(e) => e.meta(),
            Self::TipOfSourceReferenceIsDifferentException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(self, Self::ConcurrentReferenceUpdateException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(self, Self::ManualMergeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::PullRequestApprovalRulesNotSatisfiedException`.
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(self, Self::PullRequestApprovalRulesNotSatisfiedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::ReferenceDoesNotExistException`.
    pub fn is_reference_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ReferenceDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByFastForwardError::TipOfSourceReferenceIsDifferentException`.
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(self, Self::TipOfSourceReferenceIsDifferentException(_))
    }
}
impl std::error::Error for MergePullRequestByFastForwardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ConcurrentReferenceUpdateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::ManualMergeRequiredException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::ReferenceDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => Some(_inner),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified reference does not exist. You must provide a full commit ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReferenceDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException).
    pub fn builder() -> crate::error::reference_does_not_exist_exception::Builder {
        crate::error::reference_does_not_exist_exception::Builder::default()
    }
}
/// See [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException).
pub mod reference_does_not_exist_exception {

    /// A builder for [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceDoesNotExistException`](crate::error::ReferenceDoesNotExistException).
        pub fn build(self) -> crate::error::ReferenceDoesNotExistException {
            crate::error::ReferenceDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ReferenceDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReferenceDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReferenceDoesNotExistException")?;
        if let Some(inner_127) = &self.message {
            {
                write!(f, ": {}", inner_127)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReferenceDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::ReferenceDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReferenceDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type MergeBranchesByThreeWayErrorKind = MergeBranchesByThreeWayError;
/// Error type for the `MergeBranchesByThreeWayError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergeBranchesByThreeWayError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::error::FileModeRequiredException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified target branch is not valid.</p>
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for MergeBranchesByThreeWayError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for MergeBranchesByThreeWayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::ConcurrentReferenceUpdateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FileModeRequiredException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementContentException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementTypeException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidTargetBranchException(_inner) => _inner.fmt(f),
            Self::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MultipleConflictResolutionEntriesException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementContentRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementTypeRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MergeBranchesByThreeWayError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameIsTagNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitMessageLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConcurrentReferenceUpdateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileModeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FolderContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEmailException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileModeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetBranchException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ManualMergeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MultipleConflictResolutionEntriesException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NameLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementTypeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::MergeBranchesByThreeWayError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergeBranchesByThreeWayError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergeBranchesByThreeWayError {
    /// Creates the `MergeBranchesByThreeWayError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `MergeBranchesByThreeWayError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameIsTagNameException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::ConcurrentReferenceUpdateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FileModeRequiredException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidReplacementContentException(e) => e.meta(),
            Self::InvalidReplacementTypeException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidTargetBranchException(e) => e.meta(),
            Self::ManualMergeRequiredException(e) => e.meta(),
            Self::MaximumConflictResolutionEntriesExceededException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MultipleConflictResolutionEntriesException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::ReplacementContentRequiredException(e) => e.meta(),
            Self::ReplacementTypeRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(self, Self::BranchNameIsTagNameException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(self, Self::ConcurrentReferenceUpdateException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::FileModeRequiredException`.
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(self, Self::FileModeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementContentException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementTypeException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::InvalidTargetBranchException`.
    pub fn is_invalid_target_branch_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetBranchException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(self, Self::ManualMergeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            self,
            Self::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(self, Self::MultipleConflictResolutionEntriesException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementTypeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByThreeWayError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for MergeBranchesByThreeWayError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => Some(_inner),
            Self::BranchNameIsTagNameException(_inner) => Some(_inner),
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitMessageLengthExceededException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::ConcurrentReferenceUpdateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::FileModeRequiredException(_inner) => Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidEmailException(_inner) => Some(_inner),
            Self::InvalidFileModeException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidReplacementContentException(_inner) => Some(_inner),
            Self::InvalidReplacementTypeException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidTargetBranchException(_inner) => Some(_inner),
            Self::ManualMergeRequiredException(_inner) => Some(_inner),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::MultipleConflictResolutionEntriesException(_inner) => Some(_inner),
            Self::NameLengthExceededException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::ReplacementContentRequiredException(_inner) => Some(_inner),
            Self::ReplacementTypeRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified target branch is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTargetBranchException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTargetBranchException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException).
    pub fn builder() -> crate::error::invalid_target_branch_exception::Builder {
        crate::error::invalid_target_branch_exception::Builder::default()
    }
}
/// See [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException).
pub mod invalid_target_branch_exception {

    /// A builder for [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetBranchException`](crate::error::InvalidTargetBranchException).
        pub fn build(self) -> crate::error::InvalidTargetBranchException {
            crate::error::InvalidTargetBranchException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidTargetBranchException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetBranchException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetBranchException")?;
        if let Some(inner_128) = &self.message {
            {
                write!(f, ": {}", inner_128)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetBranchException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTargetBranchException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTargetBranchException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified commit is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidCommitException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidCommitException {
    /// Creates a new builder-style object to manufacture [`InvalidCommitException`](crate::error::InvalidCommitException).
    pub fn builder() -> crate::error::invalid_commit_exception::Builder {
        crate::error::invalid_commit_exception::Builder::default()
    }
}
/// See [`InvalidCommitException`](crate::error::InvalidCommitException).
pub mod invalid_commit_exception {

    /// A builder for [`InvalidCommitException`](crate::error::InvalidCommitException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidCommitException`](crate::error::InvalidCommitException).
        pub fn build(self) -> crate::error::InvalidCommitException {
            crate::error::InvalidCommitException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidCommitException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidCommitException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidCommitException")?;
        if let Some(inner_129) = &self.message {
            {
                write!(f, ": {}", inner_129)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidCommitException {}
impl aws_http::request_id::RequestId for crate::error::InvalidCommitException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidCommitException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileModeRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileModeRequiredException {
    /// Creates a new builder-style object to manufacture [`FileModeRequiredException`](crate::error::FileModeRequiredException).
    pub fn builder() -> crate::error::file_mode_required_exception::Builder {
        crate::error::file_mode_required_exception::Builder::default()
    }
}
/// See [`FileModeRequiredException`](crate::error::FileModeRequiredException).
pub mod file_mode_required_exception {

    /// A builder for [`FileModeRequiredException`](crate::error::FileModeRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileModeRequiredException`](crate::error::FileModeRequiredException).
        pub fn build(self) -> crate::error::FileModeRequiredException {
            crate::error::FileModeRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FileModeRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileModeRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileModeRequiredException")?;
        if let Some(inner_130) = &self.message {
            {
                write!(f, ": {}", inner_130)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileModeRequiredException {}
impl aws_http::request_id::RequestId for crate::error::FileModeRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FileModeRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A commit was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommitRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommitRequiredException {
    /// Creates a new builder-style object to manufacture [`CommitRequiredException`](crate::error::CommitRequiredException).
    pub fn builder() -> crate::error::commit_required_exception::Builder {
        crate::error::commit_required_exception::Builder::default()
    }
}
/// See [`CommitRequiredException`](crate::error::CommitRequiredException).
pub mod commit_required_exception {

    /// A builder for [`CommitRequiredException`](crate::error::CommitRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommitRequiredException`](crate::error::CommitRequiredException).
        pub fn build(self) -> crate::error::CommitRequiredException {
            crate::error::CommitRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommitRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitRequiredException")?;
        if let Some(inner_131) = &self.message {
            {
                write!(f, ": {}", inner_131)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommitRequiredException {}
impl aws_http::request_id::RequestId for crate::error::CommitRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommitRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type MergeBranchesBySquashErrorKind = MergeBranchesBySquashError;
/// Error type for the `MergeBranchesBySquashError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergeBranchesBySquashError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::error::FileModeRequiredException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified target branch is not valid.</p>
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for MergeBranchesBySquashError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for MergeBranchesBySquashError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::ConcurrentReferenceUpdateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FileModeRequiredException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementContentException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementTypeException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidTargetBranchException(_inner) => _inner.fmt(f),
            Self::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MultipleConflictResolutionEntriesException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementContentRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementTypeRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MergeBranchesBySquashError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameIsTagNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitMessageLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConcurrentReferenceUpdateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileModeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FolderContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEmailException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileModeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetBranchException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ManualMergeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MultipleConflictResolutionEntriesException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NameLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementTypeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::MergeBranchesBySquashError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergeBranchesBySquashError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergeBranchesBySquashError {
    /// Creates the `MergeBranchesBySquashError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `MergeBranchesBySquashError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameIsTagNameException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::ConcurrentReferenceUpdateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FileModeRequiredException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidReplacementContentException(e) => e.meta(),
            Self::InvalidReplacementTypeException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidTargetBranchException(e) => e.meta(),
            Self::ManualMergeRequiredException(e) => e.meta(),
            Self::MaximumConflictResolutionEntriesExceededException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MultipleConflictResolutionEntriesException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::ReplacementContentRequiredException(e) => e.meta(),
            Self::ReplacementTypeRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(self, Self::BranchNameIsTagNameException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(self, Self::ConcurrentReferenceUpdateException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::FileModeRequiredException`.
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(self, Self::FileModeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementContentException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementTypeException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::InvalidTargetBranchException`.
    pub fn is_invalid_target_branch_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetBranchException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(self, Self::ManualMergeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            self,
            Self::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(self, Self::MultipleConflictResolutionEntriesException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementTypeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesBySquashError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for MergeBranchesBySquashError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => Some(_inner),
            Self::BranchNameIsTagNameException(_inner) => Some(_inner),
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitMessageLengthExceededException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::ConcurrentReferenceUpdateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::FileModeRequiredException(_inner) => Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidEmailException(_inner) => Some(_inner),
            Self::InvalidFileModeException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidReplacementContentException(_inner) => Some(_inner),
            Self::InvalidReplacementTypeException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidTargetBranchException(_inner) => Some(_inner),
            Self::ManualMergeRequiredException(_inner) => Some(_inner),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::MultipleConflictResolutionEntriesException(_inner) => Some(_inner),
            Self::NameLengthExceededException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::ReplacementContentRequiredException(_inner) => Some(_inner),
            Self::ReplacementTypeRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type MergeBranchesByFastForwardErrorKind = MergeBranchesByFastForwardError;
/// Error type for the `MergeBranchesByFastForwardError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergeBranchesByFastForwardError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified target branch is not valid.</p>
    InvalidTargetBranchException(crate::error::InvalidTargetBranchException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for MergeBranchesByFastForwardError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for MergeBranchesByFastForwardError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::ConcurrentReferenceUpdateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidTargetBranchException(_inner) => _inner.fmt(f),
            Self::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MergeBranchesByFastForwardError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameIsTagNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConcurrentReferenceUpdateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetBranchException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ManualMergeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::MergeBranchesByFastForwardError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergeBranchesByFastForwardError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergeBranchesByFastForwardError {
    /// Creates the `MergeBranchesByFastForwardError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `MergeBranchesByFastForwardError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameIsTagNameException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::ConcurrentReferenceUpdateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidTargetBranchException(e) => e.meta(),
            Self::ManualMergeRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(self, Self::BranchNameIsTagNameException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(self, Self::ConcurrentReferenceUpdateException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::InvalidTargetBranchException`.
    pub fn is_invalid_target_branch_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetBranchException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(self, Self::ManualMergeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergeBranchesByFastForwardError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for MergeBranchesByFastForwardError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => Some(_inner),
            Self::BranchNameIsTagNameException(_inner) => Some(_inner),
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::ConcurrentReferenceUpdateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidTargetBranchException(_inner) => Some(_inner),
            Self::ManualMergeRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListTagsForResourceErrorKind = ListTagsForResourceError;
/// Error type for the `ListTagsForResourceError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListTagsForResourceError {
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The value for the resource ARN is not valid. For more information about resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    InvalidResourceArnException(crate::error::InvalidResourceArnException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the AWS CodeCommit User Guide.</p>
    ResourceArnRequiredException(crate::error::ResourceArnRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListTagsForResourceError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListTagsForResourceError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidResourceArnException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ResourceArnRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListTagsForResourceError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidResourceArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ResourceArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListTagsForResourceError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListTagsForResourceError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListTagsForResourceError {
    /// Creates the `ListTagsForResourceError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListTagsForResourceError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidResourceArnException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::ResourceArnRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::InvalidResourceArnException`.
    pub fn is_invalid_resource_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidResourceArnException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListTagsForResourceError::ResourceArnRequiredException`.
    pub fn is_resource_arn_required_exception(&self) -> bool {
        matches!(self, Self::ResourceArnRequiredException(_))
    }
}
impl std::error::Error for ListTagsForResourceError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidResourceArnException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::ResourceArnRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListRepositoriesForApprovalRuleTemplateErrorKind =
    ListRepositoriesForApprovalRuleTemplateError;
/// Error type for the `ListRepositoriesForApprovalRuleTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRepositoriesForApprovalRuleTemplateError {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for ListRepositoriesForApprovalRuleTemplateError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListRepositoriesForApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListRepositoriesForApprovalRuleTemplateError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxResultsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::ListRepositoriesForApprovalRuleTemplateError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRepositoriesForApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRepositoriesForApprovalRuleTemplateError {
    /// Creates the `ListRepositoriesForApprovalRuleTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListRepositoriesForApprovalRuleTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxResultsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesForApprovalRuleTemplateError::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxResultsException(_))
    }
}
impl std::error::Error for ListRepositoriesForApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxResultsException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified number of maximum results is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidMaxResultsException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidMaxResultsException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException).
    pub fn builder() -> crate::error::invalid_max_results_exception::Builder {
        crate::error::invalid_max_results_exception::Builder::default()
    }
}
/// See [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException).
pub mod invalid_max_results_exception {

    /// A builder for [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxResultsException`](crate::error::InvalidMaxResultsException).
        pub fn build(self) -> crate::error::InvalidMaxResultsException {
            crate::error::InvalidMaxResultsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidMaxResultsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxResultsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxResultsException")?;
        if let Some(inner_132) = &self.message {
            {
                write!(f, ": {}", inner_132)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxResultsException {}
impl aws_http::request_id::RequestId for crate::error::InvalidMaxResultsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidMaxResultsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified continuation token is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidContinuationTokenException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidContinuationTokenException {
    /// Creates a new builder-style object to manufacture [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException).
    pub fn builder() -> crate::error::invalid_continuation_token_exception::Builder {
        crate::error::invalid_continuation_token_exception::Builder::default()
    }
}
/// See [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException).
pub mod invalid_continuation_token_exception {

    /// A builder for [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidContinuationTokenException`](crate::error::InvalidContinuationTokenException).
        pub fn build(self) -> crate::error::InvalidContinuationTokenException {
            crate::error::InvalidContinuationTokenException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidContinuationTokenException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidContinuationTokenException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidContinuationTokenException")?;
        if let Some(inner_133) = &self.message {
            {
                write!(f, ": {}", inner_133)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidContinuationTokenException {}
impl aws_http::request_id::RequestId for crate::error::InvalidContinuationTokenException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidContinuationTokenException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListRepositoriesErrorKind = ListRepositoriesError;
/// Error type for the `ListRepositoriesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListRepositoriesError {
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified sort order is not valid.</p>
    InvalidOrderException(crate::error::InvalidOrderException),
    /// <p>The specified sort by value is not valid.</p>
    InvalidSortByException(crate::error::InvalidSortByException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListRepositoriesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidOrderException(_inner) => _inner.fmt(f),
            Self::InvalidSortByException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListRepositoriesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidOrderException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSortByException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListRepositoriesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListRepositoriesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListRepositoriesError {
    /// Creates the `ListRepositoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListRepositoriesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidOrderException(e) => e.meta(),
            Self::InvalidSortByException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListRepositoriesError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesError::InvalidOrderException`.
    pub fn is_invalid_order_exception(&self) -> bool {
        matches!(self, Self::InvalidOrderException(_))
    }
    /// Returns `true` if the error kind is `ListRepositoriesError::InvalidSortByException`.
    pub fn is_invalid_sort_by_exception(&self) -> bool {
        matches!(self, Self::InvalidSortByException(_))
    }
}
impl std::error::Error for ListRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidOrderException(_inner) => Some(_inner),
            Self::InvalidSortByException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified sort by value is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSortByException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSortByException {
    /// Creates a new builder-style object to manufacture [`InvalidSortByException`](crate::error::InvalidSortByException).
    pub fn builder() -> crate::error::invalid_sort_by_exception::Builder {
        crate::error::invalid_sort_by_exception::Builder::default()
    }
}
/// See [`InvalidSortByException`](crate::error::InvalidSortByException).
pub mod invalid_sort_by_exception {

    /// A builder for [`InvalidSortByException`](crate::error::InvalidSortByException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSortByException`](crate::error::InvalidSortByException).
        pub fn build(self) -> crate::error::InvalidSortByException {
            crate::error::InvalidSortByException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidSortByException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSortByException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSortByException")?;
        if let Some(inner_134) = &self.message {
            {
                write!(f, ": {}", inner_134)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSortByException {}
impl aws_http::request_id::RequestId for crate::error::InvalidSortByException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidSortByException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified sort order is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidOrderException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidOrderException {
    /// Creates a new builder-style object to manufacture [`InvalidOrderException`](crate::error::InvalidOrderException).
    pub fn builder() -> crate::error::invalid_order_exception::Builder {
        crate::error::invalid_order_exception::Builder::default()
    }
}
/// See [`InvalidOrderException`](crate::error::InvalidOrderException).
pub mod invalid_order_exception {

    /// A builder for [`InvalidOrderException`](crate::error::InvalidOrderException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidOrderException`](crate::error::InvalidOrderException).
        pub fn build(self) -> crate::error::InvalidOrderException {
            crate::error::InvalidOrderException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidOrderException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidOrderException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidOrderException")?;
        if let Some(inner_135) = &self.message {
            {
                write!(f, ": {}", inner_135)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidOrderException {}
impl aws_http::request_id::RequestId for crate::error::InvalidOrderException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidOrderException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListPullRequestsErrorKind = ListPullRequestsError;
/// Error type for the `ListPullRequestsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListPullRequestsError {
    /// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
    AuthorDoesNotExistException(crate::error::AuthorDoesNotExistException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.</p>
    InvalidAuthorArnException(crate::error::InvalidAuthorArnException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The pull request status is not valid. The only valid values are <code>OPEN</code> and <code>CLOSED</code>.</p>
    InvalidPullRequestStatusException(crate::error::InvalidPullRequestStatusException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListPullRequestsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListPullRequestsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::AuthorDoesNotExistException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidAuthorArnException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestStatusException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListPullRequestsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::AuthorDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidAuthorArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxResultsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestStatusException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListPullRequestsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListPullRequestsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListPullRequestsError {
    /// Creates the `ListPullRequestsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListPullRequestsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::AuthorDoesNotExistException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidAuthorArnException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxResultsException(e) => e.meta(),
            Self::InvalidPullRequestStatusException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::AuthorDoesNotExistException`.
    pub fn is_author_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::AuthorDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::InvalidAuthorArnException`.
    pub fn is_invalid_author_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidAuthorArnException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxResultsException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::InvalidPullRequestStatusException`.
    pub fn is_invalid_pull_request_status_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestStatusException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListPullRequestsError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for ListPullRequestsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::AuthorDoesNotExistException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidAuthorArnException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxResultsException(_inner) => Some(_inner),
            Self::InvalidPullRequestStatusException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the author of the pull request, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidAuthorArnException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidAuthorArnException {
    /// Creates a new builder-style object to manufacture [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException).
    pub fn builder() -> crate::error::invalid_author_arn_exception::Builder {
        crate::error::invalid_author_arn_exception::Builder::default()
    }
}
/// See [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException).
pub mod invalid_author_arn_exception {

    /// A builder for [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidAuthorArnException`](crate::error::InvalidAuthorArnException).
        pub fn build(self) -> crate::error::InvalidAuthorArnException {
            crate::error::InvalidAuthorArnException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidAuthorArnException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidAuthorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidAuthorArnException")?;
        if let Some(inner_136) = &self.message {
            {
                write!(f, ": {}", inner_136)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidAuthorArnException {}
impl aws_http::request_id::RequestId for crate::error::InvalidAuthorArnException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidAuthorArnException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct AuthorDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl AuthorDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException).
    pub fn builder() -> crate::error::author_does_not_exist_exception::Builder {
        crate::error::author_does_not_exist_exception::Builder::default()
    }
}
/// See [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException).
pub mod author_does_not_exist_exception {

    /// A builder for [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`AuthorDoesNotExistException`](crate::error::AuthorDoesNotExistException).
        pub fn build(self) -> crate::error::AuthorDoesNotExistException {
            crate::error::AuthorDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl AuthorDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for AuthorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "AuthorDoesNotExistException")?;
        if let Some(inner_137) = &self.message {
            {
                write!(f, ": {}", inner_137)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for AuthorDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::AuthorDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for AuthorDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListBranchesErrorKind = ListBranchesError;
/// Error type for the `ListBranchesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListBranchesError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListBranchesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListBranchesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListBranchesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListBranchesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListBranchesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListBranchesError {
    /// Creates the `ListBranchesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListBranchesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListBranchesError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `ListBranchesError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListBranchesError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `ListBranchesError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListBranchesError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListBranchesError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListBranchesError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `ListBranchesError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListBranchesError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for ListBranchesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind =
    ListAssociatedApprovalRuleTemplatesForRepositoryError;
/// Error type for the `ListAssociatedApprovalRuleTemplatesForRepositoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListAssociatedApprovalRuleTemplatesForRepositoryError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for ListAssociatedApprovalRuleTemplatesForRepositoryError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListAssociatedApprovalRuleTemplatesForRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ListAssociatedApprovalRuleTemplatesForRepositoryError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxResultsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for ListAssociatedApprovalRuleTemplatesForRepositoryError
{
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListAssociatedApprovalRuleTemplatesForRepositoryError {
    /// Creates the `ListAssociatedApprovalRuleTemplatesForRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListAssociatedApprovalRuleTemplatesForRepositoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxResultsException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxResultsException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `ListAssociatedApprovalRuleTemplatesForRepositoryError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for ListAssociatedApprovalRuleTemplatesForRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxResultsException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type ListApprovalRuleTemplatesErrorKind = ListApprovalRuleTemplatesError;
/// Error type for the `ListApprovalRuleTemplatesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum ListApprovalRuleTemplatesError {
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for ListApprovalRuleTemplatesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for ListApprovalRuleTemplatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ListApprovalRuleTemplatesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxResultsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::ListApprovalRuleTemplatesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for ListApprovalRuleTemplatesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl ListApprovalRuleTemplatesError {
    /// Creates the `ListApprovalRuleTemplatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `ListApprovalRuleTemplatesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxResultsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `ListApprovalRuleTemplatesError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `ListApprovalRuleTemplatesError::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxResultsException(_))
    }
}
impl std::error::Error for ListApprovalRuleTemplatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxResultsException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetRepositoryTriggersErrorKind = GetRepositoryTriggersError;
/// Error type for the `GetRepositoryTriggersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRepositoryTriggersError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRepositoryTriggersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRepositoryTriggersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRepositoryTriggersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRepositoryTriggersError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRepositoryTriggersError {
    /// Creates the `GetRepositoryTriggersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetRepositoryTriggersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryTriggersError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetRepositoryTriggersError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetRepositoryErrorKind = GetRepositoryError;
/// Error type for the `GetRepositoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetRepositoryError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetRepositoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetRepositoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetRepositoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetRepositoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetRepositoryError {
    /// Creates the `GetRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetRepositoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetRepositoryError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetRepositoryError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetPullRequestOverrideStateErrorKind = GetPullRequestOverrideStateError;
/// Error type for the `GetPullRequestOverrideStateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPullRequestOverrideStateError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetPullRequestOverrideStateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetPullRequestOverrideStateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionIdException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::RevisionIdRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetPullRequestOverrideStateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRevisionIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetPullRequestOverrideStateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPullRequestOverrideStateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPullRequestOverrideStateError {
    /// Creates the `GetPullRequestOverrideStateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetPullRequestOverrideStateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidRevisionIdException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::RevisionIdRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionIdException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestOverrideStateError::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(self, Self::RevisionIdRequiredException(_))
    }
}
impl std::error::Error for GetPullRequestOverrideStateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidRevisionIdException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::RevisionIdRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetPullRequestApprovalStatesErrorKind = GetPullRequestApprovalStatesError;
/// Error type for the `GetPullRequestApprovalStatesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPullRequestApprovalStatesError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetPullRequestApprovalStatesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetPullRequestApprovalStatesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionIdException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::RevisionIdRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetPullRequestApprovalStatesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRevisionIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetPullRequestApprovalStatesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPullRequestApprovalStatesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPullRequestApprovalStatesError {
    /// Creates the `GetPullRequestApprovalStatesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetPullRequestApprovalStatesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidRevisionIdException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::RevisionIdRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionIdException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestApprovalStatesError::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(self, Self::RevisionIdRequiredException(_))
    }
}
impl std::error::Error for GetPullRequestApprovalStatesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidRevisionIdException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::RevisionIdRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetPullRequestErrorKind = GetPullRequestError;
/// Error type for the `GetPullRequestError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetPullRequestError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetPullRequestError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetPullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetPullRequestError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetPullRequestError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetPullRequestError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetPullRequestError {
    /// Creates the `GetPullRequestError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetPullRequestError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetPullRequestError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetPullRequestError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
}
impl std::error::Error for GetPullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetMergeOptionsErrorKind = GetMergeOptionsError;
/// Error type for the `GetMergeOptionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMergeOptionsError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetMergeOptionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetMergeOptionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetMergeOptionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetMergeOptionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMergeOptionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMergeOptionsError {
    /// Creates the `GetMergeOptionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetMergeOptionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetMergeOptionsError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for GetMergeOptionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetMergeConflictsErrorKind = GetMergeConflictsError;
/// Error type for the `GetMergeConflictsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMergeConflictsError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID. </p>
    InvalidDestinationCommitSpecifierException(
        crate::error::InvalidDestinationCommitSpecifierException,
    ),
    /// <p>The specified value for the number of conflict files to return is not valid.</p>
    InvalidMaxConflictFilesException(crate::error::InvalidMaxConflictFilesException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.</p>
    InvalidSourceCommitSpecifierException(crate::error::InvalidSourceCommitSpecifierException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetMergeConflictsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetMergeConflictsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidDestinationCommitSpecifierException(_inner) => _inner.fmt(f),
            Self::InvalidMaxConflictFilesException(_inner) => _inner.fmt(f),
            Self::InvalidMergeOptionException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidSourceCommitSpecifierException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MergeOptionRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetMergeConflictsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDestinationCommitSpecifierException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxConflictFilesException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMergeOptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSourceCommitSpecifierException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MergeOptionRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetMergeConflictsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMergeConflictsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMergeConflictsError {
    /// Creates the `GetMergeConflictsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetMergeConflictsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidDestinationCommitSpecifierException(e) => e.meta(),
            Self::InvalidMaxConflictFilesException(e) => e.meta(),
            Self::InvalidMergeOptionException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidSourceCommitSpecifierException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MergeOptionRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::InvalidDestinationCommitSpecifierException`.
    pub fn is_invalid_destination_commit_specifier_exception(&self) -> bool {
        matches!(self, Self::InvalidDestinationCommitSpecifierException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::InvalidMaxConflictFilesException`.
    pub fn is_invalid_max_conflict_files_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxConflictFilesException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::InvalidMergeOptionException`.
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(self, Self::InvalidMergeOptionException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::InvalidSourceCommitSpecifierException`.
    pub fn is_invalid_source_commit_specifier_exception(&self) -> bool {
        matches!(self, Self::InvalidSourceCommitSpecifierException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::MergeOptionRequiredException`.
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(self, Self::MergeOptionRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetMergeConflictsError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for GetMergeConflictsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidDestinationCommitSpecifierException(_inner) => Some(_inner),
            Self::InvalidMaxConflictFilesException(_inner) => Some(_inner),
            Self::InvalidMergeOptionException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidSourceCommitSpecifierException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::MergeOptionRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A merge option or stategy is required, and none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MergeOptionRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MergeOptionRequiredException {
    /// Creates a new builder-style object to manufacture [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException).
    pub fn builder() -> crate::error::merge_option_required_exception::Builder {
        crate::error::merge_option_required_exception::Builder::default()
    }
}
/// See [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException).
pub mod merge_option_required_exception {

    /// A builder for [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MergeOptionRequiredException`](crate::error::MergeOptionRequiredException).
        pub fn build(self) -> crate::error::MergeOptionRequiredException {
            crate::error::MergeOptionRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MergeOptionRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MergeOptionRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MergeOptionRequiredException")?;
        if let Some(inner_138) = &self.message {
            {
                write!(f, ": {}", inner_138)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MergeOptionRequiredException {}
impl aws_http::request_id::RequestId for crate::error::MergeOptionRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MergeOptionRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The source commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidSourceCommitSpecifierException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidSourceCommitSpecifierException {
    /// Creates a new builder-style object to manufacture [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException).
    pub fn builder() -> crate::error::invalid_source_commit_specifier_exception::Builder {
        crate::error::invalid_source_commit_specifier_exception::Builder::default()
    }
}
/// See [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException).
pub mod invalid_source_commit_specifier_exception {

    /// A builder for [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidSourceCommitSpecifierException`](crate::error::InvalidSourceCommitSpecifierException).
        pub fn build(self) -> crate::error::InvalidSourceCommitSpecifierException {
            crate::error::InvalidSourceCommitSpecifierException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidSourceCommitSpecifierException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidSourceCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidSourceCommitSpecifierException")?;
        if let Some(inner_139) = &self.message {
            {
                write!(f, ": {}", inner_139)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidSourceCommitSpecifierException {}
impl aws_http::request_id::RequestId for crate::error::InvalidSourceCommitSpecifierException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidSourceCommitSpecifierException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidMergeOptionException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidMergeOptionException {
    /// Creates a new builder-style object to manufacture [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException).
    pub fn builder() -> crate::error::invalid_merge_option_exception::Builder {
        crate::error::invalid_merge_option_exception::Builder::default()
    }
}
/// See [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException).
pub mod invalid_merge_option_exception {

    /// A builder for [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMergeOptionException`](crate::error::InvalidMergeOptionException).
        pub fn build(self) -> crate::error::InvalidMergeOptionException {
            crate::error::InvalidMergeOptionException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidMergeOptionException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMergeOptionException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMergeOptionException")?;
        if let Some(inner_140) = &self.message {
            {
                write!(f, ": {}", inner_140)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMergeOptionException {}
impl aws_http::request_id::RequestId for crate::error::InvalidMergeOptionException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidMergeOptionException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified value for the number of conflict files to return is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidMaxConflictFilesException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidMaxConflictFilesException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException).
    pub fn builder() -> crate::error::invalid_max_conflict_files_exception::Builder {
        crate::error::invalid_max_conflict_files_exception::Builder::default()
    }
}
/// See [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException).
pub mod invalid_max_conflict_files_exception {

    /// A builder for [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxConflictFilesException`](crate::error::InvalidMaxConflictFilesException).
        pub fn build(self) -> crate::error::InvalidMaxConflictFilesException {
            crate::error::InvalidMaxConflictFilesException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidMaxConflictFilesException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxConflictFilesException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxConflictFilesException")?;
        if let Some(inner_141) = &self.message {
            {
                write!(f, ": {}", inner_141)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxConflictFilesException {}
impl aws_http::request_id::RequestId for crate::error::InvalidMaxConflictFilesException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidMaxConflictFilesException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The destination commit specifier is not valid. You must provide a valid branch name, tag, or full commit ID. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidDestinationCommitSpecifierException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidDestinationCommitSpecifierException {
    /// Creates a new builder-style object to manufacture [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException).
    pub fn builder() -> crate::error::invalid_destination_commit_specifier_exception::Builder {
        crate::error::invalid_destination_commit_specifier_exception::Builder::default()
    }
}
/// See [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException).
pub mod invalid_destination_commit_specifier_exception {

    /// A builder for [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidDestinationCommitSpecifierException`](crate::error::InvalidDestinationCommitSpecifierException).
        pub fn build(self) -> crate::error::InvalidDestinationCommitSpecifierException {
            crate::error::InvalidDestinationCommitSpecifierException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidDestinationCommitSpecifierException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidDestinationCommitSpecifierException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidDestinationCommitSpecifierException")?;
        if let Some(inner_142) = &self.message {
            {
                write!(f, ": {}", inner_142)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidDestinationCommitSpecifierException {}
impl aws_http::request_id::RequestId for crate::error::InvalidDestinationCommitSpecifierException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidDestinationCommitSpecifierException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetMergeCommitErrorKind = GetMergeCommitError;
/// Error type for the `GetMergeCommitError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetMergeCommitError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetMergeCommitError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetMergeCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetMergeCommitError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetMergeCommitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetMergeCommitError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetMergeCommitError {
    /// Creates the `GetMergeCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetMergeCommitError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetMergeCommitError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetMergeCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetFolderErrorKind = GetFolderError;
/// Error type for the `GetFolderError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFolderError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified folder does not exist. Either the folder name is not correct, or you did not enter the full path to the folder.</p>
    FolderDoesNotExistException(crate::error::FolderDoesNotExistException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetFolderError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetFolderError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FolderDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetFolderError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FolderDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetFolderError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFolderError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFolderError {
    /// Creates the `GetFolderError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetFolderError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FolderDoesNotExistException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetFolderError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::FolderDoesNotExistException`.
    pub fn is_folder_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::FolderDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetFolderError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetFolderError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FolderDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified folder does not exist. Either the folder name is not correct, or you did not enter the full path to the folder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FolderDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FolderDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException).
    pub fn builder() -> crate::error::folder_does_not_exist_exception::Builder {
        crate::error::folder_does_not_exist_exception::Builder::default()
    }
}
/// See [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException).
pub mod folder_does_not_exist_exception {

    /// A builder for [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FolderDoesNotExistException`](crate::error::FolderDoesNotExistException).
        pub fn build(self) -> crate::error::FolderDoesNotExistException {
            crate::error::FolderDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FolderDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FolderDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FolderDoesNotExistException")?;
        if let Some(inner_143) = &self.message {
            {
                write!(f, ": {}", inner_143)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FolderDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::FolderDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FolderDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetFileErrorKind = GetFileError;
/// Error type for the `GetFileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetFileError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    /// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    FileTooLargeException(crate::error::FileTooLargeException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetFileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileDoesNotExistException(_inner) => _inner.fmt(f),
            Self::FileTooLargeException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetFileError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileTooLargeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetFileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetFileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetFileError {
    /// Creates the `GetFileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetFileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileDoesNotExistException(e) => e.meta(),
            Self::FileTooLargeException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetFileError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::FileDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::FileTooLargeException`.
    pub fn is_file_too_large_exception(&self) -> bool {
        matches!(self, Self::FileTooLargeException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetFileError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileDoesNotExistException(_inner) => Some(_inner),
            Self::FileTooLargeException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileTooLargeException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileTooLargeException {
    /// Creates a new builder-style object to manufacture [`FileTooLargeException`](crate::error::FileTooLargeException).
    pub fn builder() -> crate::error::file_too_large_exception::Builder {
        crate::error::file_too_large_exception::Builder::default()
    }
}
/// See [`FileTooLargeException`](crate::error::FileTooLargeException).
pub mod file_too_large_exception {

    /// A builder for [`FileTooLargeException`](crate::error::FileTooLargeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileTooLargeException`](crate::error::FileTooLargeException).
        pub fn build(self) -> crate::error::FileTooLargeException {
            crate::error::FileTooLargeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FileTooLargeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileTooLargeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileTooLargeException")?;
        if let Some(inner_144) = &self.message {
            {
                write!(f, ": {}", inner_144)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileTooLargeException {}
impl aws_http::request_id::RequestId for crate::error::FileTooLargeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FileTooLargeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`FileDoesNotExistException`](crate::error::FileDoesNotExistException).
    pub fn builder() -> crate::error::file_does_not_exist_exception::Builder {
        crate::error::file_does_not_exist_exception::Builder::default()
    }
}
/// See [`FileDoesNotExistException`](crate::error::FileDoesNotExistException).
pub mod file_does_not_exist_exception {

    /// A builder for [`FileDoesNotExistException`](crate::error::FileDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileDoesNotExistException`](crate::error::FileDoesNotExistException).
        pub fn build(self) -> crate::error::FileDoesNotExistException {
            crate::error::FileDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FileDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileDoesNotExistException")?;
        if let Some(inner_145) = &self.message {
            {
                write!(f, ": {}", inner_145)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::FileDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FileDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetDifferencesErrorKind = GetDifferencesError;
/// Error type for the `GetDifferencesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetDifferencesError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified path does not exist.</p>
    PathDoesNotExistException(crate::error::PathDoesNotExistException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetDifferencesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetDifferencesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::PathDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetDifferencesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxResultsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetDifferencesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetDifferencesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetDifferencesError {
    /// Creates the `GetDifferencesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetDifferencesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxResultsException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::PathDoesNotExistException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetDifferencesError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxResultsException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::PathDoesNotExistException`.
    pub fn is_path_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PathDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetDifferencesError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetDifferencesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxResultsException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::PathDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCommitErrorKind = GetCommitError;
/// Error type for the `GetCommitError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommitError {
    /// <p>The specified commit ID does not exist.</p>
    CommitIdDoesNotExistException(crate::error::CommitIdDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCommitError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitIdDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetCommitError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitIdDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCommitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommitError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommitError {
    /// Creates the `GetCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCommitError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitIdDoesNotExistException(e) => e.meta(),
            Self::CommitIdRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCommitError::CommitIdDoesNotExistException`.
    pub fn is_commit_id_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitIdDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::CommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetCommitError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitIdDoesNotExistException(_inner) => Some(_inner),
            Self::CommitIdRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified commit ID does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommitIdDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommitIdDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException).
    pub fn builder() -> crate::error::commit_id_does_not_exist_exception::Builder {
        crate::error::commit_id_does_not_exist_exception::Builder::default()
    }
}
/// See [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException).
pub mod commit_id_does_not_exist_exception {

    /// A builder for [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdDoesNotExistException`](crate::error::CommitIdDoesNotExistException).
        pub fn build(self) -> crate::error::CommitIdDoesNotExistException {
            crate::error::CommitIdDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommitIdDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdDoesNotExistException")?;
        if let Some(inner_146) = &self.message {
            {
                write!(f, ": {}", inner_146)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::CommitIdDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommitIdDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCommentsForPullRequestErrorKind = GetCommentsForPullRequestError;
/// Error type for the `GetCommentsForPullRequestError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentsForPullRequestError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCommentsForPullRequestError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCommentsForPullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetCommentsForPullRequestError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxResultsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCommentsForPullRequestError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommentsForPullRequestError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentsForPullRequestError {
    /// Creates the `GetCommentsForPullRequestError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCommentsForPullRequestError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitIdRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxResultsException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryNotAssociatedWithPullRequestException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::CommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxResultsException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForPullRequestError::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
}
impl std::error::Error for GetCommentsForPullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitIdRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxResultsException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCommentsForComparedCommitErrorKind = GetCommentsForComparedCommitError;
/// Error type for the `GetCommentsForComparedCommitError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentsForComparedCommitError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCommentsForComparedCommitError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCommentsForComparedCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetCommentsForComparedCommitError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxResultsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCommentsForComparedCommitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommentsForComparedCommitError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentsForComparedCommitError {
    /// Creates the `GetCommentsForComparedCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCommentsForComparedCommitError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitIdRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxResultsException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::CommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxResultsException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetCommentsForComparedCommitError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetCommentsForComparedCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitIdRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxResultsException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCommentReactionsErrorKind = GetCommentReactionsError;
/// Error type for the `GetCommentReactionsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentReactionsError {
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The Amazon Resource Name (ARN) of the user or identity is not valid.</p>
    InvalidReactionUserArnException(crate::error::InvalidReactionUserArnException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCommentReactionsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCommentReactionsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommentDeletedException(_inner) => _inner.fmt(f),
            Self::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommentIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidCommentIdException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            Self::InvalidReactionUserArnException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetCommentReactionsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommentDeletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxResultsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReactionUserArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCommentReactionsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommentReactionsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentReactionsError {
    /// Creates the `GetCommentReactionsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCommentReactionsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommentDeletedException(e) => e.meta(),
            Self::CommentDoesNotExistException(e) => e.meta(),
            Self::CommentIdRequiredException(e) => e.meta(),
            Self::InvalidCommentIdException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxResultsException(e) => e.meta(),
            Self::InvalidReactionUserArnException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCommentReactionsError::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(self, Self::CommentDeletedException(_))
    }
    /// Returns `true` if the error kind is `GetCommentReactionsError::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetCommentReactionsError::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(self, Self::CommentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetCommentReactionsError::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommentIdException(_))
    }
    /// Returns `true` if the error kind is `GetCommentReactionsError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `GetCommentReactionsError::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxResultsException(_))
    }
    /// Returns `true` if the error kind is `GetCommentReactionsError::InvalidReactionUserArnException`.
    pub fn is_invalid_reaction_user_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidReactionUserArnException(_))
    }
}
impl std::error::Error for GetCommentReactionsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommentDeletedException(_inner) => Some(_inner),
            Self::CommentDoesNotExistException(_inner) => Some(_inner),
            Self::CommentIdRequiredException(_inner) => Some(_inner),
            Self::InvalidCommentIdException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxResultsException(_inner) => Some(_inner),
            Self::InvalidReactionUserArnException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The Amazon Resource Name (ARN) of the user or identity is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidReactionUserArnException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidReactionUserArnException {
    /// Creates a new builder-style object to manufacture [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException).
    pub fn builder() -> crate::error::invalid_reaction_user_arn_exception::Builder {
        crate::error::invalid_reaction_user_arn_exception::Builder::default()
    }
}
/// See [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException).
pub mod invalid_reaction_user_arn_exception {

    /// A builder for [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReactionUserArnException`](crate::error::InvalidReactionUserArnException).
        pub fn build(self) -> crate::error::InvalidReactionUserArnException {
            crate::error::InvalidReactionUserArnException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidReactionUserArnException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReactionUserArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReactionUserArnException")?;
        if let Some(inner_147) = &self.message {
            {
                write!(f, ": {}", inner_147)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReactionUserArnException {}
impl aws_http::request_id::RequestId for crate::error::InvalidReactionUserArnException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidReactionUserArnException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetCommentErrorKind = GetCommentError;
/// Error type for the `GetCommentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetCommentError {
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetCommentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetCommentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommentDeletedException(_inner) => _inner.fmt(f),
            Self::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommentIdRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommentIdException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetCommentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommentDeletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetCommentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetCommentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetCommentError {
    /// Creates the `GetCommentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetCommentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommentDeletedException(e) => e.meta(),
            Self::CommentDoesNotExistException(e) => e.meta(),
            Self::CommentIdRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommentIdException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetCommentError::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(self, Self::CommentDeletedException(_))
    }
    /// Returns `true` if the error kind is `GetCommentError::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetCommentError::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(self, Self::CommentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetCommentError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetCommentError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetCommentError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetCommentError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetCommentError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetCommentError::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommentIdException(_))
    }
}
impl std::error::Error for GetCommentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommentDeletedException(_inner) => Some(_inner),
            Self::CommentDoesNotExistException(_inner) => Some(_inner),
            Self::CommentIdRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommentIdException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetBranchErrorKind = GetBranchError;
/// Error type for the `GetBranchError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBranchError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetBranchError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetBranchError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetBranchError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetBranchError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBranchError {
    /// Creates the `GetBranchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetBranchError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetBranchError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetBranchError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => Some(_inner),
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetBlobErrorKind = GetBlobError;
/// Error type for the `GetBlobError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetBlobError {
    /// <p>The specified blob does not exist.</p>
    BlobIdDoesNotExistException(crate::error::BlobIdDoesNotExistException),
    /// <p>A blob ID is required, but was not specified.</p>
    BlobIdRequiredException(crate::error::BlobIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified file exceeds the file size limit for AWS CodeCommit. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    FileTooLargeException(crate::error::FileTooLargeException),
    /// <p>The specified blob is not valid.</p>
    InvalidBlobIdException(crate::error::InvalidBlobIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetBlobError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetBlobError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BlobIdDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BlobIdRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileTooLargeException(_inner) => _inner.fmt(f),
            Self::InvalidBlobIdException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetBlobError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BlobIdDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BlobIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileTooLargeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBlobIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetBlobError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetBlobError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetBlobError {
    /// Creates the `GetBlobError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetBlobError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BlobIdDoesNotExistException(e) => e.meta(),
            Self::BlobIdRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileTooLargeException(e) => e.meta(),
            Self::InvalidBlobIdException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetBlobError::BlobIdDoesNotExistException`.
    pub fn is_blob_id_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BlobIdDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::BlobIdRequiredException`.
    pub fn is_blob_id_required_exception(&self) -> bool {
        matches!(self, Self::BlobIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::FileTooLargeException`.
    pub fn is_file_too_large_exception(&self) -> bool {
        matches!(self, Self::FileTooLargeException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::InvalidBlobIdException`.
    pub fn is_invalid_blob_id_exception(&self) -> bool {
        matches!(self, Self::InvalidBlobIdException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetBlobError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for GetBlobError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BlobIdDoesNotExistException(_inner) => Some(_inner),
            Self::BlobIdRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileTooLargeException(_inner) => Some(_inner),
            Self::InvalidBlobIdException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified blob is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidBlobIdException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidBlobIdException {
    /// Creates a new builder-style object to manufacture [`InvalidBlobIdException`](crate::error::InvalidBlobIdException).
    pub fn builder() -> crate::error::invalid_blob_id_exception::Builder {
        crate::error::invalid_blob_id_exception::Builder::default()
    }
}
/// See [`InvalidBlobIdException`](crate::error::InvalidBlobIdException).
pub mod invalid_blob_id_exception {

    /// A builder for [`InvalidBlobIdException`](crate::error::InvalidBlobIdException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidBlobIdException`](crate::error::InvalidBlobIdException).
        pub fn build(self) -> crate::error::InvalidBlobIdException {
            crate::error::InvalidBlobIdException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidBlobIdException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidBlobIdException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidBlobIdException")?;
        if let Some(inner_148) = &self.message {
            {
                write!(f, ": {}", inner_148)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidBlobIdException {}
impl aws_http::request_id::RequestId for crate::error::InvalidBlobIdException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidBlobIdException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A blob ID is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BlobIdRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BlobIdRequiredException {
    /// Creates a new builder-style object to manufacture [`BlobIdRequiredException`](crate::error::BlobIdRequiredException).
    pub fn builder() -> crate::error::blob_id_required_exception::Builder {
        crate::error::blob_id_required_exception::Builder::default()
    }
}
/// See [`BlobIdRequiredException`](crate::error::BlobIdRequiredException).
pub mod blob_id_required_exception {

    /// A builder for [`BlobIdRequiredException`](crate::error::BlobIdRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BlobIdRequiredException`](crate::error::BlobIdRequiredException).
        pub fn build(self) -> crate::error::BlobIdRequiredException {
            crate::error::BlobIdRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl BlobIdRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BlobIdRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BlobIdRequiredException")?;
        if let Some(inner_149) = &self.message {
            {
                write!(f, ": {}", inner_149)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BlobIdRequiredException {}
impl aws_http::request_id::RequestId for crate::error::BlobIdRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BlobIdRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified blob does not exist.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BlobIdDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BlobIdDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException).
    pub fn builder() -> crate::error::blob_id_does_not_exist_exception::Builder {
        crate::error::blob_id_does_not_exist_exception::Builder::default()
    }
}
/// See [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException).
pub mod blob_id_does_not_exist_exception {

    /// A builder for [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BlobIdDoesNotExistException`](crate::error::BlobIdDoesNotExistException).
        pub fn build(self) -> crate::error::BlobIdDoesNotExistException {
            crate::error::BlobIdDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl BlobIdDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BlobIdDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BlobIdDoesNotExistException")?;
        if let Some(inner_150) = &self.message {
            {
                write!(f, ": {}", inner_150)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BlobIdDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::BlobIdDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BlobIdDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type GetApprovalRuleTemplateErrorKind = GetApprovalRuleTemplateError;
/// Error type for the `GetApprovalRuleTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum GetApprovalRuleTemplateError {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for GetApprovalRuleTemplateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for GetApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for GetApprovalRuleTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::GetApprovalRuleTemplateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for GetApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl GetApprovalRuleTemplateError {
    /// Creates the `GetApprovalRuleTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `GetApprovalRuleTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `GetApprovalRuleTemplateError::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `GetApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `GetApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
}
impl std::error::Error for GetApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type EvaluatePullRequestApprovalRulesErrorKind = EvaluatePullRequestApprovalRulesError;
/// Error type for the `EvaluatePullRequestApprovalRulesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum EvaluatePullRequestApprovalRulesError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The revision ID is not valid. Use GetPullRequest to determine the value.</p>
    InvalidRevisionIdException(crate::error::InvalidRevisionIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// <p>A revision ID is required, but was not provided.</p>
    RevisionIdRequiredException(crate::error::RevisionIdRequiredException),
    /// <p>The revision ID provided in the request does not match the current revision ID. Use GetPullRequest to retrieve the current revision ID.</p>
    RevisionNotCurrentException(crate::error::RevisionNotCurrentException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for EvaluatePullRequestApprovalRulesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for EvaluatePullRequestApprovalRulesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidRevisionIdException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::RevisionIdRequiredException(_inner) => _inner.fmt(f),
            Self::RevisionNotCurrentException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for EvaluatePullRequestApprovalRulesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRevisionIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RevisionNotCurrentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::EvaluatePullRequestApprovalRulesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for EvaluatePullRequestApprovalRulesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl EvaluatePullRequestApprovalRulesError {
    /// Creates the `EvaluatePullRequestApprovalRulesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `EvaluatePullRequestApprovalRulesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidRevisionIdException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::RevisionIdRequiredException(e) => e.meta(),
            Self::RevisionNotCurrentException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::InvalidRevisionIdException`.
    pub fn is_invalid_revision_id_exception(&self) -> bool {
        matches!(self, Self::InvalidRevisionIdException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::RevisionIdRequiredException`.
    pub fn is_revision_id_required_exception(&self) -> bool {
        matches!(self, Self::RevisionIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `EvaluatePullRequestApprovalRulesError::RevisionNotCurrentException`.
    pub fn is_revision_not_current_exception(&self) -> bool {
        matches!(self, Self::RevisionNotCurrentException(_))
    }
}
impl std::error::Error for EvaluatePullRequestApprovalRulesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidRevisionIdException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::RevisionIdRequiredException(_inner) => Some(_inner),
            Self::RevisionNotCurrentException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DisassociateApprovalRuleTemplateFromRepositoryErrorKind =
    DisassociateApprovalRuleTemplateFromRepositoryError;
/// Error type for the `DisassociateApprovalRuleTemplateFromRepositoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DisassociateApprovalRuleTemplateFromRepositoryError {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for DisassociateApprovalRuleTemplateFromRepositoryError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DisassociateApprovalRuleTemplateFromRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DisassociateApprovalRuleTemplateFromRepositoryError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::DisassociateApprovalRuleTemplateFromRepositoryError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for DisassociateApprovalRuleTemplateFromRepositoryError
{
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DisassociateApprovalRuleTemplateFromRepositoryError {
    /// Creates the `DisassociateApprovalRuleTemplateFromRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DisassociateApprovalRuleTemplateFromRepositoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DisassociateApprovalRuleTemplateFromRepositoryError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for DisassociateApprovalRuleTemplateFromRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribePullRequestEventsErrorKind = DescribePullRequestEventsError;
/// Error type for the `DescribePullRequestEventsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribePullRequestEventsError {
    /// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
    ActorDoesNotExistException(crate::error::ActorDoesNotExistException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request, and then try again.</p>
    InvalidActorArnException(crate::error::InvalidActorArnException),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified number of maximum results is not valid.</p>
    InvalidMaxResultsException(crate::error::InvalidMaxResultsException),
    /// <p>The pull request event type is not valid. </p>
    InvalidPullRequestEventTypeException(crate::error::InvalidPullRequestEventTypeException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribePullRequestEventsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribePullRequestEventsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ActorDoesNotExistException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidActorArnException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxResultsException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestEventTypeException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribePullRequestEventsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ActorDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidActorArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxResultsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestEventTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribePullRequestEventsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribePullRequestEventsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribePullRequestEventsError {
    /// Creates the `DescribePullRequestEventsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribePullRequestEventsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ActorDoesNotExistException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidActorArnException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxResultsException(e) => e.meta(),
            Self::InvalidPullRequestEventTypeException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::ActorDoesNotExistException`.
    pub fn is_actor_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ActorDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::InvalidActorArnException`.
    pub fn is_invalid_actor_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidActorArnException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::InvalidMaxResultsException`.
    pub fn is_invalid_max_results_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxResultsException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::InvalidPullRequestEventTypeException`.
    pub fn is_invalid_pull_request_event_type_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestEventTypeException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribePullRequestEventsError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
}
impl std::error::Error for DescribePullRequestEventsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ActorDoesNotExistException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidActorArnException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxResultsException(_inner) => Some(_inner),
            Self::InvalidPullRequestEventTypeException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The pull request event type is not valid. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidPullRequestEventTypeException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidPullRequestEventTypeException {
    /// Creates a new builder-style object to manufacture [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException).
    pub fn builder() -> crate::error::invalid_pull_request_event_type_exception::Builder {
        crate::error::invalid_pull_request_event_type_exception::Builder::default()
    }
}
/// See [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException).
pub mod invalid_pull_request_event_type_exception {

    /// A builder for [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidPullRequestEventTypeException`](crate::error::InvalidPullRequestEventTypeException).
        pub fn build(self) -> crate::error::InvalidPullRequestEventTypeException {
            crate::error::InvalidPullRequestEventTypeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidPullRequestEventTypeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidPullRequestEventTypeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidPullRequestEventTypeException")?;
        if let Some(inner_151) = &self.message {
            {
                write!(f, ": {}", inner_151)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidPullRequestEventTypeException {}
impl aws_http::request_id::RequestId for crate::error::InvalidPullRequestEventTypeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for InvalidPullRequestEventTypeException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The Amazon Resource Name (ARN) is not valid. Make sure that you have provided the full ARN for the user who initiated the change for the pull request, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidActorArnException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidActorArnException {
    /// Creates a new builder-style object to manufacture [`InvalidActorArnException`](crate::error::InvalidActorArnException).
    pub fn builder() -> crate::error::invalid_actor_arn_exception::Builder {
        crate::error::invalid_actor_arn_exception::Builder::default()
    }
}
/// See [`InvalidActorArnException`](crate::error::InvalidActorArnException).
pub mod invalid_actor_arn_exception {

    /// A builder for [`InvalidActorArnException`](crate::error::InvalidActorArnException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidActorArnException`](crate::error::InvalidActorArnException).
        pub fn build(self) -> crate::error::InvalidActorArnException {
            crate::error::InvalidActorArnException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidActorArnException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidActorArnException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidActorArnException")?;
        if let Some(inner_152) = &self.message {
            {
                write!(f, ": {}", inner_152)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidActorArnException {}
impl aws_http::request_id::RequestId for crate::error::InvalidActorArnException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidActorArnException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified Amazon Resource Name (ARN) does not exist in the AWS account.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ActorDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ActorDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException).
    pub fn builder() -> crate::error::actor_does_not_exist_exception::Builder {
        crate::error::actor_does_not_exist_exception::Builder::default()
    }
}
/// See [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException).
pub mod actor_does_not_exist_exception {

    /// A builder for [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ActorDoesNotExistException`](crate::error::ActorDoesNotExistException).
        pub fn build(self) -> crate::error::ActorDoesNotExistException {
            crate::error::ActorDoesNotExistException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ActorDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ActorDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ActorDoesNotExistException")?;
        if let Some(inner_153) = &self.message {
            {
                write!(f, ": {}", inner_153)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ActorDoesNotExistException {}
impl aws_http::request_id::RequestId for crate::error::ActorDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ActorDoesNotExistException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DescribeMergeConflictsErrorKind = DescribeMergeConflictsError;
/// Error type for the `DescribeMergeConflictsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DescribeMergeConflictsError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified value for the number of merge hunks to return is not valid.</p>
    InvalidMaxMergeHunksException(crate::error::InvalidMaxMergeHunksException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DescribeMergeConflictsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DescribeMergeConflictsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxMergeHunksException(_inner) => _inner.fmt(f),
            Self::InvalidMergeOptionException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MergeOptionRequiredException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DescribeMergeConflictsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxMergeHunksException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMergeOptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MergeOptionRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DescribeMergeConflictsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DescribeMergeConflictsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DescribeMergeConflictsError {
    /// Creates the `DescribeMergeConflictsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DescribeMergeConflictsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileDoesNotExistException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxMergeHunksException(e) => e.meta(),
            Self::InvalidMergeOptionException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MergeOptionRequiredException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::FileDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::InvalidMaxMergeHunksException`.
    pub fn is_invalid_max_merge_hunks_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxMergeHunksException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::InvalidMergeOptionException`.
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(self, Self::InvalidMergeOptionException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::MergeOptionRequiredException`.
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(self, Self::MergeOptionRequiredException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DescribeMergeConflictsError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for DescribeMergeConflictsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxMergeHunksException(_inner) => Some(_inner),
            Self::InvalidMergeOptionException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::MergeOptionRequiredException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified value for the number of merge hunks to return is not valid.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidMaxMergeHunksException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidMaxMergeHunksException {
    /// Creates a new builder-style object to manufacture [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException).
    pub fn builder() -> crate::error::invalid_max_merge_hunks_exception::Builder {
        crate::error::invalid_max_merge_hunks_exception::Builder::default()
    }
}
/// See [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException).
pub mod invalid_max_merge_hunks_exception {

    /// A builder for [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidMaxMergeHunksException`](crate::error::InvalidMaxMergeHunksException).
        pub fn build(self) -> crate::error::InvalidMaxMergeHunksException {
            crate::error::InvalidMaxMergeHunksException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidMaxMergeHunksException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidMaxMergeHunksException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidMaxMergeHunksException")?;
        if let Some(inner_154) = &self.message {
            {
                write!(f, ": {}", inner_154)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidMaxMergeHunksException {}
impl aws_http::request_id::RequestId for crate::error::InvalidMaxMergeHunksException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidMaxMergeHunksException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteRepositoryErrorKind = DeleteRepositoryError;
/// Error type for the `DeleteRepositoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteRepositoryError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteRepositoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteRepositoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteRepositoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteRepositoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteRepositoryError {
    /// Creates the `DeleteRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteRepositoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteRepositoryError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `DeleteRepositoryError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteRepositoryError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `DeleteRepositoryError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteRepositoryError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteRepositoryError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteRepositoryError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for DeleteRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeletePullRequestApprovalRuleErrorKind = DeletePullRequestApprovalRuleError;
/// Error type for the `DeletePullRequestApprovalRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeletePullRequestApprovalRuleError {
    /// <p>An approval rule name is required, but was not specified.</p>
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    /// <p>The approval rule cannot be deleted from the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
    CannotDeleteApprovalRuleFromTemplateException(
        crate::error::CannotDeleteApprovalRuleFromTemplateException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name for the approval rule is not valid.</p>
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeletePullRequestApprovalRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeletePullRequestApprovalRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleNameRequiredException(_inner) => _inner.fmt(f),
            Self::CannotDeleteApprovalRuleFromTemplateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleNameException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DeletePullRequestApprovalRuleError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CannotDeleteApprovalRuleFromTemplateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeletePullRequestApprovalRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeletePullRequestApprovalRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeletePullRequestApprovalRuleError {
    /// Creates the `DeletePullRequestApprovalRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeletePullRequestApprovalRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleNameRequiredException(e) => e.meta(),
            Self::CannotDeleteApprovalRuleFromTemplateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidApprovalRuleNameException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::ApprovalRuleNameRequiredException`.
    pub fn is_approval_rule_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::CannotDeleteApprovalRuleFromTemplateException`.
    pub fn is_cannot_delete_approval_rule_from_template_exception(&self) -> bool {
        matches!(self, Self::CannotDeleteApprovalRuleFromTemplateException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::InvalidApprovalRuleNameException`.
    pub fn is_invalid_approval_rule_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleNameException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeletePullRequestApprovalRuleError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
}
impl std::error::Error for DeletePullRequestApprovalRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleNameRequiredException(_inner) => Some(_inner),
            Self::CannotDeleteApprovalRuleFromTemplateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleNameException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The approval rule cannot be deleted from the pull request because it was created by an approval rule template and applied to the pull request automatically.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CannotDeleteApprovalRuleFromTemplateException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CannotDeleteApprovalRuleFromTemplateException {
    /// Creates a new builder-style object to manufacture [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException).
    pub fn builder() -> crate::error::cannot_delete_approval_rule_from_template_exception::Builder {
        crate::error::cannot_delete_approval_rule_from_template_exception::Builder::default()
    }
}
/// See [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException).
pub mod cannot_delete_approval_rule_from_template_exception {

    /// A builder for [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CannotDeleteApprovalRuleFromTemplateException`](crate::error::CannotDeleteApprovalRuleFromTemplateException).
        pub fn build(self) -> crate::error::CannotDeleteApprovalRuleFromTemplateException {
            crate::error::CannotDeleteApprovalRuleFromTemplateException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CannotDeleteApprovalRuleFromTemplateException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CannotDeleteApprovalRuleFromTemplateException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CannotDeleteApprovalRuleFromTemplateException")?;
        if let Some(inner_155) = &self.message {
            {
                write!(f, ": {}", inner_155)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CannotDeleteApprovalRuleFromTemplateException {}
impl aws_http::request_id::RequestId
    for crate::error::CannotDeleteApprovalRuleFromTemplateException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CannotDeleteApprovalRuleFromTemplateException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteFileErrorKind = DeleteFileError;
/// Error type for the `DeleteFileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFileError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteFileError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileDoesNotExistException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteFileError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameIsTagNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitMessageLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEmailException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParentCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NameLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParentCommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParentCommitIdOutdatedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParentCommitIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteFileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFileError {
    /// Creates the `DeleteFileError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteFileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameIsTagNameException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileDoesNotExistException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidParentCommitIdException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::ParentCommitDoesNotExistException(e) => e.meta(),
            Self::ParentCommitIdOutdatedException(e) => e.meta(),
            Self::ParentCommitIdRequiredException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteFileError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(self, Self::BranchNameIsTagNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::FileDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidParentCommitIdException`.
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidParentCommitIdException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::ParentCommitDoesNotExistException`.
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ParentCommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::ParentCommitIdOutdatedException`.
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdOutdatedException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::ParentCommitIdRequiredException`.
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for DeleteFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => Some(_inner),
            Self::BranchNameIsTagNameException(_inner) => Some(_inner),
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::CommitMessageLengthExceededException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileDoesNotExistException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidEmailException(_inner) => Some(_inner),
            Self::InvalidParentCommitIdException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::NameLengthExceededException(_inner) => Some(_inner),
            Self::ParentCommitDoesNotExistException(_inner) => Some(_inner),
            Self::ParentCommitIdOutdatedException(_inner) => Some(_inner),
            Self::ParentCommitIdRequiredException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteCommentContentErrorKind = DeleteCommentContentError;
/// Error type for the `DeleteCommentContentError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteCommentContentError {
    /// <p>This comment has already been deleted. You cannot edit or delete a deleted comment.</p>
    CommentDeletedException(crate::error::CommentDeletedException),
    /// <p>No comment exists with the provided ID. Verify that you have used the correct ID, and then try again.</p>
    CommentDoesNotExistException(crate::error::CommentDoesNotExistException),
    /// <p>The comment ID is missing or null. A comment ID is required.</p>
    CommentIdRequiredException(crate::error::CommentIdRequiredException),
    /// <p>The comment ID is not in a valid format. Make sure that you have provided the full comment ID.</p>
    InvalidCommentIdException(crate::error::InvalidCommentIdException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteCommentContentError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteCommentContentError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommentDeletedException(_inner) => _inner.fmt(f),
            Self::CommentDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommentIdRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidCommentIdException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteCommentContentError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommentDeletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommentIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommentIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteCommentContentError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteCommentContentError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteCommentContentError {
    /// Creates the `DeleteCommentContentError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteCommentContentError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommentDeletedException(e) => e.meta(),
            Self::CommentDoesNotExistException(e) => e.meta(),
            Self::CommentIdRequiredException(e) => e.meta(),
            Self::InvalidCommentIdException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteCommentContentError::CommentDeletedException`.
    pub fn is_comment_deleted_exception(&self) -> bool {
        matches!(self, Self::CommentDeletedException(_))
    }
    /// Returns `true` if the error kind is `DeleteCommentContentError::CommentDoesNotExistException`.
    pub fn is_comment_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommentDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteCommentContentError::CommentIdRequiredException`.
    pub fn is_comment_id_required_exception(&self) -> bool {
        matches!(self, Self::CommentIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteCommentContentError::InvalidCommentIdException`.
    pub fn is_invalid_comment_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommentIdException(_))
    }
}
impl std::error::Error for DeleteCommentContentError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommentDeletedException(_inner) => Some(_inner),
            Self::CommentDoesNotExistException(_inner) => Some(_inner),
            Self::CommentIdRequiredException(_inner) => Some(_inner),
            Self::InvalidCommentIdException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteBranchErrorKind = DeleteBranchError;
/// Error type for the `DeleteBranchError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteBranchError {
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.</p>
    DefaultBranchCannotBeDeletedException(crate::error::DefaultBranchCannotBeDeletedException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteBranchError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::DefaultBranchCannotBeDeletedException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteBranchError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DefaultBranchCannotBeDeletedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteBranchError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteBranchError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteBranchError {
    /// Creates the `DeleteBranchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteBranchError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::DefaultBranchCannotBeDeletedException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteBranchError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::DefaultBranchCannotBeDeletedException`.
    pub fn is_default_branch_cannot_be_deleted_exception(&self) -> bool {
        matches!(self, Self::DefaultBranchCannotBeDeletedException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteBranchError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for DeleteBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::DefaultBranchCannotBeDeletedException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The specified branch is the default branch for the repository, and cannot be deleted. To delete this branch, you must first set another branch as the default branch.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct DefaultBranchCannotBeDeletedException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl DefaultBranchCannotBeDeletedException {
    /// Creates a new builder-style object to manufacture [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException).
    pub fn builder() -> crate::error::default_branch_cannot_be_deleted_exception::Builder {
        crate::error::default_branch_cannot_be_deleted_exception::Builder::default()
    }
}
/// See [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException).
pub mod default_branch_cannot_be_deleted_exception {

    /// A builder for [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`DefaultBranchCannotBeDeletedException`](crate::error::DefaultBranchCannotBeDeletedException).
        pub fn build(self) -> crate::error::DefaultBranchCannotBeDeletedException {
            crate::error::DefaultBranchCannotBeDeletedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl DefaultBranchCannotBeDeletedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for DefaultBranchCannotBeDeletedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "DefaultBranchCannotBeDeletedException")?;
        if let Some(inner_156) = &self.message {
            {
                write!(f, ": {}", inner_156)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for DefaultBranchCannotBeDeletedException {}
impl aws_http::request_id::RequestId for crate::error::DefaultBranchCannotBeDeletedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for DefaultBranchCannotBeDeletedException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type DeleteApprovalRuleTemplateErrorKind = DeleteApprovalRuleTemplateError;
/// Error type for the `DeleteApprovalRuleTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteApprovalRuleTemplateError {
    /// <p>The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove all associations, and then try again.</p>
    ApprovalRuleTemplateInUseException(crate::error::ApprovalRuleTemplateInUseException),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteApprovalRuleTemplateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for DeleteApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateInUseException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteApprovalRuleTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateInUseException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::DeleteApprovalRuleTemplateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for DeleteApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteApprovalRuleTemplateError {
    /// Creates the `DeleteApprovalRuleTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `DeleteApprovalRuleTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateInUseException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteApprovalRuleTemplateError::ApprovalRuleTemplateInUseException`.
    pub fn is_approval_rule_template_in_use_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateInUseException(_))
    }
    /// Returns `true` if the error kind is `DeleteApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
}
impl std::error::Error for DeleteApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateInUseException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The approval rule template is associated with one or more repositories. You cannot delete a template that is associated with a repository. Remove all associations, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalRuleTemplateInUseException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleTemplateInUseException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException).
    pub fn builder() -> crate::error::approval_rule_template_in_use_exception::Builder {
        crate::error::approval_rule_template_in_use_exception::Builder::default()
    }
}
/// See [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException).
pub mod approval_rule_template_in_use_exception {

    /// A builder for [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleTemplateInUseException`](crate::error::ApprovalRuleTemplateInUseException).
        pub fn build(self) -> crate::error::ApprovalRuleTemplateInUseException {
            crate::error::ApprovalRuleTemplateInUseException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalRuleTemplateInUseException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleTemplateInUseException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleTemplateInUseException")?;
        if let Some(inner_157) = &self.message {
            {
                write!(f, ": {}", inner_157)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleTemplateInUseException {}
impl aws_http::request_id::RequestId for crate::error::ApprovalRuleTemplateInUseException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ApprovalRuleTemplateInUseException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateUnreferencedMergeCommitErrorKind = CreateUnreferencedMergeCommitError;
/// Error type for the `CreateUnreferencedMergeCommitError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateUnreferencedMergeCommitError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::error::FileModeRequiredException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateUnreferencedMergeCommitError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateUnreferencedMergeCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::ConcurrentReferenceUpdateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FileModeRequiredException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidMergeOptionException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementContentException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementTypeException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MergeOptionRequiredException(_inner) => _inner.fmt(f),
            Self::MultipleConflictResolutionEntriesException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementContentRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementTypeRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreateUnreferencedMergeCommitError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitMessageLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConcurrentReferenceUpdateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileModeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FolderContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEmailException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileModeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMergeOptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ManualMergeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MergeOptionRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MultipleConflictResolutionEntriesException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NameLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementTypeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateUnreferencedMergeCommitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateUnreferencedMergeCommitError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateUnreferencedMergeCommitError {
    /// Creates the `CreateUnreferencedMergeCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateUnreferencedMergeCommitError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::ConcurrentReferenceUpdateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FileModeRequiredException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidMergeOptionException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidReplacementContentException(e) => e.meta(),
            Self::InvalidReplacementTypeException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::ManualMergeRequiredException(e) => e.meta(),
            Self::MaximumConflictResolutionEntriesExceededException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MergeOptionRequiredException(e) => e.meta(),
            Self::MultipleConflictResolutionEntriesException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::ReplacementContentRequiredException(e) => e.meta(),
            Self::ReplacementTypeRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(self, Self::ConcurrentReferenceUpdateException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::FileModeRequiredException`.
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(self, Self::FileModeRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidMergeOptionException`.
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(self, Self::InvalidMergeOptionException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementContentException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementTypeException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(self, Self::ManualMergeRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            self,
            Self::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::MergeOptionRequiredException`.
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(self, Self::MergeOptionRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(self, Self::MultipleConflictResolutionEntriesException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementTypeRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateUnreferencedMergeCommitError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for CreateUnreferencedMergeCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitMessageLengthExceededException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::ConcurrentReferenceUpdateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::FileModeRequiredException(_inner) => Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidEmailException(_inner) => Some(_inner),
            Self::InvalidFileModeException(_inner) => Some(_inner),
            Self::InvalidMergeOptionException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidReplacementContentException(_inner) => Some(_inner),
            Self::InvalidReplacementTypeException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::ManualMergeRequiredException(_inner) => Some(_inner),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::MergeOptionRequiredException(_inner) => Some(_inner),
            Self::MultipleConflictResolutionEntriesException(_inner) => Some(_inner),
            Self::NameLengthExceededException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::ReplacementContentRequiredException(_inner) => Some(_inner),
            Self::ReplacementTypeRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateRepositoryErrorKind = CreateRepositoryError;
/// Error type for the `CreateRepositoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateRepositoryError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified repository description is not valid.</p>
    InvalidRepositoryDescriptionException(crate::error::InvalidRepositoryDescriptionException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified tag is not valid. Key names cannot be prefixed with aws:.</p>
    InvalidSystemTagUsageException(crate::error::InvalidSystemTagUsageException),
    /// <p>The map of tags is not valid.</p>
    InvalidTagsMapException(crate::error::InvalidTagsMapException),
    /// <p>A repository resource limit was exceeded.</p>
    RepositoryLimitExceededException(crate::error::RepositoryLimitExceededException),
    /// <p>The specified repository name already exists.</p>
    RepositoryNameExistsException(crate::error::RepositoryNameExistsException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The tag policy is not valid.</p>
    TagPolicyException(crate::error::TagPolicyException),
    /// <p>The maximum number of tags for an AWS CodeCommit resource has been exceeded.</p>
    TooManyTagsException(crate::error::TooManyTagsException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateRepositoryError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryDescriptionException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidSystemTagUsageException(_inner) => _inner.fmt(f),
            Self::InvalidTagsMapException(_inner) => _inner.fmt(f),
            Self::RepositoryLimitExceededException(_inner) => _inner.fmt(f),
            Self::RepositoryNameExistsException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::TagPolicyException(_inner) => _inner.fmt(f),
            Self::TooManyTagsException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateRepositoryError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryDescriptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidSystemTagUsageException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTagsMapException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TagPolicyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TooManyTagsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateRepositoryError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateRepositoryError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateRepositoryError {
    /// Creates the `CreateRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateRepositoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryDescriptionException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidSystemTagUsageException(e) => e.meta(),
            Self::InvalidTagsMapException(e) => e.meta(),
            Self::RepositoryLimitExceededException(e) => e.meta(),
            Self::RepositoryNameExistsException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::TagPolicyException(e) => e.meta(),
            Self::TooManyTagsException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::InvalidRepositoryDescriptionException`.
    pub fn is_invalid_repository_description_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryDescriptionException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::InvalidSystemTagUsageException`.
    pub fn is_invalid_system_tag_usage_exception(&self) -> bool {
        matches!(self, Self::InvalidSystemTagUsageException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::InvalidTagsMapException`.
    pub fn is_invalid_tags_map_exception(&self) -> bool {
        matches!(self, Self::InvalidTagsMapException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::RepositoryLimitExceededException`.
    pub fn is_repository_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::RepositoryLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::RepositoryNameExistsException`.
    pub fn is_repository_name_exists_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::TagPolicyException`.
    pub fn is_tag_policy_exception(&self) -> bool {
        matches!(self, Self::TagPolicyException(_))
    }
    /// Returns `true` if the error kind is `CreateRepositoryError::TooManyTagsException`.
    pub fn is_too_many_tags_exception(&self) -> bool {
        matches!(self, Self::TooManyTagsException(_))
    }
}
impl std::error::Error for CreateRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryDescriptionException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidSystemTagUsageException(_inner) => Some(_inner),
            Self::InvalidTagsMapException(_inner) => Some(_inner),
            Self::RepositoryLimitExceededException(_inner) => Some(_inner),
            Self::RepositoryNameExistsException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::TagPolicyException(_inner) => Some(_inner),
            Self::TooManyTagsException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A repository resource limit was exceeded.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryLimitExceededException {
    /// Creates a new builder-style object to manufacture [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException).
    pub fn builder() -> crate::error::repository_limit_exceeded_exception::Builder {
        crate::error::repository_limit_exceeded_exception::Builder::default()
    }
}
/// See [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException).
pub mod repository_limit_exceeded_exception {

    /// A builder for [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryLimitExceededException`](crate::error::RepositoryLimitExceededException).
        pub fn build(self) -> crate::error::RepositoryLimitExceededException {
            crate::error::RepositoryLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryLimitExceededException")?;
        if let Some(inner_158) = &self.message {
            {
                write!(f, ": {}", inner_158)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::RepositoryLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RepositoryLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreatePullRequestApprovalRuleErrorKind = CreatePullRequestApprovalRuleError;
/// Error type for the `CreatePullRequestApprovalRuleError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePullRequestApprovalRuleError {
    /// <p>The content for the approval rule is empty. You must provide some content for an approval rule. The content cannot be null.</p>
    ApprovalRuleContentRequiredException(crate::error::ApprovalRuleContentRequiredException),
    /// <p>An approval rule with that name already exists. Approval rule names must be unique within the scope of a pull request.</p>
    ApprovalRuleNameAlreadyExistsException(crate::error::ApprovalRuleNameAlreadyExistsException),
    /// <p>An approval rule name is required, but was not specified.</p>
    ApprovalRuleNameRequiredException(crate::error::ApprovalRuleNameRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The content for the approval rule is not valid.</p>
    InvalidApprovalRuleContentException(crate::error::InvalidApprovalRuleContentException),
    /// <p>The name for the approval rule is not valid.</p>
    InvalidApprovalRuleNameException(crate::error::InvalidApprovalRuleNameException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::error::InvalidPullRequestIdException),
    /// <p>The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.</p>
    NumberOfRulesExceededException(crate::error::NumberOfRulesExceededException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::error::PullRequestAlreadyClosedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::error::PullRequestIdRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreatePullRequestApprovalRuleError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreatePullRequestApprovalRuleError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleContentRequiredException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleNameAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleNameRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleContentException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleNameException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::NumberOfRulesExceededException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for CreatePullRequestApprovalRuleError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleNameAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfRulesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreatePullRequestApprovalRuleError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePullRequestApprovalRuleError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePullRequestApprovalRuleError {
    /// Creates the `CreatePullRequestApprovalRuleError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreatePullRequestApprovalRuleError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleContentRequiredException(e) => e.meta(),
            Self::ApprovalRuleNameAlreadyExistsException(e) => e.meta(),
            Self::ApprovalRuleNameRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidApprovalRuleContentException(e) => e.meta(),
            Self::InvalidApprovalRuleNameException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::NumberOfRulesExceededException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::ApprovalRuleContentRequiredException`.
    pub fn is_approval_rule_content_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::ApprovalRuleNameAlreadyExistsException`.
    pub fn is_approval_rule_name_already_exists_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleNameAlreadyExistsException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::ApprovalRuleNameRequiredException`.
    pub fn is_approval_rule_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::InvalidApprovalRuleContentException`.
    pub fn is_invalid_approval_rule_content_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleContentException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::InvalidApprovalRuleNameException`.
    pub fn is_invalid_approval_rule_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleNameException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::NumberOfRulesExceededException`.
    pub fn is_number_of_rules_exceeded_exception(&self) -> bool {
        matches!(self, Self::NumberOfRulesExceededException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestApprovalRuleError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
}
impl std::error::Error for CreatePullRequestApprovalRuleError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleContentRequiredException(_inner) => Some(_inner),
            Self::ApprovalRuleNameAlreadyExistsException(_inner) => Some(_inner),
            Self::ApprovalRuleNameRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleContentException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleNameException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::NumberOfRulesExceededException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The approval rule cannot be added. The pull request has the maximum number of approval rules associated with it.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumberOfRulesExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NumberOfRulesExceededException {
    /// Creates a new builder-style object to manufacture [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException).
    pub fn builder() -> crate::error::number_of_rules_exceeded_exception::Builder {
        crate::error::number_of_rules_exceeded_exception::Builder::default()
    }
}
/// See [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException).
pub mod number_of_rules_exceeded_exception {

    /// A builder for [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NumberOfRulesExceededException`](crate::error::NumberOfRulesExceededException).
        pub fn build(self) -> crate::error::NumberOfRulesExceededException {
            crate::error::NumberOfRulesExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NumberOfRulesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NumberOfRulesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NumberOfRulesExceededException")?;
        if let Some(inner_159) = &self.message {
            {
                write!(f, ": {}", inner_159)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NumberOfRulesExceededException {}
impl aws_http::request_id::RequestId for crate::error::NumberOfRulesExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NumberOfRulesExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>An approval rule with that name already exists. Approval rule names must be unique within the scope of a pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ApprovalRuleNameAlreadyExistsException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleNameAlreadyExistsException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException).
    pub fn builder() -> crate::error::approval_rule_name_already_exists_exception::Builder {
        crate::error::approval_rule_name_already_exists_exception::Builder::default()
    }
}
/// See [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException).
pub mod approval_rule_name_already_exists_exception {

    /// A builder for [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ApprovalRuleNameAlreadyExistsException`](crate::error::ApprovalRuleNameAlreadyExistsException).
        pub fn build(self) -> crate::error::ApprovalRuleNameAlreadyExistsException {
            crate::error::ApprovalRuleNameAlreadyExistsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ApprovalRuleNameAlreadyExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ApprovalRuleNameAlreadyExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ApprovalRuleNameAlreadyExistsException")?;
        if let Some(inner_160) = &self.message {
            {
                write!(f, ": {}", inner_160)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ApprovalRuleNameAlreadyExistsException {}
impl aws_http::request_id::RequestId for crate::error::ApprovalRuleNameAlreadyExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ApprovalRuleNameAlreadyExistsException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreatePullRequestErrorKind = CreatePullRequestError;
/// Error type for the `CreatePullRequestError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreatePullRequestError {
    /// <p>A client request token is required. A client request token is an unique, client-generated idempotency token that, when provided in a request, ensures the request cannot be repeated with a changed parameter. If a request is received with the same parameters and a token is included, the request returns information about the initial request that used that token.</p>
    ClientRequestTokenRequiredException(crate::error::ClientRequestTokenRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The client request token is not valid. Either the token is not in a valid format, or the token has been used in a previous request and cannot be reused.</p>
    IdempotencyParameterMismatchException(crate::error::IdempotencyParameterMismatchException),
    /// <p>The client request token is not valid.</p>
    InvalidClientRequestTokenException(crate::error::InvalidClientRequestTokenException),
    /// <p>The pull request description is not valid. Descriptions cannot be more than 1,000 characters.</p>
    InvalidDescriptionException(crate::error::InvalidDescriptionException),
    /// <p>The specified reference name format is not valid. Reference names must conform to the Git references format (for example, refs/heads/master). For more information, see <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">Git Internals - Git References</a> or consult your Git documentation.</p>
    InvalidReferenceNameException(crate::error::InvalidReferenceNameException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
    InvalidTargetException(crate::error::InvalidTargetException),
    /// <p>The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for the repository name, source branch, and destination branch for a pull request.</p>
    InvalidTargetsException(crate::error::InvalidTargetsException),
    /// <p>The title of the pull request is not valid. Pull request titles cannot exceed 100 characters in length.</p>
    InvalidTitleException(crate::error::InvalidTitleException),
    /// <p>You cannot create the pull request because the repository has too many open pull requests. The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.</p>
    MaximumOpenPullRequestsExceededException(
        crate::error::MaximumOpenPullRequestsExceededException,
    ),
    /// <p>You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.</p>
    MultipleRepositoriesInPullRequestException(
        crate::error::MultipleRepositoriesInPullRequestException,
    ),
    /// <p>The specified reference does not exist. You must provide a full commit ID.</p>
    ReferenceDoesNotExistException(crate::error::ReferenceDoesNotExistException),
    /// <p>A reference name is required, but none was provided.</p>
    ReferenceNameRequiredException(crate::error::ReferenceNameRequiredException),
    /// <p>The specified reference is not a supported type. </p>
    ReferenceTypeNotSupportedException(crate::error::ReferenceTypeNotSupportedException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The source branch and destination branch for the pull request are the same. You must specify different branches for the source and destination.</p>
    SourceAndDestinationAreSameException(crate::error::SourceAndDestinationAreSameException),
    /// <p>A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
    TargetRequiredException(crate::error::TargetRequiredException),
    /// <p>An array of target objects is required. It cannot be empty or null.</p>
    TargetsRequiredException(crate::error::TargetsRequiredException),
    /// <p>A pull request title is required. It cannot be empty or null.</p>
    TitleRequiredException(crate::error::TitleRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreatePullRequestError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreatePullRequestError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ClientRequestTokenRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::IdempotencyParameterMismatchException(_inner) => _inner.fmt(f),
            Self::InvalidClientRequestTokenException(_inner) => _inner.fmt(f),
            Self::InvalidDescriptionException(_inner) => _inner.fmt(f),
            Self::InvalidReferenceNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidTargetException(_inner) => _inner.fmt(f),
            Self::InvalidTargetsException(_inner) => _inner.fmt(f),
            Self::InvalidTitleException(_inner) => _inner.fmt(f),
            Self::MaximumOpenPullRequestsExceededException(_inner) => _inner.fmt(f),
            Self::MultipleRepositoriesInPullRequestException(_inner) => _inner.fmt(f),
            Self::ReferenceDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ReferenceNameRequiredException(_inner) => _inner.fmt(f),
            Self::ReferenceTypeNotSupportedException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::SourceAndDestinationAreSameException(_inner) => _inner.fmt(f),
            Self::TargetRequiredException(_inner) => _inner.fmt(f),
            Self::TargetsRequiredException(_inner) => _inner.fmt(f),
            Self::TitleRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreatePullRequestError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ClientRequestTokenRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::IdempotencyParameterMismatchException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidClientRequestTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDescriptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReferenceNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTargetsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidTitleException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumOpenPullRequestsExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MultipleRepositoriesInPullRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReferenceDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReferenceNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReferenceTypeNotSupportedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SourceAndDestinationAreSameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TargetRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TargetsRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TitleRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreatePullRequestError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreatePullRequestError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreatePullRequestError {
    /// Creates the `CreatePullRequestError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreatePullRequestError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ClientRequestTokenRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::IdempotencyParameterMismatchException(e) => e.meta(),
            Self::InvalidClientRequestTokenException(e) => e.meta(),
            Self::InvalidDescriptionException(e) => e.meta(),
            Self::InvalidReferenceNameException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidTargetException(e) => e.meta(),
            Self::InvalidTargetsException(e) => e.meta(),
            Self::InvalidTitleException(e) => e.meta(),
            Self::MaximumOpenPullRequestsExceededException(e) => e.meta(),
            Self::MultipleRepositoriesInPullRequestException(e) => e.meta(),
            Self::ReferenceDoesNotExistException(e) => e.meta(),
            Self::ReferenceNameRequiredException(e) => e.meta(),
            Self::ReferenceTypeNotSupportedException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::SourceAndDestinationAreSameException(e) => e.meta(),
            Self::TargetRequiredException(e) => e.meta(),
            Self::TargetsRequiredException(e) => e.meta(),
            Self::TitleRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::ClientRequestTokenRequiredException`.
    pub fn is_client_request_token_required_exception(&self) -> bool {
        matches!(self, Self::ClientRequestTokenRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::IdempotencyParameterMismatchException`.
    pub fn is_idempotency_parameter_mismatch_exception(&self) -> bool {
        matches!(self, Self::IdempotencyParameterMismatchException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::InvalidClientRequestTokenException`.
    pub fn is_invalid_client_request_token_exception(&self) -> bool {
        matches!(self, Self::InvalidClientRequestTokenException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::InvalidDescriptionException`.
    pub fn is_invalid_description_exception(&self) -> bool {
        matches!(self, Self::InvalidDescriptionException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::InvalidReferenceNameException`.
    pub fn is_invalid_reference_name_exception(&self) -> bool {
        matches!(self, Self::InvalidReferenceNameException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::InvalidTargetException`.
    pub fn is_invalid_target_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::InvalidTargetsException`.
    pub fn is_invalid_targets_exception(&self) -> bool {
        matches!(self, Self::InvalidTargetsException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::InvalidTitleException`.
    pub fn is_invalid_title_exception(&self) -> bool {
        matches!(self, Self::InvalidTitleException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::MaximumOpenPullRequestsExceededException`.
    pub fn is_maximum_open_pull_requests_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumOpenPullRequestsExceededException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::MultipleRepositoriesInPullRequestException`.
    pub fn is_multiple_repositories_in_pull_request_exception(&self) -> bool {
        matches!(self, Self::MultipleRepositoriesInPullRequestException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::ReferenceDoesNotExistException`.
    pub fn is_reference_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ReferenceDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::ReferenceNameRequiredException`.
    pub fn is_reference_name_required_exception(&self) -> bool {
        matches!(self, Self::ReferenceNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::ReferenceTypeNotSupportedException`.
    pub fn is_reference_type_not_supported_exception(&self) -> bool {
        matches!(self, Self::ReferenceTypeNotSupportedException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::SourceAndDestinationAreSameException`.
    pub fn is_source_and_destination_are_same_exception(&self) -> bool {
        matches!(self, Self::SourceAndDestinationAreSameException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::TargetRequiredException`.
    pub fn is_target_required_exception(&self) -> bool {
        matches!(self, Self::TargetRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::TargetsRequiredException`.
    pub fn is_targets_required_exception(&self) -> bool {
        matches!(self, Self::TargetsRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreatePullRequestError::TitleRequiredException`.
    pub fn is_title_required_exception(&self) -> bool {
        matches!(self, Self::TitleRequiredException(_))
    }
}
impl std::error::Error for CreatePullRequestError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ClientRequestTokenRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::IdempotencyParameterMismatchException(_inner) => Some(_inner),
            Self::InvalidClientRequestTokenException(_inner) => Some(_inner),
            Self::InvalidDescriptionException(_inner) => Some(_inner),
            Self::InvalidReferenceNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidTargetException(_inner) => Some(_inner),
            Self::InvalidTargetsException(_inner) => Some(_inner),
            Self::InvalidTitleException(_inner) => Some(_inner),
            Self::MaximumOpenPullRequestsExceededException(_inner) => Some(_inner),
            Self::MultipleRepositoriesInPullRequestException(_inner) => Some(_inner),
            Self::ReferenceDoesNotExistException(_inner) => Some(_inner),
            Self::ReferenceNameRequiredException(_inner) => Some(_inner),
            Self::ReferenceTypeNotSupportedException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::SourceAndDestinationAreSameException(_inner) => Some(_inner),
            Self::TargetRequiredException(_inner) => Some(_inner),
            Self::TargetsRequiredException(_inner) => Some(_inner),
            Self::TitleRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>An array of target objects is required. It cannot be empty or null.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TargetsRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TargetsRequiredException {
    /// Creates a new builder-style object to manufacture [`TargetsRequiredException`](crate::error::TargetsRequiredException).
    pub fn builder() -> crate::error::targets_required_exception::Builder {
        crate::error::targets_required_exception::Builder::default()
    }
}
/// See [`TargetsRequiredException`](crate::error::TargetsRequiredException).
pub mod targets_required_exception {

    /// A builder for [`TargetsRequiredException`](crate::error::TargetsRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TargetsRequiredException`](crate::error::TargetsRequiredException).
        pub fn build(self) -> crate::error::TargetsRequiredException {
            crate::error::TargetsRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TargetsRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetsRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetsRequiredException")?;
        if let Some(inner_161) = &self.message {
            {
                write!(f, ": {}", inner_161)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TargetsRequiredException {}
impl aws_http::request_id::RequestId for crate::error::TargetsRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TargetsRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A pull request target is required. It cannot be empty or null. A pull request target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct TargetRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl TargetRequiredException {
    /// Creates a new builder-style object to manufacture [`TargetRequiredException`](crate::error::TargetRequiredException).
    pub fn builder() -> crate::error::target_required_exception::Builder {
        crate::error::target_required_exception::Builder::default()
    }
}
/// See [`TargetRequiredException`](crate::error::TargetRequiredException).
pub mod target_required_exception {

    /// A builder for [`TargetRequiredException`](crate::error::TargetRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`TargetRequiredException`](crate::error::TargetRequiredException).
        pub fn build(self) -> crate::error::TargetRequiredException {
            crate::error::TargetRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl TargetRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for TargetRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "TargetRequiredException")?;
        if let Some(inner_162) = &self.message {
            {
                write!(f, ": {}", inner_162)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for TargetRequiredException {}
impl aws_http::request_id::RequestId for crate::error::TargetRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for TargetRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The source branch and destination branch for the pull request are the same. You must specify different branches for the source and destination.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceAndDestinationAreSameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SourceAndDestinationAreSameException {
    /// Creates a new builder-style object to manufacture [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException).
    pub fn builder() -> crate::error::source_and_destination_are_same_exception::Builder {
        crate::error::source_and_destination_are_same_exception::Builder::default()
    }
}
/// See [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException).
pub mod source_and_destination_are_same_exception {

    /// A builder for [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SourceAndDestinationAreSameException`](crate::error::SourceAndDestinationAreSameException).
        pub fn build(self) -> crate::error::SourceAndDestinationAreSameException {
            crate::error::SourceAndDestinationAreSameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SourceAndDestinationAreSameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceAndDestinationAreSameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceAndDestinationAreSameException")?;
        if let Some(inner_163) = &self.message {
            {
                write!(f, ": {}", inner_163)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SourceAndDestinationAreSameException {}
impl aws_http::request_id::RequestId for crate::error::SourceAndDestinationAreSameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for SourceAndDestinationAreSameException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified reference is not a supported type. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceTypeNotSupportedException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReferenceTypeNotSupportedException {
    /// Creates a new builder-style object to manufacture [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException).
    pub fn builder() -> crate::error::reference_type_not_supported_exception::Builder {
        crate::error::reference_type_not_supported_exception::Builder::default()
    }
}
/// See [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException).
pub mod reference_type_not_supported_exception {

    /// A builder for [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceTypeNotSupportedException`](crate::error::ReferenceTypeNotSupportedException).
        pub fn build(self) -> crate::error::ReferenceTypeNotSupportedException {
            crate::error::ReferenceTypeNotSupportedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ReferenceTypeNotSupportedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReferenceTypeNotSupportedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReferenceTypeNotSupportedException")?;
        if let Some(inner_164) = &self.message {
            {
                write!(f, ": {}", inner_164)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReferenceTypeNotSupportedException {}
impl aws_http::request_id::RequestId for crate::error::ReferenceTypeNotSupportedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for ReferenceTypeNotSupportedException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>A reference name is required, but none was provided.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ReferenceNameRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl ReferenceNameRequiredException {
    /// Creates a new builder-style object to manufacture [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException).
    pub fn builder() -> crate::error::reference_name_required_exception::Builder {
        crate::error::reference_name_required_exception::Builder::default()
    }
}
/// See [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException).
pub mod reference_name_required_exception {

    /// A builder for [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`ReferenceNameRequiredException`](crate::error::ReferenceNameRequiredException).
        pub fn build(self) -> crate::error::ReferenceNameRequiredException {
            crate::error::ReferenceNameRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl ReferenceNameRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for ReferenceNameRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "ReferenceNameRequiredException")?;
        if let Some(inner_165) = &self.message {
            {
                write!(f, ": {}", inner_165)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for ReferenceNameRequiredException {}
impl aws_http::request_id::RequestId for crate::error::ReferenceNameRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for ReferenceNameRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot include more than one repository in a pull request. Make sure you have specified only one repository name in your request, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MultipleRepositoriesInPullRequestException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MultipleRepositoriesInPullRequestException {
    /// Creates a new builder-style object to manufacture [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException).
    pub fn builder() -> crate::error::multiple_repositories_in_pull_request_exception::Builder {
        crate::error::multiple_repositories_in_pull_request_exception::Builder::default()
    }
}
/// See [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException).
pub mod multiple_repositories_in_pull_request_exception {

    /// A builder for [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MultipleRepositoriesInPullRequestException`](crate::error::MultipleRepositoriesInPullRequestException).
        pub fn build(self) -> crate::error::MultipleRepositoriesInPullRequestException {
            crate::error::MultipleRepositoriesInPullRequestException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MultipleRepositoriesInPullRequestException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MultipleRepositoriesInPullRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MultipleRepositoriesInPullRequestException")?;
        if let Some(inner_166) = &self.message {
            {
                write!(f, ": {}", inner_166)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MultipleRepositoriesInPullRequestException {}
impl aws_http::request_id::RequestId for crate::error::MultipleRepositoriesInPullRequestException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MultipleRepositoriesInPullRequestException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>You cannot create the pull request because the repository has too many open pull requests. The maximum number of open pull requests for a repository is 1,000. Close one or more open pull requests, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumOpenPullRequestsExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumOpenPullRequestsExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException).
    pub fn builder() -> crate::error::maximum_open_pull_requests_exceeded_exception::Builder {
        crate::error::maximum_open_pull_requests_exceeded_exception::Builder::default()
    }
}
/// See [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException).
pub mod maximum_open_pull_requests_exceeded_exception {

    /// A builder for [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumOpenPullRequestsExceededException`](crate::error::MaximumOpenPullRequestsExceededException).
        pub fn build(self) -> crate::error::MaximumOpenPullRequestsExceededException {
            crate::error::MaximumOpenPullRequestsExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumOpenPullRequestsExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumOpenPullRequestsExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumOpenPullRequestsExceededException")?;
        if let Some(inner_167) = &self.message {
            {
                write!(f, ": {}", inner_167)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumOpenPullRequestsExceededException {}
impl aws_http::request_id::RequestId for crate::error::MaximumOpenPullRequestsExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MaximumOpenPullRequestsExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The targets for the pull request is not valid or not in a valid format. Targets are a list of target objects. Each target object must contain the full values for the repository name, source branch, and destination branch for a pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTargetsException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTargetsException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetsException`](crate::error::InvalidTargetsException).
    pub fn builder() -> crate::error::invalid_targets_exception::Builder {
        crate::error::invalid_targets_exception::Builder::default()
    }
}
/// See [`InvalidTargetsException`](crate::error::InvalidTargetsException).
pub mod invalid_targets_exception {

    /// A builder for [`InvalidTargetsException`](crate::error::InvalidTargetsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetsException`](crate::error::InvalidTargetsException).
        pub fn build(self) -> crate::error::InvalidTargetsException {
            crate::error::InvalidTargetsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidTargetsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetsException")?;
        if let Some(inner_168) = &self.message {
            {
                write!(f, ": {}", inner_168)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetsException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTargetsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTargetsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The target for the pull request is not valid. A target must contain the full values for the repository name, source branch, and destination branch for the pull request.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidTargetException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidTargetException {
    /// Creates a new builder-style object to manufacture [`InvalidTargetException`](crate::error::InvalidTargetException).
    pub fn builder() -> crate::error::invalid_target_exception::Builder {
        crate::error::invalid_target_exception::Builder::default()
    }
}
/// See [`InvalidTargetException`](crate::error::InvalidTargetException).
pub mod invalid_target_exception {

    /// A builder for [`InvalidTargetException`](crate::error::InvalidTargetException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidTargetException`](crate::error::InvalidTargetException).
        pub fn build(self) -> crate::error::InvalidTargetException {
            crate::error::InvalidTargetException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidTargetException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidTargetException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidTargetException")?;
        if let Some(inner_169) = &self.message {
            {
                write!(f, ": {}", inner_169)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidTargetException {}
impl aws_http::request_id::RequestId for crate::error::InvalidTargetException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidTargetException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The specified reference name format is not valid. Reference names must conform to the Git references format (for example, refs/heads/master). For more information, see <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">Git Internals - Git References</a> or consult your Git documentation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct InvalidReferenceNameException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl InvalidReferenceNameException {
    /// Creates a new builder-style object to manufacture [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException).
    pub fn builder() -> crate::error::invalid_reference_name_exception::Builder {
        crate::error::invalid_reference_name_exception::Builder::default()
    }
}
/// See [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException).
pub mod invalid_reference_name_exception {

    /// A builder for [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`InvalidReferenceNameException`](crate::error::InvalidReferenceNameException).
        pub fn build(self) -> crate::error::InvalidReferenceNameException {
            crate::error::InvalidReferenceNameException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl InvalidReferenceNameException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for InvalidReferenceNameException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "InvalidReferenceNameException")?;
        if let Some(inner_170) = &self.message {
            {
                write!(f, ": {}", inner_170)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for InvalidReferenceNameException {}
impl aws_http::request_id::RequestId for crate::error::InvalidReferenceNameException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for InvalidReferenceNameException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateCommitErrorKind = CreateCommitError;
/// Error type for the `CreateCommitError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateCommitError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::error::CommitMessageLengthExceededException),
    /// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
    DirectoryNameConflictsWithFileNameException(
        crate::error::DirectoryNameConflictsWithFileNameException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.</p>
    FileContentAndSourceFileSpecifiedException(
        crate::error::FileContentAndSourceFileSpecifiedException,
    ),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::error::FileContentSizeLimitExceededException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::error::FileDoesNotExistException),
    /// <p>The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.</p>
    FileEntryRequiredException(crate::error::FileEntryRequiredException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::error::FileModeRequiredException),
    /// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
    FileNameConflictsWithDirectoryNameException(
        crate::error::FileNameConflictsWithDirectoryNameException,
    ),
    /// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
    FilePathConflictsWithSubmodulePathException(
        crate::error::FilePathConflictsWithSubmodulePathException,
    ),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified deletion parameter is not valid.</p>
    InvalidDeletionParameterException(crate::error::InvalidDeletionParameterException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::error::InvalidFileModeException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.</p>
    MaximumFileEntriesExceededException(crate::error::MaximumFileEntriesExceededException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::error::NameLengthExceededException),
    /// <p>The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.</p>
    NoChangeException(crate::error::NoChangeException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::error::ParentCommitIdRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::error::PathRequiredException),
    /// <p>The commit cannot be created because one or more files specified in the commit reference both a file and a folder.</p>
    PutFileEntryConflictException(crate::error::PutFileEntryConflictException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.</p>
    RestrictedSourceFileException(crate::error::RestrictedSourceFileException),
    /// <p>The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.</p>
    SamePathRequestException(crate::error::SamePathRequestException),
    /// <p>The commit cannot be created because no source files or file content have been specified for the commit.</p>
    SourceFileOrContentRequiredException(crate::error::SourceFileOrContentRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateCommitError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateCommitError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentAndSourceFileSpecifiedException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FileDoesNotExistException(_inner) => _inner.fmt(f),
            Self::FileEntryRequiredException(_inner) => _inner.fmt(f),
            Self::FileModeRequiredException(_inner) => _inner.fmt(f),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => _inner.fmt(f),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeletionParameterException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::MaximumFileEntriesExceededException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::NoChangeException(_inner) => _inner.fmt(f),
            Self::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::PutFileEntryConflictException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RestrictedSourceFileException(_inner) => _inner.fmt(f),
            Self::SamePathRequestException(_inner) => _inner.fmt(f),
            Self::SourceFileOrContentRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateCommitError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameIsTagNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitMessageLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::DirectoryNameConflictsWithFileNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentAndSourceFileSpecifiedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileEntryRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileModeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileNameConflictsWithDirectoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FilePathConflictsWithSubmodulePathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FolderContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidDeletionParameterException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEmailException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileModeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidParentCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileEntriesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NameLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NoChangeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParentCommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParentCommitIdOutdatedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ParentCommitIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PutFileEntryConflictException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RestrictedSourceFileException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SamePathRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::SourceFileOrContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateCommitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateCommitError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateCommitError {
    /// Creates the `CreateCommitError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateCommitError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameIsTagNameException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::DirectoryNameConflictsWithFileNameException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentAndSourceFileSpecifiedException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FileDoesNotExistException(e) => e.meta(),
            Self::FileEntryRequiredException(e) => e.meta(),
            Self::FileModeRequiredException(e) => e.meta(),
            Self::FileNameConflictsWithDirectoryNameException(e) => e.meta(),
            Self::FilePathConflictsWithSubmodulePathException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidDeletionParameterException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidParentCommitIdException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::MaximumFileEntriesExceededException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::NoChangeException(e) => e.meta(),
            Self::ParentCommitDoesNotExistException(e) => e.meta(),
            Self::ParentCommitIdOutdatedException(e) => e.meta(),
            Self::ParentCommitIdRequiredException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::PutFileEntryConflictException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RestrictedSourceFileException(e) => e.meta(),
            Self::SamePathRequestException(e) => e.meta(),
            Self::SourceFileOrContentRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateCommitError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(self, Self::BranchNameIsTagNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::DirectoryNameConflictsWithFileNameException`.
    pub fn is_directory_name_conflicts_with_file_name_exception(&self) -> bool {
        matches!(self, Self::DirectoryNameConflictsWithFileNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileContentAndSourceFileSpecifiedException`.
    pub fn is_file_content_and_source_file_specified_exception(&self) -> bool {
        matches!(self, Self::FileContentAndSourceFileSpecifiedException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::FileDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileEntryRequiredException`.
    pub fn is_file_entry_required_exception(&self) -> bool {
        matches!(self, Self::FileEntryRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileModeRequiredException`.
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(self, Self::FileModeRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileNameConflictsWithDirectoryNameException`.
    pub fn is_file_name_conflicts_with_directory_name_exception(&self) -> bool {
        matches!(self, Self::FileNameConflictsWithDirectoryNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FilePathConflictsWithSubmodulePathException`.
    pub fn is_file_path_conflicts_with_submodule_path_exception(&self) -> bool {
        matches!(self, Self::FilePathConflictsWithSubmodulePathException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidDeletionParameterException`.
    pub fn is_invalid_deletion_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidDeletionParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidParentCommitIdException`.
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidParentCommitIdException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::MaximumFileEntriesExceededException`.
    pub fn is_maximum_file_entries_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileEntriesExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::NoChangeException`.
    pub fn is_no_change_exception(&self) -> bool {
        matches!(self, Self::NoChangeException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::ParentCommitDoesNotExistException`.
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ParentCommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::ParentCommitIdOutdatedException`.
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdOutdatedException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::ParentCommitIdRequiredException`.
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::PutFileEntryConflictException`.
    pub fn is_put_file_entry_conflict_exception(&self) -> bool {
        matches!(self, Self::PutFileEntryConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::RestrictedSourceFileException`.
    pub fn is_restricted_source_file_exception(&self) -> bool {
        matches!(self, Self::RestrictedSourceFileException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::SamePathRequestException`.
    pub fn is_same_path_request_exception(&self) -> bool {
        matches!(self, Self::SamePathRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::SourceFileOrContentRequiredException`.
    pub fn is_source_file_or_content_required_exception(&self) -> bool {
        matches!(self, Self::SourceFileOrContentRequiredException(_))
    }
}
impl std::error::Error for CreateCommitError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => Some(_inner),
            Self::BranchNameIsTagNameException(_inner) => Some(_inner),
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::CommitMessageLengthExceededException(_inner) => Some(_inner),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileContentAndSourceFileSpecifiedException(_inner) => Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::FileDoesNotExistException(_inner) => Some(_inner),
            Self::FileEntryRequiredException(_inner) => Some(_inner),
            Self::FileModeRequiredException(_inner) => Some(_inner),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => Some(_inner),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidDeletionParameterException(_inner) => Some(_inner),
            Self::InvalidEmailException(_inner) => Some(_inner),
            Self::InvalidFileModeException(_inner) => Some(_inner),
            Self::InvalidParentCommitIdException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::MaximumFileEntriesExceededException(_inner) => Some(_inner),
            Self::NameLengthExceededException(_inner) => Some(_inner),
            Self::NoChangeException(_inner) => Some(_inner),
            Self::ParentCommitDoesNotExistException(_inner) => Some(_inner),
            Self::ParentCommitIdOutdatedException(_inner) => Some(_inner),
            Self::ParentCommitIdRequiredException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::PutFileEntryConflictException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RestrictedSourceFileException(_inner) => Some(_inner),
            Self::SamePathRequestException(_inner) => Some(_inner),
            Self::SourceFileOrContentRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The commit cannot be created because no source files or file content have been specified for the commit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SourceFileOrContentRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SourceFileOrContentRequiredException {
    /// Creates a new builder-style object to manufacture [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException).
    pub fn builder() -> crate::error::source_file_or_content_required_exception::Builder {
        crate::error::source_file_or_content_required_exception::Builder::default()
    }
}
/// See [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException).
pub mod source_file_or_content_required_exception {

    /// A builder for [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SourceFileOrContentRequiredException`](crate::error::SourceFileOrContentRequiredException).
        pub fn build(self) -> crate::error::SourceFileOrContentRequiredException {
            crate::error::SourceFileOrContentRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SourceFileOrContentRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SourceFileOrContentRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SourceFileOrContentRequiredException")?;
        if let Some(inner_171) = &self.message {
            {
                write!(f, ": {}", inner_171)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SourceFileOrContentRequiredException {}
impl aws_http::request_id::RequestId for crate::error::SourceFileOrContentRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for SourceFileOrContentRequiredException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct SamePathRequestException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl SamePathRequestException {
    /// Creates a new builder-style object to manufacture [`SamePathRequestException`](crate::error::SamePathRequestException).
    pub fn builder() -> crate::error::same_path_request_exception::Builder {
        crate::error::same_path_request_exception::Builder::default()
    }
}
/// See [`SamePathRequestException`](crate::error::SamePathRequestException).
pub mod same_path_request_exception {

    /// A builder for [`SamePathRequestException`](crate::error::SamePathRequestException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`SamePathRequestException`](crate::error::SamePathRequestException).
        pub fn build(self) -> crate::error::SamePathRequestException {
            crate::error::SamePathRequestException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl SamePathRequestException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for SamePathRequestException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "SamePathRequestException")?;
        if let Some(inner_172) = &self.message {
            {
                write!(f, ": {}", inner_172)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for SamePathRequestException {}
impl aws_http::request_id::RequestId for crate::error::SamePathRequestException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for SamePathRequestException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RestrictedSourceFileException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RestrictedSourceFileException {
    /// Creates a new builder-style object to manufacture [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException).
    pub fn builder() -> crate::error::restricted_source_file_exception::Builder {
        crate::error::restricted_source_file_exception::Builder::default()
    }
}
/// See [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException).
pub mod restricted_source_file_exception {

    /// A builder for [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RestrictedSourceFileException`](crate::error::RestrictedSourceFileException).
        pub fn build(self) -> crate::error::RestrictedSourceFileException {
            crate::error::RestrictedSourceFileException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RestrictedSourceFileException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RestrictedSourceFileException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RestrictedSourceFileException")?;
        if let Some(inner_173) = &self.message {
            {
                write!(f, ": {}", inner_173)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RestrictedSourceFileException {}
impl aws_http::request_id::RequestId for crate::error::RestrictedSourceFileException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RestrictedSourceFileException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit cannot be created because one or more files specified in the commit reference both a file and a folder.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct PutFileEntryConflictException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl PutFileEntryConflictException {
    /// Creates a new builder-style object to manufacture [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException).
    pub fn builder() -> crate::error::put_file_entry_conflict_exception::Builder {
        crate::error::put_file_entry_conflict_exception::Builder::default()
    }
}
/// See [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException).
pub mod put_file_entry_conflict_exception {

    /// A builder for [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`PutFileEntryConflictException`](crate::error::PutFileEntryConflictException).
        pub fn build(self) -> crate::error::PutFileEntryConflictException {
            crate::error::PutFileEntryConflictException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl PutFileEntryConflictException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for PutFileEntryConflictException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "PutFileEntryConflictException")?;
        if let Some(inner_174) = &self.message {
            {
                write!(f, ": {}", inner_174)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for PutFileEntryConflictException {}
impl aws_http::request_id::RequestId for crate::error::PutFileEntryConflictException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PutFileEntryConflictException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NoChangeException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NoChangeException {
    /// Creates a new builder-style object to manufacture [`NoChangeException`](crate::error::NoChangeException).
    pub fn builder() -> crate::error::no_change_exception::Builder {
        crate::error::no_change_exception::Builder::default()
    }
}
/// See [`NoChangeException`](crate::error::NoChangeException).
pub mod no_change_exception {

    /// A builder for [`NoChangeException`](crate::error::NoChangeException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NoChangeException`](crate::error::NoChangeException).
        pub fn build(self) -> crate::error::NoChangeException {
            crate::error::NoChangeException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NoChangeException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NoChangeException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NoChangeException")?;
        if let Some(inner_175) = &self.message {
            {
                write!(f, ": {}", inner_175)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NoChangeException {}
impl aws_http::request_id::RequestId for crate::error::NoChangeException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for NoChangeException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumFileEntriesExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumFileEntriesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException).
    pub fn builder() -> crate::error::maximum_file_entries_exceeded_exception::Builder {
        crate::error::maximum_file_entries_exceeded_exception::Builder::default()
    }
}
/// See [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException).
pub mod maximum_file_entries_exceeded_exception {

    /// A builder for [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumFileEntriesExceededException`](crate::error::MaximumFileEntriesExceededException).
        pub fn build(self) -> crate::error::MaximumFileEntriesExceededException {
            crate::error::MaximumFileEntriesExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumFileEntriesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumFileEntriesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumFileEntriesExceededException")?;
        if let Some(inner_176) = &self.message {
            {
                write!(f, ": {}", inner_176)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumFileEntriesExceededException {}
impl aws_http::request_id::RequestId for crate::error::MaximumFileEntriesExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MaximumFileEntriesExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileEntryRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileEntryRequiredException {
    /// Creates a new builder-style object to manufacture [`FileEntryRequiredException`](crate::error::FileEntryRequiredException).
    pub fn builder() -> crate::error::file_entry_required_exception::Builder {
        crate::error::file_entry_required_exception::Builder::default()
    }
}
/// See [`FileEntryRequiredException`](crate::error::FileEntryRequiredException).
pub mod file_entry_required_exception {

    /// A builder for [`FileEntryRequiredException`](crate::error::FileEntryRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileEntryRequiredException`](crate::error::FileEntryRequiredException).
        pub fn build(self) -> crate::error::FileEntryRequiredException {
            crate::error::FileEntryRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FileEntryRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileEntryRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileEntryRequiredException")?;
        if let Some(inner_177) = &self.message {
            {
                write!(f, ": {}", inner_177)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileEntryRequiredException {}
impl aws_http::request_id::RequestId for crate::error::FileEntryRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for FileEntryRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct FileContentAndSourceFileSpecifiedException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl FileContentAndSourceFileSpecifiedException {
    /// Creates a new builder-style object to manufacture [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException).
    pub fn builder() -> crate::error::file_content_and_source_file_specified_exception::Builder {
        crate::error::file_content_and_source_file_specified_exception::Builder::default()
    }
}
/// See [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException).
pub mod file_content_and_source_file_specified_exception {

    /// A builder for [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`FileContentAndSourceFileSpecifiedException`](crate::error::FileContentAndSourceFileSpecifiedException).
        pub fn build(self) -> crate::error::FileContentAndSourceFileSpecifiedException {
            crate::error::FileContentAndSourceFileSpecifiedException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl FileContentAndSourceFileSpecifiedException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for FileContentAndSourceFileSpecifiedException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "FileContentAndSourceFileSpecifiedException")?;
        if let Some(inner_178) = &self.message {
            {
                write!(f, ": {}", inner_178)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for FileContentAndSourceFileSpecifiedException {}
impl aws_http::request_id::RequestId for crate::error::FileContentAndSourceFileSpecifiedException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for FileContentAndSourceFileSpecifiedException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateBranchErrorKind = CreateBranchError;
/// Error type for the `CreateBranchError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateBranchError {
    /// <p>Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name. Branch names must be unique.</p>
    BranchNameExistsException(crate::error::BranchNameExistsException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::error::BranchNameRequiredException),
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit ID was not specified.</p>
    CommitIdRequiredException(crate::error::CommitIdRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::error::InvalidBranchNameException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::error::InvalidCommitIdException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateBranchError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateBranchError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchNameExistsException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateBranchError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchNameExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::BranchNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateBranchError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateBranchError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateBranchError {
    /// Creates the `CreateBranchError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateBranchError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchNameExistsException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitIdRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateBranchError::BranchNameExistsException`.
    pub fn is_branch_name_exists_exception(&self) -> bool {
        matches!(self, Self::BranchNameExistsException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::CommitIdRequiredException`.
    pub fn is_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::CommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateBranchError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for CreateBranchError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchNameExistsException(_inner) => Some(_inner),
            Self::BranchNameRequiredException(_inner) => Some(_inner),
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitIdRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidBranchNameException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>Cannot create the branch with the specified name because the commit conflicts with an existing branch with the same name. Branch names must be unique.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct BranchNameExistsException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl BranchNameExistsException {
    /// Creates a new builder-style object to manufacture [`BranchNameExistsException`](crate::error::BranchNameExistsException).
    pub fn builder() -> crate::error::branch_name_exists_exception::Builder {
        crate::error::branch_name_exists_exception::Builder::default()
    }
}
/// See [`BranchNameExistsException`](crate::error::BranchNameExistsException).
pub mod branch_name_exists_exception {

    /// A builder for [`BranchNameExistsException`](crate::error::BranchNameExistsException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`BranchNameExistsException`](crate::error::BranchNameExistsException).
        pub fn build(self) -> crate::error::BranchNameExistsException {
            crate::error::BranchNameExistsException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl BranchNameExistsException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for BranchNameExistsException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "BranchNameExistsException")?;
        if let Some(inner_179) = &self.message {
            {
                write!(f, ": {}", inner_179)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for BranchNameExistsException {}
impl aws_http::request_id::RequestId for crate::error::BranchNameExistsException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BranchNameExistsException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateApprovalRuleTemplateErrorKind = CreateApprovalRuleTemplateError;
/// Error type for the `CreateApprovalRuleTemplateError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum CreateApprovalRuleTemplateError {
    /// <p>The content for the approval rule template is empty. You must provide some content for an approval rule template. The content cannot be null.</p>
    ApprovalRuleTemplateContentRequiredException(
        crate::error::ApprovalRuleTemplateContentRequiredException,
    ),
    /// <p>You cannot create an approval rule template with that name because a template with that name already exists in this AWS Region for your AWS account. Approval rule template names must be unique.</p>
    ApprovalRuleTemplateNameAlreadyExistsException(
        crate::error::ApprovalRuleTemplateNameAlreadyExistsException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>The content of the approval rule template is not valid.</p>
    InvalidApprovalRuleTemplateContentException(
        crate::error::InvalidApprovalRuleTemplateContentException,
    ),
    /// <p>The description for the approval rule template is not valid because it exceeds the maximum characters allowed for a description. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateDescriptionException(
        crate::error::InvalidApprovalRuleTemplateDescriptionException,
    ),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The maximum number of approval rule templates has been exceeded for this AWS Region. </p>
    NumberOfRuleTemplatesExceededException(crate::error::NumberOfRuleTemplatesExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for CreateApprovalRuleTemplateError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for CreateApprovalRuleTemplateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateContentRequiredException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameAlreadyExistsException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateContentException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateDescriptionException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::NumberOfRuleTemplatesExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateApprovalRuleTemplateError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameAlreadyExistsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateDescriptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NumberOfRuleTemplatesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::CreateApprovalRuleTemplateError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for CreateApprovalRuleTemplateError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl CreateApprovalRuleTemplateError {
    /// Creates the `CreateApprovalRuleTemplateError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `CreateApprovalRuleTemplateError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateContentRequiredException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameAlreadyExistsException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateContentException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateDescriptionException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::NumberOfRuleTemplatesExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateError::ApprovalRuleTemplateContentRequiredException`.
    pub fn is_approval_rule_template_content_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateError::ApprovalRuleTemplateNameAlreadyExistsException`.
    pub fn is_approval_rule_template_name_already_exists_exception(&self) -> bool {
        matches!(
            self,
            Self::ApprovalRuleTemplateNameAlreadyExistsException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateContentException`.
    pub fn is_invalid_approval_rule_template_content_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateContentException(_))
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateDescriptionException`.
    pub fn is_invalid_approval_rule_template_description_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidApprovalRuleTemplateDescriptionException(_)
        )
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `CreateApprovalRuleTemplateError::NumberOfRuleTemplatesExceededException`.
    pub fn is_number_of_rule_templates_exceeded_exception(&self) -> bool {
        matches!(self, Self::NumberOfRuleTemplatesExceededException(_))
    }
}
impl std::error::Error for CreateApprovalRuleTemplateError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateContentRequiredException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameAlreadyExistsException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateContentException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateDescriptionException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::NumberOfRuleTemplatesExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of approval rule templates has been exceeded for this AWS Region. </p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct NumberOfRuleTemplatesExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl NumberOfRuleTemplatesExceededException {
    /// Creates a new builder-style object to manufacture [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException).
    pub fn builder() -> crate::error::number_of_rule_templates_exceeded_exception::Builder {
        crate::error::number_of_rule_templates_exceeded_exception::Builder::default()
    }
}
/// See [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException).
pub mod number_of_rule_templates_exceeded_exception {

    /// A builder for [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`NumberOfRuleTemplatesExceededException`](crate::error::NumberOfRuleTemplatesExceededException).
        pub fn build(self) -> crate::error::NumberOfRuleTemplatesExceededException {
            crate::error::NumberOfRuleTemplatesExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl NumberOfRuleTemplatesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for NumberOfRuleTemplatesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "NumberOfRuleTemplatesExceededException")?;
        if let Some(inner_180) = &self.message {
            {
                write!(f, ": {}", inner_180)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for NumberOfRuleTemplatesExceededException {}
impl aws_http::request_id::RequestId for crate::error::NumberOfRuleTemplatesExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for NumberOfRuleTemplatesExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetRepositoriesErrorKind = BatchGetRepositoriesError;
/// Error type for the `BatchGetRepositoriesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetRepositoriesError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    /// <p>At least one repository name object is required, but was not specified.</p>
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetRepositoriesError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::MaximumRepositoryNamesExceededException(_inner) => _inner.fmt(f),
            Self::RepositoryNamesRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetRepositoriesError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumRepositoryNamesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNamesRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchGetRepositoriesError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetRepositoriesError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetRepositoriesError {
    /// Creates the `BatchGetRepositoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetRepositoriesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::MaximumRepositoryNamesExceededException(e) => e.meta(),
            Self::RepositoryNamesRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesError::MaximumRepositoryNamesExceededException`.
    pub fn is_maximum_repository_names_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumRepositoryNamesExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetRepositoriesError::RepositoryNamesRequiredException`.
    pub fn is_repository_names_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNamesRequiredException(_))
    }
}
impl std::error::Error for BatchGetRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::MaximumRepositoryNamesExceededException(_inner) => Some(_inner),
            Self::RepositoryNamesRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>At least one repository name object is required, but was not specified.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct RepositoryNamesRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl RepositoryNamesRequiredException {
    /// Creates a new builder-style object to manufacture [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException).
    pub fn builder() -> crate::error::repository_names_required_exception::Builder {
        crate::error::repository_names_required_exception::Builder::default()
    }
}
/// See [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException).
pub mod repository_names_required_exception {

    /// A builder for [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`RepositoryNamesRequiredException`](crate::error::RepositoryNamesRequiredException).
        pub fn build(self) -> crate::error::RepositoryNamesRequiredException {
            crate::error::RepositoryNamesRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl RepositoryNamesRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for RepositoryNamesRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "RepositoryNamesRequiredException")?;
        if let Some(inner_181) = &self.message {
            {
                write!(f, ": {}", inner_181)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for RepositoryNamesRequiredException {}
impl aws_http::request_id::RequestId for crate::error::RepositoryNamesRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for RepositoryNamesRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumRepositoryNamesExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumRepositoryNamesExceededException {
    /// Creates a new builder-style object to manufacture [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException).
    pub fn builder() -> crate::error::maximum_repository_names_exceeded_exception::Builder {
        crate::error::maximum_repository_names_exceeded_exception::Builder::default()
    }
}
/// See [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException).
pub mod maximum_repository_names_exceeded_exception {

    /// A builder for [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumRepositoryNamesExceededException`](crate::error::MaximumRepositoryNamesExceededException).
        pub fn build(self) -> crate::error::MaximumRepositoryNamesExceededException {
            crate::error::MaximumRepositoryNamesExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumRepositoryNamesExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumRepositoryNamesExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumRepositoryNamesExceededException")?;
        if let Some(inner_182) = &self.message {
            {
                write!(f, ": {}", inner_182)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumRepositoryNamesExceededException {}
impl aws_http::request_id::RequestId for crate::error::MaximumRepositoryNamesExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MaximumRepositoryNamesExceededException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchGetCommitsErrorKind = BatchGetCommitsError;
/// Error type for the `BatchGetCommitsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchGetCommitsError {
    /// <p>The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.</p>
    CommitIdsLimitExceededException(crate::error::CommitIdsLimitExceededException),
    /// <p>A list of commit IDs is required, but was either not specified or the list was empty.</p>
    CommitIdsListRequiredException(crate::error::CommitIdsListRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchGetCommitsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchGetCommitsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitIdsLimitExceededException(_inner) => _inner.fmt(f),
            Self::CommitIdsListRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchGetCommitsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitIdsLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitIdsListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchGetCommitsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchGetCommitsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchGetCommitsError {
    /// Creates the `BatchGetCommitsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchGetCommitsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitIdsLimitExceededException(e) => e.meta(),
            Self::CommitIdsListRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::CommitIdsLimitExceededException`.
    pub fn is_commit_ids_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitIdsLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::CommitIdsListRequiredException`.
    pub fn is_commit_ids_list_required_exception(&self) -> bool {
        matches!(self, Self::CommitIdsListRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchGetCommitsError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for BatchGetCommitsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitIdsLimitExceededException(_inner) => Some(_inner),
            Self::CommitIdsListRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>A list of commit IDs is required, but was either not specified or the list was empty.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommitIdsListRequiredException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommitIdsListRequiredException {
    /// Creates a new builder-style object to manufacture [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException).
    pub fn builder() -> crate::error::commit_ids_list_required_exception::Builder {
        crate::error::commit_ids_list_required_exception::Builder::default()
    }
}
/// See [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException).
pub mod commit_ids_list_required_exception {

    /// A builder for [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdsListRequiredException`](crate::error::CommitIdsListRequiredException).
        pub fn build(self) -> crate::error::CommitIdsListRequiredException {
            crate::error::CommitIdsListRequiredException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommitIdsListRequiredException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdsListRequiredException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdsListRequiredException")?;
        if let Some(inner_183) = &self.message {
            {
                write!(f, ": {}", inner_183)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdsListRequiredException {}
impl aws_http::request_id::RequestId for crate::error::CommitIdsListRequiredException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommitIdsListRequiredException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// <p>The maximum number of allowed commit IDs in a batch request is 100. Verify that your batch requests contains no more than 100 commit IDs, and then try again.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct CommitIdsLimitExceededException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl CommitIdsLimitExceededException {
    /// Creates a new builder-style object to manufacture [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException).
    pub fn builder() -> crate::error::commit_ids_limit_exceeded_exception::Builder {
        crate::error::commit_ids_limit_exceeded_exception::Builder::default()
    }
}
/// See [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException).
pub mod commit_ids_limit_exceeded_exception {

    /// A builder for [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`CommitIdsLimitExceededException`](crate::error::CommitIdsLimitExceededException).
        pub fn build(self) -> crate::error::CommitIdsLimitExceededException {
            crate::error::CommitIdsLimitExceededException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl CommitIdsLimitExceededException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for CommitIdsLimitExceededException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "CommitIdsLimitExceededException")?;
        if let Some(inner_184) = &self.message {
            {
                write!(f, ": {}", inner_184)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for CommitIdsLimitExceededException {}
impl aws_http::request_id::RequestId for crate::error::CommitIdsLimitExceededException {
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for CommitIdsLimitExceededException {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind =
    BatchDisassociateApprovalRuleTemplateFromRepositoriesError;
/// Error type for the `BatchDisassociateApprovalRuleTemplateFromRepositoriesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    /// <p>At least one repository name object is required, but was not specified.</p>
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for BatchDisassociateApprovalRuleTemplateFromRepositoriesError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::MaximumRepositoryNamesExceededException(_inner) => _inner.fmt(f),
            Self::RepositoryNamesRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for BatchDisassociateApprovalRuleTemplateFromRepositoriesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumRepositoryNamesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNamesRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for BatchDisassociateApprovalRuleTemplateFromRepositoriesError
{
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    /// Creates the `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::MaximumRepositoryNamesExceededException(e) => e.meta(),
            Self::RepositoryNamesRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::MaximumRepositoryNamesExceededException`.
    pub fn is_maximum_repository_names_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumRepositoryNamesExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchDisassociateApprovalRuleTemplateFromRepositoriesError::RepositoryNamesRequiredException`.
    pub fn is_repository_names_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNamesRequiredException(_))
    }
}
impl std::error::Error for BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::MaximumRepositoryNamesExceededException(_inner) => Some(_inner),
            Self::RepositoryNamesRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchDescribeMergeConflictsErrorKind = BatchDescribeMergeConflictsError;
/// Error type for the `BatchDescribeMergeConflictsError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchDescribeMergeConflictsError {
    /// <p>The specified commit does not exist or no commit was specified, and the specified repository has no default branch.</p>
    CommitDoesNotExistException(crate::error::CommitDoesNotExistException),
    /// <p>A commit was not specified.</p>
    CommitRequiredException(crate::error::CommitRequiredException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The specified commit is not valid.</p>
    InvalidCommitException(crate::error::InvalidCommitException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified continuation token is not valid.</p>
    InvalidContinuationTokenException(crate::error::InvalidContinuationTokenException),
    /// <p>The specified value for the number of conflict files to return is not valid.</p>
    InvalidMaxConflictFilesException(crate::error::InvalidMaxConflictFilesException),
    /// <p>The specified value for the number of merge hunks to return is not valid.</p>
    InvalidMaxMergeHunksException(crate::error::InvalidMaxMergeHunksException),
    /// <p>The specified merge option is not valid for this operation. Not all merge strategies are supported for all operations.</p>
    InvalidMergeOptionException(crate::error::InvalidMergeOptionException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::error::MaximumItemsToCompareExceededException),
    /// <p>A merge option or stategy is required, and none was provided.</p>
    MergeOptionRequiredException(crate::error::MergeOptionRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for BatchDescribeMergeConflictsError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchDescribeMergeConflictsError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::CommitRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidCommitException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidContinuationTokenException(_inner) => _inner.fmt(f),
            Self::InvalidMaxConflictFilesException(_inner) => _inner.fmt(f),
            Self::InvalidMaxMergeHunksException(_inner) => _inner.fmt(f),
            Self::InvalidMergeOptionException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MergeOptionRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for BatchDescribeMergeConflictsError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::CommitRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidContinuationTokenException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxConflictFilesException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMaxMergeHunksException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidMergeOptionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MergeOptionRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::error::BatchDescribeMergeConflictsError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for BatchDescribeMergeConflictsError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchDescribeMergeConflictsError {
    /// Creates the `BatchDescribeMergeConflictsError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchDescribeMergeConflictsError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitDoesNotExistException(e) => e.meta(),
            Self::CommitRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidCommitException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidContinuationTokenException(e) => e.meta(),
            Self::InvalidMaxConflictFilesException(e) => e.meta(),
            Self::InvalidMaxMergeHunksException(e) => e.meta(),
            Self::InvalidMergeOptionException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MergeOptionRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::CommitDoesNotExistException`.
    pub fn is_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::CommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::CommitRequiredException`.
    pub fn is_commit_required_exception(&self) -> bool {
        matches!(self, Self::CommitRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::InvalidCommitException`.
    pub fn is_invalid_commit_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::InvalidContinuationTokenException`.
    pub fn is_invalid_continuation_token_exception(&self) -> bool {
        matches!(self, Self::InvalidContinuationTokenException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::InvalidMaxConflictFilesException`.
    pub fn is_invalid_max_conflict_files_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxConflictFilesException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::InvalidMaxMergeHunksException`.
    pub fn is_invalid_max_merge_hunks_exception(&self) -> bool {
        matches!(self, Self::InvalidMaxMergeHunksException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::InvalidMergeOptionException`.
    pub fn is_invalid_merge_option_exception(&self) -> bool {
        matches!(self, Self::InvalidMergeOptionException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::MergeOptionRequiredException`.
    pub fn is_merge_option_required_exception(&self) -> bool {
        matches!(self, Self::MergeOptionRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchDescribeMergeConflictsError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for BatchDescribeMergeConflictsError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitDoesNotExistException(_inner) => Some(_inner),
            Self::CommitRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidCommitException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidContinuationTokenException(_inner) => Some(_inner),
            Self::InvalidMaxConflictFilesException(_inner) => Some(_inner),
            Self::InvalidMaxMergeHunksException(_inner) => Some(_inner),
            Self::InvalidMergeOptionException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::MergeOptionRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind =
    BatchAssociateApprovalRuleTemplateWithRepositoriesError;
/// Error type for the `BatchAssociateApprovalRuleTemplateWithRepositoriesError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>The maximum number of allowed repository names was exceeded. Currently, this number is 100.</p>
    MaximumRepositoryNamesExceededException(crate::error::MaximumRepositoryNamesExceededException),
    /// <p>At least one repository name object is required, but was not specified.</p>
    RepositoryNamesRequiredException(crate::error::RepositoryNamesRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for BatchAssociateApprovalRuleTemplateWithRepositoriesError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::MaximumRepositoryNamesExceededException(_inner) => _inner.fmt(f),
            Self::RepositoryNamesRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for BatchAssociateApprovalRuleTemplateWithRepositoriesError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumRepositoryNamesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNamesRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for BatchAssociateApprovalRuleTemplateWithRepositoriesError
{
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    /// Creates the `BatchAssociateApprovalRuleTemplateWithRepositoriesError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `BatchAssociateApprovalRuleTemplateWithRepositoriesError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::MaximumRepositoryNamesExceededException(e) => e.meta(),
            Self::RepositoryNamesRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::MaximumRepositoryNamesExceededException`.
    pub fn is_maximum_repository_names_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumRepositoryNamesExceededException(_))
    }
    /// Returns `true` if the error kind is `BatchAssociateApprovalRuleTemplateWithRepositoriesError::RepositoryNamesRequiredException`.
    pub fn is_repository_names_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNamesRequiredException(_))
    }
}
impl std::error::Error for BatchAssociateApprovalRuleTemplateWithRepositoriesError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::MaximumRepositoryNamesExceededException(_inner) => Some(_inner),
            Self::RepositoryNamesRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type AssociateApprovalRuleTemplateWithRepositoryErrorKind =
    AssociateApprovalRuleTemplateWithRepositoryError;
/// Error type for the `AssociateApprovalRuleTemplateWithRepositoryError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum AssociateApprovalRuleTemplateWithRepositoryError {
    /// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the AWS Region where the template was created, and then try again.</p>
    ApprovalRuleTemplateDoesNotExistException(
        crate::error::ApprovalRuleTemplateDoesNotExistException,
    ),
    /// <p>An approval rule template name is required, but was not specified.</p>
    ApprovalRuleTemplateNameRequiredException(
        crate::error::ApprovalRuleTemplateNameRequiredException,
    ),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::error::EncryptionKeyUnavailableException),
    /// <p>The name of the approval rule template is not valid. Template names must be between 1 and 100 valid characters in length. For more information about limits in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">AWS CodeCommit User Guide</a>.</p>
    InvalidApprovalRuleTemplateNameException(
        crate::error::InvalidApprovalRuleTemplateNameException,
    ),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::error::InvalidRepositoryNameException),
    /// <p>The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25 approval rule templates with a repository.</p>
    MaximumRuleTemplatesAssociatedWithRepositoryException(
        crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException,
    ),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError
    for AssociateApprovalRuleTemplateWithRepositoryError
{
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for AssociateApprovalRuleTemplateWithRepositoryError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::MaximumRuleTemplatesAssociatedWithRepositoryException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for AssociateApprovalRuleTemplateWithRepositoryError
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidApprovalRuleTemplateNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumRuleTemplatesAssociatedWithRepositoryException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::error::AssociateApprovalRuleTemplateWithRepositoryError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind
    for AssociateApprovalRuleTemplateWithRepositoryError
{
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl AssociateApprovalRuleTemplateWithRepositoryError {
    /// Creates the `AssociateApprovalRuleTemplateWithRepositoryError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `AssociateApprovalRuleTemplateWithRepositoryError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(e) => e.meta(),
            Self::ApprovalRuleTemplateNameRequiredException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidApprovalRuleTemplateNameException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::MaximumRuleTemplatesAssociatedWithRepositoryException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::ApprovalRuleTemplateDoesNotExistException`.
    pub fn is_approval_rule_template_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::ApprovalRuleTemplateNameRequiredException`.
    pub fn is_approval_rule_template_name_required_exception(&self) -> bool {
        matches!(self, Self::ApprovalRuleTemplateNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::InvalidApprovalRuleTemplateNameException`.
    pub fn is_invalid_approval_rule_template_name_exception(&self) -> bool {
        matches!(self, Self::InvalidApprovalRuleTemplateNameException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::MaximumRuleTemplatesAssociatedWithRepositoryException`.
    pub fn is_maximum_rule_templates_associated_with_repository_exception(&self) -> bool {
        matches!(
            self,
            Self::MaximumRuleTemplatesAssociatedWithRepositoryException(_)
        )
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `AssociateApprovalRuleTemplateWithRepositoryError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for AssociateApprovalRuleTemplateWithRepositoryError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::ApprovalRuleTemplateDoesNotExistException(_inner) => Some(_inner),
            Self::ApprovalRuleTemplateNameRequiredException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidApprovalRuleTemplateNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::MaximumRuleTemplatesAssociatedWithRepositoryException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

/// <p>The maximum number of approval rule templates for a repository has been exceeded. You cannot associate more than 25 approval rule templates with a repository.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct MaximumRuleTemplatesAssociatedWithRepositoryException {
    /// <p>Any message associated with the exception.</p>
    #[doc(hidden)]
    pub message: std::option::Option<std::string::String>,
    pub(crate) meta: aws_smithy_types::error::ErrorMetadata,
}
impl MaximumRuleTemplatesAssociatedWithRepositoryException {
    /// Creates a new builder-style object to manufacture [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException).
    pub fn builder(
    ) -> crate::error::maximum_rule_templates_associated_with_repository_exception::Builder {
        crate::error::maximum_rule_templates_associated_with_repository_exception::Builder::default(
        )
    }
}
/// See [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException).
pub mod maximum_rule_templates_associated_with_repository_exception {

    /// A builder for [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException).
    #[non_exhaustive]
    #[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
    pub struct Builder {
        pub(crate) message: std::option::Option<std::string::String>,
        meta: Option<aws_smithy_types::error::ErrorMetadata>,
    }
    impl Builder {
        /// <p>Any message associated with the exception.</p>
        pub fn message(mut self, input: impl Into<std::string::String>) -> Self {
            self.message = Some(input.into());
            self
        }
        /// <p>Any message associated with the exception.</p>
        pub fn set_message(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.message = input;
            self
        }
        /// Sets error metadata
        pub fn meta(mut self, meta: aws_smithy_types::error::ErrorMetadata) -> Self {
            self.meta = Some(meta);
            self
        }

        /// Sets error metadata
        pub fn set_meta(
            &mut self,
            meta: Option<aws_smithy_types::error::ErrorMetadata>,
        ) -> &mut Self {
            self.meta = meta;
            self
        }
        /// Consumes the builder and constructs a [`MaximumRuleTemplatesAssociatedWithRepositoryException`](crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException).
        pub fn build(self) -> crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException {
            crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException {
                message: self.message,
                meta: self.meta.unwrap_or_default(),
            }
        }
    }
}
impl MaximumRuleTemplatesAssociatedWithRepositoryException {
    /// Returns the error message.
    pub fn message(&self) -> std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl std::fmt::Display for MaximumRuleTemplatesAssociatedWithRepositoryException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MaximumRuleTemplatesAssociatedWithRepositoryException")?;
        if let Some(inner_185) = &self.message {
            {
                write!(f, ": {}", inner_185)?;
            }
        }
        Ok(())
    }
}
impl std::error::Error for MaximumRuleTemplatesAssociatedWithRepositoryException {}
impl aws_http::request_id::RequestId
    for crate::error::MaximumRuleTemplatesAssociatedWithRepositoryException
{
    fn request_id(&self) -> Option<&str> {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata
    for MaximumRuleTemplatesAssociatedWithRepositoryException
{
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
