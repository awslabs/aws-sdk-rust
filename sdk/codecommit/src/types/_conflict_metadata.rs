// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Information about the metadata for a conflict in a merge operation.</p>
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::fmt::Debug)]
pub struct ConflictMetadata {
    /// <p>The path of the file that contains conflicts.</p>
    #[doc(hidden)]
    pub file_path: std::option::Option<std::string::String>,
    /// <p>The file sizes of the file in the source, destination, and base of the merge.</p>
    #[doc(hidden)]
    pub file_sizes: std::option::Option<crate::types::FileSizes>,
    /// <p>The file modes of the file in the source, destination, and base of the merge.</p>
    #[doc(hidden)]
    pub file_modes: std::option::Option<crate::types::FileModes>,
    /// <p>Information about any object type conflicts in a merge operation.</p>
    #[doc(hidden)]
    pub object_types: std::option::Option<crate::types::ObjectTypes>,
    /// <p>The number of conflicts, including both hunk conflicts and metadata conflicts.</p>
    #[doc(hidden)]
    pub number_of_conflicts: i32,
    /// <p>A boolean value (true or false) indicating whether the file is binary or textual in the source, destination, and base of the merge.</p>
    #[doc(hidden)]
    pub is_binary_file: std::option::Option<crate::types::IsBinaryFile>,
    /// <p>A boolean value indicating whether there are conflicts in the content of a file.</p>
    #[doc(hidden)]
    pub content_conflict: bool,
    /// <p>A boolean value indicating whether there are conflicts in the file mode of a file.</p>
    #[doc(hidden)]
    pub file_mode_conflict: bool,
    /// <p>A boolean value (true or false) indicating whether there are conflicts between the branches in the object type of a file, folder, or submodule.</p>
    #[doc(hidden)]
    pub object_type_conflict: bool,
    /// <p>Whether an add, modify, or delete operation caused the conflict between the source and destination of the merge.</p>
    #[doc(hidden)]
    pub merge_operations: std::option::Option<crate::types::MergeOperations>,
}
impl ConflictMetadata {
    /// <p>The path of the file that contains conflicts.</p>
    pub fn file_path(&self) -> std::option::Option<&str> {
        self.file_path.as_deref()
    }
    /// <p>The file sizes of the file in the source, destination, and base of the merge.</p>
    pub fn file_sizes(&self) -> std::option::Option<&crate::types::FileSizes> {
        self.file_sizes.as_ref()
    }
    /// <p>The file modes of the file in the source, destination, and base of the merge.</p>
    pub fn file_modes(&self) -> std::option::Option<&crate::types::FileModes> {
        self.file_modes.as_ref()
    }
    /// <p>Information about any object type conflicts in a merge operation.</p>
    pub fn object_types(&self) -> std::option::Option<&crate::types::ObjectTypes> {
        self.object_types.as_ref()
    }
    /// <p>The number of conflicts, including both hunk conflicts and metadata conflicts.</p>
    pub fn number_of_conflicts(&self) -> i32 {
        self.number_of_conflicts
    }
    /// <p>A boolean value (true or false) indicating whether the file is binary or textual in the source, destination, and base of the merge.</p>
    pub fn is_binary_file(&self) -> std::option::Option<&crate::types::IsBinaryFile> {
        self.is_binary_file.as_ref()
    }
    /// <p>A boolean value indicating whether there are conflicts in the content of a file.</p>
    pub fn content_conflict(&self) -> bool {
        self.content_conflict
    }
    /// <p>A boolean value indicating whether there are conflicts in the file mode of a file.</p>
    pub fn file_mode_conflict(&self) -> bool {
        self.file_mode_conflict
    }
    /// <p>A boolean value (true or false) indicating whether there are conflicts between the branches in the object type of a file, folder, or submodule.</p>
    pub fn object_type_conflict(&self) -> bool {
        self.object_type_conflict
    }
    /// <p>Whether an add, modify, or delete operation caused the conflict between the source and destination of the merge.</p>
    pub fn merge_operations(&self) -> std::option::Option<&crate::types::MergeOperations> {
        self.merge_operations.as_ref()
    }
}
impl ConflictMetadata {
    /// Creates a new builder-style object to manufacture [`ConflictMetadata`](crate::types::ConflictMetadata).
    pub fn builder() -> crate::types::builders::ConflictMetadataBuilder {
        crate::types::builders::ConflictMetadataBuilder::default()
    }
}

/// A builder for [`ConflictMetadata`](crate::types::ConflictMetadata).
#[non_exhaustive]
#[derive(std::clone::Clone, std::cmp::PartialEq, std::default::Default, std::fmt::Debug)]
pub struct ConflictMetadataBuilder {
    pub(crate) file_path: std::option::Option<std::string::String>,
    pub(crate) file_sizes: std::option::Option<crate::types::FileSizes>,
    pub(crate) file_modes: std::option::Option<crate::types::FileModes>,
    pub(crate) object_types: std::option::Option<crate::types::ObjectTypes>,
    pub(crate) number_of_conflicts: std::option::Option<i32>,
    pub(crate) is_binary_file: std::option::Option<crate::types::IsBinaryFile>,
    pub(crate) content_conflict: std::option::Option<bool>,
    pub(crate) file_mode_conflict: std::option::Option<bool>,
    pub(crate) object_type_conflict: std::option::Option<bool>,
    pub(crate) merge_operations: std::option::Option<crate::types::MergeOperations>,
}
impl ConflictMetadataBuilder {
    /// <p>The path of the file that contains conflicts.</p>
    pub fn file_path(mut self, input: impl Into<std::string::String>) -> Self {
        self.file_path = Some(input.into());
        self
    }
    /// <p>The path of the file that contains conflicts.</p>
    pub fn set_file_path(mut self, input: std::option::Option<std::string::String>) -> Self {
        self.file_path = input;
        self
    }
    /// <p>The file sizes of the file in the source, destination, and base of the merge.</p>
    pub fn file_sizes(mut self, input: crate::types::FileSizes) -> Self {
        self.file_sizes = Some(input);
        self
    }
    /// <p>The file sizes of the file in the source, destination, and base of the merge.</p>
    pub fn set_file_sizes(mut self, input: std::option::Option<crate::types::FileSizes>) -> Self {
        self.file_sizes = input;
        self
    }
    /// <p>The file modes of the file in the source, destination, and base of the merge.</p>
    pub fn file_modes(mut self, input: crate::types::FileModes) -> Self {
        self.file_modes = Some(input);
        self
    }
    /// <p>The file modes of the file in the source, destination, and base of the merge.</p>
    pub fn set_file_modes(mut self, input: std::option::Option<crate::types::FileModes>) -> Self {
        self.file_modes = input;
        self
    }
    /// <p>Information about any object type conflicts in a merge operation.</p>
    pub fn object_types(mut self, input: crate::types::ObjectTypes) -> Self {
        self.object_types = Some(input);
        self
    }
    /// <p>Information about any object type conflicts in a merge operation.</p>
    pub fn set_object_types(
        mut self,
        input: std::option::Option<crate::types::ObjectTypes>,
    ) -> Self {
        self.object_types = input;
        self
    }
    /// <p>The number of conflicts, including both hunk conflicts and metadata conflicts.</p>
    pub fn number_of_conflicts(mut self, input: i32) -> Self {
        self.number_of_conflicts = Some(input);
        self
    }
    /// <p>The number of conflicts, including both hunk conflicts and metadata conflicts.</p>
    pub fn set_number_of_conflicts(mut self, input: std::option::Option<i32>) -> Self {
        self.number_of_conflicts = input;
        self
    }
    /// <p>A boolean value (true or false) indicating whether the file is binary or textual in the source, destination, and base of the merge.</p>
    pub fn is_binary_file(mut self, input: crate::types::IsBinaryFile) -> Self {
        self.is_binary_file = Some(input);
        self
    }
    /// <p>A boolean value (true or false) indicating whether the file is binary or textual in the source, destination, and base of the merge.</p>
    pub fn set_is_binary_file(
        mut self,
        input: std::option::Option<crate::types::IsBinaryFile>,
    ) -> Self {
        self.is_binary_file = input;
        self
    }
    /// <p>A boolean value indicating whether there are conflicts in the content of a file.</p>
    pub fn content_conflict(mut self, input: bool) -> Self {
        self.content_conflict = Some(input);
        self
    }
    /// <p>A boolean value indicating whether there are conflicts in the content of a file.</p>
    pub fn set_content_conflict(mut self, input: std::option::Option<bool>) -> Self {
        self.content_conflict = input;
        self
    }
    /// <p>A boolean value indicating whether there are conflicts in the file mode of a file.</p>
    pub fn file_mode_conflict(mut self, input: bool) -> Self {
        self.file_mode_conflict = Some(input);
        self
    }
    /// <p>A boolean value indicating whether there are conflicts in the file mode of a file.</p>
    pub fn set_file_mode_conflict(mut self, input: std::option::Option<bool>) -> Self {
        self.file_mode_conflict = input;
        self
    }
    /// <p>A boolean value (true or false) indicating whether there are conflicts between the branches in the object type of a file, folder, or submodule.</p>
    pub fn object_type_conflict(mut self, input: bool) -> Self {
        self.object_type_conflict = Some(input);
        self
    }
    /// <p>A boolean value (true or false) indicating whether there are conflicts between the branches in the object type of a file, folder, or submodule.</p>
    pub fn set_object_type_conflict(mut self, input: std::option::Option<bool>) -> Self {
        self.object_type_conflict = input;
        self
    }
    /// <p>Whether an add, modify, or delete operation caused the conflict between the source and destination of the merge.</p>
    pub fn merge_operations(mut self, input: crate::types::MergeOperations) -> Self {
        self.merge_operations = Some(input);
        self
    }
    /// <p>Whether an add, modify, or delete operation caused the conflict between the source and destination of the merge.</p>
    pub fn set_merge_operations(
        mut self,
        input: std::option::Option<crate::types::MergeOperations>,
    ) -> Self {
        self.merge_operations = input;
        self
    }
    /// Consumes the builder and constructs a [`ConflictMetadata`](crate::types::ConflictMetadata).
    pub fn build(self) -> crate::types::ConflictMetadata {
        crate::types::ConflictMetadata {
            file_path: self.file_path,
            file_sizes: self.file_sizes,
            file_modes: self.file_modes,
            object_types: self.object_types,
            number_of_conflicts: self.number_of_conflicts.unwrap_or_default(),
            is_binary_file: self.is_binary_file,
            content_conflict: self.content_conflict.unwrap_or_default(),
            file_mode_conflict: self.file_mode_conflict.unwrap_or_default(),
            object_type_conflict: self.object_type_conflict.unwrap_or_default(),
            merge_operations: self.merge_operations,
        }
    }
}
