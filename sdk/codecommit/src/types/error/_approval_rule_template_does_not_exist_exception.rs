// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>The specified approval rule template does not exist. Verify that the name is correct and that you are signed in to the Amazon Web Services Region where the template was created, and then try again.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct ApprovalRuleTemplateDoesNotExistException {
    /// <p>Any message associated with the exception.</p>
    pub message: ::std::option::Option<::std::string::String>,
    pub(crate) meta: ::aws_smithy_types::error::ErrorMetadata,
}
impl ApprovalRuleTemplateDoesNotExistException {
    /// Returns the error message.
    pub fn message(&self) -> ::std::option::Option<&str> {
        self.message.as_deref()
    }
}
impl ::std::fmt::Display for ApprovalRuleTemplateDoesNotExistException {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        ::std::write!(f, "ApprovalRuleTemplateDoesNotExistException")?;
        if let ::std::option::Option::Some(inner_1) = &self.message {
            {
                ::std::write!(f, ": {inner_1}")?;
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ApprovalRuleTemplateDoesNotExistException {}
impl ::aws_types::request_id::RequestId for crate::types::error::ApprovalRuleTemplateDoesNotExistException {
    fn request_id(&self) -> Option<&str> {
        use ::aws_smithy_types::error::metadata::ProvideErrorMetadata;
        self.meta().request_id()
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for ApprovalRuleTemplateDoesNotExistException {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        &self.meta
    }
}
impl ApprovalRuleTemplateDoesNotExistException {
    /// Creates a new builder-style object to manufacture [`ApprovalRuleTemplateDoesNotExistException`](crate::types::error::ApprovalRuleTemplateDoesNotExistException).
    pub fn builder() -> crate::types::error::builders::ApprovalRuleTemplateDoesNotExistExceptionBuilder {
        crate::types::error::builders::ApprovalRuleTemplateDoesNotExistExceptionBuilder::default()
    }
}

/// A builder for [`ApprovalRuleTemplateDoesNotExistException`](crate::types::error::ApprovalRuleTemplateDoesNotExistException).
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct ApprovalRuleTemplateDoesNotExistExceptionBuilder {
    pub(crate) message: ::std::option::Option<::std::string::String>,
    meta: std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
}
impl ApprovalRuleTemplateDoesNotExistExceptionBuilder {
    /// <p>Any message associated with the exception.</p>
    pub fn message(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.message = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Any message associated with the exception.</p>
    pub fn set_message(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.message = input;
        self
    }
    /// <p>Any message associated with the exception.</p>
    pub fn get_message(&self) -> &::std::option::Option<::std::string::String> {
        &self.message
    }
    /// Sets error metadata
    pub fn meta(mut self, meta: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        self.meta = Some(meta);
        self
    }

    /// Sets error metadata
    pub fn set_meta(&mut self, meta: std::option::Option<::aws_smithy_types::error::ErrorMetadata>) -> &mut Self {
        self.meta = meta;
        self
    }
    /// Consumes the builder and constructs a [`ApprovalRuleTemplateDoesNotExistException`](crate::types::error::ApprovalRuleTemplateDoesNotExistException).
    pub fn build(self) -> crate::types::error::ApprovalRuleTemplateDoesNotExistException {
        crate::types::error::ApprovalRuleTemplateDoesNotExistException {
            message: self.message,
            meta: self.meta.unwrap_or_default(),
        }
    }
}
