// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_approval_rule_template_with_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateApprovalRuleTemplateWithRepositoryOutput,
    crate::error::AssociateApprovalRuleTemplateWithRepositoryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRuleTemplatesAssociatedWithRepositoryException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::MaximumRuleTemplatesAssociatedWithRepositoryException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_rule_templates_associated_with_repository_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_rule_templates_associated_with_repository_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_approval_rule_template_with_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateApprovalRuleTemplateWithRepositoryOutput,
    crate::error::AssociateApprovalRuleTemplateWithRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::associate_approval_rule_template_with_repository_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_associate_approval_rule_template_with_repositories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchAssociateApprovalRuleTemplateWithRepositoriesOutput,
    crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(
        crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled,
    )?;
    let error_code =
        match generic.code() {
            Some(code) => code,
            None => return Err(
                crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled(
                    generic,
                ),
            ),
        };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryNamesExceededException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::MaximumRepositoryNamesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_repository_names_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_repository_names_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNamesRequiredException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::RepositoryNamesRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_names_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_names_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_associate_approval_rule_template_with_repositories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchAssociateApprovalRuleTemplateWithRepositoriesOutput,
    crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::batch_associate_approval_rule_template_with_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_batch_associate_approval_rule_template_with_repositories(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_merge_conflicts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDescribeMergeConflictsOutput,
    crate::error::BatchDescribeMergeConflictsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::BatchDescribeMergeConflictsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::CommitRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidCommitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxConflictFilesException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidMaxConflictFilesException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_max_conflict_files_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_max_conflict_files_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxMergeHunksException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_max_merge_hunks_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_max_merge_hunks_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMergeOptionException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidMergeOptionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_merge_option_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_file_content_to_load_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_items_to_compare_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MergeOptionRequiredException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::MergeOptionRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_merge_option_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchDescribeMergeConflictsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_merge_conflicts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDescribeMergeConflictsOutput,
    crate::error::BatchDescribeMergeConflictsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_describe_merge_conflicts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_batch_describe_merge_conflicts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_disassociate_approval_rule_template_from_repositories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput,
    crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(
        crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled,
    )?;
    let error_code =
        match generic.code() {
            Some(code) => code,
            None => return Err(
                crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled(
                    generic,
                ),
            ),
        };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryNamesExceededException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::MaximumRepositoryNamesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_repository_names_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_repository_names_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNamesRequiredException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::RepositoryNamesRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_names_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_names_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_disassociate_approval_rule_template_from_repositories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput,
    crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::batch_disassociate_approval_rule_template_from_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_batch_disassociate_approval_rule_template_from_repositories(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_commits_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetCommitsOutput, crate::error::BatchGetCommitsError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::BatchGetCommitsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetCommitsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitIdsLimitExceededException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::CommitIdsLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_ids_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_ids_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommitIdsListRequiredException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::CommitIdsListRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_ids_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_ids_list_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::BatchGetCommitsError {
            meta: generic,
            kind: crate::error::BatchGetCommitsErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::BatchGetCommitsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_commits_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetCommitsOutput, crate::error::BatchGetCommitsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_commits_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_batch_get_commits(response.body().as_ref(), output)
                .map_err(crate::error::BatchGetCommitsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_repositories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetRepositoriesOutput,
    crate::error::BatchGetRepositoriesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetRepositoriesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryNamesExceededException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::MaximumRepositoryNamesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_repository_names_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_repository_names_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNamesRequiredException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::RepositoryNamesRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_names_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_names_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetRepositoriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_repositories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetRepositoriesOutput,
    crate::error::BatchGetRepositoriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_batch_get_repositories(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_approval_rule_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateApprovalRuleTemplateOutput,
    crate::error::CreateApprovalRuleTemplateError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateApprovalRuleTemplateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateContentRequiredException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameAlreadyExistsException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateContentException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_content_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateDescriptionException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateDescriptionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_description_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NumberOfRuleTemplatesExceededException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::NumberOfRuleTemplatesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::number_of_rule_templates_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_number_of_rule_templates_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_approval_rule_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateApprovalRuleTemplateOutput,
    crate::error::CreateApprovalRuleTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_approval_rule_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_branch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateBranchOutput, crate::error::CreateBranchError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateBranchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateBranchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchNameExistsException" => {
            crate::error::CreateBranchError {
                meta: generic,
                kind: crate::error::CreateBranchErrorKind::BranchNameExistsException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_name_exists_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_name_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "BranchNameRequiredException" => {
            crate::error::CreateBranchError {
                meta: generic,
                kind: crate::error::CreateBranchErrorKind::BranchNameRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_name_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommitDoesNotExistException" => {
            crate::error::CreateBranchError {
                meta: generic,
                kind: crate::error::CreateBranchErrorKind::CommitDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::commit_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommitIdRequiredException" => {
            crate::error::CreateBranchError {
                meta: generic,
                kind: crate::error::CreateBranchErrorKind::CommitIdRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::commit_id_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::CreateBranchError {
            meta: generic,
            kind: crate::error::CreateBranchErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::CreateBranchError {
            meta: generic,
            kind: crate::error::CreateBranchErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::CreateBranchError {
            meta: generic,
            kind: crate::error::CreateBranchErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::CreateBranchError {
            meta: generic,
            kind: crate::error::CreateBranchErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::CreateBranchError {
            meta: generic,
            kind: crate::error::CreateBranchErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidBranchNameException" => {
            crate::error::CreateBranchError {
                meta: generic,
                kind: crate::error::CreateBranchErrorKind::InvalidBranchNameException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_branch_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidCommitIdException" => crate::error::CreateBranchError {
            meta: generic,
            kind: crate::error::CreateBranchErrorKind::InvalidCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::CreateBranchError {
            meta: generic,
            kind: crate::error::CreateBranchErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::CreateBranchError {
            meta: generic,
            kind: crate::error::CreateBranchErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::CreateBranchError {
            meta: generic,
            kind: crate::error::CreateBranchErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateBranchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_branch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateBranchOutput, crate::error::CreateBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_branch_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCommitOutput, crate::error::CreateCommitError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateCommitError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateCommitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::BranchDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "BranchNameIsTagNameException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::BranchNameIsTagNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_name_is_tag_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "BranchNameRequiredException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::BranchNameRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_name_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommitMessageLengthExceededException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::CommitMessageLengthExceededException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_message_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectoryNameConflictsWithFileNameException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::DirectoryNameConflictsWithFileNameException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::directory_name_conflicts_with_file_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_directory_name_conflicts_with_file_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EncryptionIntegrityChecksFailedException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FileContentAndSourceFileSpecifiedException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::FileContentAndSourceFileSpecifiedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::file_content_and_source_file_specified_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_content_and_source_file_specified_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "FileContentSizeLimitExceededException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::FileContentSizeLimitExceededException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "FileDoesNotExistException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::FileDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::file_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "FileEntryRequiredException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::FileEntryRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::file_entry_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_entry_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "FileModeRequiredException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::FileModeRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::file_mode_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_mode_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "FileNameConflictsWithDirectoryNameException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::FileNameConflictsWithDirectoryNameException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::file_name_conflicts_with_directory_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_name_conflicts_with_directory_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "FilePathConflictsWithSubmodulePathException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::FilePathConflictsWithSubmodulePathException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::file_path_conflicts_with_submodule_path_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_path_conflicts_with_submodule_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "FolderContentSizeLimitExceededException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::FolderContentSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_folder_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidBranchNameException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::InvalidBranchNameException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_branch_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDeletionParameterException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::InvalidDeletionParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_deletion_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_deletion_parameter_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidEmailException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::InvalidEmailException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_email_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFileModeException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::InvalidFileModeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_invalid_file_mode_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParentCommitIdException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::InvalidParentCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parent_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_parent_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPathException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MaximumFileEntriesExceededException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::MaximumFileEntriesExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::maximum_file_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_file_entries_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NameLengthExceededException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::NameLengthExceededException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::name_length_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_name_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "NoChangeException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::NoChangeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_change_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_no_change_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParentCommitDoesNotExistException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::ParentCommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_parent_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParentCommitIdOutdatedException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::ParentCommitIdOutdatedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_outdated_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_parent_commit_id_outdated_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParentCommitIdRequiredException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::ParentCommitIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_parent_commit_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PathRequiredException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::PathRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PutFileEntryConflictException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::PutFileEntryConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::put_file_entry_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_put_file_entry_conflict_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RestrictedSourceFileException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::RestrictedSourceFileException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::restricted_source_file_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_restricted_source_file_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SamePathRequestException" => crate::error::CreateCommitError {
            meta: generic,
            kind: crate::error::CreateCommitErrorKind::SamePathRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::same_path_request_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_same_path_request_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SourceFileOrContentRequiredException" => {
            crate::error::CreateCommitError {
                meta: generic,
                kind: crate::error::CreateCommitErrorKind::SourceFileOrContentRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::source_file_or_content_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_source_file_or_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::CreateCommitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCommitOutput, crate::error::CreateCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_commit(response.body().as_ref(), output)
            .map_err(crate::error::CreateCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePullRequestOutput, crate::error::CreatePullRequestError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreatePullRequestError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePullRequestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClientRequestTokenRequiredException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::ClientRequestTokenRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_client_request_token_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionIntegrityChecksFailedException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind:
                crate::error::CreatePullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "IdempotencyParameterMismatchException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::IdempotencyParameterMismatchException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_idempotency_parameter_mismatch_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidClientRequestTokenException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::InvalidClientRequestTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_client_request_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDescriptionException" => {
            crate::error::CreatePullRequestError {
                meta: generic,
                kind: crate::error::CreatePullRequestErrorKind::InvalidDescriptionException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_description_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_description_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidReferenceNameException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::InvalidReferenceNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_reference_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_reference_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTargetException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::InvalidTargetException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_target_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTargetsException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::InvalidTargetsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_targets_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_targets_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTitleException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::InvalidTitleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_title_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_title_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MaximumOpenPullRequestsExceededException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind:
                crate::error::CreatePullRequestErrorKind::MaximumOpenPullRequestsExceededException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::maximum_open_pull_requests_exceeded_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_maximum_open_pull_requests_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "MultipleRepositoriesInPullRequestException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind:
                crate::error::CreatePullRequestErrorKind::MultipleRepositoriesInPullRequestException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::multiple_repositories_in_pull_request_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_multiple_repositories_in_pull_request_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "ReferenceDoesNotExistException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::ReferenceDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reference_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_reference_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ReferenceNameRequiredException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::ReferenceNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reference_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_reference_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ReferenceTypeNotSupportedException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::ReferenceTypeNotSupportedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reference_type_not_supported_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_reference_type_not_supported_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SourceAndDestinationAreSameException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::SourceAndDestinationAreSameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::source_and_destination_are_same_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_source_and_destination_are_same_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TargetRequiredException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::TargetRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::target_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_target_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TargetsRequiredException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::TargetsRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::targets_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_targets_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TitleRequiredException" => crate::error::CreatePullRequestError {
            meta: generic,
            kind: crate::error::CreatePullRequestErrorKind::TitleRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::title_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_title_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreatePullRequestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePullRequestOutput, crate::error::CreatePullRequestError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_pull_request(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePullRequestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_approval_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePullRequestApprovalRuleOutput,
    crate::error::CreatePullRequestApprovalRuleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreatePullRequestApprovalRuleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleContentRequiredException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::ApprovalRuleContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleNameAlreadyExistsException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_name_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleNameRequiredException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleContentException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_content_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleNameException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NumberOfRulesExceededException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::NumberOfRulesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::number_of_rules_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_number_of_rules_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreatePullRequestApprovalRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_approval_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePullRequestApprovalRuleOutput,
    crate::error::CreatePullRequestApprovalRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_pull_request_approval_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_pull_request_approval_rule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRepositoryOutput, crate::error::CreateRepositoryError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateRepositoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateRepositoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryDescriptionException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::InvalidRepositoryDescriptionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_description_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSystemTagUsageException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::InvalidSystemTagUsageException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_system_tag_usage_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_system_tag_usage_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTagsMapException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::InvalidTagsMapException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_tags_map_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_tags_map_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryLimitExceededException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::RepositoryLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameExistsException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::RepositoryNameExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagPolicyException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::TagPolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tag_policy_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyTagsException" => crate::error::CreateRepositoryError {
            meta: generic,
            kind: crate::error::CreateRepositoryErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::CreateRepositoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRepositoryOutput, crate::error::CreateRepositoryError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_repository_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_create_repository(response.body().as_ref(), output)
                .map_err(crate::error::CreateRepositoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_unreferenced_merge_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateUnreferencedMergeCommitOutput,
    crate::error::CreateUnreferencedMergeCommitError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateUnreferencedMergeCommitError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitMessageLengthExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_message_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::CommitRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_reference_update_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileModeRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::FileModeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_mode_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_folder_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidCommitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidEmailException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_email_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_file_mode_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMergeOptionException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidMergeOptionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_merge_option_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidPathException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_content_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_type_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_manual_merge_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_conflict_resolution_entries_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_file_content_to_load_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_items_to_compare_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MergeOptionRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MergeOptionRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_merge_option_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_multiple_conflict_resolution_entries_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_name_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::PathRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_type_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateUnreferencedMergeCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_unreferenced_merge_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateUnreferencedMergeCommitOutput,
    crate::error::CreateUnreferencedMergeCommitError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_unreferenced_merge_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_create_unreferenced_merge_commit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_approval_rule_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteApprovalRuleTemplateOutput,
    crate::error::DeleteApprovalRuleTemplateError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteApprovalRuleTemplateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateInUseException" => crate::error::DeleteApprovalRuleTemplateError { meta: generic, kind: crate::error::DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateInUseException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_in_use_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::DeleteApprovalRuleTemplateError { meta: generic, kind: crate::error::DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::DeleteApprovalRuleTemplateError { meta: generic, kind: crate::error::DeleteApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_approval_rule_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteApprovalRuleTemplateOutput,
    crate::error::DeleteApprovalRuleTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_approval_rule_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_branch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBranchOutput, crate::error::DeleteBranchError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteBranchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteBranchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchNameRequiredException" => {
            crate::error::DeleteBranchError {
                meta: generic,
                kind: crate::error::DeleteBranchErrorKind::BranchNameRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_name_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DefaultBranchCannotBeDeletedException" => {
            crate::error::DeleteBranchError {
                meta: generic,
                kind: crate::error::DeleteBranchErrorKind::DefaultBranchCannotBeDeletedException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::default_branch_cannot_be_deleted_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_default_branch_cannot_be_deleted_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::DeleteBranchError {
            meta: generic,
            kind: crate::error::DeleteBranchErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::DeleteBranchError {
            meta: generic,
            kind: crate::error::DeleteBranchErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::DeleteBranchError {
            meta: generic,
            kind: crate::error::DeleteBranchErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::DeleteBranchError {
            meta: generic,
            kind: crate::error::DeleteBranchErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::DeleteBranchError {
            meta: generic,
            kind: crate::error::DeleteBranchErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidBranchNameException" => {
            crate::error::DeleteBranchError {
                meta: generic,
                kind: crate::error::DeleteBranchErrorKind::InvalidBranchNameException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_branch_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidRepositoryNameException" => crate::error::DeleteBranchError {
            meta: generic,
            kind: crate::error::DeleteBranchErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::DeleteBranchError {
            meta: generic,
            kind: crate::error::DeleteBranchErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::DeleteBranchError {
            meta: generic,
            kind: crate::error::DeleteBranchErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteBranchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_branch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBranchOutput, crate::error::DeleteBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_branch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_branch(response.body().as_ref(), output)
            .map_err(crate::error::DeleteBranchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_comment_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCommentContentOutput,
    crate::error::DeleteCommentContentError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteCommentContentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteCommentContentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => crate::error::DeleteCommentContentError {
            meta: generic,
            kind: crate::error::DeleteCommentContentErrorKind::CommentDeletedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_deleted_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentDoesNotExistException" => crate::error::DeleteCommentContentError {
            meta: generic,
            kind: crate::error::DeleteCommentContentErrorKind::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentIdRequiredException" => {
            crate::error::DeleteCommentContentError {
                meta: generic,
                kind: crate::error::DeleteCommentContentErrorKind::CommentIdRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::comment_id_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_comment_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidCommentIdException" => {
            crate::error::DeleteCommentContentError {
                meta: generic,
                kind: crate::error::DeleteCommentContentErrorKind::InvalidCommentIdException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_comment_id_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_comment_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::DeleteCommentContentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_comment_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCommentContentOutput,
    crate::error::DeleteCommentContentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_comment_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_comment_content(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteCommentContentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_file_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFileOutput, crate::error::DeleteFileError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteFileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::DeleteFileError {
                meta: generic,
                kind: crate::error::DeleteFileErrorKind::BranchDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "BranchNameIsTagNameException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::BranchNameIsTagNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_name_is_tag_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "BranchNameRequiredException" => {
            crate::error::DeleteFileError {
                meta: generic,
                kind: crate::error::DeleteFileErrorKind::BranchNameRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_name_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommitMessageLengthExceededException" => {
            crate::error::DeleteFileError {
                meta: generic,
                kind: crate::error::DeleteFileErrorKind::CommitMessageLengthExceededException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_message_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FileDoesNotExistException" => {
            crate::error::DeleteFileError {
                meta: generic,
                kind: crate::error::DeleteFileErrorKind::FileDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::file_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidBranchNameException" => {
            crate::error::DeleteFileError {
                meta: generic,
                kind: crate::error::DeleteFileErrorKind::InvalidBranchNameException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_branch_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidEmailException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::InvalidEmailException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_email_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParentCommitIdException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::InvalidParentCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parent_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_parent_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPathException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NameLengthExceededException" => {
            crate::error::DeleteFileError {
                meta: generic,
                kind: crate::error::DeleteFileErrorKind::NameLengthExceededException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::name_length_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_name_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ParentCommitDoesNotExistException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::ParentCommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_parent_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParentCommitIdOutdatedException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::ParentCommitIdOutdatedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_outdated_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_parent_commit_id_outdated_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParentCommitIdRequiredException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::ParentCommitIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_parent_commit_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PathRequiredException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::PathRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::DeleteFileError {
            meta: generic,
            kind: crate::error::DeleteFileErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteFileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_file_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFileOutput, crate::error::DeleteFileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_file_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_file(response.body().as_ref(), output)
            .map_err(crate::error::DeleteFileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pull_request_approval_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePullRequestApprovalRuleOutput,
    crate::error::DeletePullRequestApprovalRuleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeletePullRequestApprovalRuleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleNameRequiredException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CannotDeleteApprovalRuleFromTemplateException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::CannotDeleteApprovalRuleFromTemplateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cannot_delete_approval_rule_from_template_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_cannot_delete_approval_rule_from_template_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleNameException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeletePullRequestApprovalRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pull_request_approval_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePullRequestApprovalRuleOutput,
    crate::error::DeletePullRequestApprovalRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_pull_request_approval_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_delete_pull_request_approval_rule(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRepositoryOutput, crate::error::DeleteRepositoryError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DeleteRepositoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRepositoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::DeleteRepositoryError {
            meta: generic,
            kind: crate::error::DeleteRepositoryErrorKind::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::DeleteRepositoryError {
            meta: generic,
            kind: crate::error::DeleteRepositoryErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::DeleteRepositoryError {
            meta: generic,
            kind: crate::error::DeleteRepositoryErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::DeleteRepositoryError {
            meta: generic,
            kind: crate::error::DeleteRepositoryErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::DeleteRepositoryError {
            meta: generic,
            kind: crate::error::DeleteRepositoryErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::DeleteRepositoryError {
            meta: generic,
            kind: crate::error::DeleteRepositoryErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::DeleteRepositoryError {
            meta: generic,
            kind: crate::error::DeleteRepositoryErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::DeleteRepositoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRepositoryOutput, crate::error::DeleteRepositoryError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_repository_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_delete_repository(response.body().as_ref(), output)
                .map_err(crate::error::DeleteRepositoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_merge_conflicts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMergeConflictsOutput,
    crate::error::DescribeMergeConflictsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMergeConflictsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::CommitRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileDoesNotExistException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::FileDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::file_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidCommitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxMergeHunksException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_max_merge_hunks_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_max_merge_hunks_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMergeOptionException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidMergeOptionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_merge_option_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidPathException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_file_content_to_load_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_items_to_compare_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MergeOptionRequiredException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::MergeOptionRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_merge_option_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::PathRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeMergeConflictsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_merge_conflicts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMergeConflictsOutput,
    crate::error::DescribeMergeConflictsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_merge_conflicts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_merge_conflicts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pull_request_events_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePullRequestEventsOutput,
    crate::error::DescribePullRequestEventsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePullRequestEventsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ActorDoesNotExistException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::ActorDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::actor_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_actor_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidActorArnException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidActorArnException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_actor_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_actor_arn_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_max_results_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestEventTypeException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidPullRequestEventTypeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_event_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_event_type_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribePullRequestEventsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pull_request_events_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePullRequestEventsOutput,
    crate::error::DescribePullRequestEventsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_pull_request_events_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_describe_pull_request_events(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_approval_rule_template_from_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateApprovalRuleTemplateFromRepositoryOutput,
    crate::error::DisassociateApprovalRuleTemplateFromRepositoryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_approval_rule_template_from_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateApprovalRuleTemplateFromRepositoryOutput,
    crate::error::DisassociateApprovalRuleTemplateFromRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::disassociate_approval_rule_template_from_repository_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_evaluate_pull_request_approval_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EvaluatePullRequestApprovalRulesOutput,
    crate::error::EvaluatePullRequestApprovalRulesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_revision_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_revision_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionNotCurrentException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::RevisionNotCurrentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::revision_not_current_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_revision_not_current_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::EvaluatePullRequestApprovalRulesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_evaluate_pull_request_approval_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EvaluatePullRequestApprovalRulesOutput,
    crate::error::EvaluatePullRequestApprovalRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::evaluate_pull_request_approval_rules_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_evaluate_pull_request_approval_rules(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_approval_rule_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetApprovalRuleTemplateOutput,
    crate::error::GetApprovalRuleTemplateError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetApprovalRuleTemplateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::GetApprovalRuleTemplateError { meta: generic, kind: crate::error::GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::GetApprovalRuleTemplateError { meta: generic, kind: crate::error::GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::GetApprovalRuleTemplateError { meta: generic, kind: crate::error::GetApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_approval_rule_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetApprovalRuleTemplateOutput,
    crate::error::GetApprovalRuleTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_approval_rule_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_blob_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetBlobOutput, crate::error::GetBlobError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetBlobError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetBlobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BlobIdDoesNotExistException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::BlobIdDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::blob_id_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_blob_id_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "BlobIdRequiredException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::BlobIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::blob_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_blob_id_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionIntegrityChecksFailedException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FileTooLargeException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::FileTooLargeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_too_large_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_too_large_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidBlobIdException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::InvalidBlobIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_blob_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_blob_id_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetBlobError {
            meta: generic,
            kind: crate::error::GetBlobErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetBlobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_blob_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetBlobOutput, crate::error::GetBlobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_blob_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_blob(response.body().as_ref(), output)
            .map_err(crate::error::GetBlobError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_branch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetBranchOutput, crate::error::GetBranchError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetBranchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetBranchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::GetBranchError {
                meta: generic,
                kind: crate::error::GetBranchErrorKind::BranchDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "BranchNameRequiredException" => {
            crate::error::GetBranchError {
                meta: generic,
                kind: crate::error::GetBranchErrorKind::BranchNameRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_name_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::GetBranchError {
            meta: generic,
            kind: crate::error::GetBranchErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetBranchError {
            meta: generic,
            kind: crate::error::GetBranchErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetBranchError {
            meta: generic,
            kind: crate::error::GetBranchErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetBranchError {
            meta: generic,
            kind: crate::error::GetBranchErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetBranchError {
            meta: generic,
            kind: crate::error::GetBranchErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidBranchNameException" => {
            crate::error::GetBranchError {
                meta: generic,
                kind: crate::error::GetBranchErrorKind::InvalidBranchNameException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_branch_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidRepositoryNameException" => crate::error::GetBranchError {
            meta: generic,
            kind: crate::error::GetBranchErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::GetBranchError {
            meta: generic,
            kind: crate::error::GetBranchErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetBranchError {
            meta: generic,
            kind: crate::error::GetBranchErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetBranchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_branch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetBranchOutput, crate::error::GetBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_branch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_branch(response.body().as_ref(), output)
            .map_err(crate::error::GetBranchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCommentOutput, crate::error::GetCommentError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetCommentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCommentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => crate::error::GetCommentError {
            meta: generic,
            kind: crate::error::GetCommentErrorKind::CommentDeletedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_deleted_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentDoesNotExistException" => crate::error::GetCommentError {
            meta: generic,
            kind: crate::error::GetCommentErrorKind::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentIdRequiredException" => {
            crate::error::GetCommentError {
                meta: generic,
                kind: crate::error::GetCommentErrorKind::CommentIdRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::comment_id_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_comment_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommentError {
            meta: generic,
            kind: crate::error::GetCommentErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommentError {
            meta: generic,
            kind: crate::error::GetCommentErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetCommentError {
            meta: generic,
            kind: crate::error::GetCommentErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetCommentError {
            meta: generic,
            kind: crate::error::GetCommentErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetCommentError {
            meta: generic,
            kind: crate::error::GetCommentErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommentIdException" => {
            crate::error::GetCommentError {
                meta: generic,
                kind: crate::error::GetCommentErrorKind::InvalidCommentIdException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_comment_id_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_comment_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::GetCommentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCommentOutput, crate::error::GetCommentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_comment(response.body().as_ref(), output)
            .map_err(crate::error::GetCommentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_reactions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentReactionsOutput,
    crate::error::GetCommentReactionsError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetCommentReactionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCommentReactionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => crate::error::GetCommentReactionsError {
            meta: generic,
            kind: crate::error::GetCommentReactionsErrorKind::CommentDeletedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_deleted_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentDoesNotExistException" => crate::error::GetCommentReactionsError {
            meta: generic,
            kind: crate::error::GetCommentReactionsErrorKind::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentIdRequiredException" => {
            crate::error::GetCommentReactionsError {
                meta: generic,
                kind: crate::error::GetCommentReactionsErrorKind::CommentIdRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::comment_id_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_comment_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidCommentIdException" => {
            crate::error::GetCommentReactionsError {
                meta: generic,
                kind: crate::error::GetCommentReactionsErrorKind::InvalidCommentIdException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_comment_id_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_comment_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidContinuationTokenException" => crate::error::GetCommentReactionsError {
            meta: generic,
            kind: crate::error::GetCommentReactionsErrorKind::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidMaxResultsException" => {
            crate::error::GetCommentReactionsError {
                meta: generic,
                kind: crate::error::GetCommentReactionsErrorKind::InvalidMaxResultsException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_max_results_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_max_results_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidReactionUserArnException" => crate::error::GetCommentReactionsError {
            meta: generic,
            kind: crate::error::GetCommentReactionsErrorKind::InvalidReactionUserArnException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_reaction_user_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_reaction_user_arn_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetCommentReactionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_reactions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentReactionsOutput,
    crate::error::GetCommentReactionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comment_reactions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_comment_reactions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCommentReactionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_compared_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentsForComparedCommitOutput,
    crate::error::GetCommentsForComparedCommitError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetCommentsForComparedCommitError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_max_results_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetCommentsForComparedCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_compared_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentsForComparedCommitOutput,
    crate::error::GetCommentsForComparedCommitError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comments_for_compared_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_comments_for_compared_commit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_pull_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentsForPullRequestOutput,
    crate::error::GetCommentsForPullRequestError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetCommentsForPullRequestError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_max_results_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_not_associated_with_pull_request_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetCommentsForPullRequestError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_pull_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentsForPullRequestOutput,
    crate::error::GetCommentsForPullRequestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comments_for_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_comments_for_pull_request(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCommitOutput, crate::error::GetCommitError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetCommitError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCommitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitIdDoesNotExistException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::CommitIdDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_id_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_id_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommitIdRequiredException" => {
            crate::error::GetCommitError {
                meta: generic,
                kind: crate::error::GetCommitErrorKind::CommitIdRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::commit_id_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommitIdException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::InvalidCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetCommitError {
            meta: generic,
            kind: crate::error::GetCommitErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetCommitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCommitOutput, crate::error::GetCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_commit(response.body().as_ref(), output)
            .map_err(crate::error::GetCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_differences_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDifferencesOutput, crate::error::GetDifferencesError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetDifferencesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDifferencesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetDifferencesError {
                meta: generic,
                kind: crate::error::GetDifferencesErrorKind::CommitDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::commit_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommitRequiredException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::CommitRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionIntegrityChecksFailedException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommitException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::InvalidCommitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommitIdException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::InvalidCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidContinuationTokenException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidMaxResultsException" => {
            crate::error::GetDifferencesError {
                meta: generic,
                kind: crate::error::GetDifferencesErrorKind::InvalidMaxResultsException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_max_results_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_max_results_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidPathException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PathDoesNotExistException" => {
            crate::error::GetDifferencesError {
                meta: generic,
                kind: crate::error::GetDifferencesErrorKind::PathDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::path_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_path_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "RepositoryDoesNotExistException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetDifferencesError {
            meta: generic,
            kind: crate::error::GetDifferencesErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetDifferencesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_differences_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDifferencesOutput, crate::error::GetDifferencesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_differences_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_differences(response.body().as_ref(), output)
                .map_err(crate::error::GetDifferencesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_file_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFileOutput, crate::error::GetFileError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetFileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetFileError {
                meta: generic,
                kind: crate::error::GetFileErrorKind::CommitDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::commit_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FileDoesNotExistException" => {
            crate::error::GetFileError {
                meta: generic,
                kind: crate::error::GetFileErrorKind::FileDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::file_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "FileTooLargeException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::FileTooLargeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_too_large_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_too_large_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommitException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::InvalidCommitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPathException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PathRequiredException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::PathRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetFileError {
            meta: generic,
            kind: crate::error::GetFileErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetFileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_file_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFileOutput, crate::error::GetFileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_file_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_file(response.body().as_ref(), output)
            .map_err(crate::error::GetFileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFolderOutput, crate::error::GetFolderError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetFolderError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFolderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetFolderError {
                meta: generic,
                kind: crate::error::GetFolderErrorKind::CommitDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::commit_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FolderDoesNotExistException" => {
            crate::error::GetFolderError {
                meta: generic,
                kind: crate::error::GetFolderErrorKind::FolderDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::folder_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_folder_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidCommitException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::InvalidCommitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPathException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PathRequiredException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::PathRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetFolderError {
            meta: generic,
            kind: crate::error::GetFolderErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetFolderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFolderOutput, crate::error::GetFolderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_folder_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_folder(response.body().as_ref(), output)
            .map_err(crate::error::GetFolderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeCommitOutput, crate::error::GetMergeCommitError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetMergeCommitError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMergeCommitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetMergeCommitError {
                meta: generic,
                kind: crate::error::GetMergeCommitErrorKind::CommitDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::commit_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommitRequiredException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::CommitRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionIntegrityChecksFailedException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommitException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::InvalidCommitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidConflictDetailLevelException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::InvalidConflictDetailLevelException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidConflictResolutionStrategyException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::InvalidConflictResolutionStrategyException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "InvalidRepositoryNameException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetMergeCommitError {
            meta: generic,
            kind: crate::error::GetMergeCommitErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetMergeCommitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeCommitOutput, crate::error::GetMergeCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_merge_commit_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_merge_commit(response.body().as_ref(), output)
                .map_err(crate::error::GetMergeCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_conflicts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeConflictsOutput, crate::error::GetMergeConflictsError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetMergeConflictsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMergeConflictsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetMergeConflictsError {
                meta: generic,
                kind: crate::error::GetMergeConflictsErrorKind::CommitDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::commit_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommitRequiredException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::CommitRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionIntegrityChecksFailedException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind:
                crate::error::GetMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommitException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::InvalidCommitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidConflictDetailLevelException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::InvalidConflictDetailLevelException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidConflictResolutionStrategyException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind:
                crate::error::GetMergeConflictsErrorKind::InvalidConflictResolutionStrategyException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidContinuationTokenException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidDestinationCommitSpecifierException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind:
                crate::error::GetMergeConflictsErrorKind::InvalidDestinationCommitSpecifierException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_destination_commit_specifier_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_invalid_destination_commit_specifier_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidMaxConflictFilesException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::InvalidMaxConflictFilesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_max_conflict_files_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_max_conflict_files_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidMergeOptionException" => {
            crate::error::GetMergeConflictsError {
                meta: generic,
                kind: crate::error::GetMergeConflictsErrorKind::InvalidMergeOptionException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_merge_option_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_merge_option_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidRepositoryNameException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSourceCommitSpecifierException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::InvalidSourceCommitSpecifierException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::invalid_source_commit_specifier_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_source_commit_specifier_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "MaximumFileContentToLoadExceededException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind:
                crate::error::GetMergeConflictsErrorKind::MaximumFileContentToLoadExceededException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_maximum_file_content_to_load_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "MaximumItemsToCompareExceededException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::MaximumItemsToCompareExceededException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_maximum_items_to_compare_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "MergeOptionRequiredException" => {
            crate::error::GetMergeConflictsError {
                meta: generic,
                kind: crate::error::GetMergeConflictsErrorKind::MergeOptionRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::merge_option_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_merge_option_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "RepositoryDoesNotExistException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TipsDivergenceExceededException" => crate::error::GetMergeConflictsError {
            meta: generic,
            kind: crate::error::GetMergeConflictsErrorKind::TipsDivergenceExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetMergeConflictsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_conflicts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeConflictsOutput, crate::error::GetMergeConflictsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_merge_conflicts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_merge_conflicts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetMergeConflictsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeOptionsOutput, crate::error::GetMergeOptionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetMergeOptionsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMergeOptionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetMergeOptionsError {
                meta: generic,
                kind: crate::error::GetMergeOptionsErrorKind::CommitDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::commit_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommitRequiredException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::CommitRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionIntegrityChecksFailedException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommitException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::InvalidCommitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidConflictDetailLevelException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::InvalidConflictDetailLevelException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidConflictResolutionStrategyException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind:
                crate::error::GetMergeOptionsErrorKind::InvalidConflictResolutionStrategyException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidRepositoryNameException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "MaximumFileContentToLoadExceededException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::MaximumFileContentToLoadExceededException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_maximum_file_content_to_load_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "MaximumItemsToCompareExceededException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::MaximumItemsToCompareExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::maximum_items_to_compare_exceeded_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_items_to_compare_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TipsDivergenceExceededException" => crate::error::GetMergeOptionsError {
            meta: generic,
            kind: crate::error::GetMergeOptionsErrorKind::TipsDivergenceExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetMergeOptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeOptionsOutput, crate::error::GetMergeOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_merge_options_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_merge_options(response.body().as_ref(), output)
                .map_err(crate::error::GetMergeOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPullRequestOutput, crate::error::GetPullRequestError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetPullRequestError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPullRequestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetPullRequestError {
            meta: generic,
            kind: crate::error::GetPullRequestErrorKind::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetPullRequestError {
            meta: generic,
            kind: crate::error::GetPullRequestErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetPullRequestError {
            meta: generic,
            kind: crate::error::GetPullRequestErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetPullRequestError {
            meta: generic,
            kind: crate::error::GetPullRequestErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetPullRequestError {
            meta: generic,
            kind: crate::error::GetPullRequestErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPullRequestIdException" => crate::error::GetPullRequestError {
            meta: generic,
            kind: crate::error::GetPullRequestErrorKind::InvalidPullRequestIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PullRequestDoesNotExistException" => crate::error::GetPullRequestError {
            meta: generic,
            kind: crate::error::GetPullRequestErrorKind::PullRequestDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PullRequestIdRequiredException" => crate::error::GetPullRequestError {
            meta: generic,
            kind: crate::error::GetPullRequestErrorKind::PullRequestIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetPullRequestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPullRequestOutput, crate::error::GetPullRequestError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_pull_request_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_pull_request(response.body().as_ref(), output)
                .map_err(crate::error::GetPullRequestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_approval_states_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPullRequestApprovalStatesOutput,
    crate::error::GetPullRequestApprovalStatesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetPullRequestApprovalStatesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_revision_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_revision_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetPullRequestApprovalStatesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_approval_states_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPullRequestApprovalStatesOutput,
    crate::error::GetPullRequestApprovalStatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_pull_request_approval_states_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_pull_request_approval_states(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_override_state_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPullRequestOverrideStateOutput,
    crate::error::GetPullRequestOverrideStateError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetPullRequestOverrideStateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_revision_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_revision_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetPullRequestOverrideStateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_override_state_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPullRequestOverrideStateOutput,
    crate::error::GetPullRequestOverrideStateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_pull_request_override_state_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_pull_request_override_state(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRepositoryOutput, crate::error::GetRepositoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetRepositoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRepositoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetRepositoryError {
            meta: generic,
            kind: crate::error::GetRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::GetRepositoryError {
            meta: generic,
            kind: crate::error::GetRepositoryErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::GetRepositoryError {
            meta: generic,
            kind: crate::error::GetRepositoryErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::GetRepositoryError {
            meta: generic,
            kind: crate::error::GetRepositoryErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::GetRepositoryError {
            meta: generic,
            kind: crate::error::GetRepositoryErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::GetRepositoryError {
            meta: generic,
            kind: crate::error::GetRepositoryErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::GetRepositoryError {
            meta: generic,
            kind: crate::error::GetRepositoryErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::GetRepositoryError {
            meta: generic,
            kind: crate::error::GetRepositoryErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::GetRepositoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRepositoryOutput, crate::error::GetRepositoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_repository_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_get_repository(response.body().as_ref(), output)
                .map_err(crate::error::GetRepositoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_triggers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRepositoryTriggersOutput,
    crate::error::GetRepositoryTriggersError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRepositoryTriggersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetRepositoryTriggersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_triggers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRepositoryTriggersOutput,
    crate::error::GetRepositoryTriggersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_repository_triggers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_get_repository_triggers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_approval_rule_templates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListApprovalRuleTemplatesOutput,
    crate::error::ListApprovalRuleTemplatesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListApprovalRuleTemplatesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidContinuationTokenException" => crate::error::ListApprovalRuleTemplatesError {
            meta: generic,
            kind:
                crate::error::ListApprovalRuleTemplatesErrorKind::InvalidContinuationTokenException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "InvalidMaxResultsException" => {
            crate::error::ListApprovalRuleTemplatesError {
                meta: generic,
                kind: crate::error::ListApprovalRuleTemplatesErrorKind::InvalidMaxResultsException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]
                            let mut output =
                                crate::error::invalid_max_results_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_invalid_max_results_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
            }
        }
        _ => crate::error::ListApprovalRuleTemplatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_approval_rule_templates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListApprovalRuleTemplatesOutput,
    crate::error::ListApprovalRuleTemplatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_approval_rule_templates_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_approval_rule_templates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associated_approval_rule_templates_for_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAssociatedApprovalRuleTemplatesForRepositoryOutput,
    crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_max_results_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associated_approval_rule_templates_for_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAssociatedApprovalRuleTemplatesForRepositoryOutput,
    crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]let mut output = crate::output::list_associated_approval_rule_templates_for_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_associated_approval_rule_templates_for_repository(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_branches_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListBranchesOutput, crate::error::ListBranchesError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListBranchesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListBranchesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::ListBranchesError {
            meta: generic,
            kind: crate::error::ListBranchesErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::ListBranchesError {
            meta: generic,
            kind: crate::error::ListBranchesErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::ListBranchesError {
            meta: generic,
            kind: crate::error::ListBranchesErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::ListBranchesError {
            meta: generic,
            kind: crate::error::ListBranchesErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::ListBranchesError {
            meta: generic,
            kind: crate::error::ListBranchesErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidContinuationTokenException" => crate::error::ListBranchesError {
            meta: generic,
            kind: crate::error::ListBranchesErrorKind::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::ListBranchesError {
            meta: generic,
            kind: crate::error::ListBranchesErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::ListBranchesError {
            meta: generic,
            kind: crate::error::ListBranchesErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::ListBranchesError {
            meta: generic,
            kind: crate::error::ListBranchesErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListBranchesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_branches_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListBranchesOutput, crate::error::ListBranchesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_branches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_branches(response.body().as_ref(), output)
            .map_err(crate::error::ListBranchesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pull_requests_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPullRequestsOutput, crate::error::ListPullRequestsError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListPullRequestsError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListPullRequestsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorDoesNotExistException" => {
            crate::error::ListPullRequestsError {
                meta: generic,
                kind: crate::error::ListPullRequestsErrorKind::AuthorDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::author_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_author_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidAuthorArnException" => {
            crate::error::ListPullRequestsError {
                meta: generic,
                kind: crate::error::ListPullRequestsErrorKind::InvalidAuthorArnException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_author_arn_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_author_arn_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidContinuationTokenException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidMaxResultsException" => {
            crate::error::ListPullRequestsError {
                meta: generic,
                kind: crate::error::ListPullRequestsErrorKind::InvalidMaxResultsException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_max_results_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_max_results_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidPullRequestStatusException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::InvalidPullRequestStatusException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_status_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::ListPullRequestsError {
            meta: generic,
            kind: crate::error::ListPullRequestsErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListPullRequestsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pull_requests_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPullRequestsOutput, crate::error::ListPullRequestsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_pull_requests_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_pull_requests(response.body().as_ref(), output)
                .map_err(crate::error::ListPullRequestsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRepositoriesOutput, crate::error::ListRepositoriesError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListRepositoriesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRepositoriesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidContinuationTokenException" => crate::error::ListRepositoriesError {
            meta: generic,
            kind: crate::error::ListRepositoriesErrorKind::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidOrderException" => crate::error::ListRepositoriesError {
            meta: generic,
            kind: crate::error::ListRepositoriesErrorKind::InvalidOrderException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_order_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_order_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRepositoriesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidSortByException" => crate::error::ListRepositoriesError {
            meta: generic,
            kind: crate::error::ListRepositoriesErrorKind::InvalidSortByException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_sort_by_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_sort_by_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::ListRepositoriesError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::ListRepositoriesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRepositoriesOutput, crate::error::ListRepositoriesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_repositories_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_list_repositories(response.body().as_ref(), output)
                .map_err(crate::error::ListRepositoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_for_approval_rule_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRepositoriesForApprovalRuleTemplateOutput,
    crate::error::ListRepositoriesForApprovalRuleTemplateError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_continuation_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_max_results_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListRepositoriesForApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_for_approval_rule_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRepositoriesForApprovalRuleTemplateOutput,
    crate::error::ListRepositoriesForApprovalRuleTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_repositories_for_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_repositories_for_approval_rule_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceArnException" => {
            crate::error::ListTagsForResourceError {
                meta: generic,
                kind: crate::error::ListTagsForResourceErrorKind::InvalidResourceArnException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_resource_arn_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_resource_arn_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "RepositoryDoesNotExistException" => crate::error::ListTagsForResourceError {
            meta: generic,
            kind: crate::error::ListTagsForResourceErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceArnRequiredException" => {
            crate::error::ListTagsForResourceError {
                meta: generic,
                kind: crate::error::ListTagsForResourceErrorKind::ResourceArnRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_arn_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_arn_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_fast_forward_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesByFastForwardOutput,
    crate::error::MergeBranchesByFastForwardError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergeBranchesByFastForwardError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameIsTagNameException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::BranchNameIsTagNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_name_is_tag_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::CommitRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_reference_update_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::InvalidCommitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTargetBranchException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::InvalidTargetBranchException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_target_branch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_target_branch_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_manual_merge_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergeBranchesByFastForwardError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_fast_forward_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesByFastForwardOutput,
    crate::error::MergeBranchesByFastForwardError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_branches_by_fast_forward_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_merge_branches_by_fast_forward(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_squash_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesBySquashOutput,
    crate::error::MergeBranchesBySquashError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::MergeBranchesBySquashError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameIsTagNameException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::BranchNameIsTagNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_name_is_tag_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitMessageLengthExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_message_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::CommitRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_reference_update_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileModeRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::FileModeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_mode_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_folder_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidCommitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidEmailException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_email_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_file_mode_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidPathException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_content_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_type_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTargetBranchException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidTargetBranchException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_target_branch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_target_branch_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_manual_merge_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_conflict_resolution_entries_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_file_content_to_load_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_items_to_compare_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_multiple_conflict_resolution_entries_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_name_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::PathRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_type_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergeBranchesBySquashError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_squash_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesBySquashOutput,
    crate::error::MergeBranchesBySquashError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_branches_by_squash_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_merge_branches_by_squash(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_three_way_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesByThreeWayOutput,
    crate::error::MergeBranchesByThreeWayError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergeBranchesByThreeWayError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameIsTagNameException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::BranchNameIsTagNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_name_is_tag_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitMessageLengthExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_message_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::CommitRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_reference_update_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileModeRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::FileModeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_mode_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_folder_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidCommitException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidEmailException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_email_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_file_mode_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidPathException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_content_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_type_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTargetBranchException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidTargetBranchException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_target_branch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_target_branch_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_manual_merge_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_conflict_resolution_entries_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_file_content_to_load_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_items_to_compare_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_multiple_conflict_resolution_entries_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_name_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::PathRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_type_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergeBranchesByThreeWayError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_three_way_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesByThreeWayOutput,
    crate::error::MergeBranchesByThreeWayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_branches_by_three_way_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_merge_branches_by_three_way(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_fast_forward_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestByFastForwardOutput,
    crate::error::MergePullRequestByFastForwardError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergePullRequestByFastForwardError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentReferenceUpdateException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_reference_update_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_manual_merge_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestApprovalRulesNotSatisfiedException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::PullRequestApprovalRulesNotSatisfiedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_approval_rules_not_satisfied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReferenceDoesNotExistException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::ReferenceDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::reference_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_reference_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_not_associated_with_pull_request_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipOfSourceReferenceIsDifferentException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::TipOfSourceReferenceIsDifferentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tip_of_source_reference_is_different_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tip_of_source_reference_is_different_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergePullRequestByFastForwardError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_fast_forward_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestByFastForwardOutput,
    crate::error::MergePullRequestByFastForwardError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::merge_pull_request_by_fast_forward_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_merge_pull_request_by_fast_forward(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_squash_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestBySquashOutput,
    crate::error::MergePullRequestBySquashError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergePullRequestBySquashError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitMessageLengthExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_message_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_reference_update_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_folder_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidEmailException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_email_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_file_mode_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidPathException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_content_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_type_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_manual_merge_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_conflict_resolution_entries_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_file_content_to_load_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_items_to_compare_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_multiple_conflict_resolution_entries_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_name_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PathRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestApprovalRulesNotSatisfiedException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PullRequestApprovalRulesNotSatisfiedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_approval_rules_not_satisfied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_type_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_not_associated_with_pull_request_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipOfSourceReferenceIsDifferentException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::TipOfSourceReferenceIsDifferentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tip_of_source_reference_is_different_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tip_of_source_reference_is_different_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergePullRequestBySquashError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_squash_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestBySquashOutput,
    crate::error::MergePullRequestBySquashError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_pull_request_by_squash_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_merge_pull_request_by_squash(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_three_way_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestByThreeWayOutput,
    crate::error::MergePullRequestByThreeWayError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergePullRequestByThreeWayError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitMessageLengthExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_message_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_concurrent_reference_update_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_folder_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_detail_level_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_conflict_resolution_strategy_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidEmailException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_email_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_file_mode_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidPathException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_content_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_replacement_type_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_manual_merge_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_conflict_resolution_entries_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_file_content_to_load_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_items_to_compare_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_multiple_conflict_resolution_entries_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_name_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PathRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestApprovalRulesNotSatisfiedException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PullRequestApprovalRulesNotSatisfiedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_approval_rules_not_satisfied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_replacement_type_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_not_associated_with_pull_request_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipOfSourceReferenceIsDifferentException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::TipOfSourceReferenceIsDifferentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tip_of_source_reference_is_different_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tip_of_source_reference_is_different_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tips_divergence_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergePullRequestByThreeWayError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_three_way_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestByThreeWayOutput,
    crate::error::MergePullRequestByThreeWayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_pull_request_by_three_way_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_merge_pull_request_by_three_way(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_override_pull_request_approval_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::OverridePullRequestApprovalRulesOutput,
    crate::error::OverridePullRequestApprovalRulesError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::OverridePullRequestApprovalRulesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidOverrideStatusException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::InvalidOverrideStatusException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_override_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_override_status_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_revision_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OverrideAlreadySetException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::OverrideAlreadySetException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::override_already_set_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_override_already_set_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OverrideStatusRequiredException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::OverrideStatusRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::override_status_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_override_status_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_revision_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionNotCurrentException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::RevisionNotCurrentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::revision_not_current_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_revision_not_current_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::OverridePullRequestApprovalRulesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_override_pull_request_approval_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::OverridePullRequestApprovalRulesOutput,
    crate::error::OverridePullRequestApprovalRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::override_pull_request_approval_rules_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_compared_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PostCommentForComparedCommitOutput,
    crate::error::PostCommentForComparedCommitError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PostCommentForComparedCommitError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BeforeCommitIdAndAfterCommitIdAreSameException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_before_commit_id_and_after_commit_id_are_same_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClientRequestTokenRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::ClientRequestTokenRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_client_request_token_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::CommentContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentSizeLimitExceededException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::CommentContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotencyParameterMismatchException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::IdempotencyParameterMismatchException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_idempotency_parameter_mismatch_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClientRequestTokenException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidClientRequestTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_client_request_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileLocationException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidFileLocationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_file_location_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_file_location_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFilePositionException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidFilePositionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_file_position_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_file_position_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidPathException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRelativeFileVersionEnumException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidRelativeFileVersionEnumException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_relative_file_version_enum_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_relative_file_version_enum_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathDoesNotExistException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::PathDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::PathRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PostCommentForComparedCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_compared_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PostCommentForComparedCommitOutput,
    crate::error::PostCommentForComparedCommitError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::post_comment_for_compared_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_post_comment_for_compared_commit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_pull_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PostCommentForPullRequestOutput,
    crate::error::PostCommentForPullRequestError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PostCommentForPullRequestError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BeforeCommitIdAndAfterCommitIdAreSameException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_before_commit_id_and_after_commit_id_are_same_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClientRequestTokenRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::ClientRequestTokenRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_client_request_token_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::CommentContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentSizeLimitExceededException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::CommentContentSizeLimitExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_commit_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotencyParameterMismatchException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::IdempotencyParameterMismatchException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_idempotency_parameter_mismatch_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClientRequestTokenException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidClientRequestTokenException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_client_request_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileLocationException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidFileLocationException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_file_location_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_file_location_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFilePositionException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidFilePositionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_file_position_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_file_position_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidPathException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRelativeFileVersionEnumException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidRelativeFileVersionEnumException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_relative_file_version_enum_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_relative_file_version_enum_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathDoesNotExistException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::PathDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::PathRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_not_associated_with_pull_request_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PostCommentForPullRequestError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_pull_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PostCommentForPullRequestOutput,
    crate::error::PostCommentForPullRequestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::post_comment_for_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_post_comment_for_pull_request(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_reply_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PostCommentReplyOutput, crate::error::PostCommentReplyError>
{
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PostCommentReplyError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PostCommentReplyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClientRequestTokenRequiredException" => crate::error::PostCommentReplyError {
            meta: generic,
            kind: crate::error::PostCommentReplyErrorKind::ClientRequestTokenRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_client_request_token_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentContentRequiredException" => crate::error::PostCommentReplyError {
            meta: generic,
            kind: crate::error::PostCommentReplyErrorKind::CommentContentRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentContentSizeLimitExceededException" => crate::error::PostCommentReplyError {
            meta: generic,
            kind: crate::error::PostCommentReplyErrorKind::CommentContentSizeLimitExceededException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_comment_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "CommentDoesNotExistException" => crate::error::PostCommentReplyError {
            meta: generic,
            kind: crate::error::PostCommentReplyErrorKind::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentIdRequiredException" => {
            crate::error::PostCommentReplyError {
                meta: generic,
                kind: crate::error::PostCommentReplyErrorKind::CommentIdRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::comment_id_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_comment_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "IdempotencyParameterMismatchException" => crate::error::PostCommentReplyError {
            meta: generic,
            kind: crate::error::PostCommentReplyErrorKind::IdempotencyParameterMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_idempotency_parameter_mismatch_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidClientRequestTokenException" => crate::error::PostCommentReplyError {
            meta: generic,
            kind: crate::error::PostCommentReplyErrorKind::InvalidClientRequestTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_client_request_token_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommentIdException" => {
            crate::error::PostCommentReplyError {
                meta: generic,
                kind: crate::error::PostCommentReplyErrorKind::InvalidCommentIdException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_comment_id_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_comment_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::PostCommentReplyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_reply_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PostCommentReplyOutput, crate::error::PostCommentReplyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::post_comment_reply_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_post_comment_reply(response.body().as_ref(), output)
                .map_err(crate::error::PostCommentReplyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_comment_reaction_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutCommentReactionOutput,
    crate::error::PutCommentReactionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutCommentReactionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutCommentReactionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => crate::error::PutCommentReactionError {
            meta: generic,
            kind: crate::error::PutCommentReactionErrorKind::CommentDeletedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_deleted_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentDoesNotExistException" => crate::error::PutCommentReactionError {
            meta: generic,
            kind: crate::error::PutCommentReactionErrorKind::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentIdRequiredException" => {
            crate::error::PutCommentReactionError {
                meta: generic,
                kind: crate::error::PutCommentReactionErrorKind::CommentIdRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::comment_id_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_comment_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidCommentIdException" => {
            crate::error::PutCommentReactionError {
                meta: generic,
                kind: crate::error::PutCommentReactionErrorKind::InvalidCommentIdException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_comment_id_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_comment_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidReactionValueException" => crate::error::PutCommentReactionError {
            meta: generic,
            kind: crate::error::PutCommentReactionErrorKind::InvalidReactionValueException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_reaction_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_reaction_value_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ReactionLimitExceededException" => crate::error::PutCommentReactionError {
            meta: generic,
            kind: crate::error::PutCommentReactionErrorKind::ReactionLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reaction_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_reaction_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ReactionValueRequiredException" => crate::error::PutCommentReactionError {
            meta: generic,
            kind: crate::error::PutCommentReactionErrorKind::ReactionValueRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reaction_value_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_reaction_value_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutCommentReactionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_comment_reaction_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutCommentReactionOutput,
    crate::error::PutCommentReactionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_comment_reaction_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_file_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutFileOutput, crate::error::PutFileError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutFileError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutFileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::PutFileError {
                meta: generic,
                kind: crate::error::PutFileErrorKind::BranchDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "BranchNameIsTagNameException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::BranchNameIsTagNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_branch_name_is_tag_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "BranchNameRequiredException" => {
            crate::error::PutFileError {
                meta: generic,
                kind: crate::error::PutFileErrorKind::BranchNameRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_name_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommitMessageLengthExceededException" => {
            crate::error::PutFileError {
                meta: generic,
                kind: crate::error::PutFileErrorKind::CommitMessageLengthExceededException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_commit_message_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "DirectoryNameConflictsWithFileNameException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::DirectoryNameConflictsWithFileNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::directory_name_conflicts_with_file_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_directory_name_conflicts_with_file_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionIntegrityChecksFailedException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FileContentRequiredException" => {
            crate::error::PutFileError {
                meta: generic,
                kind: crate::error::PutFileErrorKind::FileContentRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::file_content_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "FileContentSizeLimitExceededException" => {
            crate::error::PutFileError {
                meta: generic,
                kind: crate::error::PutFileErrorKind::FileContentSizeLimitExceededException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_file_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "FileNameConflictsWithDirectoryNameException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::FileNameConflictsWithDirectoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::file_name_conflicts_with_directory_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_name_conflicts_with_directory_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FilePathConflictsWithSubmodulePathException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::FilePathConflictsWithSubmodulePathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::file_path_conflicts_with_submodule_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_file_path_conflicts_with_submodule_path_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "FolderContentSizeLimitExceededException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::FolderContentSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_folder_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidBranchNameException" => {
            crate::error::PutFileError {
                meta: generic,
                kind: crate::error::PutFileErrorKind::InvalidBranchNameException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_branch_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidDeletionParameterException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::InvalidDeletionParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_deletion_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_deletion_parameter_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidEmailException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::InvalidEmailException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_email_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidFileModeException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::InvalidFileModeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_invalid_file_mode_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidParentCommitIdException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::InvalidParentCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parent_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_parent_commit_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidPathException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_path_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidRepositoryNameException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "NameLengthExceededException" => {
            crate::error::PutFileError {
                meta: generic,
                kind: crate::error::PutFileErrorKind::NameLengthExceededException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::name_length_exceeded_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_name_length_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "ParentCommitDoesNotExistException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::ParentCommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_parent_commit_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParentCommitIdOutdatedException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::ParentCommitIdOutdatedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_outdated_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_parent_commit_id_outdated_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ParentCommitIdRequiredException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::ParentCommitIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_parent_commit_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PathRequiredException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::PathRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_path_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "SameFileContentException" => crate::error::PutFileError {
            meta: generic,
            kind: crate::error::PutFileErrorKind::SameFileContentException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::same_file_content_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_same_file_content_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::PutFileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_file_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutFileOutput, crate::error::PutFileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_file_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_put_file(response.body().as_ref(), output)
            .map_err(crate::error::PutFileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_repository_triggers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRepositoryTriggersOutput,
    crate::error::PutRepositoryTriggersError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutRepositoryTriggersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerBranchNameException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerCustomDataException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_custom_data_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_custom_data_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerDestinationArnException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_destination_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_destination_arn_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerEventsException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_events_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_events_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerNameException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerRegionException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_region_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumBranchesExceededException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::MaximumBranchesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_branches_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_branches_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryTriggersExceededException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_repository_triggers_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_repository_triggers_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerBranchNameListRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_trigger_branch_name_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_trigger_branch_name_list_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerDestinationArnRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_trigger_destination_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_trigger_destination_arn_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerEventsListRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_trigger_events_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_trigger_events_list_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerNameRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_trigger_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_trigger_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggersListRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_triggers_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_triggers_list_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutRepositoryTriggersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_repository_triggers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRepositoryTriggersOutput,
    crate::error::PutRepositoryTriggersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_repository_triggers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_put_repository_triggers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceArnException" => {
            crate::error::TagResourceError {
                meta: generic,
                kind: crate::error::TagResourceErrorKind::InvalidResourceArnException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_resource_arn_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_resource_arn_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidSystemTagUsageException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::InvalidSystemTagUsageException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_system_tag_usage_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_system_tag_usage_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTagsMapException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::InvalidTagsMapException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_tags_map_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_tags_map_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceArnRequiredException" => {
            crate::error::TagResourceError {
                meta: generic,
                kind: crate::error::TagResourceErrorKind::ResourceArnRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_arn_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_arn_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TagPolicyException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TagPolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tag_policy_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagsMapRequiredException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TagsMapRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tags_map_required_exception::Builder::default();
                    let _ = response;
                    output =
                        crate::json_deser::deser_structure_tags_map_required_exceptionjson_err(
                            response.body().as_ref(),
                            output,
                        )
                        .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyTagsException" => crate::error::TagResourceError {
            meta: generic,
            kind: crate::error::TagResourceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_repository_triggers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestRepositoryTriggersOutput,
    crate::error::TestRepositoryTriggersError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::TestRepositoryTriggersError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerBranchNameException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerCustomDataException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_custom_data_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_custom_data_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerDestinationArnException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_destination_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_destination_arn_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerEventsException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_events_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_events_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerNameException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerRegionException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_trigger_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_trigger_region_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumBranchesExceededException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::MaximumBranchesExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_branches_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_branches_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryTriggersExceededException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_repository_triggers_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_repository_triggers_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerBranchNameListRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_trigger_branch_name_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_trigger_branch_name_list_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerDestinationArnRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_trigger_destination_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_trigger_destination_arn_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerEventsListRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_trigger_events_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_trigger_events_list_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerNameRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_trigger_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_trigger_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggersListRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_triggers_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_triggers_list_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::TestRepositoryTriggersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_repository_triggers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestRepositoryTriggersOutput,
    crate::error::TestRepositoryTriggersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_repository_triggers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_test_repository_triggers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidResourceArnException" => {
            crate::error::UntagResourceError {
                meta: generic,
                kind: crate::error::UntagResourceErrorKind::InvalidResourceArnException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_resource_arn_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_resource_arn_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidSystemTagUsageException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::InvalidSystemTagUsageException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_system_tag_usage_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_system_tag_usage_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTagKeysListException" => {
            crate::error::UntagResourceError {
                meta: generic,
                kind: crate::error::UntagResourceErrorKind::InvalidTagKeysListException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_tag_keys_list_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_tag_keys_list_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "RepositoryDoesNotExistException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "ResourceArnRequiredException" => {
            crate::error::UntagResourceError {
                meta: generic,
                kind: crate::error::UntagResourceErrorKind::ResourceArnRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::resource_arn_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_resource_arn_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "TagKeysListRequiredException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::TagKeysListRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::tag_keys_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tag_keys_list_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TagPolicyException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::TagPolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_tag_policy_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TooManyTagsException" => crate::error::UntagResourceError {
            meta: generic,
            kind: crate::error::UntagResourceErrorKind::TooManyTagsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_too_many_tags_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateContentOutput,
    crate::error::UpdateApprovalRuleTemplateContentError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateContentRequiredException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateContentException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_content_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRuleContentSha256Exception" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::InvalidRuleContentSha256Exception({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_rule_content_sha256_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_rule_content_sha256_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateApprovalRuleTemplateContentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateContentOutput,
    crate::error::UpdateApprovalRuleTemplateContentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_approval_rule_template_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_approval_rule_template_content(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_description_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateDescriptionOutput,
    crate::error::UpdateApprovalRuleTemplateDescriptionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::UpdateApprovalRuleTemplateDescriptionError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::UpdateApprovalRuleTemplateDescriptionError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateDescriptionException" => crate::error::UpdateApprovalRuleTemplateDescriptionError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateDescriptionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_description_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::UpdateApprovalRuleTemplateDescriptionError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateApprovalRuleTemplateDescriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_description_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateDescriptionOutput,
    crate::error::UpdateApprovalRuleTemplateDescriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_approval_rule_template_description_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_approval_rule_template_description(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_name_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateNameOutput,
    crate::error::UpdateApprovalRuleTemplateNameError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::UpdateApprovalRuleTemplateNameError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameAlreadyExistsException" => crate::error::UpdateApprovalRuleTemplateNameError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameAlreadyExistsException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_already_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::UpdateApprovalRuleTemplateNameError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_template_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::UpdateApprovalRuleTemplateNameError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateNameErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_template_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateApprovalRuleTemplateNameError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_name_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateNameOutput,
    crate::error::UpdateApprovalRuleTemplateNameError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_approval_rule_template_name_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_approval_rule_template_name(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_comment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateCommentOutput, crate::error::UpdateCommentError> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateCommentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateCommentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentContentRequiredException" => crate::error::UpdateCommentError {
            meta: generic,
            kind: crate::error::UpdateCommentErrorKind::CommentContentRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentContentSizeLimitExceededException" => crate::error::UpdateCommentError {
            meta: generic,
            kind: crate::error::UpdateCommentErrorKind::CommentContentSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_content_size_limit_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentDeletedException" => crate::error::UpdateCommentError {
            meta: generic,
            kind: crate::error::UpdateCommentErrorKind::CommentDeletedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_deleted_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentDoesNotExistException" => crate::error::UpdateCommentError {
            meta: generic,
            kind: crate::error::UpdateCommentErrorKind::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "CommentIdRequiredException" => {
            crate::error::UpdateCommentError {
                meta: generic,
                kind: crate::error::UpdateCommentErrorKind::CommentIdRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::comment_id_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_comment_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "CommentNotCreatedByCallerException" => crate::error::UpdateCommentError {
            meta: generic,
            kind: crate::error::UpdateCommentErrorKind::CommentNotCreatedByCallerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_not_created_by_caller_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_comment_not_created_by_caller_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidCommentIdException" => {
            crate::error::UpdateCommentError {
                meta: generic,
                kind: crate::error::UpdateCommentErrorKind::InvalidCommentIdException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_comment_id_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_comment_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        _ => crate::error::UpdateCommentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_comment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateCommentOutput, crate::error::UpdateCommentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_comment_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_update_comment(response.body().as_ref(), output)
                .map_err(crate::error::UpdateCommentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_default_branch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDefaultBranchOutput,
    crate::error::UpdateDefaultBranchError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDefaultBranchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::UpdateDefaultBranchError {
                meta: generic,
                kind: crate::error::UpdateDefaultBranchErrorKind::BranchDoesNotExistException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "BranchNameRequiredException" => {
            crate::error::UpdateDefaultBranchError {
                meta: generic,
                kind: crate::error::UpdateDefaultBranchErrorKind::BranchNameRequiredException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::branch_name_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_branch_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdateDefaultBranchError {
            meta: generic,
            kind:
                crate::error::UpdateDefaultBranchErrorKind::EncryptionIntegrityChecksFailedException(
                    {
                        #[allow(unused_mut)]
                        let mut tmp = {
                            #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                            let _ = response;
                            output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                            output.build()
                        };
                        if (&tmp.message).is_none() {
                            tmp.message = _error_message;
                        }
                        tmp
                    },
                ),
        },
        "EncryptionKeyAccessDeniedException" => crate::error::UpdateDefaultBranchError {
            meta: generic,
            kind: crate::error::UpdateDefaultBranchErrorKind::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyDisabledException" => crate::error::UpdateDefaultBranchError {
            meta: generic,
            kind: crate::error::UpdateDefaultBranchErrorKind::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyNotFoundException" => crate::error::UpdateDefaultBranchError {
            meta: generic,
            kind: crate::error::UpdateDefaultBranchErrorKind::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "EncryptionKeyUnavailableException" => crate::error::UpdateDefaultBranchError {
            meta: generic,
            kind: crate::error::UpdateDefaultBranchErrorKind::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidBranchNameException" => {
            crate::error::UpdateDefaultBranchError {
                meta: generic,
                kind: crate::error::UpdateDefaultBranchErrorKind::InvalidBranchNameException({
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::invalid_branch_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_invalid_branch_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                }),
            }
        }
        "InvalidRepositoryNameException" => crate::error::UpdateDefaultBranchError {
            meta: generic,
            kind: crate::error::UpdateDefaultBranchErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::UpdateDefaultBranchError {
            meta: generic,
            kind: crate::error::UpdateDefaultBranchErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::UpdateDefaultBranchError {
            meta: generic,
            kind: crate::error::UpdateDefaultBranchErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateDefaultBranchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_default_branch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDefaultBranchOutput,
    crate::error::UpdateDefaultBranchError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_default_branch_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_rule_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestApprovalRuleContentOutput,
    crate::error::UpdatePullRequestApprovalRuleContentError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleContentRequiredException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleContentRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_content_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleDoesNotExistException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleNameRequiredException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_rule_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_rule_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CannotModifyApprovalRuleFromTemplateException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::CannotModifyApprovalRuleFromTemplateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::cannot_modify_approval_rule_from_template_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_cannot_modify_approval_rule_from_template_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleContentException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleContentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_content_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleNameException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_rule_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_rule_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRuleContentSha256Exception" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::InvalidRuleContentSha256Exception({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_rule_content_sha256_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_rule_content_sha256_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdatePullRequestApprovalRuleContentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_rule_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestApprovalRuleContentOutput,
    crate::error::UpdatePullRequestApprovalRuleContentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_pull_request_approval_rule_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_pull_request_approval_rule_content(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_state_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestApprovalStateOutput,
    crate::error::UpdatePullRequestApprovalStateError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdatePullRequestApprovalStateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalStateRequiredException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::ApprovalStateRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::approval_state_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_approval_state_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalStateException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::InvalidApprovalStateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_approval_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_approval_state_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_revision_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumNumberOfApprovalsExceededException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::MaximumNumberOfApprovalsExceededException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::maximum_number_of_approvals_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_maximum_number_of_approvals_exceeded_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestCannotBeApprovedByAuthorException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::PullRequestCannotBeApprovedByAuthorException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_cannot_be_approved_by_author_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_cannot_be_approved_by_author_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_revision_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionNotCurrentException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::RevisionNotCurrentException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::revision_not_current_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_revision_not_current_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdatePullRequestApprovalStateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_state_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestApprovalStateOutput,
    crate::error::UpdatePullRequestApprovalStateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_pull_request_approval_state_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_description_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestDescriptionOutput,
    crate::error::UpdatePullRequestDescriptionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdatePullRequestDescriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDescriptionException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::InvalidDescriptionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_description_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdatePullRequestDescriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_description_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestDescriptionOutput,
    crate::error::UpdatePullRequestDescriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_description_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_pull_request_description(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestStatusOutput,
    crate::error::UpdatePullRequestStatusError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdatePullRequestStatusError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestStatusException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_status_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestStatusUpdateException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusUpdateException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_pull_request_status_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_status_update_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestStatusRequiredException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::PullRequestStatusRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::pull_request_status_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_status_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdatePullRequestStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestStatusOutput,
    crate::error::UpdatePullRequestStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_pull_request_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_title_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestTitleOutput,
    crate::error::UpdatePullRequestTitleError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdatePullRequestTitleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestTitleError {
            meta: generic,
            kind: crate::error::UpdatePullRequestTitleErrorKind::InvalidPullRequestIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_pull_request_id_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "InvalidTitleException" => crate::error::UpdatePullRequestTitleError {
            meta: generic,
            kind: crate::error::UpdatePullRequestTitleErrorKind::InvalidTitleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_title_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_title_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestTitleError {
            meta: generic,
            kind: crate::error::UpdatePullRequestTitleErrorKind::PullRequestAlreadyClosedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::pull_request_already_closed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_pull_request_already_closed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestTitleError {
            meta: generic,
            kind: crate::error::UpdatePullRequestTitleErrorKind::PullRequestDoesNotExistException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                        let mut output =
                            crate::error::pull_request_does_not_exist_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_pull_request_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                        output.build()
                    };
                    if (&tmp.message).is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            ),
        },
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestTitleError {
            meta: generic,
            kind: crate::error::UpdatePullRequestTitleErrorKind::PullRequestIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_pull_request_id_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "TitleRequiredException" => crate::error::UpdatePullRequestTitleError {
            meta: generic,
            kind: crate::error::UpdatePullRequestTitleErrorKind::TitleRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::title_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_title_required_exceptionjson_err(
                        response.body().as_ref(),
                        output,
                    )
                    .map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdatePullRequestTitleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_title_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestTitleOutput,
    crate::error::UpdatePullRequestTitleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_title_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_update_pull_request_title(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_description_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRepositoryDescriptionOutput,
    crate::error::UpdateRepositoryDescriptionError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateRepositoryDescriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_integrity_checks_failed_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_access_denied_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_disabled_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_not_found_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_encryption_key_unavailable_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryDescriptionException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::InvalidRepositoryDescriptionException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_description_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]let mut tmp =
                 {
                    #[allow(unused_mut)]let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if (&tmp.message).is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateRepositoryDescriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_description_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRepositoryDescriptionOutput,
    crate::error::UpdateRepositoryDescriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_repository_description_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_name_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRepositoryNameOutput,
    crate::error::UpdateRepositoryNameError,
> {
    let generic = crate::json_deser::parse_http_generic_error(response)
        .map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateRepositoryNameError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => crate::error::UpdateRepositoryNameError {
            meta: generic,
            kind: crate::error::UpdateRepositoryNameErrorKind::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_invalid_repository_name_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryDoesNotExistException" => crate::error::UpdateRepositoryNameError {
            meta: generic,
            kind: crate::error::UpdateRepositoryNameErrorKind::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_does_not_exist_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameExistsException" => crate::error::UpdateRepositoryNameError {
            meta: generic,
            kind: crate::error::UpdateRepositoryNameErrorKind::RepositoryNameExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_exists_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        "RepositoryNameRequiredException" => crate::error::UpdateRepositoryNameError {
            meta: generic,
            kind: crate::error::UpdateRepositoryNameErrorKind::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_repository_name_required_exceptionjson_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    output.build()
                };
                if (&tmp.message).is_none() {
                    tmp.message = _error_message;
                }
                tmp
            }),
        },
        _ => crate::error::UpdateRepositoryNameError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_name_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRepositoryNameOutput,
    crate::error::UpdateRepositoryNameError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_repository_name_output::Builder::default();
        let _ = response;
        output.build()
    })
}
