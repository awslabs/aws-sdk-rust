// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_approval_rule_template_with_repository_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateApprovalRuleTemplateWithRepositoryOutput, crate::error::AssociateApprovalRuleTemplateWithRepositoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRuleTemplatesAssociatedWithRepositoryException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::MaximumRuleTemplatesAssociatedWithRepositoryException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_rule_templates_associated_with_repository_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_rule_templates_associated_with_repository_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError { meta: generic, kind: crate::error::AssociateApprovalRuleTemplateWithRepositoryErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_approval_rule_template_with_repository_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::AssociateApprovalRuleTemplateWithRepositoryOutput, crate::error::AssociateApprovalRuleTemplateWithRepositoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_approval_rule_template_with_repository_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_associate_approval_rule_template_with_repositories_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchAssociateApprovalRuleTemplateWithRepositoriesOutput, crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryNamesExceededException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::MaximumRepositoryNamesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_repository_names_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_names_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNamesRequiredException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError { meta: generic, kind: crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesErrorKind::RepositoryNamesRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_names_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_names_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_associate_approval_rule_template_with_repositories_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchAssociateApprovalRuleTemplateWithRepositoriesOutput, crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_associate_approval_rule_template_with_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_associate_approval_rule_template_with_repositories(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_merge_conflicts_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchDescribeMergeConflictsOutput, crate::error::BatchDescribeMergeConflictsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchDescribeMergeConflictsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxConflictFilesException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidMaxConflictFilesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_conflict_files_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_conflict_files_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxMergeHunksException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_merge_hunks_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_merge_hunks_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMergeOptionException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidMergeOptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_merge_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MergeOptionRequiredException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::MergeOptionRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_merge_option_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::BatchDescribeMergeConflictsError { meta: generic, kind: crate::error::BatchDescribeMergeConflictsErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchDescribeMergeConflictsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_merge_conflicts_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchDescribeMergeConflictsOutput, crate::error::BatchDescribeMergeConflictsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_describe_merge_conflicts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_describe_merge_conflicts(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_disassociate_approval_rule_template_from_repositories_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput, crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryNamesExceededException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::MaximumRepositoryNamesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_repository_names_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_names_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNamesRequiredException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError { meta: generic, kind: crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesErrorKind::RepositoryNamesRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_names_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_names_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_disassociate_approval_rule_template_from_repositories_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput, crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_disassociate_approval_rule_template_from_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_disassociate_approval_rule_template_from_repositories(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_commits_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetCommitsOutput, crate::error::BatchGetCommitsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchGetCommitsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchGetCommitsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitIdsLimitExceededException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::CommitIdsLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_ids_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_ids_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdsListRequiredException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::CommitIdsListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_ids_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_ids_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::BatchGetCommitsError { meta: generic, kind: crate::error::BatchGetCommitsErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetCommitsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_commits_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetCommitsOutput, crate::error::BatchGetCommitsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_commits_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_commits(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_repositories_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetRepositoriesOutput, crate::error::BatchGetRepositoriesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::BatchGetRepositoriesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryNamesExceededException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::MaximumRepositoryNamesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_repository_names_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_names_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNamesRequiredException" => crate::error::BatchGetRepositoriesError { meta: generic, kind: crate::error::BatchGetRepositoriesErrorKind::RepositoryNamesRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_names_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_names_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::BatchGetRepositoriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_repositories_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::BatchGetRepositoriesOutput, crate::error::BatchGetRepositoriesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_repositories(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_approval_rule_template_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateApprovalRuleTemplateOutput, crate::error::CreateApprovalRuleTemplateError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateApprovalRuleTemplateError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateContentRequiredException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameAlreadyExistsException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateContentException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateDescriptionException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateDescriptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NumberOfRuleTemplatesExceededException" => crate::error::CreateApprovalRuleTemplateError { meta: generic, kind: crate::error::CreateApprovalRuleTemplateErrorKind::NumberOfRuleTemplatesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::number_of_rule_templates_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_number_of_rule_templates_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_approval_rule_template_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateApprovalRuleTemplateOutput, crate::error::CreateApprovalRuleTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_approval_rule_template(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_branch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateBranchOutput, crate::error::CreateBranchError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateBranchError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateBranchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchNameExistsException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::BranchNameExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::CreateBranchError { meta: generic, kind: crate::error::CreateBranchErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateBranchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_branch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateBranchOutput, crate::error::CreateBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_branch_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_commit_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCommitOutput, crate::error::CreateCommitError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateCommitError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateCommitError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameIsTagNameException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::BranchNameIsTagNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitMessageLengthExceededException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectoryNameConflictsWithFileNameException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::DirectoryNameConflictsWithFileNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::directory_name_conflicts_with_file_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_directory_name_conflicts_with_file_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentAndSourceFileSpecifiedException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::FileContentAndSourceFileSpecifiedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_and_source_file_specified_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_and_source_file_specified_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileDoesNotExistException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::FileDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileEntryRequiredException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::FileEntryRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_entry_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_entry_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileModeRequiredException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::FileModeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_mode_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileNameConflictsWithDirectoryNameException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::FileNameConflictsWithDirectoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_name_conflicts_with_directory_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_name_conflicts_with_directory_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FilePathConflictsWithSubmodulePathException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::FilePathConflictsWithSubmodulePathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_path_conflicts_with_submodule_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_path_conflicts_with_submodule_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDeletionParameterException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::InvalidDeletionParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_deletion_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_deletion_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParentCommitIdException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::InvalidParentCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_parent_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parent_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileEntriesExceededException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::MaximumFileEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NoChangeException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::NoChangeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_change_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_change_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ParentCommitDoesNotExistException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::ParentCommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parent_commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ParentCommitIdOutdatedException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::ParentCommitIdOutdatedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parent_commit_id_outdated_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_outdated_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ParentCommitIdRequiredException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::ParentCommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parent_commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PutFileEntryConflictException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::PutFileEntryConflictException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::put_file_entry_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_put_file_entry_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RestrictedSourceFileException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::RestrictedSourceFileException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::restricted_source_file_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_restricted_source_file_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SamePathRequestException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::SamePathRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::same_path_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_same_path_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SourceFileOrContentRequiredException" => crate::error::CreateCommitError { meta: generic, kind: crate::error::CreateCommitErrorKind::SourceFileOrContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::source_file_or_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_source_file_or_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_commit_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateCommitOutput, crate::error::CreateCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_commit(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePullRequestOutput, crate::error::CreatePullRequestError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreatePullRequestError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreatePullRequestError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ClientRequestTokenRequiredException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::ClientRequestTokenRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_client_request_token_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotencyParameterMismatchException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::IdempotencyParameterMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotency_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClientRequestTokenException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::InvalidClientRequestTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_client_request_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDescriptionException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::InvalidDescriptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReferenceNameException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::InvalidReferenceNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_reference_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_reference_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTargetException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::InvalidTargetException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTargetsException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::InvalidTargetsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_targets_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_targets_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTitleException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::InvalidTitleException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_title_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_title_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumOpenPullRequestsExceededException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::MaximumOpenPullRequestsExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_open_pull_requests_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_open_pull_requests_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleRepositoriesInPullRequestException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::MultipleRepositoriesInPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_repositories_in_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_repositories_in_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReferenceDoesNotExistException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::ReferenceDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::reference_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reference_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReferenceNameRequiredException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::ReferenceNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::reference_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reference_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReferenceTypeNotSupportedException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::ReferenceTypeNotSupportedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::reference_type_not_supported_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reference_type_not_supported_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SourceAndDestinationAreSameException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::SourceAndDestinationAreSameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::source_and_destination_are_same_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_source_and_destination_are_same_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TargetRequiredException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::TargetRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::target_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_target_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TargetsRequiredException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::TargetsRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::targets_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_targets_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TitleRequiredException" => crate::error::CreatePullRequestError { meta: generic, kind: crate::error::CreatePullRequestErrorKind::TitleRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::title_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_title_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreatePullRequestError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePullRequestOutput, crate::error::CreatePullRequestError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_pull_request(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_approval_rule_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePullRequestApprovalRuleOutput, crate::error::CreatePullRequestApprovalRuleError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreatePullRequestApprovalRuleError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleContentRequiredException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::ApprovalRuleContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleNameAlreadyExistsException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_name_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleNameRequiredException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleContentException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleNameException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NumberOfRulesExceededException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::NumberOfRulesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::number_of_rules_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_number_of_rules_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::CreatePullRequestApprovalRuleError { meta: generic, kind: crate::error::CreatePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreatePullRequestApprovalRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_approval_rule_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreatePullRequestApprovalRuleOutput, crate::error::CreatePullRequestApprovalRuleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_pull_request_approval_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_pull_request_approval_rule(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_repository_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateRepositoryOutput, crate::error::CreateRepositoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateRepositoryError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateRepositoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryDescriptionException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::InvalidRepositoryDescriptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSystemTagUsageException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::InvalidSystemTagUsageException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_system_tag_usage_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_system_tag_usage_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagsMapException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::InvalidTagsMapException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_tags_map_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_tags_map_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryLimitExceededException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::RepositoryLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameExistsException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::RepositoryNameExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagPolicyException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::TagPolicyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tag_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TooManyTagsException" => crate::error::CreateRepositoryError { meta: generic, kind: crate::error::CreateRepositoryErrorKind::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_repository_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateRepositoryOutput, crate::error::CreateRepositoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_repository(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_unreferenced_merge_commit_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateUnreferencedMergeCommitOutput, crate::error::CreateUnreferencedMergeCommitError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::CreateUnreferencedMergeCommitError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitMessageLengthExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileModeRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::FileModeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_mode_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMergeOptionException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidMergeOptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_merge_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MergeOptionRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MergeOptionRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_merge_option_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::CreateUnreferencedMergeCommitError { meta: generic, kind: crate::error::CreateUnreferencedMergeCommitErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::CreateUnreferencedMergeCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_unreferenced_merge_commit_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::CreateUnreferencedMergeCommitOutput, crate::error::CreateUnreferencedMergeCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_unreferenced_merge_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_unreferenced_merge_commit(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_approval_rule_template_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteApprovalRuleTemplateOutput, crate::error::DeleteApprovalRuleTemplateError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteApprovalRuleTemplateError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateInUseException" => crate::error::DeleteApprovalRuleTemplateError { meta: generic, kind: crate::error::DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateInUseException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::DeleteApprovalRuleTemplateError { meta: generic, kind: crate::error::DeleteApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::DeleteApprovalRuleTemplateError { meta: generic, kind: crate::error::DeleteApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_approval_rule_template_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteApprovalRuleTemplateOutput, crate::error::DeleteApprovalRuleTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_approval_rule_template(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_branch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteBranchOutput, crate::error::DeleteBranchError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteBranchError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteBranchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchNameRequiredException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DefaultBranchCannotBeDeletedException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::DefaultBranchCannotBeDeletedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::default_branch_cannot_be_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_default_branch_cannot_be_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::DeleteBranchError { meta: generic, kind: crate::error::DeleteBranchErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteBranchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_branch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteBranchOutput, crate::error::DeleteBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_branch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_branch(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_comment_content_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCommentContentOutput, crate::error::DeleteCommentContentError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteCommentContentError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteCommentContentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => crate::error::DeleteCommentContentError { meta: generic, kind: crate::error::DeleteCommentContentErrorKind::CommentDeletedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentDoesNotExistException" => crate::error::DeleteCommentContentError { meta: generic, kind: crate::error::DeleteCommentContentErrorKind::CommentDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentIdRequiredException" => crate::error::DeleteCommentContentError { meta: generic, kind: crate::error::DeleteCommentContentErrorKind::CommentIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommentIdException" => crate::error::DeleteCommentContentError { meta: generic, kind: crate::error::DeleteCommentContentErrorKind::InvalidCommentIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteCommentContentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_comment_content_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteCommentContentOutput, crate::error::DeleteCommentContentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_comment_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_comment_content(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_file_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFileOutput, crate::error::DeleteFileError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteFileError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteFileError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameIsTagNameException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::BranchNameIsTagNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitMessageLengthExceededException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileDoesNotExistException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::FileDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParentCommitIdException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::InvalidParentCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_parent_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parent_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ParentCommitDoesNotExistException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::ParentCommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parent_commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ParentCommitIdOutdatedException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::ParentCommitIdOutdatedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parent_commit_id_outdated_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_outdated_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ParentCommitIdRequiredException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::ParentCommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parent_commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::DeleteFileError { meta: generic, kind: crate::error::DeleteFileErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteFileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_file_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteFileOutput, crate::error::DeleteFileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_file_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_file(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pull_request_approval_rule_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeletePullRequestApprovalRuleOutput, crate::error::DeletePullRequestApprovalRuleError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeletePullRequestApprovalRuleError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleNameRequiredException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::ApprovalRuleNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CannotDeleteApprovalRuleFromTemplateException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::CannotDeleteApprovalRuleFromTemplateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cannot_delete_approval_rule_from_template_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_cannot_delete_approval_rule_from_template_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleNameException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::InvalidApprovalRuleNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::DeletePullRequestApprovalRuleError { meta: generic, kind: crate::error::DeletePullRequestApprovalRuleErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeletePullRequestApprovalRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pull_request_approval_rule_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeletePullRequestApprovalRuleOutput, crate::error::DeletePullRequestApprovalRuleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_pull_request_approval_rule_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_pull_request_approval_rule(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_repository_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteRepositoryOutput, crate::error::DeleteRepositoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DeleteRepositoryError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DeleteRepositoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::DeleteRepositoryError { meta: generic, kind: crate::error::DeleteRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DeleteRepositoryError { meta: generic, kind: crate::error::DeleteRepositoryErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DeleteRepositoryError { meta: generic, kind: crate::error::DeleteRepositoryErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DeleteRepositoryError { meta: generic, kind: crate::error::DeleteRepositoryErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DeleteRepositoryError { meta: generic, kind: crate::error::DeleteRepositoryErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::DeleteRepositoryError { meta: generic, kind: crate::error::DeleteRepositoryErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::DeleteRepositoryError { meta: generic, kind: crate::error::DeleteRepositoryErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DeleteRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_repository_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DeleteRepositoryOutput, crate::error::DeleteRepositoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_repository(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_merge_conflicts_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMergeConflictsOutput, crate::error::DescribeMergeConflictsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribeMergeConflictsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileDoesNotExistException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::FileDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxMergeHunksException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidMaxMergeHunksException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_merge_hunks_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_merge_hunks_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMergeOptionException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidMergeOptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_merge_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MergeOptionRequiredException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::MergeOptionRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_merge_option_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::DescribeMergeConflictsError { meta: generic, kind: crate::error::DescribeMergeConflictsErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribeMergeConflictsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_merge_conflicts_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribeMergeConflictsOutput, crate::error::DescribeMergeConflictsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_merge_conflicts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_merge_conflicts(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pull_request_events_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePullRequestEventsOutput, crate::error::DescribePullRequestEventsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DescribePullRequestEventsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ActorDoesNotExistException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::ActorDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::actor_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_actor_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidActorArnException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidActorArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_actor_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_actor_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestEventTypeException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidPullRequestEventTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_event_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_event_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::DescribePullRequestEventsError { meta: generic, kind: crate::error::DescribePullRequestEventsErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DescribePullRequestEventsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pull_request_events_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DescribePullRequestEventsOutput, crate::error::DescribePullRequestEventsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_pull_request_events_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_pull_request_events(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_approval_rule_template_from_repository_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateApprovalRuleTemplateFromRepositoryOutput, crate::error::DisassociateApprovalRuleTemplateFromRepositoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError { meta: generic, kind: crate::error::DisassociateApprovalRuleTemplateFromRepositoryErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_approval_rule_template_from_repository_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::DisassociateApprovalRuleTemplateFromRepositoryOutput, crate::error::DisassociateApprovalRuleTemplateFromRepositoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_approval_rule_template_from_repository_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_evaluate_pull_request_approval_rules_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EvaluatePullRequestApprovalRulesOutput, crate::error::EvaluatePullRequestApprovalRulesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionNotCurrentException" => crate::error::EvaluatePullRequestApprovalRulesError { meta: generic, kind: crate::error::EvaluatePullRequestApprovalRulesErrorKind::RevisionNotCurrentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_not_current_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_not_current_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::EvaluatePullRequestApprovalRulesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_evaluate_pull_request_approval_rules_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::EvaluatePullRequestApprovalRulesOutput, crate::error::EvaluatePullRequestApprovalRulesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::evaluate_pull_request_approval_rules_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_evaluate_pull_request_approval_rules(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_approval_rule_template_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetApprovalRuleTemplateOutput, crate::error::GetApprovalRuleTemplateError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetApprovalRuleTemplateError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::GetApprovalRuleTemplateError { meta: generic, kind: crate::error::GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::GetApprovalRuleTemplateError { meta: generic, kind: crate::error::GetApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::GetApprovalRuleTemplateError { meta: generic, kind: crate::error::GetApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_approval_rule_template_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetApprovalRuleTemplateOutput, crate::error::GetApprovalRuleTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_approval_rule_template(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_blob_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetBlobOutput, crate::error::GetBlobError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetBlobError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetBlobError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BlobIdDoesNotExistException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::BlobIdDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::blob_id_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_blob_id_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BlobIdRequiredException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::BlobIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::blob_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_blob_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileTooLargeException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::FileTooLargeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_too_large_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_too_large_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBlobIdException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::InvalidBlobIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_blob_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_blob_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetBlobError { meta: generic, kind: crate::error::GetBlobErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetBlobError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_blob_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetBlobOutput, crate::error::GetBlobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_blob_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_blob(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_branch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetBranchOutput, crate::error::GetBranchError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetBranchError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetBranchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetBranchError { meta: generic, kind: crate::error::GetBranchErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetBranchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_branch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetBranchOutput, crate::error::GetBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_branch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_branch(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommentOutput, crate::error::GetCommentError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetCommentError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetCommentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => crate::error::GetCommentError { meta: generic, kind: crate::error::GetCommentErrorKind::CommentDeletedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentDoesNotExistException" => crate::error::GetCommentError { meta: generic, kind: crate::error::GetCommentErrorKind::CommentDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentIdRequiredException" => crate::error::GetCommentError { meta: generic, kind: crate::error::GetCommentErrorKind::CommentIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommentError { meta: generic, kind: crate::error::GetCommentErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommentError { meta: generic, kind: crate::error::GetCommentErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetCommentError { meta: generic, kind: crate::error::GetCommentErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetCommentError { meta: generic, kind: crate::error::GetCommentErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetCommentError { meta: generic, kind: crate::error::GetCommentErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommentIdException" => crate::error::GetCommentError { meta: generic, kind: crate::error::GetCommentErrorKind::InvalidCommentIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetCommentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommentOutput, crate::error::GetCommentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_comment(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_reactions_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommentReactionsOutput, crate::error::GetCommentReactionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetCommentReactionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetCommentReactionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => crate::error::GetCommentReactionsError { meta: generic, kind: crate::error::GetCommentReactionsErrorKind::CommentDeletedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentDoesNotExistException" => crate::error::GetCommentReactionsError { meta: generic, kind: crate::error::GetCommentReactionsErrorKind::CommentDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentIdRequiredException" => crate::error::GetCommentReactionsError { meta: generic, kind: crate::error::GetCommentReactionsErrorKind::CommentIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommentIdException" => crate::error::GetCommentReactionsError { meta: generic, kind: crate::error::GetCommentReactionsErrorKind::InvalidCommentIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::GetCommentReactionsError { meta: generic, kind: crate::error::GetCommentReactionsErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::GetCommentReactionsError { meta: generic, kind: crate::error::GetCommentReactionsErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReactionUserArnException" => crate::error::GetCommentReactionsError { meta: generic, kind: crate::error::GetCommentReactionsErrorKind::InvalidReactionUserArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_reaction_user_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_reaction_user_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetCommentReactionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_reactions_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommentReactionsOutput, crate::error::GetCommentReactionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comment_reactions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_comment_reactions(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_compared_commit_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommentsForComparedCommitOutput, crate::error::GetCommentsForComparedCommitError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetCommentsForComparedCommitError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetCommentsForComparedCommitError { meta: generic, kind: crate::error::GetCommentsForComparedCommitErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetCommentsForComparedCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_compared_commit_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommentsForComparedCommitOutput, crate::error::GetCommentsForComparedCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comments_for_compared_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_comments_for_compared_commit(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_pull_request_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommentsForPullRequestOutput, crate::error::GetCommentsForPullRequestError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetCommentsForPullRequestError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::GetCommentsForPullRequestError { meta: generic, kind: crate::error::GetCommentsForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetCommentsForPullRequestError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_pull_request_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommentsForPullRequestOutput, crate::error::GetCommentsForPullRequestError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comments_for_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_comments_for_pull_request(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_commit_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommitOutput, crate::error::GetCommitError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetCommitError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetCommitError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitIdDoesNotExistException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::CommitIdDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetCommitError { meta: generic, kind: crate::error::GetCommitErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_commit_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetCommitOutput, crate::error::GetCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_commit(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_differences_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDifferencesOutput, crate::error::GetDifferencesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetDifferencesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetDifferencesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathDoesNotExistException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::PathDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetDifferencesError { meta: generic, kind: crate::error::GetDifferencesErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetDifferencesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_differences_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetDifferencesOutput, crate::error::GetDifferencesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_differences_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_differences(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_file_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetFileOutput, crate::error::GetFileError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetFileError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetFileError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileDoesNotExistException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::FileDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileTooLargeException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::FileTooLargeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_too_large_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_too_large_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetFileError { meta: generic, kind: crate::error::GetFileErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetFileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_file_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetFileOutput, crate::error::GetFileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_file_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_file(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetFolderOutput, crate::error::GetFolderError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetFolderError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetFolderError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderDoesNotExistException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::FolderDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetFolderError { meta: generic, kind: crate::error::GetFolderErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetFolderError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetFolderOutput, crate::error::GetFolderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_folder_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_folder(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_commit_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMergeCommitOutput, crate::error::GetMergeCommitError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetMergeCommitError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetMergeCommitError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetMergeCommitError { meta: generic, kind: crate::error::GetMergeCommitErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetMergeCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_commit_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMergeCommitOutput, crate::error::GetMergeCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_merge_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_merge_commit(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_conflicts_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMergeConflictsOutput, crate::error::GetMergeConflictsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetMergeConflictsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetMergeConflictsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDestinationCommitSpecifierException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::InvalidDestinationCommitSpecifierException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_destination_commit_specifier_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_destination_commit_specifier_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxConflictFilesException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::InvalidMaxConflictFilesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_conflict_files_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_conflict_files_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMergeOptionException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::InvalidMergeOptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_merge_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSourceCommitSpecifierException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::InvalidSourceCommitSpecifierException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_source_commit_specifier_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_source_commit_specifier_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MergeOptionRequiredException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::MergeOptionRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_merge_option_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::GetMergeConflictsError { meta: generic, kind: crate::error::GetMergeConflictsErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetMergeConflictsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_conflicts_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMergeConflictsOutput, crate::error::GetMergeConflictsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_merge_conflicts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_merge_conflicts(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_options_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMergeOptionsOutput, crate::error::GetMergeOptionsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetMergeOptionsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetMergeOptionsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::GetMergeOptionsError { meta: generic, kind: crate::error::GetMergeOptionsErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetMergeOptionsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_options_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetMergeOptionsOutput, crate::error::GetMergeOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_merge_options_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_merge_options(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPullRequestOutput, crate::error::GetPullRequestError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetPullRequestError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetPullRequestError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetPullRequestError { meta: generic, kind: crate::error::GetPullRequestErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetPullRequestError { meta: generic, kind: crate::error::GetPullRequestErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetPullRequestError { meta: generic, kind: crate::error::GetPullRequestErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetPullRequestError { meta: generic, kind: crate::error::GetPullRequestErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetPullRequestError { meta: generic, kind: crate::error::GetPullRequestErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::GetPullRequestError { meta: generic, kind: crate::error::GetPullRequestErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::GetPullRequestError { meta: generic, kind: crate::error::GetPullRequestErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::GetPullRequestError { meta: generic, kind: crate::error::GetPullRequestErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetPullRequestError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPullRequestOutput, crate::error::GetPullRequestError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_pull_request(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_approval_states_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPullRequestApprovalStatesOutput, crate::error::GetPullRequestApprovalStatesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetPullRequestApprovalStatesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::GetPullRequestApprovalStatesError { meta: generic, kind: crate::error::GetPullRequestApprovalStatesErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetPullRequestApprovalStatesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_approval_states_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPullRequestApprovalStatesOutput, crate::error::GetPullRequestApprovalStatesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_pull_request_approval_states_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_pull_request_approval_states(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_override_state_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPullRequestOverrideStateOutput, crate::error::GetPullRequestOverrideStateError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetPullRequestOverrideStateError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::GetPullRequestOverrideStateError { meta: generic, kind: crate::error::GetPullRequestOverrideStateErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetPullRequestOverrideStateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_override_state_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetPullRequestOverrideStateOutput, crate::error::GetPullRequestOverrideStateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_pull_request_override_state_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_pull_request_override_state(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetRepositoryOutput, crate::error::GetRepositoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetRepositoryError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetRepositoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetRepositoryError { meta: generic, kind: crate::error::GetRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetRepositoryError { meta: generic, kind: crate::error::GetRepositoryErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetRepositoryError { meta: generic, kind: crate::error::GetRepositoryErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetRepositoryError { meta: generic, kind: crate::error::GetRepositoryErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetRepositoryError { meta: generic, kind: crate::error::GetRepositoryErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetRepositoryError { meta: generic, kind: crate::error::GetRepositoryErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetRepositoryError { meta: generic, kind: crate::error::GetRepositoryErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetRepositoryError { meta: generic, kind: crate::error::GetRepositoryErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetRepositoryOutput, crate::error::GetRepositoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_repository(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_triggers_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetRepositoryTriggersOutput, crate::error::GetRepositoryTriggersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::GetRepositoryTriggersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::GetRepositoryTriggersError { meta: generic, kind: crate::error::GetRepositoryTriggersErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::GetRepositoryTriggersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_triggers_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::GetRepositoryTriggersOutput, crate::error::GetRepositoryTriggersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_repository_triggers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_repository_triggers(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_approval_rule_templates_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListApprovalRuleTemplatesOutput, crate::error::ListApprovalRuleTemplatesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListApprovalRuleTemplatesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidContinuationTokenException" => crate::error::ListApprovalRuleTemplatesError { meta: generic, kind: crate::error::ListApprovalRuleTemplatesErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::ListApprovalRuleTemplatesError { meta: generic, kind: crate::error::ListApprovalRuleTemplatesErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListApprovalRuleTemplatesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_approval_rule_templates_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListApprovalRuleTemplatesOutput, crate::error::ListApprovalRuleTemplatesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_approval_rule_templates_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_approval_rule_templates(response.body().as_ref(), output).map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associated_approval_rule_templates_for_repository_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListAssociatedApprovalRuleTemplatesForRepositoryOutput, crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError { meta: generic, kind: crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associated_approval_rule_templates_for_repository_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListAssociatedApprovalRuleTemplatesForRepositoryOutput, crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_associated_approval_rule_templates_for_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_associated_approval_rule_templates_for_repository(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_branches_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBranchesOutput, crate::error::ListBranchesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListBranchesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListBranchesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::ListBranchesError { meta: generic, kind: crate::error::ListBranchesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::ListBranchesError { meta: generic, kind: crate::error::ListBranchesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::ListBranchesError { meta: generic, kind: crate::error::ListBranchesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::ListBranchesError { meta: generic, kind: crate::error::ListBranchesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::ListBranchesError { meta: generic, kind: crate::error::ListBranchesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::ListBranchesError { meta: generic, kind: crate::error::ListBranchesErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::ListBranchesError { meta: generic, kind: crate::error::ListBranchesErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::ListBranchesError { meta: generic, kind: crate::error::ListBranchesErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::ListBranchesError { meta: generic, kind: crate::error::ListBranchesErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListBranchesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_branches_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListBranchesOutput, crate::error::ListBranchesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_branches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_branches(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pull_requests_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListPullRequestsOutput, crate::error::ListPullRequestsError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListPullRequestsError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListPullRequestsError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "AuthorDoesNotExistException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::AuthorDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::author_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_author_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidAuthorArnException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::InvalidAuthorArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_author_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_author_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestStatusException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::InvalidPullRequestStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::ListPullRequestsError { meta: generic, kind: crate::error::ListPullRequestsErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListPullRequestsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pull_requests_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListPullRequestsOutput, crate::error::ListPullRequestsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_pull_requests_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_pull_requests(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListRepositoriesOutput, crate::error::ListRepositoriesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListRepositoriesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListRepositoriesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidContinuationTokenException" => crate::error::ListRepositoriesError { meta: generic, kind: crate::error::ListRepositoriesErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidOrderException" => crate::error::ListRepositoriesError { meta: generic, kind: crate::error::ListRepositoriesErrorKind::InvalidOrderException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_order_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_order_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSortByException" => crate::error::ListRepositoriesError { meta: generic, kind: crate::error::ListRepositoriesErrorKind::InvalidSortByException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_sort_by_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_sort_by_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListRepositoriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListRepositoriesOutput, crate::error::ListRepositoriesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_repositories(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_for_approval_rule_template_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListRepositoriesForApprovalRuleTemplateOutput, crate::error::ListRepositoriesForApprovalRuleTemplateError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidContinuationTokenException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidMaxResultsException" => crate::error::ListRepositoriesForApprovalRuleTemplateError { meta: generic, kind: crate::error::ListRepositoriesForApprovalRuleTemplateErrorKind::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListRepositoriesForApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_for_approval_rule_template_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListRepositoriesForApprovalRuleTemplateOutput, crate::error::ListRepositoriesForApprovalRuleTemplateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_repositories_for_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_repositories_for_approval_rule_template(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::ListTagsForResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::ListTagsForResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidResourceArnException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::InvalidResourceArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceArnRequiredException" => crate::error::ListTagsForResourceError { meta: generic, kind: crate::error::ListTagsForResourceErrorKind::ResourceArnRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::ListTagsForResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::ListTagsForResourceOutput, crate::error::ListTagsForResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags_for_resource(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_fast_forward_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergeBranchesByFastForwardOutput, crate::error::MergeBranchesByFastForwardError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::MergeBranchesByFastForwardError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameIsTagNameException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::BranchNameIsTagNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTargetBranchException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::InvalidTargetBranchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_branch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_branch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergeBranchesByFastForwardError { meta: generic, kind: crate::error::MergeBranchesByFastForwardErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergeBranchesByFastForwardError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_fast_forward_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergeBranchesByFastForwardOutput, crate::error::MergeBranchesByFastForwardError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_branches_by_fast_forward_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_branches_by_fast_forward(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_squash_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergeBranchesBySquashOutput, crate::error::MergeBranchesBySquashError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::MergeBranchesBySquashError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameIsTagNameException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::BranchNameIsTagNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitMessageLengthExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileModeRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::FileModeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_mode_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTargetBranchException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::InvalidTargetBranchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_branch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_branch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergeBranchesBySquashError { meta: generic, kind: crate::error::MergeBranchesBySquashErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergeBranchesBySquashError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_squash_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergeBranchesBySquashOutput, crate::error::MergeBranchesBySquashError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_branches_by_squash_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_branches_by_squash(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_three_way_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergeBranchesByThreeWayOutput, crate::error::MergeBranchesByThreeWayError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::MergeBranchesByThreeWayError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameIsTagNameException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::BranchNameIsTagNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitMessageLengthExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileModeRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::FileModeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_mode_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTargetBranchException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::InvalidTargetBranchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_branch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_branch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergeBranchesByThreeWayError { meta: generic, kind: crate::error::MergeBranchesByThreeWayErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergeBranchesByThreeWayError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_three_way_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergeBranchesByThreeWayOutput, crate::error::MergeBranchesByThreeWayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_branches_by_three_way_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_branches_by_three_way(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_fast_forward_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergePullRequestByFastForwardOutput, crate::error::MergePullRequestByFastForwardError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::MergePullRequestByFastForwardError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ConcurrentReferenceUpdateException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestApprovalRulesNotSatisfiedException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::PullRequestApprovalRulesNotSatisfiedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_approval_rules_not_satisfied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReferenceDoesNotExistException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::ReferenceDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::reference_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reference_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipOfSourceReferenceIsDifferentException" => crate::error::MergePullRequestByFastForwardError { meta: generic, kind: crate::error::MergePullRequestByFastForwardErrorKind::TipOfSourceReferenceIsDifferentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tip_of_source_reference_is_different_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tip_of_source_reference_is_different_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergePullRequestByFastForwardError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_fast_forward_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergePullRequestByFastForwardOutput, crate::error::MergePullRequestByFastForwardError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_pull_request_by_fast_forward_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_pull_request_by_fast_forward(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_squash_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergePullRequestBySquashOutput, crate::error::MergePullRequestBySquashError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::MergePullRequestBySquashError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitMessageLengthExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestApprovalRulesNotSatisfiedException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PullRequestApprovalRulesNotSatisfiedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_approval_rules_not_satisfied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipOfSourceReferenceIsDifferentException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::TipOfSourceReferenceIsDifferentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tip_of_source_reference_is_different_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tip_of_source_reference_is_different_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergePullRequestBySquashError { meta: generic, kind: crate::error::MergePullRequestBySquashErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergePullRequestBySquashError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_squash_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergePullRequestBySquashOutput, crate::error::MergePullRequestBySquashError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_pull_request_by_squash_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_pull_request_by_squash(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_three_way_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergePullRequestByThreeWayOutput, crate::error::MergePullRequestByThreeWayError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::MergePullRequestByThreeWayError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommitMessageLengthExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ConcurrentReferenceUpdateException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictDetailLevelException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidConflictResolutionStrategyException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementContentException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReplacementTypeException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ManualMergeRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumFileContentToLoadExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumItemsToCompareExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MultipleConflictResolutionEntriesException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestApprovalRulesNotSatisfiedException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PullRequestApprovalRulesNotSatisfiedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_approval_rules_not_satisfied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementContentRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReplacementTypeRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipOfSourceReferenceIsDifferentException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::TipOfSourceReferenceIsDifferentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tip_of_source_reference_is_different_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tip_of_source_reference_is_different_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TipsDivergenceExceededException" => crate::error::MergePullRequestByThreeWayError { meta: generic, kind: crate::error::MergePullRequestByThreeWayErrorKind::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::MergePullRequestByThreeWayError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_three_way_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::MergePullRequestByThreeWayOutput, crate::error::MergePullRequestByThreeWayError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_pull_request_by_three_way_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_pull_request_by_three_way(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_override_pull_request_approval_rules_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::OverridePullRequestApprovalRulesOutput, crate::error::OverridePullRequestApprovalRulesError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::OverridePullRequestApprovalRulesError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidOverrideStatusException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::InvalidOverrideStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_override_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_override_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OverrideAlreadySetException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::OverrideAlreadySetException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::override_already_set_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_override_already_set_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "OverrideStatusRequiredException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::OverrideStatusRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::override_status_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_override_status_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionNotCurrentException" => crate::error::OverridePullRequestApprovalRulesError { meta: generic, kind: crate::error::OverridePullRequestApprovalRulesErrorKind::RevisionNotCurrentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_not_current_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_not_current_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::OverridePullRequestApprovalRulesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_override_pull_request_approval_rules_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::OverridePullRequestApprovalRulesOutput, crate::error::OverridePullRequestApprovalRulesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::override_pull_request_approval_rules_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_compared_commit_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PostCommentForComparedCommitOutput, crate::error::PostCommentForComparedCommitError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PostCommentForComparedCommitError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BeforeCommitIdAndAfterCommitIdAreSameException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_before_commit_id_and_after_commit_id_are_same_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClientRequestTokenRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::ClientRequestTokenRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_client_request_token_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::CommentContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentSizeLimitExceededException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::CommentContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotencyParameterMismatchException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::IdempotencyParameterMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotency_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClientRequestTokenException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidClientRequestTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_client_request_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileLocationException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidFileLocationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_location_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_location_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFilePositionException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidFilePositionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_position_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_position_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRelativeFileVersionEnumException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidRelativeFileVersionEnumException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_relative_file_version_enum_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_relative_file_version_enum_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathDoesNotExistException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::PathDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::PostCommentForComparedCommitError { meta: generic, kind: crate::error::PostCommentForComparedCommitErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PostCommentForComparedCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_compared_commit_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PostCommentForComparedCommitOutput, crate::error::PostCommentForComparedCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::post_comment_for_compared_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_post_comment_for_compared_commit(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_pull_request_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PostCommentForPullRequestOutput, crate::error::PostCommentForPullRequestError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PostCommentForPullRequestError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BeforeCommitIdAndAfterCommitIdAreSameException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::BeforeCommitIdAndAfterCommitIdAreSameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_before_commit_id_and_after_commit_id_are_same_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ClientRequestTokenRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::ClientRequestTokenRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_client_request_token_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::CommentContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentSizeLimitExceededException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::CommentContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitDoesNotExistException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitIdRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotencyParameterMismatchException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::IdempotencyParameterMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotency_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClientRequestTokenException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidClientRequestTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_client_request_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommitIdException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileLocationException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidFileLocationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_location_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_location_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFilePositionException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidFilePositionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_position_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_position_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRelativeFileVersionEnumException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidRelativeFileVersionEnumException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_relative_file_version_enum_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_relative_file_version_enum_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathDoesNotExistException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::PathDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::PostCommentForPullRequestError { meta: generic, kind: crate::error::PostCommentForPullRequestErrorKind::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PostCommentForPullRequestError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_pull_request_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PostCommentForPullRequestOutput, crate::error::PostCommentForPullRequestError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::post_comment_for_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_post_comment_for_pull_request(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_reply_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PostCommentReplyOutput, crate::error::PostCommentReplyError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PostCommentReplyError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PostCommentReplyError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ClientRequestTokenRequiredException" => crate::error::PostCommentReplyError { meta: generic, kind: crate::error::PostCommentReplyErrorKind::ClientRequestTokenRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_client_request_token_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentRequiredException" => crate::error::PostCommentReplyError { meta: generic, kind: crate::error::PostCommentReplyErrorKind::CommentContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentSizeLimitExceededException" => crate::error::PostCommentReplyError { meta: generic, kind: crate::error::PostCommentReplyErrorKind::CommentContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentDoesNotExistException" => crate::error::PostCommentReplyError { meta: generic, kind: crate::error::PostCommentReplyErrorKind::CommentDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentIdRequiredException" => crate::error::PostCommentReplyError { meta: generic, kind: crate::error::PostCommentReplyErrorKind::CommentIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "IdempotencyParameterMismatchException" => crate::error::PostCommentReplyError { meta: generic, kind: crate::error::PostCommentReplyErrorKind::IdempotencyParameterMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotency_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidClientRequestTokenException" => crate::error::PostCommentReplyError { meta: generic, kind: crate::error::PostCommentReplyErrorKind::InvalidClientRequestTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_client_request_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommentIdException" => crate::error::PostCommentReplyError { meta: generic, kind: crate::error::PostCommentReplyErrorKind::InvalidCommentIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PostCommentReplyError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_reply_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PostCommentReplyOutput, crate::error::PostCommentReplyError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::post_comment_reply_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_post_comment_reply(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_comment_reaction_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutCommentReactionOutput, crate::error::PutCommentReactionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutCommentReactionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutCommentReactionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => crate::error::PutCommentReactionError { meta: generic, kind: crate::error::PutCommentReactionErrorKind::CommentDeletedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentDoesNotExistException" => crate::error::PutCommentReactionError { meta: generic, kind: crate::error::PutCommentReactionErrorKind::CommentDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentIdRequiredException" => crate::error::PutCommentReactionError { meta: generic, kind: crate::error::PutCommentReactionErrorKind::CommentIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommentIdException" => crate::error::PutCommentReactionError { meta: generic, kind: crate::error::PutCommentReactionErrorKind::InvalidCommentIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidReactionValueException" => crate::error::PutCommentReactionError { meta: generic, kind: crate::error::PutCommentReactionErrorKind::InvalidReactionValueException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_reaction_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_reaction_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReactionLimitExceededException" => crate::error::PutCommentReactionError { meta: generic, kind: crate::error::PutCommentReactionErrorKind::ReactionLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::reaction_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reaction_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ReactionValueRequiredException" => crate::error::PutCommentReactionError { meta: generic, kind: crate::error::PutCommentReactionErrorKind::ReactionValueRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::reaction_value_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reaction_value_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutCommentReactionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_comment_reaction_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutCommentReactionOutput, crate::error::PutCommentReactionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_comment_reaction_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_file_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutFileOutput, crate::error::PutFileError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutFileError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutFileError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameIsTagNameException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::BranchNameIsTagNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommitMessageLengthExceededException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "DirectoryNameConflictsWithFileNameException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::DirectoryNameConflictsWithFileNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::directory_name_conflicts_with_file_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_directory_name_conflicts_with_file_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentRequiredException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::FileContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileContentSizeLimitExceededException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FileNameConflictsWithDirectoryNameException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::FileNameConflictsWithDirectoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_name_conflicts_with_directory_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_name_conflicts_with_directory_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FilePathConflictsWithSubmodulePathException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::FilePathConflictsWithSubmodulePathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_path_conflicts_with_submodule_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_path_conflicts_with_submodule_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "FolderContentSizeLimitExceededException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidDeletionParameterException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::InvalidDeletionParameterException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_deletion_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_deletion_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidEmailException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidFileModeException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidParentCommitIdException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::InvalidParentCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_parent_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parent_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPathException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "NameLengthExceededException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ParentCommitDoesNotExistException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::ParentCommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parent_commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ParentCommitIdOutdatedException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::ParentCommitIdOutdatedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parent_commit_id_outdated_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_outdated_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ParentCommitIdRequiredException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::ParentCommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::parent_commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PathRequiredException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "SameFileContentException" => crate::error::PutFileError { meta: generic, kind: crate::error::PutFileErrorKind::SameFileContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::same_file_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_same_file_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutFileError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_file_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutFileOutput, crate::error::PutFileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_file_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_file(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_repository_triggers_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutRepositoryTriggersOutput, crate::error::PutRepositoryTriggersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::PutRepositoryTriggersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerBranchNameException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerCustomDataException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_custom_data_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_custom_data_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerDestinationArnException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_destination_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_destination_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerEventsException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_events_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_events_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerNameException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerRegionException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumBranchesExceededException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::MaximumBranchesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_branches_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_branches_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryTriggersExceededException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_repository_triggers_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_triggers_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerBranchNameListRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_branch_name_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_branch_name_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerDestinationArnRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_destination_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_destination_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerEventsListRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_events_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_events_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerNameRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggersListRequiredException" => crate::error::PutRepositoryTriggersError { meta: generic, kind: crate::error::PutRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_triggers_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_triggers_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::PutRepositoryTriggersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_repository_triggers_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::PutRepositoryTriggersOutput, crate::error::PutRepositoryTriggersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_repository_triggers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_repository_triggers(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::TagResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::TagResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidResourceArnException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::InvalidResourceArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSystemTagUsageException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::InvalidSystemTagUsageException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_system_tag_usage_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_system_tag_usage_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagsMapException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::InvalidTagsMapException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_tags_map_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_tags_map_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceArnRequiredException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::ResourceArnRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagPolicyException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::TagPolicyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tag_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagsMapRequiredException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::TagsMapRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tags_map_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tags_map_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TooManyTagsException" => crate::error::TagResourceError { meta: generic, kind: crate::error::TagResourceErrorKind::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::TagResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_repository_triggers_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TestRepositoryTriggersOutput, crate::error::TestRepositoryTriggersError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::TestRepositoryTriggersError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerBranchNameException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerCustomDataException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerCustomDataException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_custom_data_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_custom_data_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerDestinationArnException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerDestinationArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_destination_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_destination_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerEventsException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerEventsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_events_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_events_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerNameException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryTriggerRegionException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::InvalidRepositoryTriggerRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumBranchesExceededException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::MaximumBranchesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_branches_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_branches_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumRepositoryTriggersExceededException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::MaximumRepositoryTriggersExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_repository_triggers_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_triggers_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerBranchNameListRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggerBranchNameListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_branch_name_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_branch_name_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerDestinationArnRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggerDestinationArnRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_destination_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_destination_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerEventsListRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggerEventsListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_events_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_events_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggerNameRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggerNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryTriggersListRequiredException" => crate::error::TestRepositoryTriggersError { meta: generic, kind: crate::error::TestRepositoryTriggersErrorKind::RepositoryTriggersListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_triggers_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_triggers_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::TestRepositoryTriggersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_repository_triggers_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::TestRepositoryTriggersOutput, crate::error::TestRepositoryTriggersError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_repository_triggers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_test_repository_triggers(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UntagResourceError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UntagResourceError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidResourceArnException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::InvalidResourceArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_resource_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidSystemTagUsageException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::InvalidSystemTagUsageException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_system_tag_usage_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_system_tag_usage_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTagKeysListException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::InvalidTagKeysListException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_tag_keys_list_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_tag_keys_list_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ResourceArnRequiredException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::ResourceArnRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::resource_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagKeysListRequiredException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::TagKeysListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_keys_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tag_keys_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TagPolicyException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::TagPolicyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tag_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TooManyTagsException" => crate::error::UntagResourceError { meta: generic, kind: crate::error::UntagResourceErrorKind::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::too_many_tags_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UntagResourceError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_content_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateApprovalRuleTemplateContentOutput, crate::error::UpdateApprovalRuleTemplateContentError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateContentRequiredException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateContentException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRuleContentSha256Exception" => crate::error::UpdateApprovalRuleTemplateContentError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateContentErrorKind::InvalidRuleContentSha256Exception({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_rule_content_sha256_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_rule_content_sha256_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateApprovalRuleTemplateContentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_content_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateApprovalRuleTemplateContentOutput, crate::error::UpdateApprovalRuleTemplateContentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_approval_rule_template_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_approval_rule_template_content(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_description_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateApprovalRuleTemplateDescriptionOutput, crate::error::UpdateApprovalRuleTemplateDescriptionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::UpdateApprovalRuleTemplateDescriptionError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::UpdateApprovalRuleTemplateDescriptionError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateDescriptionErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateDescriptionException" => crate::error::UpdateApprovalRuleTemplateDescriptionError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateDescriptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::UpdateApprovalRuleTemplateDescriptionError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateDescriptionErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateApprovalRuleTemplateDescriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_description_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateApprovalRuleTemplateDescriptionOutput, crate::error::UpdateApprovalRuleTemplateDescriptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_approval_rule_template_description_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_approval_rule_template_description(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_name_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateApprovalRuleTemplateNameOutput, crate::error::UpdateApprovalRuleTemplateNameError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::UpdateApprovalRuleTemplateNameError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameAlreadyExistsException" => crate::error::UpdateApprovalRuleTemplateNameError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleTemplateNameRequiredException" => crate::error::UpdateApprovalRuleTemplateNameError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateNameErrorKind::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleTemplateNameException" => crate::error::UpdateApprovalRuleTemplateNameError { meta: generic, kind: crate::error::UpdateApprovalRuleTemplateNameErrorKind::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateApprovalRuleTemplateNameError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_name_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateApprovalRuleTemplateNameOutput, crate::error::UpdateApprovalRuleTemplateNameError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_approval_rule_template_name_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_approval_rule_template_name(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_comment_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateCommentOutput, crate::error::UpdateCommentError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateCommentError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateCommentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "CommentContentRequiredException" => crate::error::UpdateCommentError { meta: generic, kind: crate::error::UpdateCommentErrorKind::CommentContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentContentSizeLimitExceededException" => crate::error::UpdateCommentError { meta: generic, kind: crate::error::UpdateCommentErrorKind::CommentContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentDeletedException" => crate::error::UpdateCommentError { meta: generic, kind: crate::error::UpdateCommentErrorKind::CommentDeletedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentDoesNotExistException" => crate::error::UpdateCommentError { meta: generic, kind: crate::error::UpdateCommentErrorKind::CommentDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentIdRequiredException" => crate::error::UpdateCommentError { meta: generic, kind: crate::error::UpdateCommentErrorKind::CommentIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CommentNotCreatedByCallerException" => crate::error::UpdateCommentError { meta: generic, kind: crate::error::UpdateCommentErrorKind::CommentNotCreatedByCallerException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_not_created_by_caller_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_not_created_by_caller_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidCommentIdException" => crate::error::UpdateCommentError { meta: generic, kind: crate::error::UpdateCommentErrorKind::InvalidCommentIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateCommentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_comment_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateCommentOutput, crate::error::UpdateCommentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_comment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_comment(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_default_branch_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateDefaultBranchOutput, crate::error::UpdateDefaultBranchError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateDefaultBranchError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "BranchNameRequiredException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidBranchNameException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::UpdateDefaultBranchError { meta: generic, kind: crate::error::UpdateDefaultBranchErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateDefaultBranchError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_default_branch_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateDefaultBranchOutput, crate::error::UpdateDefaultBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_default_branch_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_rule_content_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestApprovalRuleContentOutput, crate::error::UpdatePullRequestApprovalRuleContentError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalRuleContentRequiredException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleDoesNotExistException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "ApprovalRuleNameRequiredException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::ApprovalRuleNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "CannotModifyApprovalRuleFromTemplateException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::CannotModifyApprovalRuleFromTemplateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cannot_modify_approval_rule_from_template_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_cannot_modify_approval_rule_from_template_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleContentException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalRuleNameException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::InvalidApprovalRuleNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRuleContentSha256Exception" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::InvalidRuleContentSha256Exception({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_rule_content_sha256_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_rule_content_sha256_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestApprovalRuleContentError { meta: generic, kind: crate::error::UpdatePullRequestApprovalRuleContentErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdatePullRequestApprovalRuleContentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_rule_content_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestApprovalRuleContentOutput, crate::error::UpdatePullRequestApprovalRuleContentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_approval_rule_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_pull_request_approval_rule_content(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_state_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestApprovalStateOutput, crate::error::UpdatePullRequestApprovalStateError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdatePullRequestApprovalStateError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "ApprovalStateRequiredException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::ApprovalStateRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_state_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_state_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidApprovalStateException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::InvalidApprovalStateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_state_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRevisionIdException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::InvalidRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "MaximumNumberOfApprovalsExceededException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::MaximumNumberOfApprovalsExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_number_of_approvals_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_number_of_approvals_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestCannotBeApprovedByAuthorException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::PullRequestCannotBeApprovedByAuthorException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_cannot_be_approved_by_author_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_cannot_be_approved_by_author_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionIdRequiredException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::RevisionIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RevisionNotCurrentException" => crate::error::UpdatePullRequestApprovalStateError { meta: generic, kind: crate::error::UpdatePullRequestApprovalStateErrorKind::RevisionNotCurrentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_not_current_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_not_current_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdatePullRequestApprovalStateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_state_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestApprovalStateOutput, crate::error::UpdatePullRequestApprovalStateError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_approval_state_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_description_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestDescriptionOutput, crate::error::UpdatePullRequestDescriptionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdatePullRequestDescriptionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidDescriptionException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::InvalidDescriptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestDescriptionError { meta: generic, kind: crate::error::UpdatePullRequestDescriptionErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdatePullRequestDescriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_description_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestDescriptionOutput, crate::error::UpdatePullRequestDescriptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_description_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_pull_request_description(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_status_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestStatusOutput, crate::error::UpdatePullRequestStatusError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdatePullRequestStatusError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestStatusException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidPullRequestStatusUpdateException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::InvalidPullRequestStatusUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_status_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_status_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestStatusRequiredException" => crate::error::UpdatePullRequestStatusError { meta: generic, kind: crate::error::UpdatePullRequestStatusErrorKind::PullRequestStatusRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_status_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_status_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdatePullRequestStatusError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_status_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestStatusOutput, crate::error::UpdatePullRequestStatusError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_pull_request_status(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_title_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestTitleOutput, crate::error::UpdatePullRequestTitleError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdatePullRequestTitleError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestTitleError { meta: generic, kind: crate::error::UpdatePullRequestTitleErrorKind::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidTitleException" => crate::error::UpdatePullRequestTitleError { meta: generic, kind: crate::error::UpdatePullRequestTitleErrorKind::InvalidTitleException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_title_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_title_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestTitleError { meta: generic, kind: crate::error::UpdatePullRequestTitleErrorKind::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestTitleError { meta: generic, kind: crate::error::UpdatePullRequestTitleErrorKind::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestTitleError { meta: generic, kind: crate::error::UpdatePullRequestTitleErrorKind::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "TitleRequiredException" => crate::error::UpdatePullRequestTitleError { meta: generic, kind: crate::error::UpdatePullRequestTitleErrorKind::TitleRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::title_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_title_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdatePullRequestTitleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_title_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdatePullRequestTitleOutput, crate::error::UpdatePullRequestTitleError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_title_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_pull_request_title(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_description_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateRepositoryDescriptionOutput, crate::error::UpdateRepositoryDescriptionError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateRepositoryDescriptionError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyAccessDeniedException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyDisabledException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyNotFoundException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "EncryptionKeyUnavailableException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryDescriptionException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::InvalidRepositoryDescriptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "InvalidRepositoryNameException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::UpdateRepositoryDescriptionError { meta: generic, kind: crate::error::UpdateRepositoryDescriptionErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateRepositoryDescriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_description_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateRepositoryDescriptionOutput, crate::error::UpdateRepositoryDescriptionError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_repository_description_output::Builder::default();
        let _ = response;
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_name_error(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateRepositoryNameOutput, crate::error::UpdateRepositoryNameError> {
    let generic = crate::json_deser::parse_http_generic_error(response).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
    let error_code = match generic.code() {
                                Some(code) => code,
                                None => return Err(crate::error::UpdateRepositoryNameError::unhandled(generic))
                            };
    
                            let _error_message = generic.message().map(|msg|msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => crate::error::UpdateRepositoryNameError { meta: generic, kind: crate::error::UpdateRepositoryNameErrorKind::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryDoesNotExistException" => crate::error::UpdateRepositoryNameError { meta: generic, kind: crate::error::UpdateRepositoryNameErrorKind::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameExistsException" => crate::error::UpdateRepositoryNameError { meta: generic, kind: crate::error::UpdateRepositoryNameErrorKind::RepositoryNameExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        "RepositoryNameRequiredException" => crate::error::UpdateRepositoryNameError { meta: generic, kind: crate::error::UpdateRepositoryNameErrorKind::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        })},
        _ => crate::error::UpdateRepositoryNameError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_name_response(response: &http::Response<bytes::Bytes>) -> std::result::Result<crate::output::UpdateRepositoryNameOutput, crate::error::UpdateRepositoryNameError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_repository_name_output::Builder::default();
        let _ = response;
        output.build()
    })
}

