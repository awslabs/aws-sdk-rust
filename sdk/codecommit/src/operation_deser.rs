// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_approval_rule_template_with_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateApprovalRuleTemplateWithRepositoryOutput,
    crate::error::AssociateApprovalRuleTemplateWithRepositoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameRequiredException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateNameException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumRuleTemplatesAssociatedWithRepositoryException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::MaximumRuleTemplatesAssociatedWithRepositoryException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_rule_templates_associated_with_repository_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_rule_templates_associated_with_repository_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::AssociateApprovalRuleTemplateWithRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::AssociateApprovalRuleTemplateWithRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_associate_approval_rule_template_with_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::AssociateApprovalRuleTemplateWithRepositoryOutput,
    crate::error::AssociateApprovalRuleTemplateWithRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::associate_approval_rule_template_with_repository_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_associate_approval_rule_template_with_repositories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchAssociateApprovalRuleTemplateWithRepositoriesOutput,
    crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(
        crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled,
    )?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code =
        match generic.code() {
            Some(code) => code,
            None => return Err(
                crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled(
                    generic,
                ),
            ),
        };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameRequiredException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateNameException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumRepositoryNamesExceededException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::MaximumRepositoryNamesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_repository_names_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_names_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNamesRequiredException" => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::RepositoryNamesRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_names_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_names_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_associate_approval_rule_template_with_repositories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchAssociateApprovalRuleTemplateWithRepositoriesOutput,
    crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_associate_approval_rule_template_with_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_associate_approval_rule_template_with_repositories(response.body().as_ref(), output).map_err(crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_merge_conflicts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDescribeMergeConflictsOutput,
    crate::error::BatchDescribeMergeConflictsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::BatchDescribeMergeConflictsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::BatchDescribeMergeConflictsError::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitRequiredException" => crate::error::BatchDescribeMergeConflictsError::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchDescribeMergeConflictsError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::BatchDescribeMergeConflictsError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::BatchDescribeMergeConflictsError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::BatchDescribeMergeConflictsError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::BatchDescribeMergeConflictsError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitException" => crate::error::BatchDescribeMergeConflictsError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictDetailLevelException" => crate::error::BatchDescribeMergeConflictsError::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionStrategyException" => crate::error::BatchDescribeMergeConflictsError::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidContinuationTokenException" => crate::error::BatchDescribeMergeConflictsError::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMaxConflictFilesException" => crate::error::BatchDescribeMergeConflictsError::InvalidMaxConflictFilesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_conflict_files_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_conflict_files_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMaxMergeHunksException" => crate::error::BatchDescribeMergeConflictsError::InvalidMaxMergeHunksException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_merge_hunks_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_merge_hunks_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMergeOptionException" => crate::error::BatchDescribeMergeConflictsError::InvalidMergeOptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_merge_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::BatchDescribeMergeConflictsError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumFileContentToLoadExceededException" => crate::error::BatchDescribeMergeConflictsError::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumItemsToCompareExceededException" => crate::error::BatchDescribeMergeConflictsError::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MergeOptionRequiredException" => crate::error::BatchDescribeMergeConflictsError::MergeOptionRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_merge_option_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::BatchDescribeMergeConflictsError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::BatchDescribeMergeConflictsError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TipsDivergenceExceededException" => crate::error::BatchDescribeMergeConflictsError::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::BatchDescribeMergeConflictsError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_describe_merge_conflicts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDescribeMergeConflictsOutput,
    crate::error::BatchDescribeMergeConflictsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_describe_merge_conflicts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_describe_merge_conflicts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchDescribeMergeConflictsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_disassociate_approval_rule_template_from_repositories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput,
    crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response).map_err(
        crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled,
    )?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code =
        match generic.code() {
            Some(code) => code,
            None => return Err(
                crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled(
                    generic,
                ),
            ),
        };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameRequiredException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateNameException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumRepositoryNamesExceededException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::MaximumRepositoryNamesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_repository_names_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_names_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNamesRequiredException" => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::RepositoryNamesRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_names_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_names_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_disassociate_approval_rule_template_from_repositories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput,
    crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_disassociate_approval_rule_template_from_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_disassociate_approval_rule_template_from_repositories(response.body().as_ref(), output).map_err(crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_commits_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetCommitsOutput, crate::error::BatchGetCommitsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::BatchGetCommitsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetCommitsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitIdsLimitExceededException" => {
            crate::error::BatchGetCommitsError::CommitIdsLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_ids_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_ids_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitIdsListRequiredException" => {
            crate::error::BatchGetCommitsError::CommitIdsListRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_ids_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_ids_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::BatchGetCommitsError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::BatchGetCommitsError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::BatchGetCommitsError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::BatchGetCommitsError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::BatchGetCommitsError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::BatchGetCommitsError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::BatchGetCommitsError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::BatchGetCommitsError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetCommitsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::BatchGetCommitsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_commits_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::BatchGetCommitsOutput, crate::error::BatchGetCommitsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_commits_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_commits(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchGetCommitsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_repositories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetRepositoriesOutput,
    crate::error::BatchGetRepositoriesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::BatchGetRepositoriesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::BatchGetRepositoriesError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::BatchGetRepositoriesError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::BatchGetRepositoriesError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::BatchGetRepositoriesError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::BatchGetRepositoriesError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::BatchGetRepositoriesError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MaximumRepositoryNamesExceededException" => {
            crate::error::BatchGetRepositoriesError::MaximumRepositoryNamesExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::maximum_repository_names_exceeded_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_names_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNamesRequiredException" => {
            crate::error::BatchGetRepositoriesError::RepositoryNamesRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_names_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_names_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::BatchGetRepositoriesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_batch_get_repositories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::BatchGetRepositoriesOutput,
    crate::error::BatchGetRepositoriesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::batch_get_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_batch_get_repositories(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::BatchGetRepositoriesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_approval_rule_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateApprovalRuleTemplateOutput,
    crate::error::CreateApprovalRuleTemplateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateApprovalRuleTemplateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateContentRequiredException" => crate::error::CreateApprovalRuleTemplateError::ApprovalRuleTemplateContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameAlreadyExistsException" => crate::error::CreateApprovalRuleTemplateError::ApprovalRuleTemplateNameAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameRequiredException" => crate::error::CreateApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateContentException" => crate::error::CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateDescriptionException" => crate::error::CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateDescriptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateNameException" => crate::error::CreateApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NumberOfRuleTemplatesExceededException" => crate::error::CreateApprovalRuleTemplateError::NumberOfRuleTemplatesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::number_of_rule_templates_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_number_of_rule_templates_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_approval_rule_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateApprovalRuleTemplateOutput,
    crate::error::CreateApprovalRuleTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_approval_rule_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateApprovalRuleTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_branch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateBranchOutput, crate::error::CreateBranchError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateBranchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateBranchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchNameExistsException" => {
            crate::error::CreateBranchError::BranchNameExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameRequiredException" => {
            crate::error::CreateBranchError::BranchNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitDoesNotExistException" => {
            crate::error::CreateBranchError::CommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitIdRequiredException" => {
            crate::error::CreateBranchError::CommitIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::CreateBranchError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::CreateBranchError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::CreateBranchError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::CreateBranchError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::CreateBranchError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidBranchNameException" => {
            crate::error::CreateBranchError::InvalidBranchNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommitIdException" => crate::error::CreateBranchError::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidRepositoryNameException" => {
            crate::error::CreateBranchError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::CreateBranchError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::CreateBranchError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateBranchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_branch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateBranchOutput, crate::error::CreateBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_branch_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCommitOutput, crate::error::CreateCommitError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateCommitError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateCommitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::CreateCommitError::BranchDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameIsTagNameException" => {
            crate::error::CreateCommitError::BranchNameIsTagNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameRequiredException" => {
            crate::error::CreateCommitError::BranchNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitMessageLengthExceededException" => {
            crate::error::CreateCommitError::CommitMessageLengthExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectoryNameConflictsWithFileNameException" => {
            crate::error::CreateCommitError::DirectoryNameConflictsWithFileNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::directory_name_conflicts_with_file_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_directory_name_conflicts_with_file_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::CreateCommitError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::CreateCommitError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::CreateCommitError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::CreateCommitError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::CreateCommitError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileContentAndSourceFileSpecifiedException" => {
            crate::error::CreateCommitError::FileContentAndSourceFileSpecifiedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_and_source_file_specified_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_and_source_file_specified_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileContentSizeLimitExceededException" => {
            crate::error::CreateCommitError::FileContentSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::file_content_size_limit_exceeded_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileDoesNotExistException" => {
            crate::error::CreateCommitError::FileDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::file_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileEntryRequiredException" => {
            crate::error::CreateCommitError::FileEntryRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::file_entry_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_entry_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileModeRequiredException" => {
            crate::error::CreateCommitError::FileModeRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_mode_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileNameConflictsWithDirectoryNameException" => {
            crate::error::CreateCommitError::FileNameConflictsWithDirectoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_name_conflicts_with_directory_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_name_conflicts_with_directory_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FilePathConflictsWithSubmodulePathException" => {
            crate::error::CreateCommitError::FilePathConflictsWithSubmodulePathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_path_conflicts_with_submodule_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_path_conflicts_with_submodule_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FolderContentSizeLimitExceededException" => {
            crate::error::CreateCommitError::FolderContentSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidBranchNameException" => {
            crate::error::CreateCommitError::InvalidBranchNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDeletionParameterException" => {
            crate::error::CreateCommitError::InvalidDeletionParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_deletion_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_deletion_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidEmailException" => crate::error::CreateCommitError::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_email_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidFileModeException" => crate::error::CreateCommitError::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidParentCommitIdException" => {
            crate::error::CreateCommitError::InvalidParentCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parent_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parent_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPathException" => {
            crate::error::CreateCommitError::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::CreateCommitError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MaximumFileEntriesExceededException" => {
            crate::error::CreateCommitError::MaximumFileEntriesExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::maximum_file_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NameLengthExceededException" => {
            crate::error::CreateCommitError::NameLengthExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NoChangeException" => {
            crate::error::CreateCommitError::NoChangeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::no_change_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_no_change_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParentCommitDoesNotExistException" => {
            crate::error::CreateCommitError::ParentCommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParentCommitIdOutdatedException" => {
            crate::error::CreateCommitError::ParentCommitIdOutdatedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_outdated_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_outdated_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParentCommitIdRequiredException" => {
            crate::error::CreateCommitError::ParentCommitIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PathRequiredException" => crate::error::CreateCommitError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::path_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "PutFileEntryConflictException" => {
            crate::error::CreateCommitError::PutFileEntryConflictException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::put_file_entry_conflict_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_put_file_entry_conflict_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::CreateCommitError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::CreateCommitError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RestrictedSourceFileException" => {
            crate::error::CreateCommitError::RestrictedSourceFileException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::restricted_source_file_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_restricted_source_file_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "SamePathRequestException" => crate::error::CreateCommitError::SamePathRequestException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::same_path_request_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_same_path_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "SourceFileOrContentRequiredException" => {
            crate::error::CreateCommitError::SourceFileOrContentRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::source_file_or_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_source_file_or_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::CreateCommitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateCommitOutput, crate::error::CreateCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_commit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateCommitError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePullRequestOutput, crate::error::CreatePullRequestError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePullRequestError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreatePullRequestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClientRequestTokenRequiredException" => {
            crate::error::CreatePullRequestError::ClientRequestTokenRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_client_request_token_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::CreatePullRequestError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::CreatePullRequestError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::CreatePullRequestError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::CreatePullRequestError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::CreatePullRequestError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "IdempotencyParameterMismatchException" => {
            crate::error::CreatePullRequestError::IdempotencyParameterMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotency_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidClientRequestTokenException" => {
            crate::error::CreatePullRequestError::InvalidClientRequestTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_client_request_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDescriptionException" => {
            crate::error::CreatePullRequestError::InvalidDescriptionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidReferenceNameException" => {
            crate::error::CreatePullRequestError::InvalidReferenceNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_reference_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_reference_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::CreatePullRequestError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidTargetException" => crate::error::CreatePullRequestError::InvalidTargetException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_target_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_target_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidTargetsException" => {
            crate::error::CreatePullRequestError::InvalidTargetsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_targets_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_targets_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidTitleException" => crate::error::CreatePullRequestError::InvalidTitleException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_title_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_title_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "MaximumOpenPullRequestsExceededException" => {
            crate::error::CreatePullRequestError::MaximumOpenPullRequestsExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_open_pull_requests_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_open_pull_requests_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MultipleRepositoriesInPullRequestException" => {
            crate::error::CreatePullRequestError::MultipleRepositoriesInPullRequestException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_repositories_in_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_repositories_in_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ReferenceDoesNotExistException" => {
            crate::error::CreatePullRequestError::ReferenceDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reference_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reference_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ReferenceNameRequiredException" => {
            crate::error::CreatePullRequestError::ReferenceNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reference_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reference_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ReferenceTypeNotSupportedException" => {
            crate::error::CreatePullRequestError::ReferenceTypeNotSupportedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reference_type_not_supported_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reference_type_not_supported_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::CreatePullRequestError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::CreatePullRequestError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "SourceAndDestinationAreSameException" => {
            crate::error::CreatePullRequestError::SourceAndDestinationAreSameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::source_and_destination_are_same_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_source_and_destination_are_same_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TargetRequiredException" => {
            crate::error::CreatePullRequestError::TargetRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::target_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_target_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TargetsRequiredException" => {
            crate::error::CreatePullRequestError::TargetsRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::targets_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_targets_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TitleRequiredException" => crate::error::CreatePullRequestError::TitleRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::title_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_title_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreatePullRequestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreatePullRequestOutput, crate::error::CreatePullRequestError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_pull_request(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreatePullRequestError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_approval_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePullRequestApprovalRuleOutput,
    crate::error::CreatePullRequestApprovalRuleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreatePullRequestApprovalRuleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleContentRequiredException" => crate::error::CreatePullRequestApprovalRuleError::ApprovalRuleContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleNameAlreadyExistsException" => crate::error::CreatePullRequestApprovalRuleError::ApprovalRuleNameAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_name_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleNameRequiredException" => crate::error::CreatePullRequestApprovalRuleError::ApprovalRuleNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::CreatePullRequestApprovalRuleError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::CreatePullRequestApprovalRuleError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::CreatePullRequestApprovalRuleError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::CreatePullRequestApprovalRuleError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::CreatePullRequestApprovalRuleError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleContentException" => crate::error::CreatePullRequestApprovalRuleError::InvalidApprovalRuleContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleNameException" => crate::error::CreatePullRequestApprovalRuleError::InvalidApprovalRuleNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::CreatePullRequestApprovalRuleError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NumberOfRulesExceededException" => crate::error::CreatePullRequestApprovalRuleError::NumberOfRulesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::number_of_rules_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_number_of_rules_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestAlreadyClosedException" => crate::error::CreatePullRequestApprovalRuleError::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::CreatePullRequestApprovalRuleError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::CreatePullRequestApprovalRuleError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreatePullRequestApprovalRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_pull_request_approval_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreatePullRequestApprovalRuleOutput,
    crate::error::CreatePullRequestApprovalRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::create_pull_request_approval_rule_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_create_pull_request_approval_rule(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreatePullRequestApprovalRuleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRepositoryOutput, crate::error::CreateRepositoryError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::CreateRepositoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::CreateRepositoryError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::CreateRepositoryError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::CreateRepositoryError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::CreateRepositoryError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::CreateRepositoryError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryDescriptionException" => {
            crate::error::CreateRepositoryError::InvalidRepositoryDescriptionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::CreateRepositoryError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidSystemTagUsageException" => {
            crate::error::CreateRepositoryError::InvalidSystemTagUsageException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_system_tag_usage_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_system_tag_usage_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidTagsMapException" => {
            crate::error::CreateRepositoryError::InvalidTagsMapException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_tags_map_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_tags_map_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryLimitExceededException" => {
            crate::error::CreateRepositoryError::RepositoryLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameExistsException" => {
            crate::error::CreateRepositoryError::RepositoryNameExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::CreateRepositoryError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TagPolicyException" => {
            crate::error::CreateRepositoryError::TagPolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tag_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => crate::error::CreateRepositoryError::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_tags_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateRepositoryError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::CreateRepositoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::CreateRepositoryOutput, crate::error::CreateRepositoryError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_create_repository(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::CreateRepositoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_unreferenced_merge_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateUnreferencedMergeCommitOutput,
    crate::error::CreateUnreferencedMergeCommitError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::CreateUnreferencedMergeCommitError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::CreateUnreferencedMergeCommitError::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitMessageLengthExceededException" => crate::error::CreateUnreferencedMergeCommitError::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitRequiredException" => crate::error::CreateUnreferencedMergeCommitError::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ConcurrentReferenceUpdateException" => crate::error::CreateUnreferencedMergeCommitError::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::CreateUnreferencedMergeCommitError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::CreateUnreferencedMergeCommitError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::CreateUnreferencedMergeCommitError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::CreateUnreferencedMergeCommitError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::CreateUnreferencedMergeCommitError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FileContentSizeLimitExceededException" => crate::error::CreateUnreferencedMergeCommitError::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FileModeRequiredException" => crate::error::CreateUnreferencedMergeCommitError::FileModeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_mode_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FolderContentSizeLimitExceededException" => crate::error::CreateUnreferencedMergeCommitError::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitException" => crate::error::CreateUnreferencedMergeCommitError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictDetailLevelException" => crate::error::CreateUnreferencedMergeCommitError::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionException" => crate::error::CreateUnreferencedMergeCommitError::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionStrategyException" => crate::error::CreateUnreferencedMergeCommitError::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidEmailException" => crate::error::CreateUnreferencedMergeCommitError::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFileModeException" => crate::error::CreateUnreferencedMergeCommitError::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMergeOptionException" => crate::error::CreateUnreferencedMergeCommitError::InvalidMergeOptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_merge_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPathException" => crate::error::CreateUnreferencedMergeCommitError::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementContentException" => crate::error::CreateUnreferencedMergeCommitError::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementTypeException" => crate::error::CreateUnreferencedMergeCommitError::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::CreateUnreferencedMergeCommitError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ManualMergeRequiredException" => crate::error::CreateUnreferencedMergeCommitError::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumConflictResolutionEntriesExceededException" => crate::error::CreateUnreferencedMergeCommitError::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumFileContentToLoadExceededException" => crate::error::CreateUnreferencedMergeCommitError::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumItemsToCompareExceededException" => crate::error::CreateUnreferencedMergeCommitError::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MergeOptionRequiredException" => crate::error::CreateUnreferencedMergeCommitError::MergeOptionRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_merge_option_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MultipleConflictResolutionEntriesException" => crate::error::CreateUnreferencedMergeCommitError::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NameLengthExceededException" => crate::error::CreateUnreferencedMergeCommitError::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PathRequiredException" => crate::error::CreateUnreferencedMergeCommitError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementContentRequiredException" => crate::error::CreateUnreferencedMergeCommitError::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementTypeRequiredException" => crate::error::CreateUnreferencedMergeCommitError::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::CreateUnreferencedMergeCommitError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::CreateUnreferencedMergeCommitError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TipsDivergenceExceededException" => crate::error::CreateUnreferencedMergeCommitError::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::CreateUnreferencedMergeCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_create_unreferenced_merge_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::CreateUnreferencedMergeCommitOutput,
    crate::error::CreateUnreferencedMergeCommitError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::create_unreferenced_merge_commit_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_create_unreferenced_merge_commit(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::CreateUnreferencedMergeCommitError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_approval_rule_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteApprovalRuleTemplateOutput,
    crate::error::DeleteApprovalRuleTemplateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeleteApprovalRuleTemplateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateInUseException" => {
            crate::error::DeleteApprovalRuleTemplateError::ApprovalRuleTemplateInUseException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::approval_rule_template_in_use_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_in_use_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ApprovalRuleTemplateNameRequiredException" => {
            crate::error::DeleteApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "InvalidApprovalRuleTemplateNameException" => {
            crate::error::DeleteApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        _ => crate::error::DeleteApprovalRuleTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_approval_rule_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteApprovalRuleTemplateOutput,
    crate::error::DeleteApprovalRuleTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_approval_rule_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteApprovalRuleTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_branch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBranchOutput, crate::error::DeleteBranchError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteBranchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteBranchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchNameRequiredException" => {
            crate::error::DeleteBranchError::BranchNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DefaultBranchCannotBeDeletedException" => {
            crate::error::DeleteBranchError::DefaultBranchCannotBeDeletedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::default_branch_cannot_be_deleted_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_default_branch_cannot_be_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::DeleteBranchError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::DeleteBranchError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::DeleteBranchError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::DeleteBranchError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::DeleteBranchError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidBranchNameException" => {
            crate::error::DeleteBranchError::InvalidBranchNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::DeleteBranchError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::DeleteBranchError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::DeleteBranchError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteBranchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_branch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteBranchOutput, crate::error::DeleteBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_branch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_branch(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteBranchError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_comment_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCommentContentOutput,
    crate::error::DeleteCommentContentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteCommentContentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteCommentContentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => {
            crate::error::DeleteCommentContentError::CommentDeletedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentDoesNotExistException" => {
            crate::error::DeleteCommentContentError::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentIdRequiredException" => {
            crate::error::DeleteCommentContentError::CommentIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommentIdException" => {
            crate::error::DeleteCommentContentError::InvalidCommentIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteCommentContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteCommentContentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_comment_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeleteCommentContentOutput,
    crate::error::DeleteCommentContentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_comment_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_comment_content(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteCommentContentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_file_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFileOutput, crate::error::DeleteFileError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteFileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteFileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::DeleteFileError::BranchDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameIsTagNameException" => {
            crate::error::DeleteFileError::BranchNameIsTagNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameRequiredException" => {
            crate::error::DeleteFileError::BranchNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitMessageLengthExceededException" => {
            crate::error::DeleteFileError::CommitMessageLengthExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::DeleteFileError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::DeleteFileError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::DeleteFileError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::DeleteFileError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::DeleteFileError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileDoesNotExistException" => crate::error::DeleteFileError::FileDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::file_does_not_exist_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_file_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidBranchNameException" => {
            crate::error::DeleteFileError::InvalidBranchNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidEmailException" => crate::error::DeleteFileError::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_email_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidParentCommitIdException" => {
            crate::error::DeleteFileError::InvalidParentCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parent_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parent_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPathException" => {
            crate::error::DeleteFileError::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::DeleteFileError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NameLengthExceededException" => {
            crate::error::DeleteFileError::NameLengthExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParentCommitDoesNotExistException" => {
            crate::error::DeleteFileError::ParentCommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParentCommitIdOutdatedException" => {
            crate::error::DeleteFileError::ParentCommitIdOutdatedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_outdated_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_outdated_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParentCommitIdRequiredException" => {
            crate::error::DeleteFileError::ParentCommitIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PathRequiredException" => crate::error::DeleteFileError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::path_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "RepositoryDoesNotExistException" => {
            crate::error::DeleteFileError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::DeleteFileError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteFileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_file_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteFileOutput, crate::error::DeleteFileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_file_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_file(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteFileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pull_request_approval_rule_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePullRequestApprovalRuleOutput,
    crate::error::DeletePullRequestApprovalRuleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DeletePullRequestApprovalRuleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleNameRequiredException" => crate::error::DeletePullRequestApprovalRuleError::ApprovalRuleNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CannotDeleteApprovalRuleFromTemplateException" => crate::error::DeletePullRequestApprovalRuleError::CannotDeleteApprovalRuleFromTemplateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cannot_delete_approval_rule_from_template_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_cannot_delete_approval_rule_from_template_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::DeletePullRequestApprovalRuleError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::DeletePullRequestApprovalRuleError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::DeletePullRequestApprovalRuleError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::DeletePullRequestApprovalRuleError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::DeletePullRequestApprovalRuleError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleNameException" => crate::error::DeletePullRequestApprovalRuleError::InvalidApprovalRuleNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::DeletePullRequestApprovalRuleError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestAlreadyClosedException" => crate::error::DeletePullRequestApprovalRuleError::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::DeletePullRequestApprovalRuleError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::DeletePullRequestApprovalRuleError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DeletePullRequestApprovalRuleError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_pull_request_approval_rule_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DeletePullRequestApprovalRuleOutput,
    crate::error::DeletePullRequestApprovalRuleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::delete_pull_request_approval_rule_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_delete_pull_request_approval_rule(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::DeletePullRequestApprovalRuleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRepositoryOutput, crate::error::DeleteRepositoryError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DeleteRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::DeleteRepositoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::DeleteRepositoryError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::DeleteRepositoryError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::DeleteRepositoryError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::DeleteRepositoryError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::DeleteRepositoryError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::DeleteRepositoryError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::DeleteRepositoryError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DeleteRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DeleteRepositoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_delete_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::DeleteRepositoryOutput, crate::error::DeleteRepositoryError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::delete_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_delete_repository(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DeleteRepositoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_merge_conflicts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMergeConflictsOutput,
    crate::error::DescribeMergeConflictsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribeMergeConflictsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::DescribeMergeConflictsError::CommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitRequiredException" => {
            crate::error::DescribeMergeConflictsError::CommitRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::DescribeMergeConflictsError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::DescribeMergeConflictsError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::DescribeMergeConflictsError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::DescribeMergeConflictsError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::DescribeMergeConflictsError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileDoesNotExistException" => {
            crate::error::DescribeMergeConflictsError::FileDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::file_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommitException" => {
            crate::error::DescribeMergeConflictsError::InvalidCommitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidConflictDetailLevelException" => {
            crate::error::DescribeMergeConflictsError::InvalidConflictDetailLevelException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidConflictResolutionStrategyException" => {
            crate::error::DescribeMergeConflictsError::InvalidConflictResolutionStrategyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidContinuationTokenException" => {
            crate::error::DescribeMergeConflictsError::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidMaxMergeHunksException" => {
            crate::error::DescribeMergeConflictsError::InvalidMaxMergeHunksException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_max_merge_hunks_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_merge_hunks_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidMergeOptionException" => {
            crate::error::DescribeMergeConflictsError::InvalidMergeOptionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_merge_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPathException" => {
            crate::error::DescribeMergeConflictsError::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::DescribeMergeConflictsError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MaximumFileContentToLoadExceededException" => {
            crate::error::DescribeMergeConflictsError::MaximumFileContentToLoadExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MaximumItemsToCompareExceededException" => {
            crate::error::DescribeMergeConflictsError::MaximumItemsToCompareExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::maximum_items_to_compare_exceeded_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MergeOptionRequiredException" => {
            crate::error::DescribeMergeConflictsError::MergeOptionRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_merge_option_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PathRequiredException" => {
            crate::error::DescribeMergeConflictsError::PathRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::DescribeMergeConflictsError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::DescribeMergeConflictsError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TipsDivergenceExceededException" => {
            crate::error::DescribeMergeConflictsError::TipsDivergenceExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribeMergeConflictsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_merge_conflicts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribeMergeConflictsOutput,
    crate::error::DescribeMergeConflictsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_merge_conflicts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_merge_conflicts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribeMergeConflictsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pull_request_events_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePullRequestEventsOutput,
    crate::error::DescribePullRequestEventsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::DescribePullRequestEventsError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ActorDoesNotExistException" => {
            crate::error::DescribePullRequestEventsError::ActorDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::actor_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_actor_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::DescribePullRequestEventsError::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::DescribePullRequestEventsError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::DescribePullRequestEventsError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::DescribePullRequestEventsError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::DescribePullRequestEventsError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidActorArnException" => {
            crate::error::DescribePullRequestEventsError::InvalidActorArnException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_actor_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_actor_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidContinuationTokenException" => {
            crate::error::DescribePullRequestEventsError::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidMaxResultsException" => {
            crate::error::DescribePullRequestEventsError::InvalidMaxResultsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPullRequestEventTypeException" => {
            crate::error::DescribePullRequestEventsError::InvalidPullRequestEventTypeException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_event_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_event_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPullRequestIdException" => {
            crate::error::DescribePullRequestEventsError::InvalidPullRequestIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestDoesNotExistException" => {
            crate::error::DescribePullRequestEventsError::PullRequestDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestIdRequiredException" => {
            crate::error::DescribePullRequestEventsError::PullRequestIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::DescribePullRequestEventsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_describe_pull_request_events_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DescribePullRequestEventsOutput,
    crate::error::DescribePullRequestEventsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::describe_pull_request_events_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_describe_pull_request_events(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::DescribePullRequestEventsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_approval_rule_template_from_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateApprovalRuleTemplateFromRepositoryOutput,
    crate::error::DisassociateApprovalRuleTemplateFromRepositoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameRequiredException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateNameException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::DisassociateApprovalRuleTemplateFromRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_disassociate_approval_rule_template_from_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::DisassociateApprovalRuleTemplateFromRepositoryOutput,
    crate::error::DisassociateApprovalRuleTemplateFromRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::disassociate_approval_rule_template_from_repository_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_evaluate_pull_request_approval_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EvaluatePullRequestApprovalRulesOutput,
    crate::error::EvaluatePullRequestApprovalRulesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::EvaluatePullRequestApprovalRulesError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::EvaluatePullRequestApprovalRulesError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::EvaluatePullRequestApprovalRulesError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::EvaluatePullRequestApprovalRulesError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::EvaluatePullRequestApprovalRulesError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::EvaluatePullRequestApprovalRulesError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRevisionIdException" => crate::error::EvaluatePullRequestApprovalRulesError::InvalidRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::EvaluatePullRequestApprovalRulesError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::EvaluatePullRequestApprovalRulesError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RevisionIdRequiredException" => crate::error::EvaluatePullRequestApprovalRulesError::RevisionIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RevisionNotCurrentException" => crate::error::EvaluatePullRequestApprovalRulesError::RevisionNotCurrentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_not_current_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_not_current_exception_json_err(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::EvaluatePullRequestApprovalRulesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_evaluate_pull_request_approval_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::EvaluatePullRequestApprovalRulesOutput,
    crate::error::EvaluatePullRequestApprovalRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::evaluate_pull_request_approval_rules_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_evaluate_pull_request_approval_rules(response.body().as_ref(), output).map_err(crate::error::EvaluatePullRequestApprovalRulesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_approval_rule_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetApprovalRuleTemplateOutput,
    crate::error::GetApprovalRuleTemplateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetApprovalRuleTemplateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => {
            crate::error::GetApprovalRuleTemplateError::ApprovalRuleTemplateDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ApprovalRuleTemplateNameRequiredException" => {
            crate::error::GetApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidApprovalRuleTemplateNameException" => {
            crate::error::GetApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetApprovalRuleTemplateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_approval_rule_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetApprovalRuleTemplateOutput,
    crate::error::GetApprovalRuleTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_approval_rule_template(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetApprovalRuleTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_blob_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetBlobOutput, crate::error::GetBlobError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetBlobError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetBlobError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BlobIdDoesNotExistException" => crate::error::GetBlobError::BlobIdDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::blob_id_does_not_exist_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_blob_id_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "BlobIdRequiredException" => crate::error::GetBlobError::BlobIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::blob_id_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_blob_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetBlobError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetBlobError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetBlobError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetBlobError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetBlobError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileTooLargeException" => crate::error::GetBlobError::FileTooLargeException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::file_too_large_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_file_too_large_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidBlobIdException" => crate::error::GetBlobError::InvalidBlobIdException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_blob_id_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_blob_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidRepositoryNameException" => {
            crate::error::GetBlobError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::GetBlobError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetBlobError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBlobError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetBlobError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_blob_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetBlobOutput, crate::error::GetBlobError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_blob_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_blob(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBlobError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_branch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetBranchOutput, crate::error::GetBranchError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetBranchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetBranchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::GetBranchError::BranchDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameRequiredException" => {
            crate::error::GetBranchError::BranchNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetBranchError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetBranchError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetBranchError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetBranchError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetBranchError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidBranchNameException" => crate::error::GetBranchError::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidRepositoryNameException" => {
            crate::error::GetBranchError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::GetBranchError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetBranchError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetBranchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_branch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetBranchOutput, crate::error::GetBranchError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_branch_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_branch(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetBranchError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCommentOutput, crate::error::GetCommentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCommentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCommentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => crate::error::GetCommentError::CommentDeletedException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::comment_deleted_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CommentDoesNotExistException" => {
            crate::error::GetCommentError::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentIdRequiredException" => {
            crate::error::GetCommentError::CommentIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetCommentError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetCommentError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetCommentError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetCommentError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetCommentError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommentIdException" => crate::error::GetCommentError::InvalidCommentIdException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::GetCommentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCommentOutput, crate::error::GetCommentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_comment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCommentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_reactions_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentReactionsOutput,
    crate::error::GetCommentReactionsError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCommentReactionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCommentReactionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => {
            crate::error::GetCommentReactionsError::CommentDeletedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentDoesNotExistException" => {
            crate::error::GetCommentReactionsError::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentIdRequiredException" => {
            crate::error::GetCommentReactionsError::CommentIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommentIdException" => {
            crate::error::GetCommentReactionsError::InvalidCommentIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidContinuationTokenException" => {
            crate::error::GetCommentReactionsError::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidMaxResultsException" => {
            crate::error::GetCommentReactionsError::InvalidMaxResultsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidReactionUserArnException" => {
            crate::error::GetCommentReactionsError::InvalidReactionUserArnException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_reaction_user_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_reaction_user_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentReactionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetCommentReactionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comment_reactions_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentReactionsOutput,
    crate::error::GetCommentReactionsError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comment_reactions_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_comment_reactions(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCommentReactionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_compared_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentsForComparedCommitOutput,
    crate::error::GetCommentsForComparedCommitError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetCommentsForComparedCommitError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetCommentsForComparedCommitError::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitIdRequiredException" => crate::error::GetCommentsForComparedCommitError::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommentsForComparedCommitError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommentsForComparedCommitError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::GetCommentsForComparedCommitError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::GetCommentsForComparedCommitError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::GetCommentsForComparedCommitError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitIdException" => crate::error::GetCommentsForComparedCommitError::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidContinuationTokenException" => crate::error::GetCommentsForComparedCommitError::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMaxResultsException" => crate::error::GetCommentsForComparedCommitError::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::GetCommentsForComparedCommitError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::GetCommentsForComparedCommitError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::GetCommentsForComparedCommitError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetCommentsForComparedCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_compared_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentsForComparedCommitOutput,
    crate::error::GetCommentsForComparedCommitError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comments_for_compared_commit_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_get_comments_for_compared_commit(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetCommentsForComparedCommitError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_pull_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentsForPullRequestOutput,
    crate::error::GetCommentsForPullRequestError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetCommentsForPullRequestError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetCommentsForPullRequestError::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitIdRequiredException" => crate::error::GetCommentsForPullRequestError::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::GetCommentsForPullRequestError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::GetCommentsForPullRequestError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::GetCommentsForPullRequestError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::GetCommentsForPullRequestError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::GetCommentsForPullRequestError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitIdException" => crate::error::GetCommentsForPullRequestError::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidContinuationTokenException" => crate::error::GetCommentsForPullRequestError::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMaxResultsException" => crate::error::GetCommentsForPullRequestError::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::GetCommentsForPullRequestError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::GetCommentsForPullRequestError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::GetCommentsForPullRequestError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::GetCommentsForPullRequestError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::GetCommentsForPullRequestError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::GetCommentsForPullRequestError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::GetCommentsForPullRequestError::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetCommentsForPullRequestError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_comments_for_pull_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetCommentsForPullRequestOutput,
    crate::error::GetCommentsForPullRequestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_comments_for_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_comments_for_pull_request(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCommentsForPullRequestError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCommitOutput, crate::error::GetCommitError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetCommitError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetCommitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitIdDoesNotExistException" => {
            crate::error::GetCommitError::CommitIdDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_id_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitIdRequiredException" => crate::error::GetCommitError::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::commit_id_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetCommitError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetCommitError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetCommitError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetCommitError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetCommitError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommitIdException" => crate::error::GetCommitError::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidRepositoryNameException" => {
            crate::error::GetCommitError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::GetCommitError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetCommitError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetCommitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetCommitOutput, crate::error::GetCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_commit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetCommitError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_differences_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDifferencesOutput, crate::error::GetDifferencesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetDifferencesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetDifferencesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetDifferencesError::CommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitRequiredException" => crate::error::GetDifferencesError::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::commit_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetDifferencesError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetDifferencesError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetDifferencesError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetDifferencesError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetDifferencesError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommitException" => crate::error::GetDifferencesError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_commit_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidCommitIdException" => {
            crate::error::GetDifferencesError::InvalidCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidContinuationTokenException" => {
            crate::error::GetDifferencesError::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidMaxResultsException" => {
            crate::error::GetDifferencesError::InvalidMaxResultsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPathException" => {
            crate::error::GetDifferencesError::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::GetDifferencesError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PathDoesNotExistException" => {
            crate::error::GetDifferencesError::PathDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::path_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::GetDifferencesError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetDifferencesError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetDifferencesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetDifferencesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_differences_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetDifferencesOutput, crate::error::GetDifferencesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_differences_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_differences(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetDifferencesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_file_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFileOutput, crate::error::GetFileError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetFileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => crate::error::GetFileError::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetFileError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetFileError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetFileError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetFileError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetFileError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileDoesNotExistException" => crate::error::GetFileError::FileDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::file_does_not_exist_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_file_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "FileTooLargeException" => crate::error::GetFileError::FileTooLargeException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::file_too_large_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_file_too_large_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidCommitException" => crate::error::GetFileError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_commit_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidPathException" => {
            crate::error::GetFileError::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::GetFileError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PathRequiredException" => crate::error::GetFileError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::path_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "RepositoryDoesNotExistException" => {
            crate::error::GetFileError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetFileError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetFileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_file_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFileOutput, crate::error::GetFileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_file_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_file(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetFileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFolderOutput, crate::error::GetFolderError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetFolderError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetFolderError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetFolderError::CommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetFolderError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetFolderError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetFolderError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetFolderError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetFolderError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FolderDoesNotExistException" => {
            crate::error::GetFolderError::FolderDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::folder_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommitException" => crate::error::GetFolderError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_commit_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidPathException" => {
            crate::error::GetFolderError::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::GetFolderError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PathRequiredException" => crate::error::GetFolderError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::path_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "RepositoryDoesNotExistException" => {
            crate::error::GetFolderError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetFolderError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetFolderError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetFolderError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_folder_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetFolderOutput, crate::error::GetFolderError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_folder_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_folder(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetFolderError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeCommitOutput, crate::error::GetMergeCommitError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetMergeCommitError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMergeCommitError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetMergeCommitError::CommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitRequiredException" => crate::error::GetMergeCommitError::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::commit_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetMergeCommitError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetMergeCommitError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetMergeCommitError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetMergeCommitError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetMergeCommitError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommitException" => crate::error::GetMergeCommitError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_commit_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidConflictDetailLevelException" => {
            crate::error::GetMergeCommitError::InvalidConflictDetailLevelException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidConflictResolutionStrategyException" => {
            crate::error::GetMergeCommitError::InvalidConflictResolutionStrategyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::GetMergeCommitError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::GetMergeCommitError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetMergeCommitError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetMergeCommitError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeCommitOutput, crate::error::GetMergeCommitError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_merge_commit_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_merge_commit(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetMergeCommitError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_conflicts_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeConflictsOutput, crate::error::GetMergeConflictsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetMergeConflictsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMergeConflictsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetMergeConflictsError::CommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitRequiredException" => {
            crate::error::GetMergeConflictsError::CommitRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetMergeConflictsError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetMergeConflictsError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetMergeConflictsError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetMergeConflictsError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetMergeConflictsError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommitException" => crate::error::GetMergeConflictsError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_commit_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidConflictDetailLevelException" => {
            crate::error::GetMergeConflictsError::InvalidConflictDetailLevelException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidConflictResolutionStrategyException" => {
            crate::error::GetMergeConflictsError::InvalidConflictResolutionStrategyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidContinuationTokenException" => {
            crate::error::GetMergeConflictsError::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidDestinationCommitSpecifierException" => {
            crate::error::GetMergeConflictsError::InvalidDestinationCommitSpecifierException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_destination_commit_specifier_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_destination_commit_specifier_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidMaxConflictFilesException" => {
            crate::error::GetMergeConflictsError::InvalidMaxConflictFilesException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_max_conflict_files_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_conflict_files_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidMergeOptionException" => {
            crate::error::GetMergeConflictsError::InvalidMergeOptionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_merge_option_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_merge_option_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::GetMergeConflictsError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidSourceCommitSpecifierException" => {
            crate::error::GetMergeConflictsError::InvalidSourceCommitSpecifierException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_source_commit_specifier_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_source_commit_specifier_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MaximumFileContentToLoadExceededException" => {
            crate::error::GetMergeConflictsError::MaximumFileContentToLoadExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MaximumItemsToCompareExceededException" => {
            crate::error::GetMergeConflictsError::MaximumItemsToCompareExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::maximum_items_to_compare_exceeded_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MergeOptionRequiredException" => {
            crate::error::GetMergeConflictsError::MergeOptionRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::merge_option_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_merge_option_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::GetMergeConflictsError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetMergeConflictsError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TipsDivergenceExceededException" => {
            crate::error::GetMergeConflictsError::TipsDivergenceExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeConflictsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetMergeConflictsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_conflicts_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeConflictsOutput, crate::error::GetMergeConflictsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_merge_conflicts_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_merge_conflicts(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetMergeConflictsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_options_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeOptionsOutput, crate::error::GetMergeOptionsError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetMergeOptionsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetMergeOptionsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitDoesNotExistException" => {
            crate::error::GetMergeOptionsError::CommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitRequiredException" => crate::error::GetMergeOptionsError::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::commit_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetMergeOptionsError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetMergeOptionsError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetMergeOptionsError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetMergeOptionsError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetMergeOptionsError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommitException" => crate::error::GetMergeOptionsError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_commit_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidConflictDetailLevelException" => {
            crate::error::GetMergeOptionsError::InvalidConflictDetailLevelException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidConflictResolutionStrategyException" => {
            crate::error::GetMergeOptionsError::InvalidConflictResolutionStrategyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::GetMergeOptionsError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MaximumFileContentToLoadExceededException" => {
            crate::error::GetMergeOptionsError::MaximumFileContentToLoadExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "MaximumItemsToCompareExceededException" => {
            crate::error::GetMergeOptionsError::MaximumItemsToCompareExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::maximum_items_to_compare_exceeded_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::GetMergeOptionsError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetMergeOptionsError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TipsDivergenceExceededException" => {
            crate::error::GetMergeOptionsError::TipsDivergenceExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetMergeOptionsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetMergeOptionsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_merge_options_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetMergeOptionsOutput, crate::error::GetMergeOptionsError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_merge_options_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_merge_options(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetMergeOptionsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPullRequestOutput, crate::error::GetPullRequestError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetPullRequestError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetPullRequestError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetPullRequestError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetPullRequestError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetPullRequestError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetPullRequestError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetPullRequestError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPullRequestIdException" => {
            crate::error::GetPullRequestError::InvalidPullRequestIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestDoesNotExistException" => {
            crate::error::GetPullRequestError::PullRequestDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestIdRequiredException" => {
            crate::error::GetPullRequestError::PullRequestIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetPullRequestError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetPullRequestOutput, crate::error::GetPullRequestError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_pull_request(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetPullRequestError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_approval_states_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPullRequestApprovalStatesOutput,
    crate::error::GetPullRequestApprovalStatesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetPullRequestApprovalStatesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::GetPullRequestApprovalStatesError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::GetPullRequestApprovalStatesError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::GetPullRequestApprovalStatesError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::GetPullRequestApprovalStatesError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::GetPullRequestApprovalStatesError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::GetPullRequestApprovalStatesError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRevisionIdException" => crate::error::GetPullRequestApprovalStatesError::InvalidRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::GetPullRequestApprovalStatesError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::GetPullRequestApprovalStatesError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RevisionIdRequiredException" => crate::error::GetPullRequestApprovalStatesError::RevisionIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::GetPullRequestApprovalStatesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_approval_states_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPullRequestApprovalStatesOutput,
    crate::error::GetPullRequestApprovalStatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_pull_request_approval_states_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_get_pull_request_approval_states(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetPullRequestApprovalStatesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_override_state_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPullRequestOverrideStateOutput,
    crate::error::GetPullRequestOverrideStateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::GetPullRequestOverrideStateError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetPullRequestOverrideStateError::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetPullRequestOverrideStateError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetPullRequestOverrideStateError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetPullRequestOverrideStateError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetPullRequestOverrideStateError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPullRequestIdException" => {
            crate::error::GetPullRequestOverrideStateError::InvalidPullRequestIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRevisionIdException" => {
            crate::error::GetPullRequestOverrideStateError::InvalidRevisionIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestDoesNotExistException" => {
            crate::error::GetPullRequestOverrideStateError::PullRequestDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestIdRequiredException" => {
            crate::error::GetPullRequestOverrideStateError::PullRequestIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RevisionIdRequiredException" => {
            crate::error::GetPullRequestOverrideStateError::RevisionIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetPullRequestOverrideStateError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_pull_request_override_state_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetPullRequestOverrideStateOutput,
    crate::error::GetPullRequestOverrideStateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_pull_request_override_state_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_get_pull_request_override_state(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::GetPullRequestOverrideStateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRepositoryOutput, crate::error::GetRepositoryError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRepositoryError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetRepositoryError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetRepositoryError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetRepositoryError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetRepositoryError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetRepositoryError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::GetRepositoryError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::GetRepositoryError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetRepositoryError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetRepositoryError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::GetRepositoryOutput, crate::error::GetRepositoryError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_repository(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRepositoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_triggers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRepositoryTriggersOutput,
    crate::error::GetRepositoryTriggersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::GetRepositoryTriggersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::GetRepositoryTriggersError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::GetRepositoryTriggersError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::GetRepositoryTriggersError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::GetRepositoryTriggersError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::GetRepositoryTriggersError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::GetRepositoryTriggersError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::GetRepositoryTriggersError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::GetRepositoryTriggersError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::GetRepositoryTriggersError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_get_repository_triggers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::GetRepositoryTriggersOutput,
    crate::error::GetRepositoryTriggersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::get_repository_triggers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_get_repository_triggers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::GetRepositoryTriggersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_approval_rule_templates_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListApprovalRuleTemplatesOutput,
    crate::error::ListApprovalRuleTemplatesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::ListApprovalRuleTemplatesError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidContinuationTokenException" => {
            crate::error::ListApprovalRuleTemplatesError::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidMaxResultsException" => {
            crate::error::ListApprovalRuleTemplatesError::InvalidMaxResultsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListApprovalRuleTemplatesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_approval_rule_templates_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListApprovalRuleTemplatesOutput,
    crate::error::ListApprovalRuleTemplatesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_approval_rule_templates_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_approval_rule_templates(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListApprovalRuleTemplatesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associated_approval_rule_templates_for_repository_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAssociatedApprovalRuleTemplatesForRepositoryOutput,
    crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled(
                    generic,
                ),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidContinuationTokenException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMaxResultsException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_associated_approval_rule_templates_for_repository_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListAssociatedApprovalRuleTemplatesForRepositoryOutput,
    crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_associated_approval_rule_templates_for_repository_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_associated_approval_rule_templates_for_repository(response.body().as_ref(), output).map_err(crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_branches_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListBranchesOutput, crate::error::ListBranchesError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListBranchesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListBranchesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::ListBranchesError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::ListBranchesError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::ListBranchesError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::ListBranchesError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::ListBranchesError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidContinuationTokenException" => {
            crate::error::ListBranchesError::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::ListBranchesError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::ListBranchesError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::ListBranchesError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListBranchesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListBranchesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_branches_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListBranchesOutput, crate::error::ListBranchesError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_branches_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_branches(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListBranchesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pull_requests_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPullRequestsOutput, crate::error::ListPullRequestsError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListPullRequestsError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListPullRequestsError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "AuthorDoesNotExistException" => {
            crate::error::ListPullRequestsError::AuthorDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::author_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_author_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::ListPullRequestsError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::ListPullRequestsError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::ListPullRequestsError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::ListPullRequestsError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::ListPullRequestsError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidAuthorArnException" => {
            crate::error::ListPullRequestsError::InvalidAuthorArnException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_author_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_author_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidContinuationTokenException" => {
            crate::error::ListPullRequestsError::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidMaxResultsException" => {
            crate::error::ListPullRequestsError::InvalidMaxResultsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPullRequestStatusException" => {
            crate::error::ListPullRequestsError::InvalidPullRequestStatusException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::ListPullRequestsError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::ListPullRequestsError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::ListPullRequestsError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListPullRequestsError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListPullRequestsError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_pull_requests_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListPullRequestsOutput, crate::error::ListPullRequestsError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_pull_requests_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_pull_requests(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListPullRequestsError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRepositoriesOutput, crate::error::ListRepositoriesError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListRepositoriesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListRepositoriesError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidContinuationTokenException" => {
            crate::error::ListRepositoriesError::InvalidContinuationTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidOrderException" => crate::error::ListRepositoriesError::InvalidOrderException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_order_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_order_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidSortByException" => crate::error::ListRepositoriesError::InvalidSortByException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_sort_by_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_sort_by_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::ListRepositoriesError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::ListRepositoriesOutput, crate::error::ListRepositoriesError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_repositories_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_repositories(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListRepositoriesError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_for_approval_rule_template_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRepositoriesForApprovalRuleTemplateOutput,
    crate::error::ListRepositoriesForApprovalRuleTemplateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameRequiredException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateNameException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidContinuationTokenException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::InvalidContinuationTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_continuation_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_continuation_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidMaxResultsException" => crate::error::ListRepositoriesForApprovalRuleTemplateError::InvalidMaxResultsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_max_results_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_max_results_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::ListRepositoriesForApprovalRuleTemplateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_repositories_for_approval_rule_template_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListRepositoriesForApprovalRuleTemplateOutput,
    crate::error::ListRepositoriesForApprovalRuleTemplateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::list_repositories_for_approval_rule_template_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_repositories_for_approval_rule_template(response.body().as_ref(), output).map_err(crate::error::ListRepositoriesForApprovalRuleTemplateError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::ListTagsForResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => {
            crate::error::ListTagsForResourceError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceArnException" => {
            crate::error::ListTagsForResourceError::InvalidResourceArnException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_resource_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::ListTagsForResourceError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceArnRequiredException" => {
            crate::error::ListTagsForResourceError::ResourceArnRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::ListTagsForResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::ListTagsForResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_list_tags_for_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::ListTagsForResourceOutput,
    crate::error::ListTagsForResourceError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::list_tags_for_resource_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_list_tags_for_resource(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::ListTagsForResourceError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_fast_forward_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesByFastForwardOutput,
    crate::error::MergeBranchesByFastForwardError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergeBranchesByFastForwardError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::MergeBranchesByFastForwardError::BranchDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameIsTagNameException" => {
            crate::error::MergeBranchesByFastForwardError::BranchNameIsTagNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameRequiredException" => {
            crate::error::MergeBranchesByFastForwardError::BranchNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitDoesNotExistException" => {
            crate::error::MergeBranchesByFastForwardError::CommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommitRequiredException" => {
            crate::error::MergeBranchesByFastForwardError::CommitRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ConcurrentReferenceUpdateException" => {
            crate::error::MergeBranchesByFastForwardError::ConcurrentReferenceUpdateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::MergeBranchesByFastForwardError::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::MergeBranchesByFastForwardError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::MergeBranchesByFastForwardError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::MergeBranchesByFastForwardError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::MergeBranchesByFastForwardError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidBranchNameException" => {
            crate::error::MergeBranchesByFastForwardError::InvalidBranchNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommitException" => {
            crate::error::MergeBranchesByFastForwardError::InvalidCommitException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::MergeBranchesByFastForwardError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidTargetBranchException" => {
            crate::error::MergeBranchesByFastForwardError::InvalidTargetBranchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_target_branch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_branch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ManualMergeRequiredException" => {
            crate::error::MergeBranchesByFastForwardError::ManualMergeRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::MergeBranchesByFastForwardError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::MergeBranchesByFastForwardError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TipsDivergenceExceededException" => {
            crate::error::MergeBranchesByFastForwardError::TipsDivergenceExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::MergeBranchesByFastForwardError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_fast_forward_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesByFastForwardOutput,
    crate::error::MergeBranchesByFastForwardError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_branches_by_fast_forward_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_branches_by_fast_forward(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergeBranchesByFastForwardError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_squash_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesBySquashOutput,
    crate::error::MergeBranchesBySquashError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::MergeBranchesBySquashError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::MergeBranchesBySquashError::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "BranchNameIsTagNameException" => crate::error::MergeBranchesBySquashError::BranchNameIsTagNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "BranchNameRequiredException" => crate::error::MergeBranchesBySquashError::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitDoesNotExistException" => crate::error::MergeBranchesBySquashError::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitMessageLengthExceededException" => crate::error::MergeBranchesBySquashError::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitRequiredException" => crate::error::MergeBranchesBySquashError::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ConcurrentReferenceUpdateException" => crate::error::MergeBranchesBySquashError::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::MergeBranchesBySquashError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::MergeBranchesBySquashError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::MergeBranchesBySquashError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::MergeBranchesBySquashError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::MergeBranchesBySquashError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FileContentSizeLimitExceededException" => crate::error::MergeBranchesBySquashError::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FileModeRequiredException" => crate::error::MergeBranchesBySquashError::FileModeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_mode_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FolderContentSizeLimitExceededException" => crate::error::MergeBranchesBySquashError::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidBranchNameException" => crate::error::MergeBranchesBySquashError::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitException" => crate::error::MergeBranchesBySquashError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictDetailLevelException" => crate::error::MergeBranchesBySquashError::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionException" => crate::error::MergeBranchesBySquashError::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionStrategyException" => crate::error::MergeBranchesBySquashError::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidEmailException" => crate::error::MergeBranchesBySquashError::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFileModeException" => crate::error::MergeBranchesBySquashError::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPathException" => crate::error::MergeBranchesBySquashError::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementContentException" => crate::error::MergeBranchesBySquashError::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementTypeException" => crate::error::MergeBranchesBySquashError::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::MergeBranchesBySquashError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTargetBranchException" => crate::error::MergeBranchesBySquashError::InvalidTargetBranchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_branch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_branch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ManualMergeRequiredException" => crate::error::MergeBranchesBySquashError::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergeBranchesBySquashError::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumFileContentToLoadExceededException" => crate::error::MergeBranchesBySquashError::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumItemsToCompareExceededException" => crate::error::MergeBranchesBySquashError::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MultipleConflictResolutionEntriesException" => crate::error::MergeBranchesBySquashError::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NameLengthExceededException" => crate::error::MergeBranchesBySquashError::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PathRequiredException" => crate::error::MergeBranchesBySquashError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementContentRequiredException" => crate::error::MergeBranchesBySquashError::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementTypeRequiredException" => crate::error::MergeBranchesBySquashError::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::MergeBranchesBySquashError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::MergeBranchesBySquashError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TipsDivergenceExceededException" => crate::error::MergeBranchesBySquashError::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::MergeBranchesBySquashError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_squash_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesBySquashOutput,
    crate::error::MergeBranchesBySquashError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_branches_by_squash_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_branches_by_squash(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergeBranchesBySquashError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_three_way_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesByThreeWayOutput,
    crate::error::MergeBranchesByThreeWayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergeBranchesByThreeWayError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::MergeBranchesByThreeWayError::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "BranchNameIsTagNameException" => crate::error::MergeBranchesByThreeWayError::BranchNameIsTagNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "BranchNameRequiredException" => crate::error::MergeBranchesByThreeWayError::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitDoesNotExistException" => crate::error::MergeBranchesByThreeWayError::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitMessageLengthExceededException" => crate::error::MergeBranchesByThreeWayError::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitRequiredException" => crate::error::MergeBranchesByThreeWayError::CommitRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ConcurrentReferenceUpdateException" => crate::error::MergeBranchesByThreeWayError::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::MergeBranchesByThreeWayError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::MergeBranchesByThreeWayError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::MergeBranchesByThreeWayError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::MergeBranchesByThreeWayError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::MergeBranchesByThreeWayError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FileContentSizeLimitExceededException" => crate::error::MergeBranchesByThreeWayError::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FileModeRequiredException" => crate::error::MergeBranchesByThreeWayError::FileModeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_mode_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_mode_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FolderContentSizeLimitExceededException" => crate::error::MergeBranchesByThreeWayError::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidBranchNameException" => crate::error::MergeBranchesByThreeWayError::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitException" => crate::error::MergeBranchesByThreeWayError::InvalidCommitException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictDetailLevelException" => crate::error::MergeBranchesByThreeWayError::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionException" => crate::error::MergeBranchesByThreeWayError::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionStrategyException" => crate::error::MergeBranchesByThreeWayError::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidEmailException" => crate::error::MergeBranchesByThreeWayError::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFileModeException" => crate::error::MergeBranchesByThreeWayError::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPathException" => crate::error::MergeBranchesByThreeWayError::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementContentException" => crate::error::MergeBranchesByThreeWayError::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementTypeException" => crate::error::MergeBranchesByThreeWayError::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::MergeBranchesByThreeWayError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidTargetBranchException" => crate::error::MergeBranchesByThreeWayError::InvalidTargetBranchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_target_branch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_target_branch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ManualMergeRequiredException" => crate::error::MergeBranchesByThreeWayError::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergeBranchesByThreeWayError::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumFileContentToLoadExceededException" => crate::error::MergeBranchesByThreeWayError::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumItemsToCompareExceededException" => crate::error::MergeBranchesByThreeWayError::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MultipleConflictResolutionEntriesException" => crate::error::MergeBranchesByThreeWayError::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NameLengthExceededException" => crate::error::MergeBranchesByThreeWayError::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PathRequiredException" => crate::error::MergeBranchesByThreeWayError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementContentRequiredException" => crate::error::MergeBranchesByThreeWayError::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementTypeRequiredException" => crate::error::MergeBranchesByThreeWayError::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::MergeBranchesByThreeWayError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::MergeBranchesByThreeWayError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TipsDivergenceExceededException" => crate::error::MergeBranchesByThreeWayError::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::MergeBranchesByThreeWayError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_branches_by_three_way_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergeBranchesByThreeWayOutput,
    crate::error::MergeBranchesByThreeWayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_branches_by_three_way_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_branches_by_three_way(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergeBranchesByThreeWayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_fast_forward_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestByFastForwardOutput,
    crate::error::MergePullRequestByFastForwardError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergePullRequestByFastForwardError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ConcurrentReferenceUpdateException" => crate::error::MergePullRequestByFastForwardError::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::MergePullRequestByFastForwardError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::MergePullRequestByFastForwardError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::MergePullRequestByFastForwardError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::MergePullRequestByFastForwardError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::MergePullRequestByFastForwardError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitIdException" => crate::error::MergePullRequestByFastForwardError::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::MergePullRequestByFastForwardError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::MergePullRequestByFastForwardError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ManualMergeRequiredException" => crate::error::MergePullRequestByFastForwardError::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestAlreadyClosedException" => crate::error::MergePullRequestByFastForwardError::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestApprovalRulesNotSatisfiedException" => crate::error::MergePullRequestByFastForwardError::PullRequestApprovalRulesNotSatisfiedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_approval_rules_not_satisfied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::MergePullRequestByFastForwardError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::MergePullRequestByFastForwardError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReferenceDoesNotExistException" => crate::error::MergePullRequestByFastForwardError::ReferenceDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::reference_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reference_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::MergePullRequestByFastForwardError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::MergePullRequestByFastForwardError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::MergePullRequestByFastForwardError::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TipOfSourceReferenceIsDifferentException" => crate::error::MergePullRequestByFastForwardError::TipOfSourceReferenceIsDifferentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tip_of_source_reference_is_different_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tip_of_source_reference_is_different_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::MergePullRequestByFastForwardError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_fast_forward_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestByFastForwardOutput,
    crate::error::MergePullRequestByFastForwardError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::merge_pull_request_by_fast_forward_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_merge_pull_request_by_fast_forward(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::MergePullRequestByFastForwardError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_squash_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestBySquashOutput,
    crate::error::MergePullRequestBySquashError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergePullRequestBySquashError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitMessageLengthExceededException" => crate::error::MergePullRequestBySquashError::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ConcurrentReferenceUpdateException" => crate::error::MergePullRequestBySquashError::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::MergePullRequestBySquashError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::MergePullRequestBySquashError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::MergePullRequestBySquashError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::MergePullRequestBySquashError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::MergePullRequestBySquashError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FileContentSizeLimitExceededException" => crate::error::MergePullRequestBySquashError::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FolderContentSizeLimitExceededException" => crate::error::MergePullRequestBySquashError::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitIdException" => crate::error::MergePullRequestBySquashError::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictDetailLevelException" => crate::error::MergePullRequestBySquashError::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionException" => crate::error::MergePullRequestBySquashError::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionStrategyException" => crate::error::MergePullRequestBySquashError::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidEmailException" => crate::error::MergePullRequestBySquashError::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFileModeException" => crate::error::MergePullRequestBySquashError::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPathException" => crate::error::MergePullRequestBySquashError::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::MergePullRequestBySquashError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementContentException" => crate::error::MergePullRequestBySquashError::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementTypeException" => crate::error::MergePullRequestBySquashError::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::MergePullRequestBySquashError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ManualMergeRequiredException" => crate::error::MergePullRequestBySquashError::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergePullRequestBySquashError::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumFileContentToLoadExceededException" => crate::error::MergePullRequestBySquashError::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumItemsToCompareExceededException" => crate::error::MergePullRequestBySquashError::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MultipleConflictResolutionEntriesException" => crate::error::MergePullRequestBySquashError::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NameLengthExceededException" => crate::error::MergePullRequestBySquashError::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PathRequiredException" => crate::error::MergePullRequestBySquashError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestAlreadyClosedException" => crate::error::MergePullRequestBySquashError::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestApprovalRulesNotSatisfiedException" => crate::error::MergePullRequestBySquashError::PullRequestApprovalRulesNotSatisfiedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_approval_rules_not_satisfied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::MergePullRequestBySquashError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::MergePullRequestBySquashError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementContentRequiredException" => crate::error::MergePullRequestBySquashError::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementTypeRequiredException" => crate::error::MergePullRequestBySquashError::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::MergePullRequestBySquashError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::MergePullRequestBySquashError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::MergePullRequestBySquashError::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TipOfSourceReferenceIsDifferentException" => crate::error::MergePullRequestBySquashError::TipOfSourceReferenceIsDifferentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tip_of_source_reference_is_different_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tip_of_source_reference_is_different_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TipsDivergenceExceededException" => crate::error::MergePullRequestBySquashError::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::MergePullRequestBySquashError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_squash_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestBySquashOutput,
    crate::error::MergePullRequestBySquashError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_pull_request_by_squash_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_merge_pull_request_by_squash(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::MergePullRequestBySquashError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_three_way_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestByThreeWayOutput,
    crate::error::MergePullRequestByThreeWayError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::MergePullRequestByThreeWayError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommitMessageLengthExceededException" => crate::error::MergePullRequestByThreeWayError::CommitMessageLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ConcurrentReferenceUpdateException" => crate::error::MergePullRequestByThreeWayError::ConcurrentReferenceUpdateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::concurrent_reference_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_concurrent_reference_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::MergePullRequestByThreeWayError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::MergePullRequestByThreeWayError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::MergePullRequestByThreeWayError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::MergePullRequestByThreeWayError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::MergePullRequestByThreeWayError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FileContentSizeLimitExceededException" => crate::error::MergePullRequestByThreeWayError::FileContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "FolderContentSizeLimitExceededException" => crate::error::MergePullRequestByThreeWayError::FolderContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitIdException" => crate::error::MergePullRequestByThreeWayError::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictDetailLevelException" => crate::error::MergePullRequestByThreeWayError::InvalidConflictDetailLevelException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_detail_level_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_detail_level_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionException" => crate::error::MergePullRequestByThreeWayError::InvalidConflictResolutionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidConflictResolutionStrategyException" => crate::error::MergePullRequestByThreeWayError::InvalidConflictResolutionStrategyException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_conflict_resolution_strategy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_conflict_resolution_strategy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidEmailException" => crate::error::MergePullRequestByThreeWayError::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_email_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFileModeException" => crate::error::MergePullRequestByThreeWayError::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPathException" => crate::error::MergePullRequestByThreeWayError::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::MergePullRequestByThreeWayError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementContentException" => crate::error::MergePullRequestByThreeWayError::InvalidReplacementContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidReplacementTypeException" => crate::error::MergePullRequestByThreeWayError::InvalidReplacementTypeException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_replacement_type_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_replacement_type_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::MergePullRequestByThreeWayError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ManualMergeRequiredException" => crate::error::MergePullRequestByThreeWayError::ManualMergeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::manual_merge_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_manual_merge_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumConflictResolutionEntriesExceededException" => crate::error::MergePullRequestByThreeWayError::MaximumConflictResolutionEntriesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_conflict_resolution_entries_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_conflict_resolution_entries_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumFileContentToLoadExceededException" => crate::error::MergePullRequestByThreeWayError::MaximumFileContentToLoadExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_file_content_to_load_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_file_content_to_load_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumItemsToCompareExceededException" => crate::error::MergePullRequestByThreeWayError::MaximumItemsToCompareExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_items_to_compare_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_items_to_compare_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MultipleConflictResolutionEntriesException" => crate::error::MergePullRequestByThreeWayError::MultipleConflictResolutionEntriesException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::multiple_conflict_resolution_entries_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_multiple_conflict_resolution_entries_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "NameLengthExceededException" => crate::error::MergePullRequestByThreeWayError::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PathRequiredException" => crate::error::MergePullRequestByThreeWayError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestAlreadyClosedException" => crate::error::MergePullRequestByThreeWayError::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestApprovalRulesNotSatisfiedException" => crate::error::MergePullRequestByThreeWayError::PullRequestApprovalRulesNotSatisfiedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_approval_rules_not_satisfied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_approval_rules_not_satisfied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::MergePullRequestByThreeWayError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::MergePullRequestByThreeWayError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementContentRequiredException" => crate::error::MergePullRequestByThreeWayError::ReplacementContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ReplacementTypeRequiredException" => crate::error::MergePullRequestByThreeWayError::ReplacementTypeRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::replacement_type_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_replacement_type_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::MergePullRequestByThreeWayError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::MergePullRequestByThreeWayError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::MergePullRequestByThreeWayError::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TipOfSourceReferenceIsDifferentException" => crate::error::MergePullRequestByThreeWayError::TipOfSourceReferenceIsDifferentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tip_of_source_reference_is_different_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tip_of_source_reference_is_different_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "TipsDivergenceExceededException" => crate::error::MergePullRequestByThreeWayError::TipsDivergenceExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tips_divergence_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tips_divergence_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::MergePullRequestByThreeWayError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_merge_pull_request_by_three_way_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::MergePullRequestByThreeWayOutput,
    crate::error::MergePullRequestByThreeWayError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::merge_pull_request_by_three_way_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_merge_pull_request_by_three_way(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::MergePullRequestByThreeWayError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_override_pull_request_approval_rules_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::OverridePullRequestApprovalRulesOutput,
    crate::error::OverridePullRequestApprovalRulesError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::OverridePullRequestApprovalRulesError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::OverridePullRequestApprovalRulesError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::OverridePullRequestApprovalRulesError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::OverridePullRequestApprovalRulesError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::OverridePullRequestApprovalRulesError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::OverridePullRequestApprovalRulesError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidOverrideStatusException" => crate::error::OverridePullRequestApprovalRulesError::InvalidOverrideStatusException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_override_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_override_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::OverridePullRequestApprovalRulesError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRevisionIdException" => crate::error::OverridePullRequestApprovalRulesError::InvalidRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OverrideAlreadySetException" => crate::error::OverridePullRequestApprovalRulesError::OverrideAlreadySetException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::override_already_set_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_override_already_set_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "OverrideStatusRequiredException" => crate::error::OverridePullRequestApprovalRulesError::OverrideStatusRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::override_status_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_override_status_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestAlreadyClosedException" => crate::error::OverridePullRequestApprovalRulesError::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::OverridePullRequestApprovalRulesError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::OverridePullRequestApprovalRulesError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RevisionIdRequiredException" => crate::error::OverridePullRequestApprovalRulesError::RevisionIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RevisionNotCurrentException" => crate::error::OverridePullRequestApprovalRulesError::RevisionNotCurrentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_not_current_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_not_current_exception_json_err(response.body().as_ref(), output).map_err(crate::error::OverridePullRequestApprovalRulesError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::OverridePullRequestApprovalRulesError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_override_pull_request_approval_rules_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::OverridePullRequestApprovalRulesOutput,
    crate::error::OverridePullRequestApprovalRulesError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::override_pull_request_approval_rules_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_compared_commit_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PostCommentForComparedCommitOutput,
    crate::error::PostCommentForComparedCommitError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PostCommentForComparedCommitError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BeforeCommitIdAndAfterCommitIdAreSameException" => crate::error::PostCommentForComparedCommitError::BeforeCommitIdAndAfterCommitIdAreSameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_before_commit_id_and_after_commit_id_are_same_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ClientRequestTokenRequiredException" => crate::error::PostCommentForComparedCommitError::ClientRequestTokenRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_client_request_token_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommentContentRequiredException" => crate::error::PostCommentForComparedCommitError::CommentContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommentContentSizeLimitExceededException" => crate::error::PostCommentForComparedCommitError::CommentContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitDoesNotExistException" => crate::error::PostCommentForComparedCommitError::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitIdRequiredException" => crate::error::PostCommentForComparedCommitError::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::PostCommentForComparedCommitError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::PostCommentForComparedCommitError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::PostCommentForComparedCommitError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::PostCommentForComparedCommitError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::PostCommentForComparedCommitError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IdempotencyParameterMismatchException" => crate::error::PostCommentForComparedCommitError::IdempotencyParameterMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotency_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidClientRequestTokenException" => crate::error::PostCommentForComparedCommitError::InvalidClientRequestTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_client_request_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitIdException" => crate::error::PostCommentForComparedCommitError::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFileLocationException" => crate::error::PostCommentForComparedCommitError::InvalidFileLocationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_location_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_location_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilePositionException" => crate::error::PostCommentForComparedCommitError::InvalidFilePositionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_position_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_position_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPathException" => crate::error::PostCommentForComparedCommitError::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRelativeFileVersionEnumException" => crate::error::PostCommentForComparedCommitError::InvalidRelativeFileVersionEnumException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_relative_file_version_enum_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_relative_file_version_enum_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::PostCommentForComparedCommitError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PathDoesNotExistException" => crate::error::PostCommentForComparedCommitError::PathDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PathRequiredException" => crate::error::PostCommentForComparedCommitError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::PostCommentForComparedCommitError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::PostCommentForComparedCommitError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::PostCommentForComparedCommitError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_compared_commit_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PostCommentForComparedCommitOutput,
    crate::error::PostCommentForComparedCommitError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::post_comment_for_compared_commit_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_post_comment_for_compared_commit(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::PostCommentForComparedCommitError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_pull_request_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PostCommentForPullRequestOutput,
    crate::error::PostCommentForPullRequestError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::PostCommentForPullRequestError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BeforeCommitIdAndAfterCommitIdAreSameException" => crate::error::PostCommentForPullRequestError::BeforeCommitIdAndAfterCommitIdAreSameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::before_commit_id_and_after_commit_id_are_same_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_before_commit_id_and_after_commit_id_are_same_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ClientRequestTokenRequiredException" => crate::error::PostCommentForPullRequestError::ClientRequestTokenRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_client_request_token_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommentContentRequiredException" => crate::error::PostCommentForPullRequestError::CommentContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommentContentSizeLimitExceededException" => crate::error::PostCommentForPullRequestError::CommentContentSizeLimitExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitDoesNotExistException" => crate::error::PostCommentForPullRequestError::CommitDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CommitIdRequiredException" => crate::error::PostCommentForPullRequestError::CommitIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::PostCommentForPullRequestError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::PostCommentForPullRequestError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::PostCommentForPullRequestError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::PostCommentForPullRequestError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::PostCommentForPullRequestError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "IdempotencyParameterMismatchException" => crate::error::PostCommentForPullRequestError::IdempotencyParameterMismatchException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotency_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidClientRequestTokenException" => crate::error::PostCommentForPullRequestError::InvalidClientRequestTokenException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_client_request_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidCommitIdException" => crate::error::PostCommentForPullRequestError::InvalidCommitIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFileLocationException" => crate::error::PostCommentForPullRequestError::InvalidFileLocationException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_location_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_location_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidFilePositionException" => crate::error::PostCommentForPullRequestError::InvalidFilePositionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_file_position_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_file_position_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPathException" => crate::error::PostCommentForPullRequestError::InvalidPathException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::PostCommentForPullRequestError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRelativeFileVersionEnumException" => crate::error::PostCommentForPullRequestError::InvalidRelativeFileVersionEnumException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_relative_file_version_enum_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_relative_file_version_enum_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::PostCommentForPullRequestError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PathDoesNotExistException" => crate::error::PostCommentForPullRequestError::PathDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PathRequiredException" => crate::error::PostCommentForPullRequestError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::path_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::PostCommentForPullRequestError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::PostCommentForPullRequestError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::PostCommentForPullRequestError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::PostCommentForPullRequestError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNotAssociatedWithPullRequestException" => crate::error::PostCommentForPullRequestError::RepositoryNotAssociatedWithPullRequestException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_not_associated_with_pull_request_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_not_associated_with_pull_request_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::PostCommentForPullRequestError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_for_pull_request_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PostCommentForPullRequestOutput,
    crate::error::PostCommentForPullRequestError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::post_comment_for_pull_request_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_post_comment_for_pull_request(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PostCommentForPullRequestError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_reply_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PostCommentReplyOutput, crate::error::PostCommentReplyError>
{
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PostCommentReplyError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PostCommentReplyError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ClientRequestTokenRequiredException" => {
            crate::error::PostCommentReplyError::ClientRequestTokenRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::client_request_token_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_client_request_token_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentContentRequiredException" => {
            crate::error::PostCommentReplyError::CommentContentRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentContentSizeLimitExceededException" => {
            crate::error::PostCommentReplyError::CommentContentSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentDoesNotExistException" => {
            crate::error::PostCommentReplyError::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentIdRequiredException" => {
            crate::error::PostCommentReplyError::CommentIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "IdempotencyParameterMismatchException" => {
            crate::error::PostCommentReplyError::IdempotencyParameterMismatchException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::idempotency_parameter_mismatch_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_idempotency_parameter_mismatch_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidClientRequestTokenException" => {
            crate::error::PostCommentReplyError::InvalidClientRequestTokenException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_client_request_token_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_client_request_token_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommentIdException" => {
            crate::error::PostCommentReplyError::InvalidCommentIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PostCommentReplyError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::PostCommentReplyError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_post_comment_reply_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PostCommentReplyOutput, crate::error::PostCommentReplyError>
{
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::post_comment_reply_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_post_comment_reply(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PostCommentReplyError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_comment_reaction_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutCommentReactionOutput,
    crate::error::PutCommentReactionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PutCommentReactionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutCommentReactionError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentDeletedException" => {
            crate::error::PutCommentReactionError::CommentDeletedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_deleted_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentDoesNotExistException" => {
            crate::error::PutCommentReactionError::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentIdRequiredException" => {
            crate::error::PutCommentReactionError::CommentIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommentIdException" => {
            crate::error::PutCommentReactionError::InvalidCommentIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidReactionValueException" => {
            crate::error::PutCommentReactionError::InvalidReactionValueException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_reaction_value_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_reaction_value_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ReactionLimitExceededException" => {
            crate::error::PutCommentReactionError::ReactionLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reaction_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reaction_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ReactionValueRequiredException" => {
            crate::error::PutCommentReactionError::ReactionValueRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::reaction_value_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_reaction_value_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutCommentReactionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::PutCommentReactionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_comment_reaction_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutCommentReactionOutput,
    crate::error::PutCommentReactionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_comment_reaction_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_file_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutFileOutput, crate::error::PutFileError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PutFileError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutFileError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => crate::error::PutFileError::BranchDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::branch_does_not_exist_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "BranchNameIsTagNameException" => {
            crate::error::PutFileError::BranchNameIsTagNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_is_tag_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_is_tag_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameRequiredException" => crate::error::PutFileError::BranchNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::branch_name_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CommitMessageLengthExceededException" => {
            crate::error::PutFileError::CommitMessageLengthExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::commit_message_length_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_commit_message_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "DirectoryNameConflictsWithFileNameException" => {
            crate::error::PutFileError::DirectoryNameConflictsWithFileNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::directory_name_conflicts_with_file_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_directory_name_conflicts_with_file_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::PutFileError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::PutFileError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::PutFileError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::PutFileError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::PutFileError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileContentRequiredException" => {
            crate::error::PutFileError::FileContentRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::file_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileContentSizeLimitExceededException" => {
            crate::error::PutFileError::FileContentSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::file_content_size_limit_exceeded_exception::Builder::default(
                        );
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FileNameConflictsWithDirectoryNameException" => {
            crate::error::PutFileError::FileNameConflictsWithDirectoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_name_conflicts_with_directory_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_name_conflicts_with_directory_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FilePathConflictsWithSubmodulePathException" => {
            crate::error::PutFileError::FilePathConflictsWithSubmodulePathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::file_path_conflicts_with_submodule_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_file_path_conflicts_with_submodule_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "FolderContentSizeLimitExceededException" => {
            crate::error::PutFileError::FolderContentSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::folder_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_folder_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidBranchNameException" => crate::error::PutFileError::InvalidBranchNameException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_branch_name_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidDeletionParameterException" => {
            crate::error::PutFileError::InvalidDeletionParameterException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_deletion_parameter_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_deletion_parameter_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidEmailException" => crate::error::PutFileError::InvalidEmailException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_email_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_email_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidFileModeException" => crate::error::PutFileError::InvalidFileModeException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_file_mode_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_file_mode_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "InvalidParentCommitIdException" => {
            crate::error::PutFileError::InvalidParentCommitIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_parent_commit_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_parent_commit_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPathException" => {
            crate::error::PutFileError::InvalidPathException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_path_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_path_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::PutFileError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "NameLengthExceededException" => crate::error::PutFileError::NameLengthExceededException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::name_length_exceeded_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_name_length_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "ParentCommitDoesNotExistException" => {
            crate::error::PutFileError::ParentCommitDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParentCommitIdOutdatedException" => {
            crate::error::PutFileError::ParentCommitIdOutdatedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_outdated_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_outdated_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ParentCommitIdRequiredException" => {
            crate::error::PutFileError::ParentCommitIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::parent_commit_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_parent_commit_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PathRequiredException" => crate::error::PutFileError::PathRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::path_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_path_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "RepositoryDoesNotExistException" => {
            crate::error::PutFileError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::PutFileError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "SameFileContentException" => crate::error::PutFileError::SameFileContentException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::same_file_content_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_same_file_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutFileError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::PutFileError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_file_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::PutFileOutput, crate::error::PutFileError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_file_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_file(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutFileError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_repository_triggers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRepositoryTriggersOutput,
    crate::error::PutRepositoryTriggersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::PutRepositoryTriggersError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::PutRepositoryTriggersError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::PutRepositoryTriggersError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::PutRepositoryTriggersError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::PutRepositoryTriggersError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::PutRepositoryTriggersError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::PutRepositoryTriggersError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerBranchNameException" => crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerCustomDataException" => crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_custom_data_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_custom_data_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerDestinationArnException" => crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_destination_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_destination_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerEventsException" => crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerEventsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_events_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_events_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerNameException" => crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerRegionException" => crate::error::PutRepositoryTriggersError::InvalidRepositoryTriggerRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumBranchesExceededException" => crate::error::PutRepositoryTriggersError::MaximumBranchesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_branches_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_branches_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumRepositoryTriggersExceededException" => crate::error::PutRepositoryTriggersError::MaximumRepositoryTriggersExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_repository_triggers_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_triggers_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::PutRepositoryTriggersError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::PutRepositoryTriggersError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggerBranchNameListRequiredException" => crate::error::PutRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_branch_name_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_branch_name_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggerDestinationArnRequiredException" => crate::error::PutRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_destination_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_destination_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggerEventsListRequiredException" => crate::error::PutRepositoryTriggersError::RepositoryTriggerEventsListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_events_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_events_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggerNameRequiredException" => crate::error::PutRepositoryTriggersError::RepositoryTriggerNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggersListRequiredException" => crate::error::PutRepositoryTriggersError::RepositoryTriggersListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_triggers_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_triggers_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::PutRepositoryTriggersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_put_repository_triggers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::PutRepositoryTriggersOutput,
    crate::error::PutRepositoryTriggersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::put_repository_triggers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_put_repository_triggers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::PutRepositoryTriggersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TagResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::TagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => {
            crate::error::TagResourceError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceArnException" => {
            crate::error::TagResourceError::InvalidResourceArnException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_resource_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidSystemTagUsageException" => {
            crate::error::TagResourceError::InvalidSystemTagUsageException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_system_tag_usage_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_system_tag_usage_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidTagsMapException" => crate::error::TagResourceError::InvalidTagsMapException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::invalid_tags_map_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_invalid_tags_map_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "RepositoryDoesNotExistException" => {
            crate::error::TagResourceError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceArnRequiredException" => {
            crate::error::TagResourceError::ResourceArnRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TagPolicyException" => {
            crate::error::TagResourceError::TagPolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tag_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TagsMapRequiredException" => crate::error::TagResourceError::TagsMapRequiredException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::tags_map_required_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_tags_map_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "TooManyTagsException" => crate::error::TagResourceError::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_tags_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::TagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_tag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::tag_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_repository_triggers_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestRepositoryTriggersOutput,
    crate::error::TestRepositoryTriggersError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::TestRepositoryTriggersError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => crate::error::TestRepositoryTriggersError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::TestRepositoryTriggersError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::TestRepositoryTriggersError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::TestRepositoryTriggersError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::TestRepositoryTriggersError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryNameException" => crate::error::TestRepositoryTriggersError::InvalidRepositoryNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerBranchNameException" => crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerCustomDataException" => crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_custom_data_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_custom_data_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerDestinationArnException" => crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_destination_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_destination_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerEventsException" => crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerEventsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_events_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_events_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerNameException" => crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRepositoryTriggerRegionException" => crate::error::TestRepositoryTriggersError::InvalidRepositoryTriggerRegionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_repository_trigger_region_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_trigger_region_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumBranchesExceededException" => crate::error::TestRepositoryTriggersError::MaximumBranchesExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_branches_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_branches_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumRepositoryTriggersExceededException" => crate::error::TestRepositoryTriggersError::MaximumRepositoryTriggersExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_repository_triggers_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_repository_triggers_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryDoesNotExistException" => crate::error::TestRepositoryTriggersError::RepositoryDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryNameRequiredException" => crate::error::TestRepositoryTriggersError::RepositoryNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggerBranchNameListRequiredException" => crate::error::TestRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_branch_name_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_branch_name_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggerDestinationArnRequiredException" => crate::error::TestRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_destination_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_destination_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggerEventsListRequiredException" => crate::error::TestRepositoryTriggersError::RepositoryTriggerEventsListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_events_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_events_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggerNameRequiredException" => crate::error::TestRepositoryTriggersError::RepositoryTriggerNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_trigger_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_trigger_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RepositoryTriggersListRequiredException" => crate::error::TestRepositoryTriggersError::RepositoryTriggersListRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::repository_triggers_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_triggers_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::TestRepositoryTriggersError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_test_repository_triggers_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::TestRepositoryTriggersOutput,
    crate::error::TestRepositoryTriggersError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::test_repository_triggers_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_test_repository_triggers(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::TestRepositoryTriggersError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UntagResourceError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UntagResourceError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => {
            crate::error::UntagResourceError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidResourceArnException" => {
            crate::error::UntagResourceError::InvalidResourceArnException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_resource_arn_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_resource_arn_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidSystemTagUsageException" => {
            crate::error::UntagResourceError::InvalidSystemTagUsageException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_system_tag_usage_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_system_tag_usage_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidTagKeysListException" => {
            crate::error::UntagResourceError::InvalidTagKeysListException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_tag_keys_list_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_tag_keys_list_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::UntagResourceError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "ResourceArnRequiredException" => {
            crate::error::UntagResourceError::ResourceArnRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::resource_arn_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_resource_arn_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TagKeysListRequiredException" => {
            crate::error::UntagResourceError::TagKeysListRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::tag_keys_list_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tag_keys_list_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TagPolicyException" => {
            crate::error::UntagResourceError::TagPolicyException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::tag_policy_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_tag_policy_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TooManyTagsException" => crate::error::UntagResourceError::TooManyTagsException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::too_many_tags_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_too_many_tags_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UntagResourceError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        _ => crate::error::UntagResourceError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_untag_resource_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::untag_resource_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateContentOutput,
    crate::error::UpdateApprovalRuleTemplateContentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateContentRequiredException" => crate::error::UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameRequiredException" => crate::error::UpdateApprovalRuleTemplateContentError::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateContentException" => crate::error::UpdateApprovalRuleTemplateContentError::InvalidApprovalRuleTemplateContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateNameException" => crate::error::UpdateApprovalRuleTemplateContentError::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRuleContentSha256Exception" => crate::error::UpdateApprovalRuleTemplateContentError::InvalidRuleContentSha256Exception({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_rule_content_sha256_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_rule_content_sha256_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateApprovalRuleTemplateContentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateContentOutput,
    crate::error::UpdateApprovalRuleTemplateContentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_approval_rule_template_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_approval_rule_template_content(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateContentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_description_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateDescriptionOutput,
    crate::error::UpdateApprovalRuleTemplateDescriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(
                crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled(generic),
            )
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::UpdateApprovalRuleTemplateDescriptionError::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameRequiredException" => crate::error::UpdateApprovalRuleTemplateDescriptionError::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateDescriptionException" => crate::error::UpdateApprovalRuleTemplateDescriptionError::InvalidApprovalRuleTemplateDescriptionException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateNameException" => crate::error::UpdateApprovalRuleTemplateDescriptionError::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateApprovalRuleTemplateDescriptionError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_description_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateDescriptionOutput,
    crate::error::UpdateApprovalRuleTemplateDescriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_approval_rule_template_description_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_approval_rule_template_description(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateDescriptionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_name_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateNameOutput,
    crate::error::UpdateApprovalRuleTemplateNameError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleTemplateDoesNotExistException" => crate::error::UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameAlreadyExistsException" => crate::error::UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateNameAlreadyExistsException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_already_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_already_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleTemplateNameRequiredException" => crate::error::UpdateApprovalRuleTemplateNameError::ApprovalRuleTemplateNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_template_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_template_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleTemplateNameException" => crate::error::UpdateApprovalRuleTemplateNameError::InvalidApprovalRuleTemplateNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_template_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_template_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdateApprovalRuleTemplateNameError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_approval_rule_template_name_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateApprovalRuleTemplateNameOutput,
    crate::error::UpdateApprovalRuleTemplateNameError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_approval_rule_template_name_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_update_approval_rule_template_name(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::UpdateApprovalRuleTemplateNameError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_comment_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateCommentOutput, crate::error::UpdateCommentError> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateCommentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateCommentError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "CommentContentRequiredException" => {
            crate::error::UpdateCommentError::CommentContentRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentContentSizeLimitExceededException" => {
            crate::error::UpdateCommentError::CommentContentSizeLimitExceededException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::comment_content_size_limit_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_content_size_limit_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentDeletedException" => crate::error::UpdateCommentError::CommentDeletedException({
            #[allow(unused_mut)]
            let mut tmp = {
                #[allow(unused_mut)]
                let mut output = crate::error::comment_deleted_exception::Builder::default();
                let _ = response;
                output = crate::json_deser::deser_structure_crate_error_comment_deleted_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                let output = output.meta(generic);
                output.build()
            };
            if tmp.message.is_none() {
                tmp.message = _error_message;
            }
            tmp
        }),
        "CommentDoesNotExistException" => {
            crate::error::UpdateCommentError::CommentDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentIdRequiredException" => {
            crate::error::UpdateCommentError::CommentIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "CommentNotCreatedByCallerException" => {
            crate::error::UpdateCommentError::CommentNotCreatedByCallerException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::comment_not_created_by_caller_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_comment_not_created_by_caller_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidCommentIdException" => {
            crate::error::UpdateCommentError::InvalidCommentIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_comment_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_comment_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateCommentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateCommentError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_comment_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<crate::output::UpdateCommentOutput, crate::error::UpdateCommentError> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_comment_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_comment(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdateCommentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_default_branch_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDefaultBranchOutput,
    crate::error::UpdateDefaultBranchError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateDefaultBranchError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "BranchDoesNotExistException" => {
            crate::error::UpdateDefaultBranchError::BranchDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "BranchNameRequiredException" => {
            crate::error::UpdateDefaultBranchError::BranchNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::branch_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_branch_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::UpdateDefaultBranchError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::UpdateDefaultBranchError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::UpdateDefaultBranchError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::UpdateDefaultBranchError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::UpdateDefaultBranchError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidBranchNameException" => {
            crate::error::UpdateDefaultBranchError::InvalidBranchNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_branch_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_branch_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::UpdateDefaultBranchError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::UpdateDefaultBranchError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::UpdateDefaultBranchError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateDefaultBranchError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateDefaultBranchError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_default_branch_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateDefaultBranchOutput,
    crate::error::UpdateDefaultBranchError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_default_branch_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_rule_content_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestApprovalRuleContentOutput,
    crate::error::UpdatePullRequestApprovalRuleContentError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled(generic))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalRuleContentRequiredException" => crate::error::UpdatePullRequestApprovalRuleContentError::ApprovalRuleContentRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_content_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_content_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleDoesNotExistException" => crate::error::UpdatePullRequestApprovalRuleContentError::ApprovalRuleDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "ApprovalRuleNameRequiredException" => crate::error::UpdatePullRequestApprovalRuleContentError::ApprovalRuleNameRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_rule_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_rule_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "CannotModifyApprovalRuleFromTemplateException" => crate::error::UpdatePullRequestApprovalRuleContentError::CannotModifyApprovalRuleFromTemplateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::cannot_modify_approval_rule_from_template_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_cannot_modify_approval_rule_from_template_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::UpdatePullRequestApprovalRuleContentError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleContentException" => crate::error::UpdatePullRequestApprovalRuleContentError::InvalidApprovalRuleContentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_content_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_content_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalRuleNameException" => crate::error::UpdatePullRequestApprovalRuleContentError::InvalidApprovalRuleNameException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_rule_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_rule_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestApprovalRuleContentError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRuleContentSha256Exception" => crate::error::UpdatePullRequestApprovalRuleContentError::InvalidRuleContentSha256Exception({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_rule_content_sha256_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_rule_content_sha256_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestApprovalRuleContentError::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestApprovalRuleContentError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestApprovalRuleContentError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdatePullRequestApprovalRuleContentError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_rule_content_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestApprovalRuleContentOutput,
    crate::error::UpdatePullRequestApprovalRuleContentError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_pull_request_approval_rule_content_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_pull_request_approval_rule_content(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalRuleContentError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_state_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestApprovalStateOutput,
    crate::error::UpdatePullRequestApprovalStateError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdatePullRequestApprovalStateError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "ApprovalStateRequiredException" => crate::error::UpdatePullRequestApprovalStateError::ApprovalStateRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::approval_state_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_approval_state_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionIntegrityChecksFailedException" => crate::error::UpdatePullRequestApprovalStateError::EncryptionIntegrityChecksFailedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyAccessDeniedException" => crate::error::UpdatePullRequestApprovalStateError::EncryptionKeyAccessDeniedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyDisabledException" => crate::error::UpdatePullRequestApprovalStateError::EncryptionKeyDisabledException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyNotFoundException" => crate::error::UpdatePullRequestApprovalStateError::EncryptionKeyNotFoundException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "EncryptionKeyUnavailableException" => crate::error::UpdatePullRequestApprovalStateError::EncryptionKeyUnavailableException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidApprovalStateException" => crate::error::UpdatePullRequestApprovalStateError::InvalidApprovalStateException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_approval_state_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_approval_state_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidPullRequestIdException" => crate::error::UpdatePullRequestApprovalStateError::InvalidPullRequestIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "InvalidRevisionIdException" => crate::error::UpdatePullRequestApprovalStateError::InvalidRevisionIdException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_revision_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_revision_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "MaximumNumberOfApprovalsExceededException" => crate::error::UpdatePullRequestApprovalStateError::MaximumNumberOfApprovalsExceededException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::maximum_number_of_approvals_exceeded_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_maximum_number_of_approvals_exceeded_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestAlreadyClosedException" => crate::error::UpdatePullRequestApprovalStateError::PullRequestAlreadyClosedException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestCannotBeApprovedByAuthorException" => crate::error::UpdatePullRequestApprovalStateError::PullRequestCannotBeApprovedByAuthorException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_cannot_be_approved_by_author_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_cannot_be_approved_by_author_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestDoesNotExistException" => crate::error::UpdatePullRequestApprovalStateError::PullRequestDoesNotExistException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "PullRequestIdRequiredException" => crate::error::UpdatePullRequestApprovalStateError::PullRequestIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RevisionIdRequiredException" => crate::error::UpdatePullRequestApprovalStateError::RevisionIdRequiredException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        "RevisionNotCurrentException" => crate::error::UpdatePullRequestApprovalStateError::RevisionNotCurrentException({
            #[allow(unused_mut)]
            let mut tmp =
                 {
                    #[allow(unused_mut)]
                    let mut output = crate::error::revision_not_current_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_revision_not_current_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestApprovalStateError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                }
            ;
            if tmp.message.is_none() {
                                                        tmp.message = _error_message;
                                                    }
            tmp
        }),
        _ => crate::error::UpdatePullRequestApprovalStateError::generic(generic)
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_approval_state_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestApprovalStateOutput,
    crate::error::UpdatePullRequestApprovalStateError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output =
            crate::output::update_pull_request_approval_state_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_description_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestDescriptionOutput,
    crate::error::UpdatePullRequestDescriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdatePullRequestDescriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidDescriptionException" => {
            crate::error::UpdatePullRequestDescriptionError::InvalidDescriptionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPullRequestIdException" => {
            crate::error::UpdatePullRequestDescriptionError::InvalidPullRequestIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestAlreadyClosedException" => {
            crate::error::UpdatePullRequestDescriptionError::PullRequestAlreadyClosedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestDoesNotExistException" => {
            crate::error::UpdatePullRequestDescriptionError::PullRequestDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestIdRequiredException" => {
            crate::error::UpdatePullRequestDescriptionError::PullRequestIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdatePullRequestDescriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_description_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestDescriptionOutput,
    crate::error::UpdatePullRequestDescriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_description_output::Builder::default();
        let _ = response;
        output =
            crate::json_deser::deser_operation_crate_operation_update_pull_request_description(
                response.body().as_ref(),
                output,
            )
            .map_err(crate::error::UpdatePullRequestDescriptionError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_status_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestStatusOutput,
    crate::error::UpdatePullRequestStatusError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdatePullRequestStatusError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::UpdatePullRequestStatusError::EncryptionIntegrityChecksFailedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::UpdatePullRequestStatusError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::UpdatePullRequestStatusError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::UpdatePullRequestStatusError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::UpdatePullRequestStatusError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPullRequestIdException" => {
            crate::error::UpdatePullRequestStatusError::InvalidPullRequestIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPullRequestStatusException" => {
            crate::error::UpdatePullRequestStatusError::InvalidPullRequestStatusException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_status_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_status_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidPullRequestStatusUpdateException" => {
            crate::error::UpdatePullRequestStatusError::InvalidPullRequestStatusUpdateException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_pull_request_status_update_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_status_update_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestDoesNotExistException" => {
            crate::error::UpdatePullRequestStatusError::PullRequestDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestIdRequiredException" => {
            crate::error::UpdatePullRequestStatusError::PullRequestIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestStatusRequiredException" => {
            crate::error::UpdatePullRequestStatusError::PullRequestStatusRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_status_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_status_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdatePullRequestStatusError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_status_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestStatusOutput,
    crate::error::UpdatePullRequestStatusError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_status_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_pull_request_status(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePullRequestStatusError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_title_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestTitleOutput,
    crate::error::UpdatePullRequestTitleError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdatePullRequestTitleError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidPullRequestIdException" => {
            crate::error::UpdatePullRequestTitleError::InvalidPullRequestIdException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_pull_request_id_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_pull_request_id_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidTitleException" => {
            crate::error::UpdatePullRequestTitleError::InvalidTitleException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::invalid_title_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_title_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestAlreadyClosedException" => {
            crate::error::UpdatePullRequestTitleError::PullRequestAlreadyClosedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_already_closed_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_already_closed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestDoesNotExistException" => {
            crate::error::UpdatePullRequestTitleError::PullRequestDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "PullRequestIdRequiredException" => {
            crate::error::UpdatePullRequestTitleError::PullRequestIdRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::pull_request_id_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_pull_request_id_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "TitleRequiredException" => {
            crate::error::UpdatePullRequestTitleError::TitleRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output = crate::error::title_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_title_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdatePullRequestTitleError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_pull_request_title_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdatePullRequestTitleOutput,
    crate::error::UpdatePullRequestTitleError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_pull_request_title_output::Builder::default();
        let _ = response;
        output = crate::json_deser::deser_operation_crate_operation_update_pull_request_title(
            response.body().as_ref(),
            output,
        )
        .map_err(crate::error::UpdatePullRequestTitleError::unhandled)?;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_description_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRepositoryDescriptionOutput,
    crate::error::UpdateRepositoryDescriptionError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => {
            return Err(crate::error::UpdateRepositoryDescriptionError::unhandled(
                generic,
            ))
        }
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "EncryptionIntegrityChecksFailedException" => {
            crate::error::UpdateRepositoryDescriptionError::EncryptionIntegrityChecksFailedException(
                {
                    #[allow(unused_mut)]
                    let mut tmp = {
                        #[allow(unused_mut)]
                    let mut output = crate::error::encryption_integrity_checks_failed_exception::Builder::default();
                        let _ = response;
                        output = crate::json_deser::deser_structure_crate_error_encryption_integrity_checks_failed_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                        let output = output.meta(generic);
                        output.build()
                    };
                    if tmp.message.is_none() {
                        tmp.message = _error_message;
                    }
                    tmp
                },
            )
        }
        "EncryptionKeyAccessDeniedException" => {
            crate::error::UpdateRepositoryDescriptionError::EncryptionKeyAccessDeniedException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_access_denied_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_access_denied_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyDisabledException" => {
            crate::error::UpdateRepositoryDescriptionError::EncryptionKeyDisabledException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_disabled_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_disabled_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyNotFoundException" => {
            crate::error::UpdateRepositoryDescriptionError::EncryptionKeyNotFoundException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_not_found_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_not_found_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "EncryptionKeyUnavailableException" => {
            crate::error::UpdateRepositoryDescriptionError::EncryptionKeyUnavailableException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::encryption_key_unavailable_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_encryption_key_unavailable_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryDescriptionException" => {
            crate::error::UpdateRepositoryDescriptionError::InvalidRepositoryDescriptionException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_description_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_description_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "InvalidRepositoryNameException" => {
            crate::error::UpdateRepositoryDescriptionError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::UpdateRepositoryDescriptionError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::UpdateRepositoryDescriptionError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryDescriptionError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateRepositoryDescriptionError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_description_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRepositoryDescriptionOutput,
    crate::error::UpdateRepositoryDescriptionError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_repository_description_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_name_error(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRepositoryNameOutput,
    crate::error::UpdateRepositoryNameError,
> {
    #[allow(unused_mut)]
    let mut generic_builder = crate::json_deser::parse_http_error_metadata(response)
        .map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
    generic_builder = aws_http::request_id::apply_request_id(generic_builder, response.headers());
    let generic = generic_builder.build();
    let error_code = match generic.code() {
        Some(code) => code,
        None => return Err(crate::error::UpdateRepositoryNameError::unhandled(generic)),
    };

    let _error_message = generic.message().map(|msg| msg.to_owned());
    Err(match error_code {
        "InvalidRepositoryNameException" => {
            crate::error::UpdateRepositoryNameError::InvalidRepositoryNameException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::invalid_repository_name_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_invalid_repository_name_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryDoesNotExistException" => {
            crate::error::UpdateRepositoryNameError::RepositoryDoesNotExistException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_does_not_exist_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_does_not_exist_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameExistsException" => {
            crate::error::UpdateRepositoryNameError::RepositoryNameExistsException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_exists_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_exists_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        "RepositoryNameRequiredException" => {
            crate::error::UpdateRepositoryNameError::RepositoryNameRequiredException({
                #[allow(unused_mut)]
                let mut tmp = {
                    #[allow(unused_mut)]
                    let mut output =
                        crate::error::repository_name_required_exception::Builder::default();
                    let _ = response;
                    output = crate::json_deser::deser_structure_crate_error_repository_name_required_exception_json_err(response.body().as_ref(), output).map_err(crate::error::UpdateRepositoryNameError::unhandled)?;
                    let output = output.meta(generic);
                    output.build()
                };
                if tmp.message.is_none() {
                    tmp.message = _error_message;
                }
                tmp
            })
        }
        _ => crate::error::UpdateRepositoryNameError::generic(generic),
    })
}

#[allow(clippy::unnecessary_wraps)]
pub fn parse_update_repository_name_response(
    response: &http::Response<bytes::Bytes>,
) -> std::result::Result<
    crate::output::UpdateRepositoryNameOutput,
    crate::error::UpdateRepositoryNameError,
> {
    Ok({
        #[allow(unused_mut)]
        let mut output = crate::output::update_repository_name_output::Builder::default();
        let _ = response;
        output._set_request_id(
            aws_http::request_id::RequestId::request_id(response).map(str::to_string),
        );
        output.build()
    })
}
