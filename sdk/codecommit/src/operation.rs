// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// <p>Creates an association between an approval rule template and a specified repository.
/// Then, the next time a pull request is created in the repository where the destination
/// reference (if specified) matches the destination reference (branch) for the pull
/// request, an approval rule that matches the template conditions is automatically created
/// for that pull request. If no destination references are specified in the template, an
/// approval rule that matches the template contents is created for all pull requests in
/// that repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct AssociateApprovalRuleTemplateWithRepository {
    _private: (),
}
impl AssociateApprovalRuleTemplateWithRepository {
    /// Creates a new builder-style object to manufacture [`AssociateApprovalRuleTemplateWithRepositoryInput`](crate::input::AssociateApprovalRuleTemplateWithRepositoryInput)
    pub fn builder() -> crate::input::associate_approval_rule_template_with_repository_input::Builder
    {
        crate::input::associate_approval_rule_template_with_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for AssociateApprovalRuleTemplateWithRepository {
    type Output = std::result::Result<
        crate::output::AssociateApprovalRuleTemplateWithRepositoryOutput,
        crate::error::AssociateApprovalRuleTemplateWithRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_associate_approval_rule_template_with_repository_error(
                response,
            )
        } else {
            crate::operation_deser::parse_associate_approval_rule_template_with_repository_response(
                response,
            )
        }
    }
}

/// <p>Creates an association between an approval rule template and one or more specified repositories. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchAssociateApprovalRuleTemplateWithRepositories {
    _private: (),
}
impl BatchAssociateApprovalRuleTemplateWithRepositories {
    /// Creates a new builder-style object to manufacture [`BatchAssociateApprovalRuleTemplateWithRepositoriesInput`](crate::input::BatchAssociateApprovalRuleTemplateWithRepositoriesInput)
    pub fn builder(
    ) -> crate::input::batch_associate_approval_rule_template_with_repositories_input::Builder {
        crate::input::batch_associate_approval_rule_template_with_repositories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse
    for BatchAssociateApprovalRuleTemplateWithRepositories
{
    type Output = std::result::Result<
        crate::output::BatchAssociateApprovalRuleTemplateWithRepositoriesOutput,
        crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_associate_approval_rule_template_with_repositories_error(response)
        } else {
            crate::operation_deser::parse_batch_associate_approval_rule_template_with_repositories_response(response)
        }
    }
}

/// <p>Returns information about one or more merge conflicts in the attempted merge of two commit specifiers using the squash or three-way merge strategy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDescribeMergeConflicts {
    _private: (),
}
impl BatchDescribeMergeConflicts {
    /// Creates a new builder-style object to manufacture [`BatchDescribeMergeConflictsInput`](crate::input::BatchDescribeMergeConflictsInput)
    pub fn builder() -> crate::input::batch_describe_merge_conflicts_input::Builder {
        crate::input::batch_describe_merge_conflicts_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchDescribeMergeConflicts {
    type Output = std::result::Result<
        crate::output::BatchDescribeMergeConflictsOutput,
        crate::error::BatchDescribeMergeConflictsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_describe_merge_conflicts_error(response)
        } else {
            crate::operation_deser::parse_batch_describe_merge_conflicts_response(response)
        }
    }
}

/// <p>Removes the association between an approval rule template and one or more specified repositories. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchDisassociateApprovalRuleTemplateFromRepositories {
    _private: (),
}
impl BatchDisassociateApprovalRuleTemplateFromRepositories {
    /// Creates a new builder-style object to manufacture [`BatchDisassociateApprovalRuleTemplateFromRepositoriesInput`](crate::input::BatchDisassociateApprovalRuleTemplateFromRepositoriesInput)
    pub fn builder(
    ) -> crate::input::batch_disassociate_approval_rule_template_from_repositories_input::Builder
    {
        crate::input::batch_disassociate_approval_rule_template_from_repositories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse
    for BatchDisassociateApprovalRuleTemplateFromRepositories
{
    type Output = std::result::Result<
        crate::output::BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput,
        crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_disassociate_approval_rule_template_from_repositories_error(response)
        } else {
            crate::operation_deser::parse_batch_disassociate_approval_rule_template_from_repositories_response(response)
        }
    }
}

/// <p>Returns information about the contents of one or more commits in a repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetCommits {
    _private: (),
}
impl BatchGetCommits {
    /// Creates a new builder-style object to manufacture [`BatchGetCommitsInput`](crate::input::BatchGetCommitsInput)
    pub fn builder() -> crate::input::batch_get_commits_input::Builder {
        crate::input::batch_get_commits_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetCommits {
    type Output = std::result::Result<
        crate::output::BatchGetCommitsOutput,
        crate::error::BatchGetCommitsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_commits_error(response)
        } else {
            crate::operation_deser::parse_batch_get_commits_response(response)
        }
    }
}

/// <p>Returns information about one or more repositories.</p>
/// <note>
/// <p>The description field for a repository accepts all HTML characters and all valid
/// Unicode characters. Applications that do not HTML-encode the description and display
/// it in a webpage can expose users to potentially malicious code. Make sure that you
/// HTML-encode the description field in any application that uses this API to display
/// the repository description on a webpage.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct BatchGetRepositories {
    _private: (),
}
impl BatchGetRepositories {
    /// Creates a new builder-style object to manufacture [`BatchGetRepositoriesInput`](crate::input::BatchGetRepositoriesInput)
    pub fn builder() -> crate::input::batch_get_repositories_input::Builder {
        crate::input::batch_get_repositories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for BatchGetRepositories {
    type Output = std::result::Result<
        crate::output::BatchGetRepositoriesOutput,
        crate::error::BatchGetRepositoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_batch_get_repositories_error(response)
        } else {
            crate::operation_deser::parse_batch_get_repositories_response(response)
        }
    }
}

/// <p>Creates a template for approval rules that can then be associated with one or more
/// repositories in your AWS account. When you associate a template with a repository, AWS
/// CodeCommit creates an approval rule that matches the conditions of the template for all
/// pull requests that meet the conditions of the template. For more information, see
/// <a>AssociateApprovalRuleTemplateWithRepository</a>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateApprovalRuleTemplate {
    _private: (),
}
impl CreateApprovalRuleTemplate {
    /// Creates a new builder-style object to manufacture [`CreateApprovalRuleTemplateInput`](crate::input::CreateApprovalRuleTemplateInput)
    pub fn builder() -> crate::input::create_approval_rule_template_input::Builder {
        crate::input::create_approval_rule_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateApprovalRuleTemplate {
    type Output = std::result::Result<
        crate::output::CreateApprovalRuleTemplateOutput,
        crate::error::CreateApprovalRuleTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_approval_rule_template_error(response)
        } else {
            crate::operation_deser::parse_create_approval_rule_template_response(response)
        }
    }
}

/// <p>Creates a branch in a repository and points the branch to a commit.</p>
/// <note>
/// <p>Calling the create branch operation does not set a repository's default branch. To do this, call the update default branch operation.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateBranch {
    _private: (),
}
impl CreateBranch {
    /// Creates a new builder-style object to manufacture [`CreateBranchInput`](crate::input::CreateBranchInput)
    pub fn builder() -> crate::input::create_branch_input::Builder {
        crate::input::create_branch_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateBranch {
    type Output =
        std::result::Result<crate::output::CreateBranchOutput, crate::error::CreateBranchError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_branch_error(response)
        } else {
            crate::operation_deser::parse_create_branch_response(response)
        }
    }
}

/// <p>Creates a commit for a repository on the tip of a specified branch.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateCommit {
    _private: (),
}
impl CreateCommit {
    /// Creates a new builder-style object to manufacture [`CreateCommitInput`](crate::input::CreateCommitInput)
    pub fn builder() -> crate::input::create_commit_input::Builder {
        crate::input::create_commit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateCommit {
    type Output =
        std::result::Result<crate::output::CreateCommitOutput, crate::error::CreateCommitError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_commit_error(response)
        } else {
            crate::operation_deser::parse_create_commit_response(response)
        }
    }
}

/// <p>Creates a pull request in the specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePullRequest {
    _private: (),
}
impl CreatePullRequest {
    /// Creates a new builder-style object to manufacture [`CreatePullRequestInput`](crate::input::CreatePullRequestInput)
    pub fn builder() -> crate::input::create_pull_request_input::Builder {
        crate::input::create_pull_request_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePullRequest {
    type Output = std::result::Result<
        crate::output::CreatePullRequestOutput,
        crate::error::CreatePullRequestError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_pull_request_error(response)
        } else {
            crate::operation_deser::parse_create_pull_request_response(response)
        }
    }
}

/// <p>Creates an approval rule for a pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreatePullRequestApprovalRule {
    _private: (),
}
impl CreatePullRequestApprovalRule {
    /// Creates a new builder-style object to manufacture [`CreatePullRequestApprovalRuleInput`](crate::input::CreatePullRequestApprovalRuleInput)
    pub fn builder() -> crate::input::create_pull_request_approval_rule_input::Builder {
        crate::input::create_pull_request_approval_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreatePullRequestApprovalRule {
    type Output = std::result::Result<
        crate::output::CreatePullRequestApprovalRuleOutput,
        crate::error::CreatePullRequestApprovalRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_pull_request_approval_rule_error(response)
        } else {
            crate::operation_deser::parse_create_pull_request_approval_rule_response(response)
        }
    }
}

/// <p>Creates a new, empty repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateRepository {
    _private: (),
}
impl CreateRepository {
    /// Creates a new builder-style object to manufacture [`CreateRepositoryInput`](crate::input::CreateRepositoryInput)
    pub fn builder() -> crate::input::create_repository_input::Builder {
        crate::input::create_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateRepository {
    type Output = std::result::Result<
        crate::output::CreateRepositoryOutput,
        crate::error::CreateRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_repository_error(response)
        } else {
            crate::operation_deser::parse_create_repository_response(response)
        }
    }
}

/// <p>Creates an unreferenced commit that represents the result of merging two branches
/// using a specified merge strategy. This can help you determine the outcome of a potential
/// merge. This API cannot be used with the fast-forward merge strategy because that
/// strategy does not create a merge commit.</p>
/// <note>
/// <p>This unreferenced merge commit
/// can only be accessed using the GetCommit API or through git commands such as git fetch. To retrieve this commit, you must specify its commit ID or otherwise reference it.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct CreateUnreferencedMergeCommit {
    _private: (),
}
impl CreateUnreferencedMergeCommit {
    /// Creates a new builder-style object to manufacture [`CreateUnreferencedMergeCommitInput`](crate::input::CreateUnreferencedMergeCommitInput)
    pub fn builder() -> crate::input::create_unreferenced_merge_commit_input::Builder {
        crate::input::create_unreferenced_merge_commit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for CreateUnreferencedMergeCommit {
    type Output = std::result::Result<
        crate::output::CreateUnreferencedMergeCommitOutput,
        crate::error::CreateUnreferencedMergeCommitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_create_unreferenced_merge_commit_error(response)
        } else {
            crate::operation_deser::parse_create_unreferenced_merge_commit_response(response)
        }
    }
}

/// <p>Deletes a specified approval rule template. Deleting a template does not remove approval rules on pull requests already created with the template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteApprovalRuleTemplate {
    _private: (),
}
impl DeleteApprovalRuleTemplate {
    /// Creates a new builder-style object to manufacture [`DeleteApprovalRuleTemplateInput`](crate::input::DeleteApprovalRuleTemplateInput)
    pub fn builder() -> crate::input::delete_approval_rule_template_input::Builder {
        crate::input::delete_approval_rule_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteApprovalRuleTemplate {
    type Output = std::result::Result<
        crate::output::DeleteApprovalRuleTemplateOutput,
        crate::error::DeleteApprovalRuleTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_approval_rule_template_error(response)
        } else {
            crate::operation_deser::parse_delete_approval_rule_template_response(response)
        }
    }
}

/// <p>Deletes a branch from a repository, unless that branch is the default branch for the repository. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteBranch {
    _private: (),
}
impl DeleteBranch {
    /// Creates a new builder-style object to manufacture [`DeleteBranchInput`](crate::input::DeleteBranchInput)
    pub fn builder() -> crate::input::delete_branch_input::Builder {
        crate::input::delete_branch_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteBranch {
    type Output =
        std::result::Result<crate::output::DeleteBranchOutput, crate::error::DeleteBranchError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_branch_error(response)
        } else {
            crate::operation_deser::parse_delete_branch_response(response)
        }
    }
}

/// <p>Deletes the content of a comment made on a change, file, or commit in a repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteCommentContent {
    _private: (),
}
impl DeleteCommentContent {
    /// Creates a new builder-style object to manufacture [`DeleteCommentContentInput`](crate::input::DeleteCommentContentInput)
    pub fn builder() -> crate::input::delete_comment_content_input::Builder {
        crate::input::delete_comment_content_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteCommentContent {
    type Output = std::result::Result<
        crate::output::DeleteCommentContentOutput,
        crate::error::DeleteCommentContentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_comment_content_error(response)
        } else {
            crate::operation_deser::parse_delete_comment_content_response(response)
        }
    }
}

/// <p>Deletes a specified file from a specified branch. A commit is created on the branch
/// that contains the revision. The file still exists in the commits earlier to the commit
/// that contains the deletion.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteFile {
    _private: (),
}
impl DeleteFile {
    /// Creates a new builder-style object to manufacture [`DeleteFileInput`](crate::input::DeleteFileInput)
    pub fn builder() -> crate::input::delete_file_input::Builder {
        crate::input::delete_file_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteFile {
    type Output =
        std::result::Result<crate::output::DeleteFileOutput, crate::error::DeleteFileError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_file_error(response)
        } else {
            crate::operation_deser::parse_delete_file_response(response)
        }
    }
}

/// <p>Deletes an approval rule from a specified pull request. Approval rules can be deleted from a pull request only if the pull request is open, and if the
/// approval rule was created specifically for a pull request and not generated from an approval rule template associated with the repository where the
/// pull request was created. You cannot delete an approval rule from a merged or closed pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeletePullRequestApprovalRule {
    _private: (),
}
impl DeletePullRequestApprovalRule {
    /// Creates a new builder-style object to manufacture [`DeletePullRequestApprovalRuleInput`](crate::input::DeletePullRequestApprovalRuleInput)
    pub fn builder() -> crate::input::delete_pull_request_approval_rule_input::Builder {
        crate::input::delete_pull_request_approval_rule_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeletePullRequestApprovalRule {
    type Output = std::result::Result<
        crate::output::DeletePullRequestApprovalRuleOutput,
        crate::error::DeletePullRequestApprovalRuleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_pull_request_approval_rule_error(response)
        } else {
            crate::operation_deser::parse_delete_pull_request_approval_rule_response(response)
        }
    }
}

/// <p>Deletes a repository. If a specified repository was already deleted, a null repository
/// ID is returned.</p>
/// <important>
/// <p>Deleting a repository also deletes all associated objects and metadata. After a repository is
/// deleted, all future push calls to the deleted repository fail.</p>
/// </important>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DeleteRepository {
    _private: (),
}
impl DeleteRepository {
    /// Creates a new builder-style object to manufacture [`DeleteRepositoryInput`](crate::input::DeleteRepositoryInput)
    pub fn builder() -> crate::input::delete_repository_input::Builder {
        crate::input::delete_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DeleteRepository {
    type Output = std::result::Result<
        crate::output::DeleteRepositoryOutput,
        crate::error::DeleteRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_delete_repository_error(response)
        } else {
            crate::operation_deser::parse_delete_repository_response(response)
        }
    }
}

/// <p>Returns information about one or more merge conflicts in the attempted merge of two
/// commit specifiers using the squash or three-way merge strategy. If the merge option for
/// the attempted merge is specified as FAST_FORWARD_MERGE, an exception is thrown.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribeMergeConflicts {
    _private: (),
}
impl DescribeMergeConflicts {
    /// Creates a new builder-style object to manufacture [`DescribeMergeConflictsInput`](crate::input::DescribeMergeConflictsInput)
    pub fn builder() -> crate::input::describe_merge_conflicts_input::Builder {
        crate::input::describe_merge_conflicts_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribeMergeConflicts {
    type Output = std::result::Result<
        crate::output::DescribeMergeConflictsOutput,
        crate::error::DescribeMergeConflictsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_merge_conflicts_error(response)
        } else {
            crate::operation_deser::parse_describe_merge_conflicts_response(response)
        }
    }
}

/// <p>Returns information about one or more pull request events.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DescribePullRequestEvents {
    _private: (),
}
impl DescribePullRequestEvents {
    /// Creates a new builder-style object to manufacture [`DescribePullRequestEventsInput`](crate::input::DescribePullRequestEventsInput)
    pub fn builder() -> crate::input::describe_pull_request_events_input::Builder {
        crate::input::describe_pull_request_events_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DescribePullRequestEvents {
    type Output = std::result::Result<
        crate::output::DescribePullRequestEventsOutput,
        crate::error::DescribePullRequestEventsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_describe_pull_request_events_error(response)
        } else {
            crate::operation_deser::parse_describe_pull_request_events_response(response)
        }
    }
}

/// <p>Removes the association between a template and a repository so that approval rules
/// based on the template are not automatically created when pull requests are created in
/// the specified repository. This does not delete any approval rules previously created for
/// pull requests through the template association.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct DisassociateApprovalRuleTemplateFromRepository {
    _private: (),
}
impl DisassociateApprovalRuleTemplateFromRepository {
    /// Creates a new builder-style object to manufacture [`DisassociateApprovalRuleTemplateFromRepositoryInput`](crate::input::DisassociateApprovalRuleTemplateFromRepositoryInput)
    pub fn builder(
    ) -> crate::input::disassociate_approval_rule_template_from_repository_input::Builder {
        crate::input::disassociate_approval_rule_template_from_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for DisassociateApprovalRuleTemplateFromRepository {
    type Output = std::result::Result<
        crate::output::DisassociateApprovalRuleTemplateFromRepositoryOutput,
        crate::error::DisassociateApprovalRuleTemplateFromRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_disassociate_approval_rule_template_from_repository_error(
                response,
            )
        } else {
            crate::operation_deser::parse_disassociate_approval_rule_template_from_repository_response(response)
        }
    }
}

/// <p>Evaluates whether a pull request has met all the conditions specified in its associated approval rules.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct EvaluatePullRequestApprovalRules {
    _private: (),
}
impl EvaluatePullRequestApprovalRules {
    /// Creates a new builder-style object to manufacture [`EvaluatePullRequestApprovalRulesInput`](crate::input::EvaluatePullRequestApprovalRulesInput)
    pub fn builder() -> crate::input::evaluate_pull_request_approval_rules_input::Builder {
        crate::input::evaluate_pull_request_approval_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for EvaluatePullRequestApprovalRules {
    type Output = std::result::Result<
        crate::output::EvaluatePullRequestApprovalRulesOutput,
        crate::error::EvaluatePullRequestApprovalRulesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_evaluate_pull_request_approval_rules_error(response)
        } else {
            crate::operation_deser::parse_evaluate_pull_request_approval_rules_response(response)
        }
    }
}

/// <p>Returns information about a specified approval rule template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetApprovalRuleTemplate {
    _private: (),
}
impl GetApprovalRuleTemplate {
    /// Creates a new builder-style object to manufacture [`GetApprovalRuleTemplateInput`](crate::input::GetApprovalRuleTemplateInput)
    pub fn builder() -> crate::input::get_approval_rule_template_input::Builder {
        crate::input::get_approval_rule_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetApprovalRuleTemplate {
    type Output = std::result::Result<
        crate::output::GetApprovalRuleTemplateOutput,
        crate::error::GetApprovalRuleTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_approval_rule_template_error(response)
        } else {
            crate::operation_deser::parse_get_approval_rule_template_response(response)
        }
    }
}

/// <p>Returns the base-64 encoded content of an individual blob in a repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBlob {
    _private: (),
}
impl GetBlob {
    /// Creates a new builder-style object to manufacture [`GetBlobInput`](crate::input::GetBlobInput)
    pub fn builder() -> crate::input::get_blob_input::Builder {
        crate::input::get_blob_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBlob {
    type Output = std::result::Result<crate::output::GetBlobOutput, crate::error::GetBlobError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_blob_error(response)
        } else {
            crate::operation_deser::parse_get_blob_response(response)
        }
    }
}

/// <p>Returns information about a repository branch, including its name and the last commit ID.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetBranch {
    _private: (),
}
impl GetBranch {
    /// Creates a new builder-style object to manufacture [`GetBranchInput`](crate::input::GetBranchInput)
    pub fn builder() -> crate::input::get_branch_input::Builder {
        crate::input::get_branch_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetBranch {
    type Output = std::result::Result<crate::output::GetBranchOutput, crate::error::GetBranchError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_branch_error(response)
        } else {
            crate::operation_deser::parse_get_branch_response(response)
        }
    }
}

/// <p>Returns the content of a comment made on a change, file, or commit in a repository. </p>
/// <note>
/// <p>Reaction counts might include numbers from user identities who were deleted after the reaction was made. For a count of
/// reactions from active identities, use GetCommentReactions.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetComment {
    _private: (),
}
impl GetComment {
    /// Creates a new builder-style object to manufacture [`GetCommentInput`](crate::input::GetCommentInput)
    pub fn builder() -> crate::input::get_comment_input::Builder {
        crate::input::get_comment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetComment {
    type Output =
        std::result::Result<crate::output::GetCommentOutput, crate::error::GetCommentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_comment_error(response)
        } else {
            crate::operation_deser::parse_get_comment_response(response)
        }
    }
}

/// <p>Returns information about reactions to a specified comment ID. Reactions from users who have been deleted will not be included in the count.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCommentReactions {
    _private: (),
}
impl GetCommentReactions {
    /// Creates a new builder-style object to manufacture [`GetCommentReactionsInput`](crate::input::GetCommentReactionsInput)
    pub fn builder() -> crate::input::get_comment_reactions_input::Builder {
        crate::input::get_comment_reactions_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCommentReactions {
    type Output = std::result::Result<
        crate::output::GetCommentReactionsOutput,
        crate::error::GetCommentReactionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_comment_reactions_error(response)
        } else {
            crate::operation_deser::parse_get_comment_reactions_response(response)
        }
    }
}

/// <p>Returns information about comments made on the comparison between two commits.</p>
/// <note>
/// <p>Reaction counts might include numbers from user identities who were deleted after the reaction was made. For a count of
/// reactions from active identities, use GetCommentReactions.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCommentsForComparedCommit {
    _private: (),
}
impl GetCommentsForComparedCommit {
    /// Creates a new builder-style object to manufacture [`GetCommentsForComparedCommitInput`](crate::input::GetCommentsForComparedCommitInput)
    pub fn builder() -> crate::input::get_comments_for_compared_commit_input::Builder {
        crate::input::get_comments_for_compared_commit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCommentsForComparedCommit {
    type Output = std::result::Result<
        crate::output::GetCommentsForComparedCommitOutput,
        crate::error::GetCommentsForComparedCommitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_comments_for_compared_commit_error(response)
        } else {
            crate::operation_deser::parse_get_comments_for_compared_commit_response(response)
        }
    }
}

/// <p>Returns comments made on a pull request.</p>
/// <note>
/// <p>Reaction counts might include numbers from user identities who were deleted after the reaction was made. For a count of
/// reactions from active identities, use GetCommentReactions.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCommentsForPullRequest {
    _private: (),
}
impl GetCommentsForPullRequest {
    /// Creates a new builder-style object to manufacture [`GetCommentsForPullRequestInput`](crate::input::GetCommentsForPullRequestInput)
    pub fn builder() -> crate::input::get_comments_for_pull_request_input::Builder {
        crate::input::get_comments_for_pull_request_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCommentsForPullRequest {
    type Output = std::result::Result<
        crate::output::GetCommentsForPullRequestOutput,
        crate::error::GetCommentsForPullRequestError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_comments_for_pull_request_error(response)
        } else {
            crate::operation_deser::parse_get_comments_for_pull_request_response(response)
        }
    }
}

/// <p>Returns information about a commit, including commit message and committer information.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetCommit {
    _private: (),
}
impl GetCommit {
    /// Creates a new builder-style object to manufacture [`GetCommitInput`](crate::input::GetCommitInput)
    pub fn builder() -> crate::input::get_commit_input::Builder {
        crate::input::get_commit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetCommit {
    type Output = std::result::Result<crate::output::GetCommitOutput, crate::error::GetCommitError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_commit_error(response)
        } else {
            crate::operation_deser::parse_get_commit_response(response)
        }
    }
}

/// <p>Returns information about the differences in a valid commit specifier (such as a
/// branch, tag, HEAD, commit ID, or other fully qualified reference). Results can be
/// limited to a specified path.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetDifferences {
    _private: (),
}
impl GetDifferences {
    /// Creates a new builder-style object to manufacture [`GetDifferencesInput`](crate::input::GetDifferencesInput)
    pub fn builder() -> crate::input::get_differences_input::Builder {
        crate::input::get_differences_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetDifferences {
    type Output =
        std::result::Result<crate::output::GetDifferencesOutput, crate::error::GetDifferencesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_differences_error(response)
        } else {
            crate::operation_deser::parse_get_differences_response(response)
        }
    }
}

/// <p>Returns the base-64 encoded contents of a specified file and its metadata.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFile {
    _private: (),
}
impl GetFile {
    /// Creates a new builder-style object to manufacture [`GetFileInput`](crate::input::GetFileInput)
    pub fn builder() -> crate::input::get_file_input::Builder {
        crate::input::get_file_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFile {
    type Output = std::result::Result<crate::output::GetFileOutput, crate::error::GetFileError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_file_error(response)
        } else {
            crate::operation_deser::parse_get_file_response(response)
        }
    }
}

/// <p>Returns the contents of a specified folder in a repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetFolder {
    _private: (),
}
impl GetFolder {
    /// Creates a new builder-style object to manufacture [`GetFolderInput`](crate::input::GetFolderInput)
    pub fn builder() -> crate::input::get_folder_input::Builder {
        crate::input::get_folder_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetFolder {
    type Output = std::result::Result<crate::output::GetFolderOutput, crate::error::GetFolderError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_folder_error(response)
        } else {
            crate::operation_deser::parse_get_folder_response(response)
        }
    }
}

/// <p>Returns information about a specified merge commit.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMergeCommit {
    _private: (),
}
impl GetMergeCommit {
    /// Creates a new builder-style object to manufacture [`GetMergeCommitInput`](crate::input::GetMergeCommitInput)
    pub fn builder() -> crate::input::get_merge_commit_input::Builder {
        crate::input::get_merge_commit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMergeCommit {
    type Output =
        std::result::Result<crate::output::GetMergeCommitOutput, crate::error::GetMergeCommitError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_merge_commit_error(response)
        } else {
            crate::operation_deser::parse_get_merge_commit_response(response)
        }
    }
}

/// <p>Returns information about merge conflicts between the before and after commit IDs for a pull request in a repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMergeConflicts {
    _private: (),
}
impl GetMergeConflicts {
    /// Creates a new builder-style object to manufacture [`GetMergeConflictsInput`](crate::input::GetMergeConflictsInput)
    pub fn builder() -> crate::input::get_merge_conflicts_input::Builder {
        crate::input::get_merge_conflicts_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMergeConflicts {
    type Output = std::result::Result<
        crate::output::GetMergeConflictsOutput,
        crate::error::GetMergeConflictsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_merge_conflicts_error(response)
        } else {
            crate::operation_deser::parse_get_merge_conflicts_response(response)
        }
    }
}

/// <p>Returns information about the merge options available for merging two specified
/// branches. For details about why a merge option is not available, use GetMergeConflicts
/// or DescribeMergeConflicts.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetMergeOptions {
    _private: (),
}
impl GetMergeOptions {
    /// Creates a new builder-style object to manufacture [`GetMergeOptionsInput`](crate::input::GetMergeOptionsInput)
    pub fn builder() -> crate::input::get_merge_options_input::Builder {
        crate::input::get_merge_options_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetMergeOptions {
    type Output = std::result::Result<
        crate::output::GetMergeOptionsOutput,
        crate::error::GetMergeOptionsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_merge_options_error(response)
        } else {
            crate::operation_deser::parse_get_merge_options_response(response)
        }
    }
}

/// <p>Gets information about a pull request in a specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPullRequest {
    _private: (),
}
impl GetPullRequest {
    /// Creates a new builder-style object to manufacture [`GetPullRequestInput`](crate::input::GetPullRequestInput)
    pub fn builder() -> crate::input::get_pull_request_input::Builder {
        crate::input::get_pull_request_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPullRequest {
    type Output =
        std::result::Result<crate::output::GetPullRequestOutput, crate::error::GetPullRequestError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_pull_request_error(response)
        } else {
            crate::operation_deser::parse_get_pull_request_response(response)
        }
    }
}

/// <p>Gets information about the approval states for a specified pull request. Approval states only apply to pull requests that have one or more
/// approval rules applied to them.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPullRequestApprovalStates {
    _private: (),
}
impl GetPullRequestApprovalStates {
    /// Creates a new builder-style object to manufacture [`GetPullRequestApprovalStatesInput`](crate::input::GetPullRequestApprovalStatesInput)
    pub fn builder() -> crate::input::get_pull_request_approval_states_input::Builder {
        crate::input::get_pull_request_approval_states_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPullRequestApprovalStates {
    type Output = std::result::Result<
        crate::output::GetPullRequestApprovalStatesOutput,
        crate::error::GetPullRequestApprovalStatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_pull_request_approval_states_error(response)
        } else {
            crate::operation_deser::parse_get_pull_request_approval_states_response(response)
        }
    }
}

/// <p>Returns information about whether approval rules have been set aside (overridden) for a
/// pull request, and if so, the Amazon Resource Name (ARN) of the user or identity that overrode the rules and their requirements for the pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetPullRequestOverrideState {
    _private: (),
}
impl GetPullRequestOverrideState {
    /// Creates a new builder-style object to manufacture [`GetPullRequestOverrideStateInput`](crate::input::GetPullRequestOverrideStateInput)
    pub fn builder() -> crate::input::get_pull_request_override_state_input::Builder {
        crate::input::get_pull_request_override_state_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetPullRequestOverrideState {
    type Output = std::result::Result<
        crate::output::GetPullRequestOverrideStateOutput,
        crate::error::GetPullRequestOverrideStateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_pull_request_override_state_error(response)
        } else {
            crate::operation_deser::parse_get_pull_request_override_state_response(response)
        }
    }
}

/// <p>Returns information about a repository.</p>
/// <note>
/// <p>The description field for a repository accepts all HTML characters and all valid
/// Unicode characters. Applications that do not HTML-encode the description and display
/// it in a webpage can expose users to potentially malicious code. Make sure that you
/// HTML-encode the description field in any application that uses this API to display
/// the repository description on a webpage.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRepository {
    _private: (),
}
impl GetRepository {
    /// Creates a new builder-style object to manufacture [`GetRepositoryInput`](crate::input::GetRepositoryInput)
    pub fn builder() -> crate::input::get_repository_input::Builder {
        crate::input::get_repository_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRepository {
    type Output =
        std::result::Result<crate::output::GetRepositoryOutput, crate::error::GetRepositoryError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_repository_error(response)
        } else {
            crate::operation_deser::parse_get_repository_response(response)
        }
    }
}

/// <p>Gets information about triggers configured for a repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct GetRepositoryTriggers {
    _private: (),
}
impl GetRepositoryTriggers {
    /// Creates a new builder-style object to manufacture [`GetRepositoryTriggersInput`](crate::input::GetRepositoryTriggersInput)
    pub fn builder() -> crate::input::get_repository_triggers_input::Builder {
        crate::input::get_repository_triggers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for GetRepositoryTriggers {
    type Output = std::result::Result<
        crate::output::GetRepositoryTriggersOutput,
        crate::error::GetRepositoryTriggersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_get_repository_triggers_error(response)
        } else {
            crate::operation_deser::parse_get_repository_triggers_response(response)
        }
    }
}

/// <p>Lists all approval rule templates in the specified AWS Region in your AWS account. If
/// an AWS Region is not specified, the AWS Region where you are signed in is used.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListApprovalRuleTemplates {
    _private: (),
}
impl ListApprovalRuleTemplates {
    /// Creates a new builder-style object to manufacture [`ListApprovalRuleTemplatesInput`](crate::input::ListApprovalRuleTemplatesInput)
    pub fn builder() -> crate::input::list_approval_rule_templates_input::Builder {
        crate::input::list_approval_rule_templates_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListApprovalRuleTemplates {
    type Output = std::result::Result<
        crate::output::ListApprovalRuleTemplatesOutput,
        crate::error::ListApprovalRuleTemplatesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_approval_rule_templates_error(response)
        } else {
            crate::operation_deser::parse_list_approval_rule_templates_response(response)
        }
    }
}

/// <p>Lists all approval rule templates that are associated with a specified repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListAssociatedApprovalRuleTemplatesForRepository {
    _private: (),
}
impl ListAssociatedApprovalRuleTemplatesForRepository {
    /// Creates a new builder-style object to manufacture [`ListAssociatedApprovalRuleTemplatesForRepositoryInput`](crate::input::ListAssociatedApprovalRuleTemplatesForRepositoryInput)
    pub fn builder(
    ) -> crate::input::list_associated_approval_rule_templates_for_repository_input::Builder {
        crate::input::list_associated_approval_rule_templates_for_repository_input::Builder::default(
        )
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse
    for ListAssociatedApprovalRuleTemplatesForRepository
{
    type Output = std::result::Result<
        crate::output::ListAssociatedApprovalRuleTemplatesForRepositoryOutput,
        crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_associated_approval_rule_templates_for_repository_error(response)
        } else {
            crate::operation_deser::parse_list_associated_approval_rule_templates_for_repository_response(response)
        }
    }
}

/// <p>Gets information about one or more branches in a repository.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListBranches {
    _private: (),
}
impl ListBranches {
    /// Creates a new builder-style object to manufacture [`ListBranchesInput`](crate::input::ListBranchesInput)
    pub fn builder() -> crate::input::list_branches_input::Builder {
        crate::input::list_branches_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListBranches {
    type Output =
        std::result::Result<crate::output::ListBranchesOutput, crate::error::ListBranchesError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_branches_error(response)
        } else {
            crate::operation_deser::parse_list_branches_response(response)
        }
    }
}

/// <p>Returns a list of pull requests for a specified repository. The return list can be refined by pull request
/// status or pull request author ARN.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListPullRequests {
    _private: (),
}
impl ListPullRequests {
    /// Creates a new builder-style object to manufacture [`ListPullRequestsInput`](crate::input::ListPullRequestsInput)
    pub fn builder() -> crate::input::list_pull_requests_input::Builder {
        crate::input::list_pull_requests_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListPullRequests {
    type Output = std::result::Result<
        crate::output::ListPullRequestsOutput,
        crate::error::ListPullRequestsError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_pull_requests_error(response)
        } else {
            crate::operation_deser::parse_list_pull_requests_response(response)
        }
    }
}

/// <p>Gets information about one or more repositories.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRepositories {
    _private: (),
}
impl ListRepositories {
    /// Creates a new builder-style object to manufacture [`ListRepositoriesInput`](crate::input::ListRepositoriesInput)
    pub fn builder() -> crate::input::list_repositories_input::Builder {
        crate::input::list_repositories_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRepositories {
    type Output = std::result::Result<
        crate::output::ListRepositoriesOutput,
        crate::error::ListRepositoriesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_repositories_error(response)
        } else {
            crate::operation_deser::parse_list_repositories_response(response)
        }
    }
}

/// <p>Lists all repositories associated with the specified approval rule template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListRepositoriesForApprovalRuleTemplate {
    _private: (),
}
impl ListRepositoriesForApprovalRuleTemplate {
    /// Creates a new builder-style object to manufacture [`ListRepositoriesForApprovalRuleTemplateInput`](crate::input::ListRepositoriesForApprovalRuleTemplateInput)
    pub fn builder() -> crate::input::list_repositories_for_approval_rule_template_input::Builder {
        crate::input::list_repositories_for_approval_rule_template_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListRepositoriesForApprovalRuleTemplate {
    type Output = std::result::Result<
        crate::output::ListRepositoriesForApprovalRuleTemplateOutput,
        crate::error::ListRepositoriesForApprovalRuleTemplateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_repositories_for_approval_rule_template_error(
                response,
            )
        } else {
            crate::operation_deser::parse_list_repositories_for_approval_rule_template_response(
                response,
            )
        }
    }
}

/// <p>Gets information about AWS tags for a specified Amazon Resource Name (ARN) in AWS
/// CodeCommit. For a list of valid resources in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the<i> AWS CodeCommit User
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct ListTagsForResource {
    _private: (),
}
impl ListTagsForResource {
    /// Creates a new builder-style object to manufacture [`ListTagsForResourceInput`](crate::input::ListTagsForResourceInput)
    pub fn builder() -> crate::input::list_tags_for_resource_input::Builder {
        crate::input::list_tags_for_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for ListTagsForResource {
    type Output = std::result::Result<
        crate::output::ListTagsForResourceOutput,
        crate::error::ListTagsForResourceError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_list_tags_for_resource_error(response)
        } else {
            crate::operation_deser::parse_list_tags_for_resource_response(response)
        }
    }
}

/// <p>Merges two branches using the fast-forward merge strategy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct MergeBranchesByFastForward {
    _private: (),
}
impl MergeBranchesByFastForward {
    /// Creates a new builder-style object to manufacture [`MergeBranchesByFastForwardInput`](crate::input::MergeBranchesByFastForwardInput)
    pub fn builder() -> crate::input::merge_branches_by_fast_forward_input::Builder {
        crate::input::merge_branches_by_fast_forward_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for MergeBranchesByFastForward {
    type Output = std::result::Result<
        crate::output::MergeBranchesByFastForwardOutput,
        crate::error::MergeBranchesByFastForwardError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_merge_branches_by_fast_forward_error(response)
        } else {
            crate::operation_deser::parse_merge_branches_by_fast_forward_response(response)
        }
    }
}

/// <p>Merges two branches using the squash merge strategy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct MergeBranchesBySquash {
    _private: (),
}
impl MergeBranchesBySquash {
    /// Creates a new builder-style object to manufacture [`MergeBranchesBySquashInput`](crate::input::MergeBranchesBySquashInput)
    pub fn builder() -> crate::input::merge_branches_by_squash_input::Builder {
        crate::input::merge_branches_by_squash_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for MergeBranchesBySquash {
    type Output = std::result::Result<
        crate::output::MergeBranchesBySquashOutput,
        crate::error::MergeBranchesBySquashError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_merge_branches_by_squash_error(response)
        } else {
            crate::operation_deser::parse_merge_branches_by_squash_response(response)
        }
    }
}

/// <p>Merges two specified branches using the three-way merge strategy.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct MergeBranchesByThreeWay {
    _private: (),
}
impl MergeBranchesByThreeWay {
    /// Creates a new builder-style object to manufacture [`MergeBranchesByThreeWayInput`](crate::input::MergeBranchesByThreeWayInput)
    pub fn builder() -> crate::input::merge_branches_by_three_way_input::Builder {
        crate::input::merge_branches_by_three_way_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for MergeBranchesByThreeWay {
    type Output = std::result::Result<
        crate::output::MergeBranchesByThreeWayOutput,
        crate::error::MergeBranchesByThreeWayError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_merge_branches_by_three_way_error(response)
        } else {
            crate::operation_deser::parse_merge_branches_by_three_way_response(response)
        }
    }
}

/// <p>Attempts to merge the source commit of a pull request into the specified destination
/// branch for that pull request at the specified commit using the fast-forward merge strategy. If the merge is successful, it closes the pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct MergePullRequestByFastForward {
    _private: (),
}
impl MergePullRequestByFastForward {
    /// Creates a new builder-style object to manufacture [`MergePullRequestByFastForwardInput`](crate::input::MergePullRequestByFastForwardInput)
    pub fn builder() -> crate::input::merge_pull_request_by_fast_forward_input::Builder {
        crate::input::merge_pull_request_by_fast_forward_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for MergePullRequestByFastForward {
    type Output = std::result::Result<
        crate::output::MergePullRequestByFastForwardOutput,
        crate::error::MergePullRequestByFastForwardError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_merge_pull_request_by_fast_forward_error(response)
        } else {
            crate::operation_deser::parse_merge_pull_request_by_fast_forward_response(response)
        }
    }
}

/// <p>Attempts to merge the source commit of a pull request into the specified destination
/// branch for that pull request at the specified commit using the squash merge strategy. If the merge is successful, it closes the pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct MergePullRequestBySquash {
    _private: (),
}
impl MergePullRequestBySquash {
    /// Creates a new builder-style object to manufacture [`MergePullRequestBySquashInput`](crate::input::MergePullRequestBySquashInput)
    pub fn builder() -> crate::input::merge_pull_request_by_squash_input::Builder {
        crate::input::merge_pull_request_by_squash_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for MergePullRequestBySquash {
    type Output = std::result::Result<
        crate::output::MergePullRequestBySquashOutput,
        crate::error::MergePullRequestBySquashError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_merge_pull_request_by_squash_error(response)
        } else {
            crate::operation_deser::parse_merge_pull_request_by_squash_response(response)
        }
    }
}

/// <p>Attempts to merge the source commit of a pull request into the specified destination
/// branch for that pull request at the specified commit using the three-way merge strategy. If the merge is successful, it closes the pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct MergePullRequestByThreeWay {
    _private: (),
}
impl MergePullRequestByThreeWay {
    /// Creates a new builder-style object to manufacture [`MergePullRequestByThreeWayInput`](crate::input::MergePullRequestByThreeWayInput)
    pub fn builder() -> crate::input::merge_pull_request_by_three_way_input::Builder {
        crate::input::merge_pull_request_by_three_way_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for MergePullRequestByThreeWay {
    type Output = std::result::Result<
        crate::output::MergePullRequestByThreeWayOutput,
        crate::error::MergePullRequestByThreeWayError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_merge_pull_request_by_three_way_error(response)
        } else {
            crate::operation_deser::parse_merge_pull_request_by_three_way_response(response)
        }
    }
}

/// <p>Sets aside (overrides) all approval rule requirements for a specified pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct OverridePullRequestApprovalRules {
    _private: (),
}
impl OverridePullRequestApprovalRules {
    /// Creates a new builder-style object to manufacture [`OverridePullRequestApprovalRulesInput`](crate::input::OverridePullRequestApprovalRulesInput)
    pub fn builder() -> crate::input::override_pull_request_approval_rules_input::Builder {
        crate::input::override_pull_request_approval_rules_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for OverridePullRequestApprovalRules {
    type Output = std::result::Result<
        crate::output::OverridePullRequestApprovalRulesOutput,
        crate::error::OverridePullRequestApprovalRulesError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_override_pull_request_approval_rules_error(response)
        } else {
            crate::operation_deser::parse_override_pull_request_approval_rules_response(response)
        }
    }
}

/// <p>Posts a comment on the comparison between two commits.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PostCommentForComparedCommit {
    _private: (),
}
impl PostCommentForComparedCommit {
    /// Creates a new builder-style object to manufacture [`PostCommentForComparedCommitInput`](crate::input::PostCommentForComparedCommitInput)
    pub fn builder() -> crate::input::post_comment_for_compared_commit_input::Builder {
        crate::input::post_comment_for_compared_commit_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PostCommentForComparedCommit {
    type Output = std::result::Result<
        crate::output::PostCommentForComparedCommitOutput,
        crate::error::PostCommentForComparedCommitError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_post_comment_for_compared_commit_error(response)
        } else {
            crate::operation_deser::parse_post_comment_for_compared_commit_response(response)
        }
    }
}

/// <p>Posts a comment on a pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PostCommentForPullRequest {
    _private: (),
}
impl PostCommentForPullRequest {
    /// Creates a new builder-style object to manufacture [`PostCommentForPullRequestInput`](crate::input::PostCommentForPullRequestInput)
    pub fn builder() -> crate::input::post_comment_for_pull_request_input::Builder {
        crate::input::post_comment_for_pull_request_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PostCommentForPullRequest {
    type Output = std::result::Result<
        crate::output::PostCommentForPullRequestOutput,
        crate::error::PostCommentForPullRequestError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_post_comment_for_pull_request_error(response)
        } else {
            crate::operation_deser::parse_post_comment_for_pull_request_response(response)
        }
    }
}

/// <p>Posts a comment in reply to an existing comment on a comparison between commits or a pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PostCommentReply {
    _private: (),
}
impl PostCommentReply {
    /// Creates a new builder-style object to manufacture [`PostCommentReplyInput`](crate::input::PostCommentReplyInput)
    pub fn builder() -> crate::input::post_comment_reply_input::Builder {
        crate::input::post_comment_reply_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PostCommentReply {
    type Output = std::result::Result<
        crate::output::PostCommentReplyOutput,
        crate::error::PostCommentReplyError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_post_comment_reply_error(response)
        } else {
            crate::operation_deser::parse_post_comment_reply_response(response)
        }
    }
}

/// <p>Adds or updates a reaction to a specified comment for the user whose identity is used to make the request. You can only add or
/// update a reaction for yourself. You cannot add, modify, or delete a reaction for another user.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutCommentReaction {
    _private: (),
}
impl PutCommentReaction {
    /// Creates a new builder-style object to manufacture [`PutCommentReactionInput`](crate::input::PutCommentReactionInput)
    pub fn builder() -> crate::input::put_comment_reaction_input::Builder {
        crate::input::put_comment_reaction_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutCommentReaction {
    type Output = std::result::Result<
        crate::output::PutCommentReactionOutput,
        crate::error::PutCommentReactionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_comment_reaction_error(response)
        } else {
            crate::operation_deser::parse_put_comment_reaction_response(response)
        }
    }
}

/// <p>Adds or updates a file in a branch in an AWS CodeCommit repository, and generates a commit for the addition in the specified branch.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutFile {
    _private: (),
}
impl PutFile {
    /// Creates a new builder-style object to manufacture [`PutFileInput`](crate::input::PutFileInput)
    pub fn builder() -> crate::input::put_file_input::Builder {
        crate::input::put_file_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutFile {
    type Output = std::result::Result<crate::output::PutFileOutput, crate::error::PutFileError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_file_error(response)
        } else {
            crate::operation_deser::parse_put_file_response(response)
        }
    }
}

/// <p>Replaces all triggers for a repository. Used to create or delete triggers.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct PutRepositoryTriggers {
    _private: (),
}
impl PutRepositoryTriggers {
    /// Creates a new builder-style object to manufacture [`PutRepositoryTriggersInput`](crate::input::PutRepositoryTriggersInput)
    pub fn builder() -> crate::input::put_repository_triggers_input::Builder {
        crate::input::put_repository_triggers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for PutRepositoryTriggers {
    type Output = std::result::Result<
        crate::output::PutRepositoryTriggersOutput,
        crate::error::PutRepositoryTriggersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_put_repository_triggers_error(response)
        } else {
            crate::operation_deser::parse_put_repository_triggers_response(response)
        }
    }
}

/// <p>Adds or updates tags for a resource in AWS CodeCommit. For a list of valid resources
/// in AWS CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the <i>AWS CodeCommit User
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TagResource {
    _private: (),
}
impl TagResource {
    /// Creates a new builder-style object to manufacture [`TagResourceInput`](crate::input::TagResourceInput)
    pub fn builder() -> crate::input::tag_resource_input::Builder {
        crate::input::tag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TagResource {
    type Output =
        std::result::Result<crate::output::TagResourceOutput, crate::error::TagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_tag_resource_error(response)
        } else {
            crate::operation_deser::parse_tag_resource_response(response)
        }
    }
}

/// <p>Tests the functionality of repository triggers by sending information to the trigger
/// target. If real data is available in the repository, the test sends data from the last
/// commit. If no data is available, sample data is generated.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct TestRepositoryTriggers {
    _private: (),
}
impl TestRepositoryTriggers {
    /// Creates a new builder-style object to manufacture [`TestRepositoryTriggersInput`](crate::input::TestRepositoryTriggersInput)
    pub fn builder() -> crate::input::test_repository_triggers_input::Builder {
        crate::input::test_repository_triggers_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for TestRepositoryTriggers {
    type Output = std::result::Result<
        crate::output::TestRepositoryTriggersOutput,
        crate::error::TestRepositoryTriggersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_test_repository_triggers_error(response)
        } else {
            crate::operation_deser::parse_test_repository_triggers_response(response)
        }
    }
}

/// <p>Removes tags for a resource in AWS CodeCommit. For a list of valid resources in AWS
/// CodeCommit, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats">CodeCommit Resources and Operations</a> in the <i>AWS CodeCommit User
/// Guide</i>.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UntagResource {
    _private: (),
}
impl UntagResource {
    /// Creates a new builder-style object to manufacture [`UntagResourceInput`](crate::input::UntagResourceInput)
    pub fn builder() -> crate::input::untag_resource_input::Builder {
        crate::input::untag_resource_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UntagResource {
    type Output =
        std::result::Result<crate::output::UntagResourceOutput, crate::error::UntagResourceError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_untag_resource_error(response)
        } else {
            crate::operation_deser::parse_untag_resource_response(response)
        }
    }
}

/// <p>Updates the content of an approval rule template. You can change the number of
/// required approvals, the membership of the approval rule, and whether an approval pool is
/// defined.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateApprovalRuleTemplateContent {
    _private: (),
}
impl UpdateApprovalRuleTemplateContent {
    /// Creates a new builder-style object to manufacture [`UpdateApprovalRuleTemplateContentInput`](crate::input::UpdateApprovalRuleTemplateContentInput)
    pub fn builder() -> crate::input::update_approval_rule_template_content_input::Builder {
        crate::input::update_approval_rule_template_content_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateApprovalRuleTemplateContent {
    type Output = std::result::Result<
        crate::output::UpdateApprovalRuleTemplateContentOutput,
        crate::error::UpdateApprovalRuleTemplateContentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_approval_rule_template_content_error(response)
        } else {
            crate::operation_deser::parse_update_approval_rule_template_content_response(response)
        }
    }
}

/// <p>Updates the description for a specified approval rule template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateApprovalRuleTemplateDescription {
    _private: (),
}
impl UpdateApprovalRuleTemplateDescription {
    /// Creates a new builder-style object to manufacture [`UpdateApprovalRuleTemplateDescriptionInput`](crate::input::UpdateApprovalRuleTemplateDescriptionInput)
    pub fn builder() -> crate::input::update_approval_rule_template_description_input::Builder {
        crate::input::update_approval_rule_template_description_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateApprovalRuleTemplateDescription {
    type Output = std::result::Result<
        crate::output::UpdateApprovalRuleTemplateDescriptionOutput,
        crate::error::UpdateApprovalRuleTemplateDescriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_approval_rule_template_description_error(response)
        } else {
            crate::operation_deser::parse_update_approval_rule_template_description_response(
                response,
            )
        }
    }
}

/// <p>Updates the name of a specified approval rule template.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateApprovalRuleTemplateName {
    _private: (),
}
impl UpdateApprovalRuleTemplateName {
    /// Creates a new builder-style object to manufacture [`UpdateApprovalRuleTemplateNameInput`](crate::input::UpdateApprovalRuleTemplateNameInput)
    pub fn builder() -> crate::input::update_approval_rule_template_name_input::Builder {
        crate::input::update_approval_rule_template_name_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateApprovalRuleTemplateName {
    type Output = std::result::Result<
        crate::output::UpdateApprovalRuleTemplateNameOutput,
        crate::error::UpdateApprovalRuleTemplateNameError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_approval_rule_template_name_error(response)
        } else {
            crate::operation_deser::parse_update_approval_rule_template_name_response(response)
        }
    }
}

/// <p>Replaces the contents of a comment.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateComment {
    _private: (),
}
impl UpdateComment {
    /// Creates a new builder-style object to manufacture [`UpdateCommentInput`](crate::input::UpdateCommentInput)
    pub fn builder() -> crate::input::update_comment_input::Builder {
        crate::input::update_comment_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateComment {
    type Output =
        std::result::Result<crate::output::UpdateCommentOutput, crate::error::UpdateCommentError>;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_comment_error(response)
        } else {
            crate::operation_deser::parse_update_comment_response(response)
        }
    }
}

/// <p>Sets or changes the default branch name for the specified repository.</p>
/// <note>
/// <p>If you use this operation to change the default branch name to the current default branch name, a success message is returned even though the default branch did not change.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateDefaultBranch {
    _private: (),
}
impl UpdateDefaultBranch {
    /// Creates a new builder-style object to manufacture [`UpdateDefaultBranchInput`](crate::input::UpdateDefaultBranchInput)
    pub fn builder() -> crate::input::update_default_branch_input::Builder {
        crate::input::update_default_branch_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateDefaultBranch {
    type Output = std::result::Result<
        crate::output::UpdateDefaultBranchOutput,
        crate::error::UpdateDefaultBranchError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_default_branch_error(response)
        } else {
            crate::operation_deser::parse_update_default_branch_response(response)
        }
    }
}

/// <p>Updates the structure of an approval rule created specifically for a pull request. For example, you can change the number of required approvers and
/// the approval pool for approvers. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePullRequestApprovalRuleContent {
    _private: (),
}
impl UpdatePullRequestApprovalRuleContent {
    /// Creates a new builder-style object to manufacture [`UpdatePullRequestApprovalRuleContentInput`](crate::input::UpdatePullRequestApprovalRuleContentInput)
    pub fn builder() -> crate::input::update_pull_request_approval_rule_content_input::Builder {
        crate::input::update_pull_request_approval_rule_content_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePullRequestApprovalRuleContent {
    type Output = std::result::Result<
        crate::output::UpdatePullRequestApprovalRuleContentOutput,
        crate::error::UpdatePullRequestApprovalRuleContentError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_pull_request_approval_rule_content_error(response)
        } else {
            crate::operation_deser::parse_update_pull_request_approval_rule_content_response(
                response,
            )
        }
    }
}

/// <p>Updates the state of a user's approval on a pull request. The user is derived from the signed-in account when the request is made.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePullRequestApprovalState {
    _private: (),
}
impl UpdatePullRequestApprovalState {
    /// Creates a new builder-style object to manufacture [`UpdatePullRequestApprovalStateInput`](crate::input::UpdatePullRequestApprovalStateInput)
    pub fn builder() -> crate::input::update_pull_request_approval_state_input::Builder {
        crate::input::update_pull_request_approval_state_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePullRequestApprovalState {
    type Output = std::result::Result<
        crate::output::UpdatePullRequestApprovalStateOutput,
        crate::error::UpdatePullRequestApprovalStateError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_pull_request_approval_state_error(response)
        } else {
            crate::operation_deser::parse_update_pull_request_approval_state_response(response)
        }
    }
}

/// <p>Replaces the contents of the description of a pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePullRequestDescription {
    _private: (),
}
impl UpdatePullRequestDescription {
    /// Creates a new builder-style object to manufacture [`UpdatePullRequestDescriptionInput`](crate::input::UpdatePullRequestDescriptionInput)
    pub fn builder() -> crate::input::update_pull_request_description_input::Builder {
        crate::input::update_pull_request_description_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePullRequestDescription {
    type Output = std::result::Result<
        crate::output::UpdatePullRequestDescriptionOutput,
        crate::error::UpdatePullRequestDescriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_pull_request_description_error(response)
        } else {
            crate::operation_deser::parse_update_pull_request_description_response(response)
        }
    }
}

/// <p>Updates the status of a pull request. </p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePullRequestStatus {
    _private: (),
}
impl UpdatePullRequestStatus {
    /// Creates a new builder-style object to manufacture [`UpdatePullRequestStatusInput`](crate::input::UpdatePullRequestStatusInput)
    pub fn builder() -> crate::input::update_pull_request_status_input::Builder {
        crate::input::update_pull_request_status_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePullRequestStatus {
    type Output = std::result::Result<
        crate::output::UpdatePullRequestStatusOutput,
        crate::error::UpdatePullRequestStatusError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_pull_request_status_error(response)
        } else {
            crate::operation_deser::parse_update_pull_request_status_response(response)
        }
    }
}

/// <p>Replaces the title of a pull request.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdatePullRequestTitle {
    _private: (),
}
impl UpdatePullRequestTitle {
    /// Creates a new builder-style object to manufacture [`UpdatePullRequestTitleInput`](crate::input::UpdatePullRequestTitleInput)
    pub fn builder() -> crate::input::update_pull_request_title_input::Builder {
        crate::input::update_pull_request_title_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdatePullRequestTitle {
    type Output = std::result::Result<
        crate::output::UpdatePullRequestTitleOutput,
        crate::error::UpdatePullRequestTitleError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_pull_request_title_error(response)
        } else {
            crate::operation_deser::parse_update_pull_request_title_response(response)
        }
    }
}

/// <p>Sets or changes the comment or description for a repository.</p>
/// <note>
/// <p>The description field for a repository accepts all HTML characters and all valid
/// Unicode characters. Applications that do not HTML-encode the description and display
/// it in a webpage can expose users to potentially malicious code. Make sure that you
/// HTML-encode the description field in any application that uses this API to display
/// the repository description on a webpage.</p>
/// </note>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRepositoryDescription {
    _private: (),
}
impl UpdateRepositoryDescription {
    /// Creates a new builder-style object to manufacture [`UpdateRepositoryDescriptionInput`](crate::input::UpdateRepositoryDescriptionInput)
    pub fn builder() -> crate::input::update_repository_description_input::Builder {
        crate::input::update_repository_description_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRepositoryDescription {
    type Output = std::result::Result<
        crate::output::UpdateRepositoryDescriptionOutput,
        crate::error::UpdateRepositoryDescriptionError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_repository_description_error(response)
        } else {
            crate::operation_deser::parse_update_repository_description_response(response)
        }
    }
}

/// <p>Renames a repository. The repository name must be unique across the calling AWS
/// account. Repository names are limited to 100 alphanumeric, dash, and underscore
/// characters, and cannot include certain characters. The suffix .git is prohibited. For
/// more information about the limits on repository names, see <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">Limits</a> in the AWS CodeCommit
/// User Guide.</p>
#[derive(std::default::Default, std::clone::Clone, std::fmt::Debug)]
pub struct UpdateRepositoryName {
    _private: (),
}
impl UpdateRepositoryName {
    /// Creates a new builder-style object to manufacture [`UpdateRepositoryNameInput`](crate::input::UpdateRepositoryNameInput)
    pub fn builder() -> crate::input::update_repository_name_input::Builder {
        crate::input::update_repository_name_input::Builder::default()
    }
    pub fn new() -> Self {
        Self { _private: () }
    }
}
impl smithy_http::response::ParseStrictResponse for UpdateRepositoryName {
    type Output = std::result::Result<
        crate::output::UpdateRepositoryNameOutput,
        crate::error::UpdateRepositoryNameError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::operation_deser::parse_update_repository_name_error(response)
        } else {
            crate::operation_deser::parse_update_repository_name_response(response)
        }
    }
}
