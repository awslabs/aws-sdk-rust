// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
#[derive(std::fmt::Debug)]
pub(crate) struct Handle<C = aws_hyper::DynConnector> {
    client: aws_hyper::Client<C>,
    conf: crate::Config,
}

#[derive(Clone, std::fmt::Debug)]
pub struct Client<C = aws_hyper::DynConnector> {
    handle: std::sync::Arc<Handle<C>>,
}
impl<C> Client<C> {
    pub fn from_conf_conn(conf: crate::Config, conn: C) -> Self {
        let client = aws_hyper::Client::new(conn);
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }

    pub fn conf(&self) -> &crate::Config {
        &self.handle.conf
    }
}
impl Client {
    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_env() -> Self {
        Self::from_conf(crate::Config::builder().build())
    }

    #[cfg(any(feature = "rustls", feature = "native-tls"))]
    pub fn from_conf(conf: crate::Config) -> Self {
        let client = aws_hyper::Client::https();
        Self {
            handle: std::sync::Arc::new(Handle { client, conf }),
        }
    }
}
impl<C> Client<C>
where
    C: aws_hyper::SmithyConnector,
{
    pub fn associate_approval_rule_template_with_repository(
        &self,
    ) -> fluent_builders::AssociateApprovalRuleTemplateWithRepository<C> {
        fluent_builders::AssociateApprovalRuleTemplateWithRepository::new(self.handle.clone())
    }
    pub fn batch_associate_approval_rule_template_with_repositories(
        &self,
    ) -> fluent_builders::BatchAssociateApprovalRuleTemplateWithRepositories<C> {
        fluent_builders::BatchAssociateApprovalRuleTemplateWithRepositories::new(
            self.handle.clone(),
        )
    }
    pub fn batch_describe_merge_conflicts(
        &self,
    ) -> fluent_builders::BatchDescribeMergeConflicts<C> {
        fluent_builders::BatchDescribeMergeConflicts::new(self.handle.clone())
    }
    pub fn batch_disassociate_approval_rule_template_from_repositories(
        &self,
    ) -> fluent_builders::BatchDisassociateApprovalRuleTemplateFromRepositories<C> {
        fluent_builders::BatchDisassociateApprovalRuleTemplateFromRepositories::new(
            self.handle.clone(),
        )
    }
    pub fn batch_get_commits(&self) -> fluent_builders::BatchGetCommits<C> {
        fluent_builders::BatchGetCommits::new(self.handle.clone())
    }
    pub fn batch_get_repositories(&self) -> fluent_builders::BatchGetRepositories<C> {
        fluent_builders::BatchGetRepositories::new(self.handle.clone())
    }
    pub fn create_approval_rule_template(&self) -> fluent_builders::CreateApprovalRuleTemplate<C> {
        fluent_builders::CreateApprovalRuleTemplate::new(self.handle.clone())
    }
    pub fn create_branch(&self) -> fluent_builders::CreateBranch<C> {
        fluent_builders::CreateBranch::new(self.handle.clone())
    }
    pub fn create_commit(&self) -> fluent_builders::CreateCommit<C> {
        fluent_builders::CreateCommit::new(self.handle.clone())
    }
    pub fn create_pull_request(&self) -> fluent_builders::CreatePullRequest<C> {
        fluent_builders::CreatePullRequest::new(self.handle.clone())
    }
    pub fn create_pull_request_approval_rule(
        &self,
    ) -> fluent_builders::CreatePullRequestApprovalRule<C> {
        fluent_builders::CreatePullRequestApprovalRule::new(self.handle.clone())
    }
    pub fn create_repository(&self) -> fluent_builders::CreateRepository<C> {
        fluent_builders::CreateRepository::new(self.handle.clone())
    }
    pub fn create_unreferenced_merge_commit(
        &self,
    ) -> fluent_builders::CreateUnreferencedMergeCommit<C> {
        fluent_builders::CreateUnreferencedMergeCommit::new(self.handle.clone())
    }
    pub fn delete_approval_rule_template(&self) -> fluent_builders::DeleteApprovalRuleTemplate<C> {
        fluent_builders::DeleteApprovalRuleTemplate::new(self.handle.clone())
    }
    pub fn delete_branch(&self) -> fluent_builders::DeleteBranch<C> {
        fluent_builders::DeleteBranch::new(self.handle.clone())
    }
    pub fn delete_comment_content(&self) -> fluent_builders::DeleteCommentContent<C> {
        fluent_builders::DeleteCommentContent::new(self.handle.clone())
    }
    pub fn delete_file(&self) -> fluent_builders::DeleteFile<C> {
        fluent_builders::DeleteFile::new(self.handle.clone())
    }
    pub fn delete_pull_request_approval_rule(
        &self,
    ) -> fluent_builders::DeletePullRequestApprovalRule<C> {
        fluent_builders::DeletePullRequestApprovalRule::new(self.handle.clone())
    }
    pub fn delete_repository(&self) -> fluent_builders::DeleteRepository<C> {
        fluent_builders::DeleteRepository::new(self.handle.clone())
    }
    pub fn describe_merge_conflicts(&self) -> fluent_builders::DescribeMergeConflicts<C> {
        fluent_builders::DescribeMergeConflicts::new(self.handle.clone())
    }
    pub fn describe_pull_request_events(&self) -> fluent_builders::DescribePullRequestEvents<C> {
        fluent_builders::DescribePullRequestEvents::new(self.handle.clone())
    }
    pub fn disassociate_approval_rule_template_from_repository(
        &self,
    ) -> fluent_builders::DisassociateApprovalRuleTemplateFromRepository<C> {
        fluent_builders::DisassociateApprovalRuleTemplateFromRepository::new(self.handle.clone())
    }
    pub fn evaluate_pull_request_approval_rules(
        &self,
    ) -> fluent_builders::EvaluatePullRequestApprovalRules<C> {
        fluent_builders::EvaluatePullRequestApprovalRules::new(self.handle.clone())
    }
    pub fn get_approval_rule_template(&self) -> fluent_builders::GetApprovalRuleTemplate<C> {
        fluent_builders::GetApprovalRuleTemplate::new(self.handle.clone())
    }
    pub fn get_blob(&self) -> fluent_builders::GetBlob<C> {
        fluent_builders::GetBlob::new(self.handle.clone())
    }
    pub fn get_branch(&self) -> fluent_builders::GetBranch<C> {
        fluent_builders::GetBranch::new(self.handle.clone())
    }
    pub fn get_comment(&self) -> fluent_builders::GetComment<C> {
        fluent_builders::GetComment::new(self.handle.clone())
    }
    pub fn get_comment_reactions(&self) -> fluent_builders::GetCommentReactions<C> {
        fluent_builders::GetCommentReactions::new(self.handle.clone())
    }
    pub fn get_comments_for_compared_commit(
        &self,
    ) -> fluent_builders::GetCommentsForComparedCommit<C> {
        fluent_builders::GetCommentsForComparedCommit::new(self.handle.clone())
    }
    pub fn get_comments_for_pull_request(&self) -> fluent_builders::GetCommentsForPullRequest<C> {
        fluent_builders::GetCommentsForPullRequest::new(self.handle.clone())
    }
    pub fn get_commit(&self) -> fluent_builders::GetCommit<C> {
        fluent_builders::GetCommit::new(self.handle.clone())
    }
    pub fn get_differences(&self) -> fluent_builders::GetDifferences<C> {
        fluent_builders::GetDifferences::new(self.handle.clone())
    }
    pub fn get_file(&self) -> fluent_builders::GetFile<C> {
        fluent_builders::GetFile::new(self.handle.clone())
    }
    pub fn get_folder(&self) -> fluent_builders::GetFolder<C> {
        fluent_builders::GetFolder::new(self.handle.clone())
    }
    pub fn get_merge_commit(&self) -> fluent_builders::GetMergeCommit<C> {
        fluent_builders::GetMergeCommit::new(self.handle.clone())
    }
    pub fn get_merge_conflicts(&self) -> fluent_builders::GetMergeConflicts<C> {
        fluent_builders::GetMergeConflicts::new(self.handle.clone())
    }
    pub fn get_merge_options(&self) -> fluent_builders::GetMergeOptions<C> {
        fluent_builders::GetMergeOptions::new(self.handle.clone())
    }
    pub fn get_pull_request(&self) -> fluent_builders::GetPullRequest<C> {
        fluent_builders::GetPullRequest::new(self.handle.clone())
    }
    pub fn get_pull_request_approval_states(
        &self,
    ) -> fluent_builders::GetPullRequestApprovalStates<C> {
        fluent_builders::GetPullRequestApprovalStates::new(self.handle.clone())
    }
    pub fn get_pull_request_override_state(
        &self,
    ) -> fluent_builders::GetPullRequestOverrideState<C> {
        fluent_builders::GetPullRequestOverrideState::new(self.handle.clone())
    }
    pub fn get_repository(&self) -> fluent_builders::GetRepository<C> {
        fluent_builders::GetRepository::new(self.handle.clone())
    }
    pub fn get_repository_triggers(&self) -> fluent_builders::GetRepositoryTriggers<C> {
        fluent_builders::GetRepositoryTriggers::new(self.handle.clone())
    }
    pub fn list_approval_rule_templates(&self) -> fluent_builders::ListApprovalRuleTemplates<C> {
        fluent_builders::ListApprovalRuleTemplates::new(self.handle.clone())
    }
    pub fn list_associated_approval_rule_templates_for_repository(
        &self,
    ) -> fluent_builders::ListAssociatedApprovalRuleTemplatesForRepository<C> {
        fluent_builders::ListAssociatedApprovalRuleTemplatesForRepository::new(self.handle.clone())
    }
    pub fn list_branches(&self) -> fluent_builders::ListBranches<C> {
        fluent_builders::ListBranches::new(self.handle.clone())
    }
    pub fn list_pull_requests(&self) -> fluent_builders::ListPullRequests<C> {
        fluent_builders::ListPullRequests::new(self.handle.clone())
    }
    pub fn list_repositories(&self) -> fluent_builders::ListRepositories<C> {
        fluent_builders::ListRepositories::new(self.handle.clone())
    }
    pub fn list_repositories_for_approval_rule_template(
        &self,
    ) -> fluent_builders::ListRepositoriesForApprovalRuleTemplate<C> {
        fluent_builders::ListRepositoriesForApprovalRuleTemplate::new(self.handle.clone())
    }
    pub fn list_tags_for_resource(&self) -> fluent_builders::ListTagsForResource<C> {
        fluent_builders::ListTagsForResource::new(self.handle.clone())
    }
    pub fn merge_branches_by_fast_forward(&self) -> fluent_builders::MergeBranchesByFastForward<C> {
        fluent_builders::MergeBranchesByFastForward::new(self.handle.clone())
    }
    pub fn merge_branches_by_squash(&self) -> fluent_builders::MergeBranchesBySquash<C> {
        fluent_builders::MergeBranchesBySquash::new(self.handle.clone())
    }
    pub fn merge_branches_by_three_way(&self) -> fluent_builders::MergeBranchesByThreeWay<C> {
        fluent_builders::MergeBranchesByThreeWay::new(self.handle.clone())
    }
    pub fn merge_pull_request_by_fast_forward(
        &self,
    ) -> fluent_builders::MergePullRequestByFastForward<C> {
        fluent_builders::MergePullRequestByFastForward::new(self.handle.clone())
    }
    pub fn merge_pull_request_by_squash(&self) -> fluent_builders::MergePullRequestBySquash<C> {
        fluent_builders::MergePullRequestBySquash::new(self.handle.clone())
    }
    pub fn merge_pull_request_by_three_way(
        &self,
    ) -> fluent_builders::MergePullRequestByThreeWay<C> {
        fluent_builders::MergePullRequestByThreeWay::new(self.handle.clone())
    }
    pub fn override_pull_request_approval_rules(
        &self,
    ) -> fluent_builders::OverridePullRequestApprovalRules<C> {
        fluent_builders::OverridePullRequestApprovalRules::new(self.handle.clone())
    }
    pub fn post_comment_for_compared_commit(
        &self,
    ) -> fluent_builders::PostCommentForComparedCommit<C> {
        fluent_builders::PostCommentForComparedCommit::new(self.handle.clone())
    }
    pub fn post_comment_for_pull_request(&self) -> fluent_builders::PostCommentForPullRequest<C> {
        fluent_builders::PostCommentForPullRequest::new(self.handle.clone())
    }
    pub fn post_comment_reply(&self) -> fluent_builders::PostCommentReply<C> {
        fluent_builders::PostCommentReply::new(self.handle.clone())
    }
    pub fn put_comment_reaction(&self) -> fluent_builders::PutCommentReaction<C> {
        fluent_builders::PutCommentReaction::new(self.handle.clone())
    }
    pub fn put_file(&self) -> fluent_builders::PutFile<C> {
        fluent_builders::PutFile::new(self.handle.clone())
    }
    pub fn put_repository_triggers(&self) -> fluent_builders::PutRepositoryTriggers<C> {
        fluent_builders::PutRepositoryTriggers::new(self.handle.clone())
    }
    pub fn tag_resource(&self) -> fluent_builders::TagResource<C> {
        fluent_builders::TagResource::new(self.handle.clone())
    }
    pub fn test_repository_triggers(&self) -> fluent_builders::TestRepositoryTriggers<C> {
        fluent_builders::TestRepositoryTriggers::new(self.handle.clone())
    }
    pub fn untag_resource(&self) -> fluent_builders::UntagResource<C> {
        fluent_builders::UntagResource::new(self.handle.clone())
    }
    pub fn update_approval_rule_template_content(
        &self,
    ) -> fluent_builders::UpdateApprovalRuleTemplateContent<C> {
        fluent_builders::UpdateApprovalRuleTemplateContent::new(self.handle.clone())
    }
    pub fn update_approval_rule_template_description(
        &self,
    ) -> fluent_builders::UpdateApprovalRuleTemplateDescription<C> {
        fluent_builders::UpdateApprovalRuleTemplateDescription::new(self.handle.clone())
    }
    pub fn update_approval_rule_template_name(
        &self,
    ) -> fluent_builders::UpdateApprovalRuleTemplateName<C> {
        fluent_builders::UpdateApprovalRuleTemplateName::new(self.handle.clone())
    }
    pub fn update_comment(&self) -> fluent_builders::UpdateComment<C> {
        fluent_builders::UpdateComment::new(self.handle.clone())
    }
    pub fn update_default_branch(&self) -> fluent_builders::UpdateDefaultBranch<C> {
        fluent_builders::UpdateDefaultBranch::new(self.handle.clone())
    }
    pub fn update_pull_request_approval_rule_content(
        &self,
    ) -> fluent_builders::UpdatePullRequestApprovalRuleContent<C> {
        fluent_builders::UpdatePullRequestApprovalRuleContent::new(self.handle.clone())
    }
    pub fn update_pull_request_approval_state(
        &self,
    ) -> fluent_builders::UpdatePullRequestApprovalState<C> {
        fluent_builders::UpdatePullRequestApprovalState::new(self.handle.clone())
    }
    pub fn update_pull_request_description(
        &self,
    ) -> fluent_builders::UpdatePullRequestDescription<C> {
        fluent_builders::UpdatePullRequestDescription::new(self.handle.clone())
    }
    pub fn update_pull_request_status(&self) -> fluent_builders::UpdatePullRequestStatus<C> {
        fluent_builders::UpdatePullRequestStatus::new(self.handle.clone())
    }
    pub fn update_pull_request_title(&self) -> fluent_builders::UpdatePullRequestTitle<C> {
        fluent_builders::UpdatePullRequestTitle::new(self.handle.clone())
    }
    pub fn update_repository_description(&self) -> fluent_builders::UpdateRepositoryDescription<C> {
        fluent_builders::UpdateRepositoryDescription::new(self.handle.clone())
    }
    pub fn update_repository_name(&self) -> fluent_builders::UpdateRepositoryName<C> {
        fluent_builders::UpdateRepositoryName::new(self.handle.clone())
    }
}
pub mod fluent_builders {
    #[derive(std::fmt::Debug)]
    pub struct AssociateApprovalRuleTemplateWithRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::associate_approval_rule_template_with_repository_input::Builder,
    }
    impl<C> AssociateApprovalRuleTemplateWithRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::AssociateApprovalRuleTemplateWithRepositoryOutput,
            smithy_http::result::SdkError<
                crate::error::AssociateApprovalRuleTemplateWithRepositoryError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name for the approval rule template. </p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
        /// <p>The name of the repository that you want to associate with the template.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchAssociateApprovalRuleTemplateWithRepositories<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner:
            crate::input::batch_associate_approval_rule_template_with_repositories_input::Builder,
    }
    impl<C> BatchAssociateApprovalRuleTemplateWithRepositories<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchAssociateApprovalRuleTemplateWithRepositoriesOutput,
            smithy_http::result::SdkError<
                crate::error::BatchAssociateApprovalRuleTemplateWithRepositoriesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the template you want to associate with one or more repositories.</p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
        /// <p>The names of the repositories you want to associate with the template.</p>
        /// <note>
        /// <p>The length constraint limit is for each string in the array. The array itself can be empty.</p>
        /// </note>
        pub fn repository_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_names(inp);
            self
        }
        pub fn set_repository_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_repository_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDescribeMergeConflicts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_describe_merge_conflicts_input::Builder,
    }
    impl<C> BatchDescribeMergeConflicts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDescribeMergeConflictsOutput,
            smithy_http::result::SdkError<crate::error::BatchDescribeMergeConflictsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository that contains the merge conflicts you want to review.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn destination_commit_specifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_commit_specifier(input);
            self
        }
        pub fn set_destination_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn source_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_specifier(input);
            self
        }
        pub fn set_source_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_specifier(input);
            self
        }
        /// <p>The merge option or strategy you want to use to merge the code.</p>
        pub fn merge_option(mut self, input: crate::model::MergeOptionTypeEnum) -> Self {
            self.inner = self.inner.merge_option(input);
            self
        }
        pub fn set_merge_option(
            mut self,
            input: std::option::Option<crate::model::MergeOptionTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_merge_option(input);
            self
        }
        /// <p>The maximum number of merge hunks to include in the output.</p>
        pub fn max_merge_hunks(mut self, input: i32) -> Self {
            self.inner = self.inner.max_merge_hunks(input);
            self
        }
        pub fn set_max_merge_hunks(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_merge_hunks(input);
            self
        }
        /// <p>The maximum number of files to include in the output.</p>
        pub fn max_conflict_files(mut self, input: i32) -> Self {
            self.inner = self.inner.max_conflict_files(input);
            self
        }
        pub fn set_max_conflict_files(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_conflict_files(input);
            self
        }
        /// <p>The path of the target files used to describe the conflicts. If not specified, the default is all conflict files.</p>
        pub fn file_paths(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_paths(inp);
            self
        }
        pub fn set_file_paths(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_file_paths(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchDisassociateApprovalRuleTemplateFromRepositories<C = aws_hyper::DynConnector> {
                            handle: std::sync::Arc<super::Handle<C>>,
                            inner: crate::input::batch_disassociate_approval_rule_template_from_repositories_input::Builder
                        }
    impl<C> BatchDisassociateApprovalRuleTemplateFromRepositories<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput,
            smithy_http::result::SdkError<
                crate::error::BatchDisassociateApprovalRuleTemplateFromRepositoriesError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the template that you want to disassociate from one or more repositories.</p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
        /// <p>The repository names that you want to disassociate from the approval rule
        /// template.</p>
        /// <note>
        /// <p>The length constraint limit is for each string in the array. The array itself can be empty.</p>
        /// </note>
        pub fn repository_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_names(inp);
            self
        }
        pub fn set_repository_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_repository_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetCommits<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_commits_input::Builder,
    }
    impl<C> BatchGetCommits<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetCommitsOutput,
            smithy_http::result::SdkError<crate::error::BatchGetCommitsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The full commit IDs of the commits to get information about.</p>
        /// <note>
        /// <p>You must supply the full SHA IDs of each commit. You cannot use shortened SHA
        /// IDs.</p>
        /// </note>
        pub fn commit_ids(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_ids(inp);
            self
        }
        pub fn set_commit_ids(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_commit_ids(input);
            self
        }
        /// <p>The name of the repository that contains the commits.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct BatchGetRepositories<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::batch_get_repositories_input::Builder,
    }
    impl<C> BatchGetRepositories<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::BatchGetRepositoriesOutput,
            smithy_http::result::SdkError<crate::error::BatchGetRepositoriesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The names of the repositories to get information about.</p>
        /// <note>
        /// <p>The length constraint limit is for each string in the array. The array itself can be empty.</p>
        /// </note>
        pub fn repository_names(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_names(inp);
            self
        }
        pub fn set_repository_names(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_repository_names(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateApprovalRuleTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_approval_rule_template_input::Builder,
    }
    impl<C> CreateApprovalRuleTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateApprovalRuleTemplateOutput,
            smithy_http::result::SdkError<crate::error::CreateApprovalRuleTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the approval rule template. Provide descriptive names, because this name
        /// is applied to the approval rules created automatically in associated
        /// repositories.</p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
        /// <p>The content of the approval rule that is created on pull requests in associated
        /// repositories. If you specify one or more destination references (branches), approval
        /// rules are created in an associated repository only if their destination references
        /// (branches) match those specified in the template.</p>
        /// <note>
        /// <p>When you create the content of the approval rule template, you can specify
        /// approvers in an approval pool in one of two ways:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>CodeCommitApprovers</b>: This option only
        /// requires an AWS account and a resource. It can be used for both IAM users
        /// and federated access users whose name matches the provided resource name.
        /// This is a very powerful option that offers a great deal of flexibility. For
        /// example, if you specify the AWS account <i>123456789012</i>
        /// and <i>Mary_Major</i>, all of the following are counted as
        /// approvals coming from that user:</p>
        /// <ul>
        /// <li>
        /// <p>An IAM user in the account
        /// (arn:aws:iam::<i>123456789012</i>:user/<i>Mary_Major</i>)</p>
        /// </li>
        /// <li>
        /// <p>A federated user identified in IAM as Mary_Major
        /// (arn:aws:sts::<i>123456789012</i>:federated-user/<i>Mary_Major</i>)</p>
        /// </li>
        /// </ul>
        /// <p>This option does not recognize an active session of someone assuming the
        /// role of CodeCommitReview with a role session name of
        /// <i>Mary_Major</i>
        /// (arn:aws:sts::<i>123456789012</i>:assumed-role/CodeCommitReview/<i>Mary_Major</i>)
        /// unless you include a wildcard (*Mary_Major).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Fully qualified ARN</b>: This option allows
        /// you to specify the fully qualified Amazon Resource Name (ARN) of the IAM
        /// user or role. </p>
        /// </li>
        /// </ul>
        /// <p>For more information about IAM ARNs, wildcards, and formats, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
        /// Identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// </note>
        pub fn approval_rule_template_content(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_content(input);
            self
        }
        pub fn set_approval_rule_template_content(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_content(input);
            self
        }
        /// <p>The description of the approval rule template. Consider providing a description that
        /// explains what this template does and when it might be appropriate to associate it with
        /// repositories.</p>
        pub fn approval_rule_template_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_description(input);
            self
        }
        pub fn set_approval_rule_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateBranch<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_branch_input::Builder,
    }
    impl<C> CreateBranch<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateBranchOutput,
            smithy_http::result::SdkError<crate::error::CreateBranchError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository in which you want to create the new branch.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The name of the new branch to create.</p>
        pub fn branch_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.branch_name(input);
            self
        }
        pub fn set_branch_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_branch_name(input);
            self
        }
        /// <p>The ID of the commit to point the new branch to.</p>
        pub fn commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_id(input);
            self
        }
        pub fn set_commit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_commit_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateCommit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_commit_input::Builder,
    }
    impl<C> CreateCommit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateCommitOutput,
            smithy_http::result::SdkError<crate::error::CreateCommitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you create the commit.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The name of the branch where you create the commit.</p>
        pub fn branch_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.branch_name(input);
            self
        }
        pub fn set_branch_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_branch_name(input);
            self
        }
        /// <p>The ID of the commit that is the parent of the commit you create. Not required if this
        /// is an empty repository.</p>
        pub fn parent_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parent_commit_id(input);
            self
        }
        pub fn set_parent_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parent_commit_id(input);
            self
        }
        /// <p>The name of the author who created the commit. This information is used as both the
        /// author and committer for the commit.</p>
        pub fn author_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.author_name(input);
            self
        }
        pub fn set_author_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_author_name(input);
            self
        }
        /// <p>The email address of the person who created the commit.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email(input);
            self
        }
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_email(input);
            self
        }
        /// <p>The commit message you want to include in the commit. Commit messages are limited to
        /// 256 KB. If no message is specified, a default message is used.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_message(input);
            self
        }
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_message(input);
            self
        }
        /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
        /// changes leave the folders empty. If true, a ..gitkeep file is created for empty folders.
        /// The default is false.</p>
        pub fn keep_empty_folders(mut self, input: bool) -> Self {
            self.inner = self.inner.keep_empty_folders(input);
            self
        }
        pub fn set_keep_empty_folders(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_keep_empty_folders(input);
            self
        }
        /// <p>The files to add or update in this commit.</p>
        pub fn put_files(mut self, inp: impl Into<crate::model::PutFileEntry>) -> Self {
            self.inner = self.inner.put_files(inp);
            self
        }
        pub fn set_put_files(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::PutFileEntry>>,
        ) -> Self {
            self.inner = self.inner.set_put_files(input);
            self
        }
        /// <p>The files to delete in this commit. These files still exist in earlier commits.</p>
        pub fn delete_files(mut self, inp: impl Into<crate::model::DeleteFileEntry>) -> Self {
            self.inner = self.inner.delete_files(inp);
            self
        }
        pub fn set_delete_files(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::DeleteFileEntry>>,
        ) -> Self {
            self.inner = self.inner.set_delete_files(input);
            self
        }
        /// <p>The file modes to update for files in this commit.</p>
        pub fn set_file_modes(mut self, inp: impl Into<crate::model::SetFileModeEntry>) -> Self {
            self.inner = self.inner.set_file_modes(inp);
            self
        }
        pub fn set_set_file_modes(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::SetFileModeEntry>>,
        ) -> Self {
            self.inner = self.inner.set_set_file_modes(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePullRequest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_pull_request_input::Builder,
    }
    impl<C> CreatePullRequest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePullRequestOutput,
            smithy_http::result::SdkError<crate::error::CreatePullRequestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The title of the pull request. This title is used to identify the pull request to
        /// other users in the repository.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.title(input);
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_title(input);
            self
        }
        /// <p>A description of the pull request.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
        /// <p>The targets for the pull request, including the source of the code to be reviewed (the
        /// source branch) and the destination where the creator of the pull request intends the
        /// code to be merged after the pull request is closed (the destination branch).</p>
        pub fn targets(mut self, inp: impl Into<crate::model::Target>) -> Self {
            self.inner = self.inner.targets(inp);
            self
        }
        pub fn set_targets(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::Target>>,
        ) -> Self {
            self.inner = self.inner.set_targets(input);
            self
        }
        /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
        /// the request cannot be repeated with a changed parameter. If a request is received with
        /// the same parameters and a token is included, the request returns information about the
        /// initial request that used that token.</p>
        /// <note>
        /// <p>The AWS SDKs prepopulate client request tokens. If you are using an AWS SDK, an
        /// idempotency token is created for you.</p>
        /// </note>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreatePullRequestApprovalRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_pull_request_approval_rule_input::Builder,
    }
    impl<C> CreatePullRequestApprovalRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreatePullRequestApprovalRuleOutput,
            smithy_http::result::SdkError<crate::error::CreatePullRequestApprovalRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request for which you want to create the approval rule.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The name for the approval rule.</p>
        pub fn approval_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.approval_rule_name(input);
            self
        }
        pub fn set_approval_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_name(input);
            self
        }
        /// <p>The content of the approval rule, including the number of approvals needed and the structure of an approval pool defined for approvals, if any. For more information
        /// about approval pools, see the AWS CodeCommit User Guide.</p>
        /// <note>
        /// <p>When you create the content of the approval rule, you can specify approvers in an
        /// approval pool in one of two ways:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>CodeCommitApprovers</b>: This option only
        /// requires an AWS account and a resource. It can be used for both IAM users
        /// and federated access users whose name matches the provided resource name.
        /// This is a very powerful option that offers a great deal of flexibility. For
        /// example, if you specify the AWS account <i>123456789012</i>
        /// and <i>Mary_Major</i>, all of the following would be counted
        /// as approvals coming from that user:</p>
        /// <ul>
        /// <li>
        /// <p>An IAM user in the account
        /// (arn:aws:iam::<i>123456789012</i>:user/<i>Mary_Major</i>)</p>
        /// </li>
        /// <li>
        /// <p>A federated user identified in IAM as Mary_Major
        /// (arn:aws:sts::<i>123456789012</i>:federated-user/<i>Mary_Major</i>)</p>
        /// </li>
        /// </ul>
        /// <p>This option does not recognize an active session of someone assuming the
        /// role of CodeCommitReview with a role session name of
        /// <i>Mary_Major</i>
        /// (arn:aws:sts::<i>123456789012</i>:assumed-role/CodeCommitReview/<i>Mary_Major</i>)
        /// unless you include a wildcard (*Mary_Major).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Fully qualified ARN</b>: This option allows
        /// you to specify the fully qualified Amazon Resource Name (ARN) of the IAM
        /// user or role. </p>
        /// </li>
        /// </ul>
        /// <p>For more information about IAM ARNs, wildcards, and formats, see
        /// <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
        /// Identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// </note>
        pub fn approval_rule_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.approval_rule_content(input);
            self
        }
        pub fn set_approval_rule_content(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_content(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_repository_input::Builder,
    }
    impl<C> CreateRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateRepositoryOutput,
            smithy_http::result::SdkError<crate::error::CreateRepositoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the new repository to be created.</p>
        /// <note>
        /// <p>The repository name must be unique across the calling AWS account. Repository names
        /// are limited to 100 alphanumeric, dash, and underscore characters, and cannot include
        /// certain characters. For more information about the limits on repository names, see
        /// <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html">Limits</a> in the <i>AWS CodeCommit User Guide</i>. The
        /// suffix .git is prohibited.</p>
        /// </note>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>A comment or description about the new repository.</p>
        /// <note>
        /// <p>The description field for a repository accepts all HTML characters and all valid
        /// Unicode characters. Applications that do not HTML-encode the description and display
        /// it in a webpage can expose users to potentially malicious code. Make sure that you
        /// HTML-encode the description field in any application that uses this API to display
        /// the repository description on a webpage.</p>
        /// </note>
        pub fn repository_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_description(input);
            self
        }
        pub fn set_repository_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_description(input);
            self
        }
        /// <p>One or more tag key-value pairs to use when tagging this repository.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct CreateUnreferencedMergeCommit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::create_unreferenced_merge_commit_input::Builder,
    }
    impl<C> CreateUnreferencedMergeCommit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::CreateUnreferencedMergeCommitOutput,
            smithy_http::result::SdkError<crate::error::CreateUnreferencedMergeCommitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to create the unreferenced merge commit.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn source_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_specifier(input);
            self
        }
        pub fn set_source_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn destination_commit_specifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_commit_specifier(input);
            self
        }
        pub fn set_destination_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_commit_specifier(input);
            self
        }
        /// <p>The merge option or strategy you want to use to merge the code.</p>
        pub fn merge_option(mut self, input: crate::model::MergeOptionTypeEnum) -> Self {
            self.inner = self.inner.merge_option(input);
            self
        }
        pub fn set_merge_option(
            mut self,
            input: std::option::Option<crate::model::MergeOptionTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_merge_option(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
        /// <p>The name of the author who created the unreferenced commit. This information is used
        /// as both the author and committer for the commit.</p>
        pub fn author_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.author_name(input);
            self
        }
        pub fn set_author_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_author_name(input);
            self
        }
        /// <p>The email address for the person who created the unreferenced commit.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email(input);
            self
        }
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_email(input);
            self
        }
        /// <p>The commit message for the unreferenced commit.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_message(input);
            self
        }
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_message(input);
            self
        }
        /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
        /// changes leave the folders empty. If this is specified as true, a .gitkeep file is
        /// created for empty folders. The default is false.</p>
        pub fn keep_empty_folders(mut self, input: bool) -> Self {
            self.inner = self.inner.keep_empty_folders(input);
            self
        }
        pub fn set_keep_empty_folders(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_keep_empty_folders(input);
            self
        }
        /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
        /// resolving conflicts during a merge.</p>
        pub fn conflict_resolution(mut self, input: crate::model::ConflictResolution) -> Self {
            self.inner = self.inner.conflict_resolution(input);
            self
        }
        pub fn set_conflict_resolution(
            mut self,
            input: std::option::Option<crate::model::ConflictResolution>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteApprovalRuleTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_approval_rule_template_input::Builder,
    }
    impl<C> DeleteApprovalRuleTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteApprovalRuleTemplateOutput,
            smithy_http::result::SdkError<crate::error::DeleteApprovalRuleTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the approval rule template to delete.</p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteBranch<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_branch_input::Builder,
    }
    impl<C> DeleteBranch<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteBranchOutput,
            smithy_http::result::SdkError<crate::error::DeleteBranchError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository that contains the branch to be deleted.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The name of the branch to delete.</p>
        pub fn branch_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.branch_name(input);
            self
        }
        pub fn set_branch_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_branch_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteCommentContent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_comment_content_input::Builder,
    }
    impl<C> DeleteCommentContent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteCommentContentOutput,
            smithy_http::result::SdkError<crate::error::DeleteCommentContentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique, system-generated ID of the comment. To get this ID, use  <a>GetCommentsForComparedCommit</a>
        /// or <a>GetCommentsForPullRequest</a>.</p>
        pub fn comment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment_id(input);
            self
        }
        pub fn set_comment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteFile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_file_input::Builder,
    }
    impl<C> DeleteFile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteFileOutput,
            smithy_http::result::SdkError<crate::error::DeleteFileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository that contains the file to delete.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The name of the branch where the commit that deletes the file is made.</p>
        pub fn branch_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.branch_name(input);
            self
        }
        pub fn set_branch_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_branch_name(input);
            self
        }
        /// <p>The fully qualified path to the file that to be deleted, including the full name and
        /// extension of that file. For example, /examples/file.md is a fully qualified path to a
        /// file named file.md in a folder named examples.</p>
        pub fn file_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_path(input);
            self
        }
        pub fn set_file_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_file_path(input);
            self
        }
        /// <p>The ID of the commit that is the tip of the branch where you want to create the commit
        /// that deletes the file. This must be the HEAD commit for the branch. The commit that
        /// deletes the file is created from this commit ID.</p>
        pub fn parent_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parent_commit_id(input);
            self
        }
        pub fn set_parent_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parent_commit_id(input);
            self
        }
        /// <p>If a file is the only object in the folder or directory, specifies whether to delete
        /// the folder or directory that contains the file. By default, empty folders are deleted.
        /// This includes empty folders that are part of the directory structure. For example, if
        /// the path to a file is dir1/dir2/dir3/dir4, and dir2 and dir3 are empty, deleting the
        /// last file in dir4 also deletes the empty folders dir4, dir3, and dir2.</p>
        pub fn keep_empty_folders(mut self, input: bool) -> Self {
            self.inner = self.inner.keep_empty_folders(input);
            self
        }
        pub fn set_keep_empty_folders(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_keep_empty_folders(input);
            self
        }
        /// <p>The commit message you want to include as part of deleting the file. Commit messages
        /// are limited to 256 KB. If no message is specified, a default message is used.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_message(input);
            self
        }
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_message(input);
            self
        }
        /// <p>The name of the author of the commit that deletes the file. If no name is specified,
        /// the user's ARN is used as the author name and committer name.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>The email address for the commit that deletes the file. If no email address is
        /// specified, the email address is left blank.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email(input);
            self
        }
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_email(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeletePullRequestApprovalRule<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_pull_request_approval_rule_input::Builder,
    }
    impl<C> DeletePullRequestApprovalRule<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeletePullRequestApprovalRuleOutput,
            smithy_http::result::SdkError<crate::error::DeletePullRequestApprovalRuleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request that contains the approval rule you want to delete.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The name of the approval rule you want to delete.</p>
        pub fn approval_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.approval_rule_name(input);
            self
        }
        pub fn set_approval_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DeleteRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::delete_repository_input::Builder,
    }
    impl<C> DeleteRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DeleteRepositoryOutput,
            smithy_http::result::SdkError<crate::error::DeleteRepositoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository to delete.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribeMergeConflicts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_merge_conflicts_input::Builder,
    }
    impl<C> DescribeMergeConflicts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribeMergeConflictsOutput,
            smithy_http::result::SdkError<crate::error::DescribeMergeConflictsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to get information about a merge conflict.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn destination_commit_specifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_commit_specifier(input);
            self
        }
        pub fn set_destination_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn source_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_specifier(input);
            self
        }
        pub fn set_source_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_specifier(input);
            self
        }
        /// <p>The merge option or strategy you want to use to merge the code.</p>
        pub fn merge_option(mut self, input: crate::model::MergeOptionTypeEnum) -> Self {
            self.inner = self.inner.merge_option(input);
            self
        }
        pub fn set_merge_option(
            mut self,
            input: std::option::Option<crate::model::MergeOptionTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_merge_option(input);
            self
        }
        /// <p>The maximum number of merge hunks to include in the output.</p>
        pub fn max_merge_hunks(mut self, input: i32) -> Self {
            self.inner = self.inner.max_merge_hunks(input);
            self
        }
        pub fn set_max_merge_hunks(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_merge_hunks(input);
            self
        }
        /// <p>The path of the target files used to describe the conflicts. </p>
        pub fn file_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_path(input);
            self
        }
        pub fn set_file_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_file_path(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DescribePullRequestEvents<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::describe_pull_request_events_input::Builder,
    }
    impl<C> DescribePullRequestEvents<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DescribePullRequestEventsOutput,
            smithy_http::result::SdkError<crate::error::DescribePullRequestEventsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>Optional. The pull request event type about which you want to return information.</p>
        pub fn pull_request_event_type(
            mut self,
            input: crate::model::PullRequestEventType,
        ) -> Self {
            self.inner = self.inner.pull_request_event_type(input);
            self
        }
        pub fn set_pull_request_event_type(
            mut self,
            input: std::option::Option<crate::model::PullRequestEventType>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_event_type(input);
            self
        }
        /// <p>The Amazon Resource Name (ARN) of the user whose actions resulted in the event.
        /// Examples include updating the pull request with more commits or changing the status of a
        /// pull request.</p>
        pub fn actor_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.actor_arn(input);
            self
        }
        pub fn set_actor_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_actor_arn(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A non-zero, non-negative integer used to limit the number of returned results.
        /// The default is 100 events, which is also the maximum number of events that can be returned in a result.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct DisassociateApprovalRuleTemplateFromRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::disassociate_approval_rule_template_from_repository_input::Builder,
    }
    impl<C> DisassociateApprovalRuleTemplateFromRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::DisassociateApprovalRuleTemplateFromRepositoryOutput,
            smithy_http::result::SdkError<
                crate::error::DisassociateApprovalRuleTemplateFromRepositoryError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the approval rule template to disassociate from a specified repository.</p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
        /// <p>The name of the repository you want to disassociate from the template.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct EvaluatePullRequestApprovalRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::evaluate_pull_request_approval_rules_input::Builder,
    }
    impl<C> EvaluatePullRequestApprovalRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::EvaluatePullRequestApprovalRulesOutput,
            smithy_http::result::SdkError<crate::error::EvaluatePullRequestApprovalRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request you want to evaluate.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The system-generated ID for the pull request revision. To retrieve the most recent
        /// revision ID for a pull request, use
        /// <a>GetPullRequest</a>.</p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(input);
            self
        }
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetApprovalRuleTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_approval_rule_template_input::Builder,
    }
    impl<C> GetApprovalRuleTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetApprovalRuleTemplateOutput,
            smithy_http::result::SdkError<crate::error::GetApprovalRuleTemplateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the approval rule template for which you want to get information.</p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBlob<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_blob_input::Builder,
    }
    impl<C> GetBlob<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBlobOutput,
            smithy_http::result::SdkError<crate::error::GetBlobError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository that contains the blob.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The ID of the blob, which is its SHA-1 pointer.</p>
        pub fn blob_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.blob_id(input);
            self
        }
        pub fn set_blob_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_blob_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetBranch<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_branch_input::Builder,
    }
    impl<C> GetBranch<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetBranchOutput,
            smithy_http::result::SdkError<crate::error::GetBranchError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository that contains the branch for which you want to retrieve information.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The name of the branch for which you want to retrieve information.</p>
        pub fn branch_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.branch_name(input);
            self
        }
        pub fn set_branch_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_branch_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetComment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_comment_input::Builder,
    }
    impl<C> GetComment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCommentOutput,
            smithy_http::result::SdkError<crate::error::GetCommentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The unique, system-generated ID of the comment. To get this ID, use  <a>GetCommentsForComparedCommit</a>
        /// or <a>GetCommentsForPullRequest</a>.</p>
        pub fn comment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment_id(input);
            self
        }
        pub fn set_comment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCommentReactions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_comment_reactions_input::Builder,
    }
    impl<C> GetCommentReactions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCommentReactionsOutput,
            smithy_http::result::SdkError<crate::error::GetCommentReactionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the comment for which you want to get reactions information.</p>
        pub fn comment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment_id(input);
            self
        }
        pub fn set_comment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment_id(input);
            self
        }
        /// <p>Optional. The Amazon Resource Name (ARN) of the user or identity for which you want to get reaction information.</p>
        pub fn reaction_user_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reaction_user_arn(input);
            self
        }
        pub fn set_reaction_user_arn(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reaction_user_arn(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A non-zero, non-negative integer used to limit the number of returned results.  The default is the same as the allowed maximum, 1,000.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCommentsForComparedCommit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_comments_for_compared_commit_input::Builder,
    }
    impl<C> GetCommentsForComparedCommit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCommentsForComparedCommitOutput,
            smithy_http::result::SdkError<crate::error::GetCommentsForComparedCommitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to compare commits.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>To establish the directionality of the comparison, the full commit ID of the before
        /// commit.</p>
        pub fn before_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.before_commit_id(input);
            self
        }
        pub fn set_before_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_before_commit_id(input);
            self
        }
        /// <p>To establish the directionality of the comparison, the full commit ID of the after
        /// commit.</p>
        pub fn after_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.after_commit_id(input);
            self
        }
        pub fn set_after_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_after_commit_id(input);
            self
        }
        /// <p>An enumeration token that when provided in a request, returns the next batch of the results. </p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A non-zero, non-negative integer used to limit the number of returned results. The
        /// default is 100 comments, but you can configure up to 500.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCommentsForPullRequest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_comments_for_pull_request_input::Builder,
    }
    impl<C> GetCommentsForPullRequest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCommentsForPullRequestOutput,
            smithy_http::result::SdkError<crate::error::GetCommentsForPullRequestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The name of the repository that contains the pull request.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created.</p>
        pub fn before_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.before_commit_id(input);
            self
        }
        pub fn set_before_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_before_commit_id(input);
            self
        }
        /// <p>The full commit ID of the commit in the source branch that was the tip of the branch at the time the comment was made.</p>
        pub fn after_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.after_commit_id(input);
            self
        }
        pub fn set_after_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_after_commit_id(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A non-zero, non-negative integer used to limit the number of returned results. The default is 100 comments.
        /// You can return up to 500 comments with a single request.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetCommit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_commit_input::Builder,
    }
    impl<C> GetCommit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetCommitOutput,
            smithy_http::result::SdkError<crate::error::GetCommitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository to which the commit was made.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The commit ID. Commit IDs are the full SHA ID of the commit.</p>
        pub fn commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_id(input);
            self
        }
        pub fn set_commit_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_commit_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetDifferences<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_differences_input::Builder,
    }
    impl<C> GetDifferences<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetDifferencesOutput,
            smithy_http::result::SdkError<crate::error::GetDifferencesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to get differences.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, the full commit ID). Optional. If not specified, all changes before the
        /// <code>afterCommitSpecifier</code> value are shown. If you do not use
        /// <code>beforeCommitSpecifier</code> in your request, consider limiting the results
        /// with <code>maxResults</code>.</p>
        pub fn before_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.before_commit_specifier(input);
            self
        }
        pub fn set_before_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_before_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit.</p>
        pub fn after_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.after_commit_specifier(input);
            self
        }
        pub fn set_after_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_after_commit_specifier(input);
            self
        }
        /// <p>The file path in which to check for differences. Limits the results to this path. Can
        /// also be used to specify the previous name of a directory or folder. If
        /// <code>beforePath</code> and <code>afterPath</code> are not specified, differences
        /// are shown for all paths.</p>
        pub fn before_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.before_path(input);
            self
        }
        pub fn set_before_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_before_path(input);
            self
        }
        /// <p>The file path in which to check differences. Limits the results to this path. Can also
        /// be used to specify the changed name of a directory or folder, if it has changed. If not
        /// specified, differences are shown for all paths.</p>
        pub fn after_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.after_path(input);
            self
        }
        pub fn set_after_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_after_path(input);
            self
        }
        /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_file_input::Builder,
    }
    impl<C> GetFile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFileOutput,
            smithy_http::result::SdkError<crate::error::GetFileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository that contains the file.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The fully quaified reference that identifies the commit that contains the file. For
        /// example, you can specify a full commit ID, a tag, a branch name, or a reference such as
        /// refs/heads/master. If none is provided, the head commit is used.</p>
        pub fn commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_specifier(input);
            self
        }
        pub fn set_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_specifier(input);
            self
        }
        /// <p>The fully qualified path to the file, including the full name and extension of the
        /// file. For example, /examples/file.md is the fully qualified path to a file named file.md
        /// in a folder named examples.</p>
        pub fn file_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_path(input);
            self
        }
        pub fn set_file_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_file_path(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetFolder<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_folder_input::Builder,
    }
    impl<C> GetFolder<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetFolderOutput,
            smithy_http::result::SdkError<crate::error::GetFolderError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>A fully qualified reference used to identify a commit that contains the version of the
        /// folder's content to return. A fully qualified reference can be a commit ID, branch name,
        /// tag, or reference such as HEAD. If no specifier is provided, the folder content is
        /// returned as it exists in the HEAD commit.</p>
        pub fn commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_specifier(input);
            self
        }
        pub fn set_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_specifier(input);
            self
        }
        /// <p>The fully qualified path to the folder whose contents are returned, including the
        /// folder name. For example, /examples is a fully-qualified path to a folder named examples
        /// that was created off of the root directory (/) of a repository. </p>
        pub fn folder_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.folder_path(input);
            self
        }
        pub fn set_folder_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_folder_path(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMergeCommit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_merge_commit_input::Builder,
    }
    impl<C> GetMergeCommit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMergeCommitOutput,
            smithy_http::result::SdkError<crate::error::GetMergeCommitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository that contains the merge commit about which you want to get information.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn source_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_specifier(input);
            self
        }
        pub fn set_source_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn destination_commit_specifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_commit_specifier(input);
            self
        }
        pub fn set_destination_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_commit_specifier(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMergeConflicts<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_merge_conflicts_input::Builder,
    }
    impl<C> GetMergeConflicts<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMergeConflictsOutput,
            smithy_http::result::SdkError<crate::error::GetMergeConflictsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where the pull request was created.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn destination_commit_specifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_commit_specifier(input);
            self
        }
        pub fn set_destination_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn source_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_specifier(input);
            self
        }
        pub fn set_source_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_specifier(input);
            self
        }
        /// <p>The merge option or strategy you want to use to merge the code.  </p>
        pub fn merge_option(mut self, input: crate::model::MergeOptionTypeEnum) -> Self {
            self.inner = self.inner.merge_option(input);
            self
        }
        pub fn set_merge_option(
            mut self,
            input: std::option::Option<crate::model::MergeOptionTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_merge_option(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>The maximum number of files to include in the output.</p>
        pub fn max_conflict_files(mut self, input: i32) -> Self {
            self.inner = self.inner.max_conflict_files(input);
            self
        }
        pub fn set_max_conflict_files(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_conflict_files(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetMergeOptions<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_merge_options_input::Builder,
    }
    impl<C> GetMergeOptions<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetMergeOptionsOutput,
            smithy_http::result::SdkError<crate::error::GetMergeOptionsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository that contains the commits about which you want to get merge options.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn source_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_specifier(input);
            self
        }
        pub fn set_source_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn destination_commit_specifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_commit_specifier(input);
            self
        }
        pub fn set_destination_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_commit_specifier(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPullRequest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_pull_request_input::Builder,
    }
    impl<C> GetPullRequest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPullRequestOutput,
            smithy_http::result::SdkError<crate::error::GetPullRequestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPullRequestApprovalStates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_pull_request_approval_states_input::Builder,
    }
    impl<C> GetPullRequestApprovalStates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPullRequestApprovalStatesOutput,
            smithy_http::result::SdkError<crate::error::GetPullRequestApprovalStatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID for the pull request.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The system-generated ID for the pull request revision.</p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(input);
            self
        }
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetPullRequestOverrideState<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_pull_request_override_state_input::Builder,
    }
    impl<C> GetPullRequestOverrideState<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetPullRequestOverrideStateOutput,
            smithy_http::result::SdkError<crate::error::GetPullRequestOverrideStateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the pull request for which you want to get information about whether approval rules have been set aside (overridden).</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The system-generated ID of the revision for the pull request. To retrieve the most
        /// recent revision ID, use
        /// <a>GetPullRequest</a>.</p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(input);
            self
        }
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_repository_input::Builder,
    }
    impl<C> GetRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRepositoryOutput,
            smithy_http::result::SdkError<crate::error::GetRepositoryError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository to get information about.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct GetRepositoryTriggers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::get_repository_triggers_input::Builder,
    }
    impl<C> GetRepositoryTriggers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::GetRepositoryTriggersOutput,
            smithy_http::result::SdkError<crate::error::GetRepositoryTriggersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository for which the trigger is configured.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListApprovalRuleTemplates<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_approval_rule_templates_input::Builder,
    }
    impl<C> ListApprovalRuleTemplates<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListApprovalRuleTemplatesOutput,
            smithy_http::result::SdkError<crate::error::ListApprovalRuleTemplatesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListAssociatedApprovalRuleTemplatesForRepository<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_associated_approval_rule_templates_for_repository_input::Builder,
    }
    impl<C> ListAssociatedApprovalRuleTemplatesForRepository<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListAssociatedApprovalRuleTemplatesForRepositoryOutput,
            smithy_http::result::SdkError<
                crate::error::ListAssociatedApprovalRuleTemplatesForRepositoryError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository for which you want to list all associated approval rule templates.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListBranches<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_branches_input::Builder,
    }
    impl<C> ListBranches<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListBranchesOutput,
            smithy_http::result::SdkError<crate::error::ListBranchesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository that contains the branches.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>An enumeration token that allows the operation to batch the results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListPullRequests<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_pull_requests_input::Builder,
    }
    impl<C> ListPullRequests<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListPullRequestsOutput,
            smithy_http::result::SdkError<crate::error::ListPullRequestsError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository for which you want to list pull requests.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>Optional. The Amazon Resource Name (ARN) of the user who created the pull request. If used, this filters the results
        /// to pull requests created by that user.</p>
        pub fn author_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.author_arn(input);
            self
        }
        pub fn set_author_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_author_arn(input);
            self
        }
        /// <p>Optional. The status of the pull request. If used, this refines the results to the pull requests that match the specified status.</p>
        pub fn pull_request_status(mut self, input: crate::model::PullRequestStatusEnum) -> Self {
            self.inner = self.inner.pull_request_status(input);
            self
        }
        pub fn set_pull_request_status(
            mut self,
            input: std::option::Option<crate::model::PullRequestStatusEnum>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_status(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRepositories<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_repositories_input::Builder,
    }
    impl<C> ListRepositories<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRepositoriesOutput,
            smithy_http::result::SdkError<crate::error::ListRepositoriesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>An enumeration token that allows the operation to batch the results of the operation.
        /// Batch sizes are 1,000 for list repository operations. When the client sends the token back to AWS CodeCommit,
        /// another page of 1,000 records is retrieved.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>The criteria used to sort the results of a list repositories operation.</p>
        pub fn sort_by(mut self, input: crate::model::SortByEnum) -> Self {
            self.inner = self.inner.sort_by(input);
            self
        }
        pub fn set_sort_by(mut self, input: std::option::Option<crate::model::SortByEnum>) -> Self {
            self.inner = self.inner.set_sort_by(input);
            self
        }
        /// <p>The order in which to sort the results of a list repositories operation.</p>
        pub fn order(mut self, input: crate::model::OrderEnum) -> Self {
            self.inner = self.inner.order(input);
            self
        }
        pub fn set_order(mut self, input: std::option::Option<crate::model::OrderEnum>) -> Self {
            self.inner = self.inner.set_order(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListRepositoriesForApprovalRuleTemplate<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_repositories_for_approval_rule_template_input::Builder,
    }
    impl<C> ListRepositoriesForApprovalRuleTemplate<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListRepositoriesForApprovalRuleTemplateOutput,
            smithy_http::result::SdkError<
                crate::error::ListRepositoriesForApprovalRuleTemplateError,
            >,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the approval rule template for which you want to list repositories that are associated with that template.</p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
        /// <p>A non-zero, non-negative integer used to limit the number of returned results.</p>
        pub fn max_results(mut self, input: i32) -> Self {
            self.inner = self.inner.max_results(input);
            self
        }
        pub fn set_max_results(mut self, input: std::option::Option<i32>) -> Self {
            self.inner = self.inner.set_max_results(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct ListTagsForResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::list_tags_for_resource_input::Builder,
    }
    impl<C> ListTagsForResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::ListTagsForResourceOutput,
            smithy_http::result::SdkError<crate::error::ListTagsForResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource for which you want to get information
        /// about tags, if any.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>An enumeration token that, when provided in a request, returns the next batch of the
        /// results.</p>
        pub fn next_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.next_token(input);
            self
        }
        pub fn set_next_token(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_next_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MergeBranchesByFastForward<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::merge_branches_by_fast_forward_input::Builder,
    }
    impl<C> MergeBranchesByFastForward<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MergeBranchesByFastForwardOutput,
            smithy_http::result::SdkError<crate::error::MergeBranchesByFastForwardError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to merge two branches.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn source_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_specifier(input);
            self
        }
        pub fn set_source_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn destination_commit_specifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_commit_specifier(input);
            self
        }
        pub fn set_destination_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_commit_specifier(input);
            self
        }
        /// <p>The branch where the merge is applied.</p>
        pub fn target_branch(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_branch(input);
            self
        }
        pub fn set_target_branch(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_branch(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MergeBranchesBySquash<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::merge_branches_by_squash_input::Builder,
    }
    impl<C> MergeBranchesBySquash<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MergeBranchesBySquashOutput,
            smithy_http::result::SdkError<crate::error::MergeBranchesBySquashError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to merge two branches.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn source_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_specifier(input);
            self
        }
        pub fn set_source_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn destination_commit_specifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_commit_specifier(input);
            self
        }
        pub fn set_destination_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_commit_specifier(input);
            self
        }
        /// <p>The branch where the merge is applied. </p>
        pub fn target_branch(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_branch(input);
            self
        }
        pub fn set_target_branch(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_branch(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
        /// <p>The name of the author who created the commit. This information is used as both the
        /// author and committer for the commit.</p>
        pub fn author_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.author_name(input);
            self
        }
        pub fn set_author_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_author_name(input);
            self
        }
        /// <p>The email address of the person merging the branches. This information is used in the
        /// commit information for the merge.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email(input);
            self
        }
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_email(input);
            self
        }
        /// <p>The commit message for the merge.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_message(input);
            self
        }
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_message(input);
            self
        }
        /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
        /// changes leave the folders empty. If this is specified as true, a .gitkeep file is
        /// created for empty folders. The default is false.</p>
        pub fn keep_empty_folders(mut self, input: bool) -> Self {
            self.inner = self.inner.keep_empty_folders(input);
            self
        }
        pub fn set_keep_empty_folders(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_keep_empty_folders(input);
            self
        }
        /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
        /// resolving conflicts during a merge.</p>
        pub fn conflict_resolution(mut self, input: crate::model::ConflictResolution) -> Self {
            self.inner = self.inner.conflict_resolution(input);
            self
        }
        pub fn set_conflict_resolution(
            mut self,
            input: std::option::Option<crate::model::ConflictResolution>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MergeBranchesByThreeWay<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::merge_branches_by_three_way_input::Builder,
    }
    impl<C> MergeBranchesByThreeWay<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MergeBranchesByThreeWayOutput,
            smithy_http::result::SdkError<crate::error::MergeBranchesByThreeWayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to merge two branches.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn source_commit_specifier(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_specifier(input);
            self
        }
        pub fn set_source_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_specifier(input);
            self
        }
        /// <p>The branch, tag, HEAD, or other fully qualified reference used to identify a commit
        /// (for example, a branch name or a full commit ID).</p>
        pub fn destination_commit_specifier(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.destination_commit_specifier(input);
            self
        }
        pub fn set_destination_commit_specifier(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_destination_commit_specifier(input);
            self
        }
        /// <p>The branch where the merge is applied. </p>
        pub fn target_branch(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.target_branch(input);
            self
        }
        pub fn set_target_branch(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_target_branch(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
        /// <p>The name of the author who created the commit. This information is used as both the
        /// author and committer for the commit.</p>
        pub fn author_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.author_name(input);
            self
        }
        pub fn set_author_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_author_name(input);
            self
        }
        /// <p>The email address of the person merging the branches. This information is used in the
        /// commit information for the merge.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email(input);
            self
        }
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_email(input);
            self
        }
        /// <p>The commit message to include in the commit information for the merge.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_message(input);
            self
        }
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_message(input);
            self
        }
        /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
        /// changes leave the folders empty. If true, a .gitkeep file is created for empty folders.
        /// The default is false.</p>
        pub fn keep_empty_folders(mut self, input: bool) -> Self {
            self.inner = self.inner.keep_empty_folders(input);
            self
        }
        pub fn set_keep_empty_folders(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_keep_empty_folders(input);
            self
        }
        /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
        /// resolving conflicts during a merge.</p>
        pub fn conflict_resolution(mut self, input: crate::model::ConflictResolution) -> Self {
            self.inner = self.inner.conflict_resolution(input);
            self
        }
        pub fn set_conflict_resolution(
            mut self,
            input: std::option::Option<crate::model::ConflictResolution>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MergePullRequestByFastForward<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::merge_pull_request_by_fast_forward_input::Builder,
    }
    impl<C> MergePullRequestByFastForward<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MergePullRequestByFastForwardOutput,
            smithy_http::result::SdkError<crate::error::MergePullRequestByFastForwardError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The name of the repository where the pull request was created.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an
        /// exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.</p>
        pub fn source_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_id(input);
            self
        }
        pub fn set_source_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_id(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MergePullRequestBySquash<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::merge_pull_request_by_squash_input::Builder,
    }
    impl<C> MergePullRequestBySquash<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MergePullRequestBySquashOutput,
            smithy_http::result::SdkError<crate::error::MergePullRequestBySquashError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The name of the repository where the pull request was created.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an
        /// exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.</p>
        pub fn source_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_id(input);
            self
        }
        pub fn set_source_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_id(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
        /// <p>The commit message to include in the commit information for the merge.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_message(input);
            self
        }
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_message(input);
            self
        }
        /// <p>The name of the author who created the commit. This information is used as both the
        /// author and committer for the commit.</p>
        pub fn author_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.author_name(input);
            self
        }
        pub fn set_author_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_author_name(input);
            self
        }
        /// <p>The email address of the person merging the branches. This information is used in the
        /// commit information for the merge.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email(input);
            self
        }
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_email(input);
            self
        }
        /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
        /// changes leave the folders empty. If true, a .gitkeep file is created for empty folders.
        /// The default is false.</p>
        pub fn keep_empty_folders(mut self, input: bool) -> Self {
            self.inner = self.inner.keep_empty_folders(input);
            self
        }
        pub fn set_keep_empty_folders(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_keep_empty_folders(input);
            self
        }
        /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
        /// resolving conflicts during a merge.</p>
        pub fn conflict_resolution(mut self, input: crate::model::ConflictResolution) -> Self {
            self.inner = self.inner.conflict_resolution(input);
            self
        }
        pub fn set_conflict_resolution(
            mut self,
            input: std::option::Option<crate::model::ConflictResolution>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct MergePullRequestByThreeWay<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::merge_pull_request_by_three_way_input::Builder,
    }
    impl<C> MergePullRequestByThreeWay<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::MergePullRequestByThreeWayOutput,
            smithy_http::result::SdkError<crate::error::MergePullRequestByThreeWayError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The name of the repository where the pull request was created.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The full commit ID of the original or updated commit in the pull request source branch. Pass this value if you want an
        /// exception thrown if the current commit ID of the tip of the source branch does not match this commit ID.</p>
        pub fn source_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.source_commit_id(input);
            self
        }
        pub fn set_source_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_source_commit_id(input);
            self
        }
        /// <p>The level of conflict detail to use. If unspecified, the default FILE_LEVEL is used,
        /// which returns a not-mergeable result if the same file has differences in both branches.
        /// If LINE_LEVEL is specified, a conflict is considered not mergeable if the same file in
        /// both branches has differences on the same line.</p>
        pub fn conflict_detail_level(
            mut self,
            input: crate::model::ConflictDetailLevelTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_detail_level(input);
            self
        }
        pub fn set_conflict_detail_level(
            mut self,
            input: std::option::Option<crate::model::ConflictDetailLevelTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_detail_level(input);
            self
        }
        /// <p>Specifies which branch to use when resolving conflicts, or whether to attempt
        /// automatically merging two versions of a file. The default is NONE, which requires any
        /// conflicts to be resolved manually before the merge operation is successful.</p>
        pub fn conflict_resolution_strategy(
            mut self,
            input: crate::model::ConflictResolutionStrategyTypeEnum,
        ) -> Self {
            self.inner = self.inner.conflict_resolution_strategy(input);
            self
        }
        pub fn set_conflict_resolution_strategy(
            mut self,
            input: std::option::Option<crate::model::ConflictResolutionStrategyTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution_strategy(input);
            self
        }
        /// <p>The commit message to include in the commit information for the merge.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_message(input);
            self
        }
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_message(input);
            self
        }
        /// <p>The name of the author who created the commit. This information is used as both the
        /// author and committer for the commit.</p>
        pub fn author_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.author_name(input);
            self
        }
        pub fn set_author_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_author_name(input);
            self
        }
        /// <p>The email address of the person merging the branches. This information is used in the
        /// commit information for the merge.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email(input);
            self
        }
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_email(input);
            self
        }
        /// <p>If the commit contains deletions, whether to keep a folder or folder structure if the
        /// changes leave the folders empty. If true, a .gitkeep file is created for empty folders.
        /// The default is false.</p>
        pub fn keep_empty_folders(mut self, input: bool) -> Self {
            self.inner = self.inner.keep_empty_folders(input);
            self
        }
        pub fn set_keep_empty_folders(mut self, input: std::option::Option<bool>) -> Self {
            self.inner = self.inner.set_keep_empty_folders(input);
            self
        }
        /// <p>If AUTOMERGE is the conflict resolution strategy, a list of inputs to use when
        /// resolving conflicts during a merge.</p>
        pub fn conflict_resolution(mut self, input: crate::model::ConflictResolution) -> Self {
            self.inner = self.inner.conflict_resolution(input);
            self
        }
        pub fn set_conflict_resolution(
            mut self,
            input: std::option::Option<crate::model::ConflictResolution>,
        ) -> Self {
            self.inner = self.inner.set_conflict_resolution(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct OverridePullRequestApprovalRules<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::override_pull_request_approval_rules_input::Builder,
    }
    impl<C> OverridePullRequestApprovalRules<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::OverridePullRequestApprovalRulesOutput,
            smithy_http::result::SdkError<crate::error::OverridePullRequestApprovalRulesError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request for which you want to override all
        /// approval rule requirements. To get this information, use
        /// <a>GetPullRequest</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The system-generated ID of the most recent revision of the pull request. You cannot override approval rules for anything but the most recent revision of a pull request.
        /// To get the revision ID, use GetPullRequest.</p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(input);
            self
        }
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(input);
            self
        }
        /// <p>Whether you want to set aside approval rule requirements for the pull request (OVERRIDE) or revoke a previous override and apply
        /// approval rule requirements (REVOKE). REVOKE status is not stored.</p>
        pub fn override_status(mut self, input: crate::model::OverrideStatus) -> Self {
            self.inner = self.inner.override_status(input);
            self
        }
        pub fn set_override_status(
            mut self,
            input: std::option::Option<crate::model::OverrideStatus>,
        ) -> Self {
            self.inner = self.inner.set_override_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PostCommentForComparedCommit<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::post_comment_for_compared_commit_input::Builder,
    }
    impl<C> PostCommentForComparedCommit<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PostCommentForComparedCommitOutput,
            smithy_http::result::SdkError<crate::error::PostCommentForComparedCommitError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to post a comment on the comparison between commits.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>To establish the directionality of the comparison, the full commit ID of the before
        /// commit. Required for commenting on any commit unless that commit is the initial
        /// commit.</p>
        pub fn before_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.before_commit_id(input);
            self
        }
        pub fn set_before_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_before_commit_id(input);
            self
        }
        /// <p>To establish the directionality of the comparison, the full commit ID of the after
        /// commit.</p>
        pub fn after_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.after_commit_id(input);
            self
        }
        pub fn set_after_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_after_commit_id(input);
            self
        }
        /// <p>The location of the comparison where you want to comment.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.inner = self.inner.location(input);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
        /// <p>The content of the comment you want to make.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content(input);
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content(input);
            self
        }
        /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
        /// the request cannot be repeated with a changed parameter. If a request is received with
        /// the same parameters and a token is included, the request returns information about the
        /// initial request that used that token.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PostCommentForPullRequest<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::post_comment_for_pull_request_input::Builder,
    }
    impl<C> PostCommentForPullRequest<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PostCommentForPullRequestOutput,
            smithy_http::result::SdkError<crate::error::PostCommentForPullRequestError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The name of the repository where you want to post a comment on a pull request.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The full commit ID of the commit in the destination branch that was the tip of the branch at the time the pull request was created.</p>
        pub fn before_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.before_commit_id(input);
            self
        }
        pub fn set_before_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_before_commit_id(input);
            self
        }
        /// <p>The full commit ID of the commit in the source branch that is the current tip of the branch for the pull request when you post the comment.</p>
        pub fn after_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.after_commit_id(input);
            self
        }
        pub fn set_after_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_after_commit_id(input);
            self
        }
        /// <p>The location of the change where you want to post your comment. If no location is
        /// provided, the comment is posted as a general comment on the pull request difference
        /// between the before commit ID and the after commit ID.</p>
        pub fn location(mut self, input: crate::model::Location) -> Self {
            self.inner = self.inner.location(input);
            self
        }
        pub fn set_location(mut self, input: std::option::Option<crate::model::Location>) -> Self {
            self.inner = self.inner.set_location(input);
            self
        }
        /// <p>The content of your comment on the change.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content(input);
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content(input);
            self
        }
        /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
        /// the request cannot be repeated with a changed parameter. If a request is received with
        /// the same parameters and a token is included, the request returns information about the
        /// initial request that used that token.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PostCommentReply<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::post_comment_reply_input::Builder,
    }
    impl<C> PostCommentReply<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PostCommentReplyOutput,
            smithy_http::result::SdkError<crate::error::PostCommentReplyError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the comment to which you want to reply. To get this ID, use <a>GetCommentsForComparedCommit</a>
        /// or <a>GetCommentsForPullRequest</a>.</p>
        pub fn in_reply_to(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.in_reply_to(input);
            self
        }
        pub fn set_in_reply_to(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_in_reply_to(input);
            self
        }
        /// <p>A unique, client-generated idempotency token that, when provided in a request, ensures
        /// the request cannot be repeated with a changed parameter. If a request is received with
        /// the same parameters and a token is included, the request returns information about the
        /// initial request that used that token.</p>
        pub fn client_request_token(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.client_request_token(input);
            self
        }
        pub fn set_client_request_token(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_client_request_token(input);
            self
        }
        /// <p>The contents of your reply to a comment.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content(input);
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutCommentReaction<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_comment_reaction_input::Builder,
    }
    impl<C> PutCommentReaction<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutCommentReactionOutput,
            smithy_http::result::SdkError<crate::error::PutCommentReactionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The ID of the comment to which you want to add or update a reaction.</p>
        pub fn comment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment_id(input);
            self
        }
        pub fn set_comment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment_id(input);
            self
        }
        /// <p>The emoji reaction you want to add or update. To remove a reaction, provide a value of blank or null. You can also provide the value of none.
        /// For information about emoji reaction values supported in AWS CodeCommit, see the <a href="https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-commit-comment.html#emoji-reaction-table">AWS CodeCommit User Guide</a>.</p>
        pub fn reaction_value(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.reaction_value(input);
            self
        }
        pub fn set_reaction_value(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_reaction_value(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutFile<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_file_input::Builder,
    }
    impl<C> PutFile<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutFileOutput,
            smithy_http::result::SdkError<crate::error::PutFileError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to add or update the file.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The name of the branch where you want to add or update the file. If this is an empty
        /// repository, this branch is created.</p>
        pub fn branch_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.branch_name(input);
            self
        }
        pub fn set_branch_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_branch_name(input);
            self
        }
        /// <p>The content of the file, in binary object format. </p>
        pub fn file_content(mut self, input: smithy_types::Blob) -> Self {
            self.inner = self.inner.file_content(input);
            self
        }
        pub fn set_file_content(mut self, input: std::option::Option<smithy_types::Blob>) -> Self {
            self.inner = self.inner.set_file_content(input);
            self
        }
        /// <p>The name of the file you want to add or update, including the relative path to the file in the repository.</p>
        /// <note>
        /// <p>If the path does not currently exist in the repository, the path is created as part of adding
        /// the file.</p>
        /// </note>
        pub fn file_path(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.file_path(input);
            self
        }
        pub fn set_file_path(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_file_path(input);
            self
        }
        /// <p>The file mode permissions of the blob. Valid file mode permissions are listed
        /// here.</p>
        pub fn file_mode(mut self, input: crate::model::FileModeTypeEnum) -> Self {
            self.inner = self.inner.file_mode(input);
            self
        }
        pub fn set_file_mode(
            mut self,
            input: std::option::Option<crate::model::FileModeTypeEnum>,
        ) -> Self {
            self.inner = self.inner.set_file_mode(input);
            self
        }
        /// <p>The full commit ID of the head commit in the branch where you want to add or update the file. If this is an empty repository,
        /// no commit ID is required. If this is not an empty repository, a commit ID is required. </p>
        /// <p>The commit ID must match the ID of the head commit at the time of the operation.
        /// Otherwise, an error occurs, and the file is not added or updated.</p>
        pub fn parent_commit_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.parent_commit_id(input);
            self
        }
        pub fn set_parent_commit_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_parent_commit_id(input);
            self
        }
        /// <p>A message about why this file was added or updated. Although it is optional, a message
        /// makes the commit history for your repository more useful.</p>
        pub fn commit_message(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.commit_message(input);
            self
        }
        pub fn set_commit_message(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_commit_message(input);
            self
        }
        /// <p>The name of the person adding or updating the file. Although it is optional, a name
        /// makes the commit history for your repository more useful.</p>
        pub fn name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.name(input);
            self
        }
        pub fn set_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_name(input);
            self
        }
        /// <p>An email address for the person adding or updating the file.</p>
        pub fn email(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.email(input);
            self
        }
        pub fn set_email(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_email(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct PutRepositoryTriggers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::put_repository_triggers_input::Builder,
    }
    impl<C> PutRepositoryTriggers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::PutRepositoryTriggersOutput,
            smithy_http::result::SdkError<crate::error::PutRepositoryTriggersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository where you want to create or update the trigger.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The JSON block of configuration information for each trigger.</p>
        pub fn triggers(mut self, inp: impl Into<crate::model::RepositoryTrigger>) -> Self {
            self.inner = self.inner.triggers(inp);
            self
        }
        pub fn set_triggers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RepositoryTrigger>>,
        ) -> Self {
            self.inner = self.inner.set_triggers(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::tag_resource_input::Builder,
    }
    impl<C> TagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TagResourceOutput,
            smithy_http::result::SdkError<crate::error::TagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to which you want to add or update tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The key-value pair to use when tagging this repository.</p>
        pub fn tags(
            mut self,
            k: impl Into<std::string::String>,
            v: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.tags(k, v);
            self
        }
        pub fn set_tags(
            mut self,
            input: std::option::Option<
                std::collections::HashMap<std::string::String, std::string::String>,
            >,
        ) -> Self {
            self.inner = self.inner.set_tags(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct TestRepositoryTriggers<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::test_repository_triggers_input::Builder,
    }
    impl<C> TestRepositoryTriggers<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::TestRepositoryTriggersOutput,
            smithy_http::result::SdkError<crate::error::TestRepositoryTriggersError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository in which to test the triggers.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The list of triggers to test.</p>
        pub fn triggers(mut self, inp: impl Into<crate::model::RepositoryTrigger>) -> Self {
            self.inner = self.inner.triggers(inp);
            self
        }
        pub fn set_triggers(
            mut self,
            input: std::option::Option<std::vec::Vec<crate::model::RepositoryTrigger>>,
        ) -> Self {
            self.inner = self.inner.set_triggers(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UntagResource<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::untag_resource_input::Builder,
    }
    impl<C> UntagResource<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UntagResourceOutput,
            smithy_http::result::SdkError<crate::error::UntagResourceError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The Amazon Resource Name (ARN) of the resource to which you want to remove tags.</p>
        pub fn resource_arn(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.resource_arn(input);
            self
        }
        pub fn set_resource_arn(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_resource_arn(input);
            self
        }
        /// <p>The tag key for each tag that you want to remove from the resource.</p>
        pub fn tag_keys(mut self, inp: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.tag_keys(inp);
            self
        }
        pub fn set_tag_keys(
            mut self,
            input: std::option::Option<std::vec::Vec<std::string::String>>,
        ) -> Self {
            self.inner = self.inner.set_tag_keys(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateApprovalRuleTemplateContent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_approval_rule_template_content_input::Builder,
    }
    impl<C> UpdateApprovalRuleTemplateContent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateApprovalRuleTemplateContentOutput,
            smithy_http::result::SdkError<crate::error::UpdateApprovalRuleTemplateContentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the approval rule template where you want to update the content of the rule. </p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
        /// <p>The content that replaces the existing content of the rule. Content statements must be
        /// complete. You cannot provide only the changes.</p>
        pub fn new_rule_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_rule_content(input);
            self
        }
        pub fn set_new_rule_content(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_new_rule_content(input);
            self
        }
        /// <p>The SHA-256 hash signature for the content of the approval rule. You can retrieve this
        /// information by using
        /// <a>GetPullRequest</a>.</p>
        pub fn existing_rule_content_sha256(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.existing_rule_content_sha256(input);
            self
        }
        pub fn set_existing_rule_content_sha256(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_existing_rule_content_sha256(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateApprovalRuleTemplateDescription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_approval_rule_template_description_input::Builder,
    }
    impl<C> UpdateApprovalRuleTemplateDescription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateApprovalRuleTemplateDescriptionOutput,
            smithy_http::result::SdkError<crate::error::UpdateApprovalRuleTemplateDescriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the template for which you want to update the description.</p>
        pub fn approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_name(input);
            self
        }
        pub fn set_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_name(input);
            self
        }
        /// <p>The updated description of the approval rule template.</p>
        pub fn approval_rule_template_description(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.approval_rule_template_description(input);
            self
        }
        pub fn set_approval_rule_template_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_template_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateApprovalRuleTemplateName<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_approval_rule_template_name_input::Builder,
    }
    impl<C> UpdateApprovalRuleTemplateName<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateApprovalRuleTemplateNameOutput,
            smithy_http::result::SdkError<crate::error::UpdateApprovalRuleTemplateNameError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The current name of the approval rule template.</p>
        pub fn old_approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.old_approval_rule_template_name(input);
            self
        }
        pub fn set_old_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_old_approval_rule_template_name(input);
            self
        }
        /// <p>The new name you want to apply to the approval rule template.</p>
        pub fn new_approval_rule_template_name(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.new_approval_rule_template_name(input);
            self
        }
        pub fn set_new_approval_rule_template_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_new_approval_rule_template_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateComment<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_comment_input::Builder,
    }
    impl<C> UpdateComment<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateCommentOutput,
            smithy_http::result::SdkError<crate::error::UpdateCommentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the comment you want to update. To get this ID, use <a>GetCommentsForComparedCommit</a>
        /// or <a>GetCommentsForPullRequest</a>.</p>
        pub fn comment_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.comment_id(input);
            self
        }
        pub fn set_comment_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_comment_id(input);
            self
        }
        /// <p>The updated content to replace the existing content of the comment.</p>
        pub fn content(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.content(input);
            self
        }
        pub fn set_content(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_content(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateDefaultBranch<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_default_branch_input::Builder,
    }
    impl<C> UpdateDefaultBranch<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateDefaultBranchOutput,
            smithy_http::result::SdkError<crate::error::UpdateDefaultBranchError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository to set or change the default branch for.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The name of the branch to set as the default.</p>
        pub fn default_branch_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.default_branch_name(input);
            self
        }
        pub fn set_default_branch_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_default_branch_name(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePullRequestApprovalRuleContent<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pull_request_approval_rule_content_input::Builder,
    }
    impl<C> UpdatePullRequestApprovalRuleContent<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePullRequestApprovalRuleContentOutput,
            smithy_http::result::SdkError<crate::error::UpdatePullRequestApprovalRuleContentError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The name of the approval rule you want to update.</p>
        pub fn approval_rule_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.approval_rule_name(input);
            self
        }
        pub fn set_approval_rule_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_approval_rule_name(input);
            self
        }
        /// <p>The SHA-256 hash signature for the content of the approval rule. You can retrieve this
        /// information by using
        /// <a>GetPullRequest</a>.</p>
        pub fn existing_rule_content_sha256(
            mut self,
            input: impl Into<std::string::String>,
        ) -> Self {
            self.inner = self.inner.existing_rule_content_sha256(input);
            self
        }
        pub fn set_existing_rule_content_sha256(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_existing_rule_content_sha256(input);
            self
        }
        /// <p>The updated content for the approval rule.</p>
        /// <note>
        /// <p>When you update the content of the approval rule, you can specify approvers in an
        /// approval pool in one of two ways:</p>
        /// <ul>
        /// <li>
        /// <p>
        /// <b>CodeCommitApprovers</b>: This option only
        /// requires an AWS account and a resource. It can be used for both IAM users
        /// and federated access users whose name matches the provided resource name.
        /// This is a very powerful option that offers a great deal of flexibility. For
        /// example, if you specify the AWS account <i>123456789012</i>
        /// and <i>Mary_Major</i>, all of the following are counted as
        /// approvals coming from that user:</p>
        /// <ul>
        /// <li>
        /// <p>An IAM user in the account
        /// (arn:aws:iam::<i>123456789012</i>:user/<i>Mary_Major</i>)</p>
        /// </li>
        /// <li>
        /// <p>A federated user identified in IAM as Mary_Major
        /// (arn:aws:sts::<i>123456789012</i>:federated-user/<i>Mary_Major</i>)</p>
        /// </li>
        /// </ul>
        /// <p>This option does not recognize an active session of someone assuming the
        /// role of CodeCommitReview with a role session name of
        /// <i>Mary_Major</i>
        /// (arn:aws:sts::<i>123456789012</i>:assumed-role/CodeCommitReview/<i>Mary_Major</i>)
        /// unless you include a wildcard (*Mary_Major).</p>
        /// </li>
        /// <li>
        /// <p>
        /// <b>Fully qualified ARN</b>: This option allows
        /// you to specify the fully qualified Amazon Resource Name (ARN) of the IAM
        /// user or role. </p>
        /// </li>
        /// </ul>
        /// <p>For more information about IAM ARNs, wildcards, and formats, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
        /// Identifiers</a> in the <i>IAM User Guide</i>.</p>
        /// </note>
        pub fn new_rule_content(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_rule_content(input);
            self
        }
        pub fn set_new_rule_content(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_new_rule_content(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePullRequestApprovalState<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pull_request_approval_state_input::Builder,
    }
    impl<C> UpdatePullRequestApprovalState<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePullRequestApprovalStateOutput,
            smithy_http::result::SdkError<crate::error::UpdatePullRequestApprovalStateError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The system-generated ID of the revision.</p>
        pub fn revision_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.revision_id(input);
            self
        }
        pub fn set_revision_id(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_revision_id(input);
            self
        }
        /// <p>The approval state to associate with the user on the pull request.</p>
        pub fn approval_state(mut self, input: crate::model::ApprovalState) -> Self {
            self.inner = self.inner.approval_state(input);
            self
        }
        pub fn set_approval_state(
            mut self,
            input: std::option::Option<crate::model::ApprovalState>,
        ) -> Self {
            self.inner = self.inner.set_approval_state(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePullRequestDescription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pull_request_description_input::Builder,
    }
    impl<C> UpdatePullRequestDescription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePullRequestDescriptionOutput,
            smithy_http::result::SdkError<crate::error::UpdatePullRequestDescriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The updated content of the description for the pull request. This content replaces the
        /// existing description.</p>
        pub fn description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.description(input);
            self
        }
        pub fn set_description(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePullRequestStatus<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pull_request_status_input::Builder,
    }
    impl<C> UpdatePullRequestStatus<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePullRequestStatusOutput,
            smithy_http::result::SdkError<crate::error::UpdatePullRequestStatusError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The status of the pull request. The only valid operations are to update the status
        /// from <code>OPEN</code> to <code>OPEN</code>, <code>OPEN</code> to <code>CLOSED</code> or
        /// from <code>CLOSED</code> to <code>CLOSED</code>.</p>
        pub fn pull_request_status(mut self, input: crate::model::PullRequestStatusEnum) -> Self {
            self.inner = self.inner.pull_request_status(input);
            self
        }
        pub fn set_pull_request_status(
            mut self,
            input: std::option::Option<crate::model::PullRequestStatusEnum>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_status(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdatePullRequestTitle<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_pull_request_title_input::Builder,
    }
    impl<C> UpdatePullRequestTitle<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdatePullRequestTitleOutput,
            smithy_http::result::SdkError<crate::error::UpdatePullRequestTitleError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The system-generated ID of the pull request. To get this ID, use <a>ListPullRequests</a>.</p>
        pub fn pull_request_id(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.pull_request_id(input);
            self
        }
        pub fn set_pull_request_id(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_pull_request_id(input);
            self
        }
        /// <p>The updated title of the pull request. This replaces the existing title.</p>
        pub fn title(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.title(input);
            self
        }
        pub fn set_title(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_title(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRepositoryDescription<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_repository_description_input::Builder,
    }
    impl<C> UpdateRepositoryDescription<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRepositoryDescriptionOutput,
            smithy_http::result::SdkError<crate::error::UpdateRepositoryDescriptionError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The name of the repository to set or change the comment or description for.</p>
        pub fn repository_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_name(input);
            self
        }
        pub fn set_repository_name(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_name(input);
            self
        }
        /// <p>The new comment or description for the specified repository. Repository descriptions are limited to 1,000 characters.</p>
        pub fn repository_description(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.repository_description(input);
            self
        }
        pub fn set_repository_description(
            mut self,
            input: std::option::Option<std::string::String>,
        ) -> Self {
            self.inner = self.inner.set_repository_description(input);
            self
        }
    }
    #[derive(std::fmt::Debug)]
    pub struct UpdateRepositoryName<C = aws_hyper::DynConnector> {
        handle: std::sync::Arc<super::Handle<C>>,
        inner: crate::input::update_repository_name_input::Builder,
    }
    impl<C> UpdateRepositoryName<C> {
        pub(crate) fn new(handle: std::sync::Arc<super::Handle<C>>) -> Self {
            Self {
                handle,
                inner: Default::default(),
            }
        }

        pub async fn send(
            self,
        ) -> std::result::Result<
            crate::output::UpdateRepositoryNameOutput,
            smithy_http::result::SdkError<crate::error::UpdateRepositoryNameError>,
        >
        where
            C: aws_hyper::SmithyConnector,
        {
            let input = self
                .inner
                .build()
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            let op = input
                .make_operation(&self.handle.conf)
                .map_err(|err| smithy_http::result::SdkError::ConstructionFailure(err.into()))?;
            self.handle.client.call(op).await
        }
        /// <p>The current name of the repository.</p>
        pub fn old_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.old_name(input);
            self
        }
        pub fn set_old_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_old_name(input);
            self
        }
        /// <p>The new name for the repository.</p>
        pub fn new_name(mut self, input: impl Into<std::string::String>) -> Self {
            self.inner = self.inner.new_name(input);
            self
        }
        pub fn set_new_name(mut self, input: std::option::Option<std::string::String>) -> Self {
            self.inner = self.inner.set_new_name(input);
            self
        }
    }
}
