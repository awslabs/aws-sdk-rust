// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `PutRepositoryTriggers`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct PutRepositoryTriggers;
impl PutRepositoryTriggers {
    /// Creates a new `PutRepositoryTriggers`
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::put_repository_triggers::PutRepositoryTriggersInput,
    ) -> ::std::result::Result<
        crate::operation::put_repository_triggers::PutRepositoryTriggersOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::put_repository_triggers::PutRepositoryTriggersError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >| {
            err.map_service_error(|err| {
                err.downcast::<crate::operation::put_repository_triggers::PutRepositoryTriggersError>()
                    .expect("correct error type")
            })
        };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::put_repository_triggers::PutRepositoryTriggersOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::put_repository_triggers::PutRepositoryTriggersInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point("codecommit", "PutRepositoryTriggers", input, runtime_plugins, stop_point)
            .await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
        runtime_plugins = runtime_plugins.with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![
            ::aws_runtime::auth::sigv4::SCHEME_ID,
        ]));
        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for PutRepositoryTriggers {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("PutRepositoryTriggers");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            PutRepositoryTriggersRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            PutRepositoryTriggersResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            ::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new(),
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::orchestrator::Metadata::new(
            "PutRepositoryTriggers",
            "codecommit",
        ));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        #[allow(unused_mut)]
        let mut rcb = ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("PutRepositoryTriggers")
            .with_interceptor(
                ::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptor::new(
                    ::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptorKind::ResponseBody,
                ),
            )
            .with_interceptor(PutRepositoryTriggersEndpointParamsInterceptor)
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                crate::operation::put_repository_triggers::PutRepositoryTriggersError,
            >::new())
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                crate::operation::put_repository_triggers::PutRepositoryTriggersError,
            >::new())
            .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                crate::operation::put_repository_triggers::PutRepositoryTriggersError,
            >::new());

        ::std::borrow::Cow::Owned(rcb)
    }
}

#[derive(Debug)]
struct PutRepositoryTriggersResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for PutRepositoryTriggersResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_types::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_put_repository_triggers::de_put_repository_triggers_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_put_repository_triggers::de_put_repository_triggers_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct PutRepositoryTriggersRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for PutRepositoryTriggersRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input
            .downcast::<crate::operation::put_repository_triggers::PutRepositoryTriggersInput>()
            .expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            fn uri_base(
                _input: &crate::operation::put_repository_triggers::PutRepositoryTriggersInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::put_repository_triggers::PutRepositoryTriggersInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = _header_serialization_settings.set_default_header(
                builder,
                ::http::header::HeaderName::from_static("x-amz-target"),
                "CodeCommit_20150413.PutRepositoryTriggers",
            );
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(crate::protocol_serde::shape_put_repository_triggers::ser_put_repository_triggers_input(
            &input,
        )?);
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct PutRepositoryTriggersEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for PutRepositoryTriggersEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "PutRepositoryTriggersEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<PutRepositoryTriggersInput>()
            .ok_or("failed to downcast to PutRepositoryTriggersInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

/// Error type for the `PutRepositoryTriggersError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum PutRepositoryTriggersError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(crate::types::error::EncryptionIntegrityChecksFailedException),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::types::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::types::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::types::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::types::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p><note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::types::error::InvalidRepositoryNameException),
    /// <p>One or more branch names specified for the trigger is not valid.</p>
    InvalidRepositoryTriggerBranchNameException(crate::types::error::InvalidRepositoryTriggerBranchNameException),
    /// <p>The custom data provided for the trigger is not valid.</p>
    InvalidRepositoryTriggerCustomDataException(crate::types::error::InvalidRepositoryTriggerCustomDataException),
    /// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
    InvalidRepositoryTriggerDestinationArnException(crate::types::error::InvalidRepositoryTriggerDestinationArnException),
    /// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
    InvalidRepositoryTriggerEventsException(crate::types::error::InvalidRepositoryTriggerEventsException),
    /// <p>The name of the trigger is not valid.</p>
    InvalidRepositoryTriggerNameException(crate::types::error::InvalidRepositoryTriggerNameException),
    /// <p>The Amazon Web Services Region for the trigger target does not match the Amazon Web Services Region for the repository. Triggers must be created in the same Amazon Web Services Region as the target for the trigger.</p>
    InvalidRepositoryTriggerRegionException(crate::types::error::InvalidRepositoryTriggerRegionException),
    /// <p>The number of branches for the trigger was exceeded.</p>
    MaximumBranchesExceededException(crate::types::error::MaximumBranchesExceededException),
    /// <p>The number of triggers allowed for the repository was exceeded.</p>
    MaximumRepositoryTriggersExceededException(crate::types::error::MaximumRepositoryTriggersExceededException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::types::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::types::error::RepositoryNameRequiredException),
    /// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
    RepositoryTriggerBranchNameListRequiredException(crate::types::error::RepositoryTriggerBranchNameListRequiredException),
    /// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
    RepositoryTriggerDestinationArnRequiredException(crate::types::error::RepositoryTriggerDestinationArnRequiredException),
    /// <p>At least one event for the trigger is required, but was not specified.</p>
    RepositoryTriggerEventsListRequiredException(crate::types::error::RepositoryTriggerEventsListRequiredException),
    /// <p>A name for the trigger is required, but was not specified.</p>
    RepositoryTriggerNameRequiredException(crate::types::error::RepositoryTriggerNameRequiredException),
    /// <p>The list of triggers for the repository is required, but was not specified.</p>
    RepositoryTriggersListRequiredException(crate::types::error::RepositoryTriggersListRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-PutRepositoryTriggersError) for what information is available for the error.")]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl PutRepositoryTriggersError {
    /// Creates the `PutRepositoryTriggersError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.into(),
            meta: ::std::default::Default::default(),
        })
    }

    /// Creates the `PutRepositoryTriggersError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.clone().into(),
            meta: err,
        })
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EncryptionKeyAccessDeniedException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EncryptionKeyDisabledException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EncryptionKeyNotFoundException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EncryptionKeyUnavailableException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRepositoryNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRepositoryTriggerBranchNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRepositoryTriggerCustomDataException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRepositoryTriggerDestinationArnException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRepositoryTriggerEventsException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRepositoryTriggerNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRepositoryTriggerRegionException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::MaximumBranchesExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::MaximumRepositoryTriggersExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RepositoryDoesNotExistException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RepositoryNameRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RepositoryTriggerBranchNameListRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RepositoryTriggerDestinationArnRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RepositoryTriggerEventsListRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RepositoryTriggerNameRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RepositoryTriggersListRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::Unhandled(e) => &e.meta,
        }
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException`.
    pub fn is_invalid_repository_trigger_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerBranchNameException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException`.
    pub fn is_invalid_repository_trigger_custom_data_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerCustomDataException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException`.
    pub fn is_invalid_repository_trigger_destination_arn_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerDestinationArnException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerEventsException`.
    pub fn is_invalid_repository_trigger_events_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerEventsException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerNameException`.
    pub fn is_invalid_repository_trigger_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerNameException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerRegionException`.
    pub fn is_invalid_repository_trigger_region_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerRegionException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::MaximumBranchesExceededException`.
    pub fn is_maximum_branches_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumBranchesExceededException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::MaximumRepositoryTriggersExceededException`.
    pub fn is_maximum_repository_triggers_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumRepositoryTriggersExceededException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException`.
    pub fn is_repository_trigger_branch_name_list_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerBranchNameListRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException`.
    pub fn is_repository_trigger_destination_arn_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerDestinationArnRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerEventsListRequiredException`.
    pub fn is_repository_trigger_events_list_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerEventsListRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerNameRequiredException`.
    pub fn is_repository_trigger_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggersListRequiredException`.
    pub fn is_repository_triggers_list_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggersListRequiredException(_))
    }
}
impl ::std::error::Error for PutRepositoryTriggersError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryTriggerEventsException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryTriggerNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryTriggerRegionException(_inner) => ::std::option::Option::Some(_inner),
            Self::MaximumBranchesExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::MaximumRepositoryTriggersExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryTriggerEventsListRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryTriggerNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryTriggersListRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
        }
    }
}
impl ::std::fmt::Display for PutRepositoryTriggersError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerEventsException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerRegionException(_inner) => _inner.fmt(f),
            Self::MaximumBranchesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumRepositoryTriggersExceededException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerEventsListRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggersListRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for PutRepositoryTriggersError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for PutRepositoryTriggersError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyDisabledException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryTriggerEventsException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryTriggerNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryTriggerRegionException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::MaximumBranchesExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::MaximumRepositoryTriggersExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryTriggerEventsListRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryTriggerNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryTriggersListRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => &_inner.meta,
        }
    }
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for PutRepositoryTriggersError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source,
            meta: meta.unwrap_or_default(),
        })
    }
}
impl ::aws_types::request_id::RequestId for crate::operation::put_repository_triggers::PutRepositoryTriggersError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}

pub use crate::operation::put_repository_triggers::_put_repository_triggers_output::PutRepositoryTriggersOutput;

pub use crate::operation::put_repository_triggers::_put_repository_triggers_input::PutRepositoryTriggersInput;

mod _put_repository_triggers_input;

mod _put_repository_triggers_output;

/// Builders
pub mod builders;
