// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl PutRepositoryTriggersInput {
    /// Consumes the builder and constructs an Operation<[`PutRepositoryTriggers`](crate::operation::put_repository_triggers::PutRepositoryTriggers)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::put_repository_triggers::PutRepositoryTriggers,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::operation::put_repository_triggers::PutRepositoryTriggersInput,
                output: &mut String,
            ) -> std::result::Result<(), aws_smithy_http::operation::error::BuildError>
            {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::put_repository_triggers::PutRepositoryTriggersInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "CodeCommit_20150413.PutRepositoryTriggers",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_put_repository_triggers::ser_put_repository_triggers_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::meta::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::put_repository_triggers::PutRepositoryTriggers::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "PutRepositoryTriggers",
            "codecommit",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `PutRepositoryTriggers`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct PutRepositoryTriggers;
impl PutRepositoryTriggers {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for PutRepositoryTriggers {
    type Output = std::result::Result<
        crate::operation::put_repository_triggers::PutRepositoryTriggersOutput,
        crate::operation::put_repository_triggers::PutRepositoryTriggersError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::protocol_serde::shape_put_repository_triggers::de_put_repository_triggers_http_error(response)
        } else {
            crate::protocol_serde::shape_put_repository_triggers::de_put_repository_triggers_http_response(response)
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type PutRepositoryTriggersErrorKind = PutRepositoryTriggersError;
/// Error type for the `PutRepositoryTriggersError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum PutRepositoryTriggersError {
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::types::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::types::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::types::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::types::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::types::error::EncryptionKeyUnavailableException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::types::error::InvalidRepositoryNameException),
    /// <p>One or more branch names specified for the trigger is not valid.</p>
    InvalidRepositoryTriggerBranchNameException(
        crate::types::error::InvalidRepositoryTriggerBranchNameException,
    ),
    /// <p>The custom data provided for the trigger is not valid.</p>
    InvalidRepositoryTriggerCustomDataException(
        crate::types::error::InvalidRepositoryTriggerCustomDataException,
    ),
    /// <p>The Amazon Resource Name (ARN) for the trigger is not valid for the specified destination. The most common reason for this error is that the ARN does not meet the requirements for the service type.</p>
    InvalidRepositoryTriggerDestinationArnException(
        crate::types::error::InvalidRepositoryTriggerDestinationArnException,
    ),
    /// <p>One or more events specified for the trigger is not valid. Check to make sure that all events specified match the requirements for allowed events.</p>
    InvalidRepositoryTriggerEventsException(
        crate::types::error::InvalidRepositoryTriggerEventsException,
    ),
    /// <p>The name of the trigger is not valid.</p>
    InvalidRepositoryTriggerNameException(
        crate::types::error::InvalidRepositoryTriggerNameException,
    ),
    /// <p>The AWS Region for the trigger target does not match the AWS Region for the repository. Triggers must be created in the same Region as the target for the trigger.</p>
    InvalidRepositoryTriggerRegionException(
        crate::types::error::InvalidRepositoryTriggerRegionException,
    ),
    /// <p>The number of branches for the trigger was exceeded.</p>
    MaximumBranchesExceededException(crate::types::error::MaximumBranchesExceededException),
    /// <p>The number of triggers allowed for the repository was exceeded.</p>
    MaximumRepositoryTriggersExceededException(
        crate::types::error::MaximumRepositoryTriggersExceededException,
    ),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::types::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::types::error::RepositoryNameRequiredException),
    /// <p>At least one branch name is required, but was not specified in the trigger configuration.</p>
    RepositoryTriggerBranchNameListRequiredException(
        crate::types::error::RepositoryTriggerBranchNameListRequiredException,
    ),
    /// <p>A destination ARN for the target service for the trigger is required, but was not specified.</p>
    RepositoryTriggerDestinationArnRequiredException(
        crate::types::error::RepositoryTriggerDestinationArnRequiredException,
    ),
    /// <p>At least one event for the trigger is required, but was not specified.</p>
    RepositoryTriggerEventsListRequiredException(
        crate::types::error::RepositoryTriggerEventsListRequiredException,
    ),
    /// <p>A name for the trigger is required, but was not specified.</p>
    RepositoryTriggerNameRequiredException(
        crate::types::error::RepositoryTriggerNameRequiredException,
    ),
    /// <p>The list of triggers for the repository is required, but was not specified.</p>
    RepositoryTriggersListRequiredException(
        crate::types::error::RepositoryTriggersListRequiredException,
    ),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for PutRepositoryTriggersError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: std::option::Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for PutRepositoryTriggersError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerEventsException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerNameException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryTriggerRegionException(_inner) => _inner.fmt(f),
            Self::MaximumBranchesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumRepositoryTriggersExceededException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerEventsListRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggerNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryTriggersListRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for PutRepositoryTriggersError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerEventsException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryTriggerRegionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumBranchesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumRepositoryTriggersExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerEventsListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggerNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryTriggersListRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::operation::put_repository_triggers::PutRepositoryTriggersError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for PutRepositoryTriggersError {
    fn code(&self) -> std::option::Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> std::option::Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl PutRepositoryTriggersError {
    /// Creates the `PutRepositoryTriggersError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `PutRepositoryTriggersError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::InvalidRepositoryTriggerBranchNameException(e) => e.meta(),
            Self::InvalidRepositoryTriggerCustomDataException(e) => e.meta(),
            Self::InvalidRepositoryTriggerDestinationArnException(e) => e.meta(),
            Self::InvalidRepositoryTriggerEventsException(e) => e.meta(),
            Self::InvalidRepositoryTriggerNameException(e) => e.meta(),
            Self::InvalidRepositoryTriggerRegionException(e) => e.meta(),
            Self::MaximumBranchesExceededException(e) => e.meta(),
            Self::MaximumRepositoryTriggersExceededException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryTriggerBranchNameListRequiredException(e) => e.meta(),
            Self::RepositoryTriggerDestinationArnRequiredException(e) => e.meta(),
            Self::RepositoryTriggerEventsListRequiredException(e) => e.meta(),
            Self::RepositoryTriggerNameRequiredException(e) => e.meta(),
            Self::RepositoryTriggersListRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerBranchNameException`.
    pub fn is_invalid_repository_trigger_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerBranchNameException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerCustomDataException`.
    pub fn is_invalid_repository_trigger_custom_data_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerCustomDataException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerDestinationArnException`.
    pub fn is_invalid_repository_trigger_destination_arn_exception(&self) -> bool {
        matches!(
            self,
            Self::InvalidRepositoryTriggerDestinationArnException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerEventsException`.
    pub fn is_invalid_repository_trigger_events_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerEventsException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerNameException`.
    pub fn is_invalid_repository_trigger_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerNameException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::InvalidRepositoryTriggerRegionException`.
    pub fn is_invalid_repository_trigger_region_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryTriggerRegionException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::MaximumBranchesExceededException`.
    pub fn is_maximum_branches_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumBranchesExceededException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::MaximumRepositoryTriggersExceededException`.
    pub fn is_maximum_repository_triggers_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumRepositoryTriggersExceededException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerBranchNameListRequiredException`.
    pub fn is_repository_trigger_branch_name_list_required_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryTriggerBranchNameListRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerDestinationArnRequiredException`.
    pub fn is_repository_trigger_destination_arn_required_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryTriggerDestinationArnRequiredException(_)
        )
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerEventsListRequiredException`.
    pub fn is_repository_trigger_events_list_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerEventsListRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggerNameRequiredException`.
    pub fn is_repository_trigger_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggerNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutRepositoryTriggersError::RepositoryTriggersListRequiredException`.
    pub fn is_repository_triggers_list_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryTriggersListRequiredException(_))
    }
}
impl std::error::Error for PutRepositoryTriggersError {
    fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerBranchNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerCustomDataException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerDestinationArnException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerEventsException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerNameException(_inner) => Some(_inner),
            Self::InvalidRepositoryTriggerRegionException(_inner) => Some(_inner),
            Self::MaximumBranchesExceededException(_inner) => Some(_inner),
            Self::MaximumRepositoryTriggersExceededException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerBranchNameListRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerDestinationArnRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerEventsListRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggerNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryTriggersListRequiredException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

pub use crate::operation::put_repository_triggers::_put_repository_triggers_output::PutRepositoryTriggersOutput;

pub use crate::operation::put_repository_triggers::_put_repository_triggers_input::PutRepositoryTriggersInput;

mod _put_repository_triggers_input;

mod _put_repository_triggers_output;

/// Builders
pub mod builders;
