// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `PutFile`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
pub struct PutFile;
impl PutFile {
    /// Creates a new `PutFile`
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::put_file::PutFileInput,
    ) -> ::std::result::Result<
        crate::operation::put_file::PutFileOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::put_file::PutFileError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err =
            |err: ::aws_smithy_runtime_api::client::result::SdkError<
                ::aws_smithy_runtime_api::client::interceptors::context::Error,
                ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
            >| { err.map_service_error(|err| err.downcast::<crate::operation::put_file::PutFileError>().expect("correct error type")) };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::put_file::PutFileOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::put_file::PutFileInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point("codecommit", "PutFile", input, runtime_plugins, stop_point).await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
        runtime_plugins = runtime_plugins.with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![
            ::aws_runtime::auth::sigv4::SCHEME_ID,
        ]));
        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for PutFile {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("PutFile");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            PutFileRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            PutFileResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            ::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new(),
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::orchestrator::Metadata::new("PutFile", "codecommit"));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        #[allow(unused_mut)]
        let mut rcb = ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("PutFile")
            .with_interceptor(
                ::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptor::new(
                    ::aws_smithy_runtime::client::stalled_stream_protection::StalledStreamProtectionInterceptorKind::ResponseBody,
                ),
            )
            .with_interceptor(PutFileEndpointParamsInterceptor)
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                crate::operation::put_file::PutFileError,
            >::new())
            .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                crate::operation::put_file::PutFileError,
            >::new())
            .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                crate::operation::put_file::PutFileError,
            >::new());

        ::std::borrow::Cow::Owned(rcb)
    }
}

#[derive(Debug)]
struct PutFileResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for PutFileResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_types::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_put_file::de_put_file_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_put_file::de_put_file_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct PutFileRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for PutFileRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input.downcast::<crate::operation::put_file::PutFileInput>().expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            fn uri_base(
                _input: &crate::operation::put_file::PutFileInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::put_file::PutFileInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = _header_serialization_settings.set_default_header(
                builder,
                ::http::header::HeaderName::from_static("x-amz-target"),
                "CodeCommit_20150413.PutFile",
            );
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(crate::protocol_serde::shape_put_file::ser_put_file_input(&input)?);
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct PutFileEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for PutFileEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "PutFileEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<PutFileInput>()
            .ok_or("failed to downcast to PutFileInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

/// Error type for the `PutFileError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum PutFileError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::types::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::types::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::types::error::BranchNameRequiredException),
    /// <p>The commit message is too long. Provide a shorter string.</p>
    CommitMessageLengthExceededException(crate::types::error::CommitMessageLengthExceededException),
    /// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
    DirectoryNameConflictsWithFileNameException(crate::types::error::DirectoryNameConflictsWithFileNameException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(crate::types::error::EncryptionIntegrityChecksFailedException),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::types::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::types::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::types::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::types::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is empty. Empty files cannot be added to the repository with this API.</p>
    FileContentRequiredException(crate::types::error::FileContentRequiredException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::types::error::FileContentSizeLimitExceededException),
    /// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
    FileNameConflictsWithDirectoryNameException(crate::types::error::FileNameConflictsWithDirectoryNameException),
    /// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
    FilePathConflictsWithSubmodulePathException(crate::types::error::FilePathConflictsWithSubmodulePathException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::types::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::types::error::InvalidBranchNameException),
    /// <p>The specified deletion parameter is not valid.</p>
    InvalidDeletionParameterException(crate::types::error::InvalidDeletionParameterException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::types::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>.</p>
    InvalidFileModeException(crate::types::error::InvalidFileModeException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::types::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::types::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p><note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::types::error::InvalidRepositoryNameException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names.</p>
    NameLengthExceededException(crate::types::error::NameLengthExceededException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::types::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::types::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::types::error::ParentCommitIdRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::types::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::types::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::types::error::RepositoryNameRequiredException),
    /// <p>The file was not added or updated because the content of the file is exactly the same as the content of that file in the repository and branch that you specified.</p>
    SameFileContentException(crate::types::error::SameFileContentException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    #[deprecated(note = "Matching `Unhandled` directly is not forwards compatible. Instead, match using a \
    variable wildcard pattern and check `.code()`:
     \
    &nbsp;&nbsp;&nbsp;`err if err.code() == Some(\"SpecificExceptionCode\") => { /* handle the error */ }`
     \
    See [`ProvideErrorMetadata`](#impl-ProvideErrorMetadata-for-PutFileError) for what information is available for the error.")]
    Unhandled(crate::error::sealed_unhandled::Unhandled),
}
impl PutFileError {
    /// Creates the `PutFileError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.into(),
            meta: ::std::default::Default::default(),
        })
    }

    /// Creates the `PutFileError::Unhandled` variant from an [`ErrorMetadata`](::aws_smithy_types::error::ErrorMetadata).
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source: err.clone().into(),
            meta: err,
        })
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::BranchNameIsTagNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::BranchNameRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::CommitMessageLengthExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::DirectoryNameConflictsWithFileNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EncryptionIntegrityChecksFailedException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EncryptionKeyAccessDeniedException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EncryptionKeyDisabledException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EncryptionKeyNotFoundException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::EncryptionKeyUnavailableException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::FileContentRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::FileContentSizeLimitExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::FileNameConflictsWithDirectoryNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::FilePathConflictsWithSubmodulePathException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::FolderContentSizeLimitExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidBranchNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidDeletionParameterException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidEmailException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidFileModeException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidParentCommitIdException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidPathException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::InvalidRepositoryNameException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::NameLengthExceededException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::ParentCommitDoesNotExistException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::ParentCommitIdOutdatedException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::ParentCommitIdRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::PathRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RepositoryDoesNotExistException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::RepositoryNameRequiredException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::SameFileContentException(e) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(e),
            Self::Unhandled(e) => &e.meta,
        }
    }
    /// Returns `true` if the error kind is `PutFileError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(self, Self::BranchNameIsTagNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::DirectoryNameConflictsWithFileNameException`.
    pub fn is_directory_name_conflicts_with_file_name_exception(&self) -> bool {
        matches!(self, Self::DirectoryNameConflictsWithFileNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FileContentRequiredException`.
    pub fn is_file_content_required_exception(&self) -> bool {
        matches!(self, Self::FileContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FileNameConflictsWithDirectoryNameException`.
    pub fn is_file_name_conflicts_with_directory_name_exception(&self) -> bool {
        matches!(self, Self::FileNameConflictsWithDirectoryNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FilePathConflictsWithSubmodulePathException`.
    pub fn is_file_path_conflicts_with_submodule_path_exception(&self) -> bool {
        matches!(self, Self::FilePathConflictsWithSubmodulePathException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidDeletionParameterException`.
    pub fn is_invalid_deletion_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidDeletionParameterException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidParentCommitIdException`.
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidParentCommitIdException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::ParentCommitDoesNotExistException`.
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ParentCommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::ParentCommitIdOutdatedException`.
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdOutdatedException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::ParentCommitIdRequiredException`.
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `PutFileError::SameFileContentException`.
    pub fn is_same_file_content_exception(&self) -> bool {
        matches!(self, Self::SameFileContentException(_))
    }
}
impl ::std::error::Error for PutFileError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::BranchNameIsTagNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::BranchNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::CommitMessageLengthExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileContentRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => ::std::option::Option::Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidBranchNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidDeletionParameterException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidEmailException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidFileModeException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidParentCommitIdException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidPathException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::NameLengthExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::ParentCommitDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::ParentCommitIdOutdatedException(_inner) => ::std::option::Option::Some(_inner),
            Self::ParentCommitIdRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::PathRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::SameFileContentException(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(&*_inner.source),
        }
    }
}
impl ::std::fmt::Display for PutFileError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentRequiredException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => _inner.fmt(f),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeletionParameterException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::SameFileContentException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => {
                if let ::std::option::Option::Some(code) = ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self) {
                    write!(f, "unhandled error ({code})")
                } else {
                    f.write_str("unhandled error")
                }
            }
        }
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for PutFileError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for PutFileError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::BranchNameIsTagNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::BranchNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::CommitMessageLengthExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyDisabledException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileContentRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidBranchNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidDeletionParameterException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidEmailException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidFileModeException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidParentCommitIdException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidPathException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::NameLengthExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ParentCommitDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ParentCommitIdOutdatedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ParentCommitIdRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::PathRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::SameFileContentException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => &_inner.meta,
        }
    }
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for PutFileError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled(crate::error::sealed_unhandled::Unhandled {
            source,
            meta: meta.unwrap_or_default(),
        })
    }
}
impl ::aws_types::request_id::RequestId for crate::operation::put_file::PutFileError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}

pub use crate::operation::put_file::_put_file_output::PutFileOutput;

pub use crate::operation::put_file::_put_file_input::PutFileInput;

mod _put_file_input;

mod _put_file_output;

/// Builders
pub mod builders;
