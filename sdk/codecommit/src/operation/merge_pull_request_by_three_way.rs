// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl MergePullRequestByThreeWayInput {
    /// Consumes the builder and constructs an Operation<[`MergePullRequestByThreeWay`](crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWay)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(
        &self,
        _config: &crate::config::Config,
    ) -> std::result::Result<
        aws_smithy_http::operation::Operation<
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWay,
            aws_http::retry::AwsResponseRetryClassifier,
        >,
        aws_smithy_http::operation::error::BuildError,
    > {
        let params_result = crate::endpoint::Params::builder()
            .set_region(_config.region.as_ref().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(_config.use_dual_stack)
            .set_use_fips(_config.use_fips)
            .set_endpoint(_config.endpoint_url.clone())
            .build()
            .map_err(|err| {
                aws_smithy_http::endpoint::ResolveEndpointError::from_source(
                    "could not construct endpoint parameters",
                    err,
                )
            });
        let (endpoint_result, params) = match params_result {
            Ok(params) => (
                _config.endpoint_resolver.resolve_endpoint(&params),
                Some(params),
            ),
            Err(e) => (Err(e), None),
        };
        let mut request = {
            fn uri_base(
                _input: &crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayInput,
                output: &mut String,
            ) -> std::result::Result<(), aws_smithy_http::operation::error::BuildError>
            {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayInput,
                builder: http::request::Builder,
            ) -> std::result::Result<
                http::request::Builder,
                aws_smithy_http::operation::error::BuildError,
            > {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::CONTENT_TYPE,
                "application/x-amz-json-1.1",
            );
            builder = aws_smithy_http::header::set_request_header_if_absent(
                builder,
                http::header::HeaderName::from_static("x-amz-target"),
                "CodeCommit_20150413.MergePullRequestByThreeWay",
            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_merge_pull_request_by_three_way::ser_merge_pull_request_by_three_way_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
            request = aws_smithy_http::header::set_request_header_if_absent(
                request,
                http::header::CONTENT_LENGTH,
                content_length,
            );
        }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params {
            request.properties_mut().insert(params);
        }
        request
            .properties_mut()
            .insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
            aws_types::os_shim_internal::Env::real(),
            crate::meta::API_METADATA.clone(),
        );
        if let Some(app_name) = _config.app_name() {
            user_agent = user_agent.with_app_name(app_name.clone());
        }
        request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
        request
            .properties_mut()
            .insert(aws_types::SigningService::from_static(
                _config.signing_service(),
            ));
        if let Some(region) = &_config.region {
            request
                .properties_mut()
                .insert(aws_types::region::SigningRegion::from(region.clone()));
        }
        if let Some(region) = &_config.region {
            request.properties_mut().insert(region.clone());
        }
        aws_http::auth::set_credentials_cache(
            &mut request.properties_mut(),
            _config.credentials_cache.clone(),
        );
        let op = aws_smithy_http::operation::Operation::new(
            request,
            crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWay::new(),
        )
        .with_metadata(aws_smithy_http::operation::Metadata::new(
            "MergePullRequestByThreeWay",
            "codecommit",
        ));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `MergePullRequestByThreeWay`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct MergePullRequestByThreeWay;
impl MergePullRequestByThreeWay {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for MergePullRequestByThreeWay {
    type Output = std::result::Result<
        crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayOutput,
        crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError,
    >;
    fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
        tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
        if !response.status().is_success() && response.status().as_u16() != 200 {
            crate::protocol_serde::shape_merge_pull_request_by_three_way::de_merge_pull_request_by_three_way_http_error(response)
        } else {
            crate::protocol_serde::shape_merge_pull_request_by_three_way::de_merge_pull_request_by_three_way_http_response(response)
        }
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type MergePullRequestByThreeWayErrorKind = MergePullRequestByThreeWayError;
/// Error type for the `MergePullRequestByThreeWayError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum MergePullRequestByThreeWayError {
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::types::error::CommitMessageLengthExceededException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::types::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(
        crate::types::error::EncryptionIntegrityChecksFailedException,
    ),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::types::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::types::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::types::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::types::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(
        crate::types::error::FileContentSizeLimitExceededException,
    ),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(
        crate::types::error::FolderContentSizeLimitExceededException,
    ),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::types::error::InvalidCommitIdException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::types::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::types::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(
        crate::types::error::InvalidConflictResolutionStrategyException,
    ),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::types::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::types::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::types::error::InvalidPathException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::types::error::InvalidPullRequestIdException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::types::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::types::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::types::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::types::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(
        crate::types::error::MaximumConflictResolutionEntriesExceededException,
    ),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(
        crate::types::error::MaximumFileContentToLoadExceededException,
    ),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(
        crate::types::error::MaximumItemsToCompareExceededException,
    ),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(
        crate::types::error::MultipleConflictResolutionEntriesException,
    ),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::types::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::types::error::PathRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::types::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(
        crate::types::error::PullRequestApprovalRulesNotSatisfiedException,
    ),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::types::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::types::error::PullRequestIdRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::types::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::types::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::types::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::types::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(
        crate::types::error::RepositoryNotAssociatedWithPullRequestException,
    ),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(
        crate::types::error::TipOfSourceReferenceIsDifferentException,
    ),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::types::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for MergePullRequestByThreeWayError {
    fn create_unhandled_error(
        source: Box<dyn std::error::Error + Send + Sync + 'static>,
        meta: std::option::Option<aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl std::fmt::Display for MergePullRequestByThreeWayError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::ConcurrentReferenceUpdateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementContentException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementTypeException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MultipleConflictResolutionEntriesException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementContentRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementTypeRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => _inner.fmt(f),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for MergePullRequestByThreeWayError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ConcurrentReferenceUpdateException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionIntegrityChecksFailedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyAccessDeniedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyDisabledException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyNotFoundException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::EncryptionKeyUnavailableException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FileContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::FolderContentSizeLimitExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidCommitIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictDetailLevelException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidConflictResolutionStrategyException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidEmailException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidFileModeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPathException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidPullRequestIdException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementContentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidReplacementTypeException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::InvalidRepositoryNameException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ManualMergeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumItemsToCompareExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MultipleConflictResolutionEntriesException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::NameLengthExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PathRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestAlreadyClosedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::PullRequestIdRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementContentRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::ReplacementTypeRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryDoesNotExistException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNameRequiredException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipOfSourceReferenceIsDifferentException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::TipsDivergenceExceededException(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId
    for crate::operation::merge_pull_request_by_three_way::MergePullRequestByThreeWayError
{
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl aws_smithy_types::retry::ProvideErrorKind for MergePullRequestByThreeWayError {
    fn code(&self) -> std::option::Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> std::option::Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl MergePullRequestByThreeWayError {
    /// Creates the `MergePullRequestByThreeWayError::Unhandled` variant from any error type.
    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err)
                .build(),
        )
    }

    /// Creates the `MergePullRequestByThreeWayError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(
            aws_smithy_types::error::Unhandled::builder()
                .source(err.clone())
                .meta(err)
                .build(),
        )
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::ConcurrentReferenceUpdateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidReplacementContentException(e) => e.meta(),
            Self::InvalidReplacementTypeException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::ManualMergeRequiredException(e) => e.meta(),
            Self::MaximumConflictResolutionEntriesExceededException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MultipleConflictResolutionEntriesException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestApprovalRulesNotSatisfiedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::ReplacementContentRequiredException(e) => e.meta(),
            Self::ReplacementTypeRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryNotAssociatedWithPullRequestException(e) => e.meta(),
            Self::TipOfSourceReferenceIsDifferentException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(self, Self::ConcurrentReferenceUpdateException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementContentException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementTypeException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(self, Self::ManualMergeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(
            self,
            Self::MaximumConflictResolutionEntriesExceededException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(self, Self::MultipleConflictResolutionEntriesException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PullRequestApprovalRulesNotSatisfiedException`.
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(self, Self::PullRequestApprovalRulesNotSatisfiedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementTypeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(
            self,
            Self::RepositoryNotAssociatedWithPullRequestException(_)
        )
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::TipOfSourceReferenceIsDifferentException`.
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(self, Self::TipOfSourceReferenceIsDifferentException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestByThreeWayError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl std::error::Error for MergePullRequestByThreeWayError {
    fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => Some(_inner),
            Self::ConcurrentReferenceUpdateException(_inner) => Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => Some(_inner),
            Self::InvalidCommitIdException(_inner) => Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionException(_inner) => Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => Some(_inner),
            Self::InvalidEmailException(_inner) => Some(_inner),
            Self::InvalidFileModeException(_inner) => Some(_inner),
            Self::InvalidPathException(_inner) => Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => Some(_inner),
            Self::InvalidReplacementContentException(_inner) => Some(_inner),
            Self::InvalidReplacementTypeException(_inner) => Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => Some(_inner),
            Self::ManualMergeRequiredException(_inner) => Some(_inner),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => Some(_inner),
            Self::MultipleConflictResolutionEntriesException(_inner) => Some(_inner),
            Self::NameLengthExceededException(_inner) => Some(_inner),
            Self::PathRequiredException(_inner) => Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => Some(_inner),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => Some(_inner),
            Self::ReplacementContentRequiredException(_inner) => Some(_inner),
            Self::ReplacementTypeRequiredException(_inner) => Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => Some(_inner),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => Some(_inner),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => Some(_inner),
            Self::Unhandled(_inner) => Some(_inner),
        }
    }
}

pub use crate::operation::merge_pull_request_by_three_way::_merge_pull_request_by_three_way_output::MergePullRequestByThreeWayOutput;

pub use crate::operation::merge_pull_request_by_three_way::_merge_pull_request_by_three_way_input::MergePullRequestByThreeWayInput;

mod _merge_pull_request_by_three_way_input;

mod _merge_pull_request_by_three_way_output;

/// Builders
pub mod builders;
