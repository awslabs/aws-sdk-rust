// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
use std::fmt::Write;

impl DeleteFileInput {
    /// Consumes the builder and constructs an Operation<[`DeleteFile`](crate::operation::delete_file::DeleteFile)>
    #[allow(unused_mut)]
    #[allow(clippy::let_and_return)]
    #[allow(clippy::needless_borrow)]
    pub async fn make_operation(&self, _config: &crate::config::Config) -> std::result::Result<aws_smithy_http::operation::Operation<crate::operation::delete_file::DeleteFile, aws_http::retry::AwsResponseRetryClassifier>, aws_smithy_http::operation::error::BuildError> {
        let params_result = crate::endpoint::Params::builder().set_region(_config.region.as_ref().map(|r|r.as_ref().to_owned()))
        .set_use_dual_stack(_config.use_dual_stack)
        .set_use_fips(_config.use_fips)
        .set_endpoint(_config.endpoint_url
        .clone()).build()
                                    .map_err(|err|aws_smithy_http::endpoint::ResolveEndpointError::from_source("could not construct endpoint parameters", err));
                                let (endpoint_result, params) = match params_result {
                                    Ok(params) => (_config.endpoint_resolver.resolve_endpoint(&params), Some(params)),
                                    Err(e) => (Err(e), None)
                                };
        let mut request = {
            fn uri_base(_input: &crate::operation::delete_file::DeleteFileInput, output: &mut String) -> Result<(), aws_smithy_http::operation::error::BuildError> {
                write!(output, "/").expect("formatting should succeed");
                Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                            input: &crate::operation::delete_file::DeleteFileInput,
                            builder: http::request::Builder
                        ) -> std::result::Result<http::request::Builder, aws_smithy_http::operation::error::BuildError> {
                let mut uri = String::new();
                uri_base(input, &mut uri)?;
                Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&self, http::request::Builder::new())?;
            builder = aws_smithy_http::header::set_request_header_if_absent(builder, http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = aws_smithy_http::header::set_request_header_if_absent(
                                builder,
                                http::header::HeaderName::from_static("x-amz-target"),
                                "CodeCommit_20150413.DeleteFile"
                            );
            builder
        };
        let mut properties = aws_smithy_http::property_bag::SharedPropertyBag::new();
        #[allow(clippy::useless_conversion)]
        let body = aws_smithy_http::body::SdkBody::from(
            crate::protocol_serde::shape_delete_file::ser_delete_file_input(&self)?
        );
        if let Some(content_length) = body.content_length() {
                                request = aws_smithy_http::header::set_request_header_if_absent(request, http::header::CONTENT_LENGTH, content_length);
                            }
        let request = request.body(body).expect("should be valid request");
        let mut request = aws_smithy_http::operation::Request::from_parts(request, properties);
        request.properties_mut().insert(endpoint_result);
        if let Some(params) = params { request.properties_mut().insert(params); }
        request.properties_mut().insert(aws_smithy_http::http_versions::DEFAULT_HTTP_VERSION_LIST.clone());
        let mut user_agent = aws_http::user_agent::AwsUserAgent::new_from_environment(
                                aws_types::os_shim_internal::Env::real(),
                                crate::meta::API_METADATA.clone(),
                            );
                            if let Some(app_name) = _config.app_name() {
                                user_agent = user_agent.with_app_name(app_name.clone());
                            }
                            request.properties_mut().insert(user_agent);
        let mut signing_config = aws_sig_auth::signer::OperationSigningConfig::default_config();
        request.properties_mut().insert(signing_config);
                            request.properties_mut().insert(aws_types::SigningService::from_static(_config.signing_service()));
                            if let Some(region) = &_config.region {
                                request.properties_mut().insert(aws_types::region::SigningRegion::from(region.clone()));
                            }
        if let Some(region) = &_config.region {
                                request.properties_mut().insert(region.clone());
                            }
        aws_http::auth::set_credentials_cache(&mut request.properties_mut(), _config.credentials_cache.clone());
        let op = aws_smithy_http::operation::Operation::new(request, crate::operation::delete_file::DeleteFile::new())
                            .with_metadata(aws_smithy_http::operation::Metadata::new("DeleteFile", "codecommit"));
        let op = op.with_retry_classifier(aws_http::retry::AwsResponseRetryClassifier::new());
        Ok(op)
    }
}
/// `ParseStrictResponse` impl for `DeleteFile`.
#[derive(std::clone::Clone, std::default::Default, std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct DeleteFile;
impl DeleteFile {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
}
impl aws_smithy_http::response::ParseStrictResponse for DeleteFile {
                type Output = std::result::Result<crate::operation::delete_file::DeleteFileOutput, crate::operation::delete_file::DeleteFileError>;
                fn parse(&self, response: &http::Response<bytes::Bytes>) -> Self::Output {
                     tracing::debug!(request_id = ?aws_http::request_id::RequestId::request_id(response));
                     if !response.status().is_success() && response.status().as_u16() != 200 {
                        crate::protocol_serde::shape_delete_file::de_delete_file_http_error(response)
                     } else {
                        crate::protocol_serde::shape_delete_file::de_delete_file_http_response(response)
                     }
                }
            }

/// Do not use this.
            ///
            /// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
            #[deprecated(note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).")]
            pub type DeleteFileErrorKind = DeleteFileError;
/// Error type for the `DeleteFileError` operation.
#[non_exhaustive]
#[derive(std::fmt::Debug)]
pub enum DeleteFileError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::types::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::types::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::types::error::BranchNameRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::types::error::CommitMessageLengthExceededException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(crate::types::error::EncryptionIntegrityChecksFailedException),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::types::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::types::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::types::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::types::error::EncryptionKeyUnavailableException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::types::error::FileDoesNotExistException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::types::error::InvalidBranchNameException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::types::error::InvalidEmailException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::types::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::types::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note> 
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p> 
    /// </note>
    InvalidRepositoryNameException(crate::types::error::InvalidRepositoryNameException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::types::error::NameLengthExceededException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::types::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::types::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::types::error::ParentCommitIdRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::types::error::PathRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::types::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::types::error::RepositoryNameRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
                    Unhandled(aws_smithy_types::error::Unhandled),
}
impl aws_smithy_http::result::CreateUnhandledError for DeleteFileError {
    
                    fn create_unhandled_error(
                        source: Box<dyn std::error::Error + Send + Sync + 'static>,
                        meta: Option<aws_smithy_types::error::ErrorMetadata>
                    ) -> Self
                     {
        Self::Unhandled({
                                let mut builder = aws_smithy_types::error::Unhandled::builder().source(source);
                                builder.set_meta(meta);
                                builder.build()
                            })
    }
}
impl std::fmt::Display for DeleteFileError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BranchNameIsTagNameException(_inner) =>
            _inner.fmt(f)
            ,
            Self::BranchNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            Self::CommitMessageLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::EncryptionIntegrityChecksFailedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::EncryptionKeyAccessDeniedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::EncryptionKeyDisabledException(_inner) =>
            _inner.fmt(f)
            ,
            Self::EncryptionKeyNotFoundException(_inner) =>
            _inner.fmt(f)
            ,
            Self::EncryptionKeyUnavailableException(_inner) =>
            _inner.fmt(f)
            ,
            Self::FileDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidBranchNameException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidEmailException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidParentCommitIdException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidPathException(_inner) =>
            _inner.fmt(f)
            ,
            Self::InvalidRepositoryNameException(_inner) =>
            _inner.fmt(f)
            ,
            Self::NameLengthExceededException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ParentCommitDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ParentCommitIdOutdatedException(_inner) =>
            _inner.fmt(f)
            ,
            Self::ParentCommitIdRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            Self::PathRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            Self::RepositoryDoesNotExistException(_inner) =>
            _inner.fmt(f)
            ,
            Self::RepositoryNameRequiredException(_inner) =>
            _inner.fmt(f)
            ,
            Self::Unhandled(_inner) => {
                _inner.fmt(f)
            }
        }
    }
}
impl aws_smithy_types::error::metadata::ProvideErrorMetadata for DeleteFileError {
    fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BranchNameIsTagNameException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::BranchNameRequiredException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::CommitMessageLengthExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::EncryptionIntegrityChecksFailedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::EncryptionKeyAccessDeniedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::EncryptionKeyDisabledException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::EncryptionKeyNotFoundException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::EncryptionKeyUnavailableException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::FileDoesNotExistException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidBranchNameException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidEmailException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidParentCommitIdException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidPathException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::InvalidRepositoryNameException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::NameLengthExceededException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ParentCommitDoesNotExistException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ParentCommitIdOutdatedException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::ParentCommitIdRequiredException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::PathRequiredException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::RepositoryDoesNotExistException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::RepositoryNameRequiredException(_inner) =>
            aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            ,
            Self::Unhandled(_inner) => {
                aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
        }
    }
}
impl aws_http::request_id::RequestId for crate::operation::delete_file::DeleteFileError {
                            fn request_id(&self) -> Option<&str> {
                                self.meta().request_id()
                            }
                        }
impl aws_smithy_types::retry::ProvideErrorKind for DeleteFileError {
    fn code(&self) -> Option<&str> {
        aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> Option<aws_smithy_types::retry::ErrorKind> {
        None
    }
}
impl DeleteFileError {
    /// Creates the `DeleteFileError::Unhandled` variant from any error type.
                    pub fn unhandled(err: impl Into<Box<dyn std::error::Error + Send + Sync + 'static>>) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err).build())
                    }
    
                    /// Creates the `DeleteFileError::Unhandled` variant from a `aws_smithy_types::error::ErrorMetadata`.
                    pub fn generic(err: aws_smithy_types::error::ErrorMetadata) -> Self {
                        Self::Unhandled(aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
                    }
    /// 
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    /// 
    pub fn meta(&self) -> &aws_smithy_types::error::ErrorMetadata {
        use aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameIsTagNameException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileDoesNotExistException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidParentCommitIdException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::ParentCommitDoesNotExistException(e) => e.meta(),
            Self::ParentCommitIdOutdatedException(e) => e.meta(),
            Self::ParentCommitIdRequiredException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `DeleteFileError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(self, Self::BranchNameIsTagNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::FileDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidParentCommitIdException`.
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidParentCommitIdException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::ParentCommitDoesNotExistException`.
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ParentCommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::ParentCommitIdOutdatedException`.
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdOutdatedException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::ParentCommitIdRequiredException`.
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `DeleteFileError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
}
impl std::error::Error for DeleteFileError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            Self::BranchNameIsTagNameException(_inner) =>
            Some(_inner)
            ,
            Self::BranchNameRequiredException(_inner) =>
            Some(_inner)
            ,
            Self::CommitMessageLengthExceededException(_inner) =>
            Some(_inner)
            ,
            Self::EncryptionIntegrityChecksFailedException(_inner) =>
            Some(_inner)
            ,
            Self::EncryptionKeyAccessDeniedException(_inner) =>
            Some(_inner)
            ,
            Self::EncryptionKeyDisabledException(_inner) =>
            Some(_inner)
            ,
            Self::EncryptionKeyNotFoundException(_inner) =>
            Some(_inner)
            ,
            Self::EncryptionKeyUnavailableException(_inner) =>
            Some(_inner)
            ,
            Self::FileDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidBranchNameException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidEmailException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidParentCommitIdException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidPathException(_inner) =>
            Some(_inner)
            ,
            Self::InvalidRepositoryNameException(_inner) =>
            Some(_inner)
            ,
            Self::NameLengthExceededException(_inner) =>
            Some(_inner)
            ,
            Self::ParentCommitDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            Self::ParentCommitIdOutdatedException(_inner) =>
            Some(_inner)
            ,
            Self::ParentCommitIdRequiredException(_inner) =>
            Some(_inner)
            ,
            Self::PathRequiredException(_inner) =>
            Some(_inner)
            ,
            Self::RepositoryDoesNotExistException(_inner) =>
            Some(_inner)
            ,
            Self::RepositoryNameRequiredException(_inner) =>
            Some(_inner)
            ,
            Self::Unhandled(_inner) => {
                Some(_inner)
            }
        }
    }
}

pub use crate::operation::delete_file::_delete_file_output::DeleteFileOutput;

pub use crate::operation::delete_file::_delete_file_input::DeleteFileInput;

mod _delete_file_input;

mod _delete_file_output;

/// Builders
pub mod builders;

