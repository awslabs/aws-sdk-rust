// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `MergePullRequestBySquash`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct MergePullRequestBySquash;
impl MergePullRequestBySquash {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashInput,
    ) -> ::std::result::Result<
        crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >| {
            err.map_service_error(|err| {
                err.downcast::<crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError>()
                    .expect("correct error type")
            })
        };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point(
            "codecommit",
            "MergePullRequestBySquash",
            input,
            runtime_plugins,
            stop_point,
        )
        .await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
        runtime_plugins = runtime_plugins.with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![
            ::aws_runtime::auth::sigv4::SCHEME_ID,
        ]));
        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for MergePullRequestBySquash {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("MergePullRequestBySquash");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            MergePullRequestBySquashRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            MergePullRequestBySquashResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            ::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new(),
        ));

        cfg.store_put(::aws_smithy_http::operation::Metadata::new("MergePullRequestBySquash", "codecommit"));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        ::std::borrow::Cow::Owned(
            ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("MergePullRequestBySquash")
                .with_interceptor(MergePullRequestBySquashEndpointParamsInterceptor)
                .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                    crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError,
                >::new())
                .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                    crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError,
                >::new())
                .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                    crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError,
                >::new()),
        )
    }
}

#[derive(Debug)]
struct MergePullRequestBySquashResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for MergePullRequestBySquashResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_http::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_merge_pull_request_by_squash::de_merge_pull_request_by_squash_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_merge_pull_request_by_squash::de_merge_pull_request_by_squash_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct MergePullRequestBySquashRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for MergePullRequestBySquashRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input
            .downcast::<crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashInput>()
            .expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            fn uri_base(
                _input: &crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = _header_serialization_settings.set_default_header(
                builder,
                ::http::header::HeaderName::from_static("x-amz-target"),
                "CodeCommit_20150413.MergePullRequestBySquash",
            );
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(
            crate::protocol_serde::shape_merge_pull_request_by_squash::ser_merge_pull_request_by_squash_input(&input)?,
        );
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct MergePullRequestBySquashEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for MergePullRequestBySquashEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "MergePullRequestBySquashEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<MergePullRequestBySquashInput>()
            .ok_or("failed to downcast to MergePullRequestBySquashInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type MergePullRequestBySquashErrorKind = MergePullRequestBySquashError;
/// Error type for the `MergePullRequestBySquashError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum MergePullRequestBySquashError {
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::types::error::CommitMessageLengthExceededException),
    /// <p>The merge cannot be completed because the target branch has been modified. Another user might have modified the target branch while the merge was in progress. Wait a few minutes, and then try again.</p>
    ConcurrentReferenceUpdateException(crate::types::error::ConcurrentReferenceUpdateException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(crate::types::error::EncryptionIntegrityChecksFailedException),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::types::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::types::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::types::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::types::error::EncryptionKeyUnavailableException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::types::error::FileContentSizeLimitExceededException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::types::error::FolderContentSizeLimitExceededException),
    /// <p>The specified commit ID is not valid.</p>
    InvalidCommitIdException(crate::types::error::InvalidCommitIdException),
    /// <p>The specified conflict detail level is not valid.</p>
    InvalidConflictDetailLevelException(crate::types::error::InvalidConflictDetailLevelException),
    /// <p>The specified conflict resolution list is not valid.</p>
    InvalidConflictResolutionException(crate::types::error::InvalidConflictResolutionException),
    /// <p>The specified conflict resolution strategy is not valid.</p>
    InvalidConflictResolutionStrategyException(crate::types::error::InvalidConflictResolutionStrategyException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::types::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::types::error::InvalidFileModeException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::types::error::InvalidPathException),
    /// <p>The pull request ID is not valid. Make sure that you have provided the full ID and that the pull request is in the specified repository, and then try again.</p>
    InvalidPullRequestIdException(crate::types::error::InvalidPullRequestIdException),
    /// <p>Automerge was specified for resolving the conflict, but the replacement type is not valid or content is missing. </p>
    InvalidReplacementContentException(crate::types::error::InvalidReplacementContentException),
    /// <p>Automerge was specified for resolving the conflict, but the specified replacement type is not valid.</p>
    InvalidReplacementTypeException(crate::types::error::InvalidReplacementTypeException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::types::error::InvalidRepositoryNameException),
    /// <p>The pull request cannot be merged automatically into the destination branch. You must manually merge the branches and resolve any conflicts.</p>
    ManualMergeRequiredException(crate::types::error::ManualMergeRequiredException),
    /// <p>The number of allowed conflict resolution entries was exceeded.</p>
    MaximumConflictResolutionEntriesExceededException(crate::types::error::MaximumConflictResolutionEntriesExceededException),
    /// <p>The number of files to load exceeds the allowed limit.</p>
    MaximumFileContentToLoadExceededException(crate::types::error::MaximumFileContentToLoadExceededException),
    /// <p>The number of items to compare between the source or destination branches and the merge base has exceeded the maximum allowed.</p>
    MaximumItemsToCompareExceededException(crate::types::error::MaximumItemsToCompareExceededException),
    /// <p>More than one conflict resolution entries exists for the conflict. A conflict can have only one conflict resolution entry.</p>
    MultipleConflictResolutionEntriesException(crate::types::error::MultipleConflictResolutionEntriesException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::types::error::NameLengthExceededException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::types::error::PathRequiredException),
    /// <p>The pull request status cannot be updated because it is already closed.</p>
    PullRequestAlreadyClosedException(crate::types::error::PullRequestAlreadyClosedException),
    /// <p>The pull request cannot be merged because one or more approval rules applied to the pull request have conditions that have not been met.</p>
    PullRequestApprovalRulesNotSatisfiedException(crate::types::error::PullRequestApprovalRulesNotSatisfiedException),
    /// <p>The pull request ID could not be found. Make sure that you have specified the correct repository name and pull request ID, and then try again.</p>
    PullRequestDoesNotExistException(crate::types::error::PullRequestDoesNotExistException),
    /// <p>A pull request ID is required, but none was provided.</p>
    PullRequestIdRequiredException(crate::types::error::PullRequestIdRequiredException),
    /// <p>USE_NEW_CONTENT was specified, but no replacement content has been provided.</p>
    ReplacementContentRequiredException(crate::types::error::ReplacementContentRequiredException),
    /// <p>A replacement type is required.</p>
    ReplacementTypeRequiredException(crate::types::error::ReplacementTypeRequiredException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::types::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::types::error::RepositoryNameRequiredException),
    /// <p>The repository does not contain any pull requests with that pull request ID. Use GetPullRequest to verify the correct repository name for the pull request ID.</p>
    RepositoryNotAssociatedWithPullRequestException(crate::types::error::RepositoryNotAssociatedWithPullRequestException),
    /// <p>The tip of the source branch in the destination repository does not match the tip of the source branch specified in your request. The pull request might have been updated. Make sure that you have the latest changes.</p>
    TipOfSourceReferenceIsDifferentException(crate::types::error::TipOfSourceReferenceIsDifferentException),
    /// <p>The divergence between the tips of the provided commit specifiers is too great to determine whether there might be any merge conflicts. Locally compare the specifiers using <code>git diff</code> or a diff tool.</p>
    TipsDivergenceExceededException(crate::types::error::TipsDivergenceExceededException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(::aws_smithy_types::error::Unhandled),
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for MergePullRequestBySquashError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = ::aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl ::std::fmt::Display for MergePullRequestBySquashError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::ConcurrentReferenceUpdateException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidConflictDetailLevelException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionException(_inner) => _inner.fmt(f),
            Self::InvalidConflictResolutionStrategyException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidPullRequestIdException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementContentException(_inner) => _inner.fmt(f),
            Self::InvalidReplacementTypeException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::ManualMergeRequiredException(_inner) => _inner.fmt(f),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => _inner.fmt(f),
            Self::MaximumFileContentToLoadExceededException(_inner) => _inner.fmt(f),
            Self::MaximumItemsToCompareExceededException(_inner) => _inner.fmt(f),
            Self::MultipleConflictResolutionEntriesException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::PullRequestAlreadyClosedException(_inner) => _inner.fmt(f),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => _inner.fmt(f),
            Self::PullRequestDoesNotExistException(_inner) => _inner.fmt(f),
            Self::PullRequestIdRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementContentRequiredException(_inner) => _inner.fmt(f),
            Self::ReplacementTypeRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => _inner.fmt(f),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => _inner.fmt(f),
            Self::TipsDivergenceExceededException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for MergePullRequestBySquashError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ConcurrentReferenceUpdateException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyDisabledException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidCommitIdException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidConflictResolutionException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidEmailException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidFileModeException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidPathException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidPullRequestIdException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidReplacementContentException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidReplacementTypeException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ManualMergeRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => {
                ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner)
            }
            Self::MaximumFileContentToLoadExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::MultipleConflictResolutionEntriesException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::NameLengthExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::PathRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::PullRequestDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::PullRequestIdRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ReplacementContentRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ReplacementTypeRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::TipsDivergenceExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
        }
    }
}
impl ::aws_http::request_id::RequestId for crate::operation::merge_pull_request_by_squash::MergePullRequestBySquashError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for MergePullRequestBySquashError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl MergePullRequestBySquashError {
    /// Creates the `MergePullRequestBySquashError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(::aws_smithy_types::error::Unhandled::builder().source(err).build())
    }

    /// Creates the `MergePullRequestBySquashError::Unhandled` variant from a `::aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(::aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        use ::aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::ConcurrentReferenceUpdateException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidCommitIdException(e) => e.meta(),
            Self::InvalidConflictDetailLevelException(e) => e.meta(),
            Self::InvalidConflictResolutionException(e) => e.meta(),
            Self::InvalidConflictResolutionStrategyException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidPullRequestIdException(e) => e.meta(),
            Self::InvalidReplacementContentException(e) => e.meta(),
            Self::InvalidReplacementTypeException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::ManualMergeRequiredException(e) => e.meta(),
            Self::MaximumConflictResolutionEntriesExceededException(e) => e.meta(),
            Self::MaximumFileContentToLoadExceededException(e) => e.meta(),
            Self::MaximumItemsToCompareExceededException(e) => e.meta(),
            Self::MultipleConflictResolutionEntriesException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::PullRequestAlreadyClosedException(e) => e.meta(),
            Self::PullRequestApprovalRulesNotSatisfiedException(e) => e.meta(),
            Self::PullRequestDoesNotExistException(e) => e.meta(),
            Self::PullRequestIdRequiredException(e) => e.meta(),
            Self::ReplacementContentRequiredException(e) => e.meta(),
            Self::ReplacementTypeRequiredException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RepositoryNotAssociatedWithPullRequestException(e) => e.meta(),
            Self::TipOfSourceReferenceIsDifferentException(e) => e.meta(),
            Self::TipsDivergenceExceededException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::ConcurrentReferenceUpdateException`.
    pub fn is_concurrent_reference_update_exception(&self) -> bool {
        matches!(self, Self::ConcurrentReferenceUpdateException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidCommitIdException`.
    pub fn is_invalid_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidCommitIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidConflictDetailLevelException`.
    pub fn is_invalid_conflict_detail_level_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictDetailLevelException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidConflictResolutionException`.
    pub fn is_invalid_conflict_resolution_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidConflictResolutionStrategyException`.
    pub fn is_invalid_conflict_resolution_strategy_exception(&self) -> bool {
        matches!(self, Self::InvalidConflictResolutionStrategyException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidPullRequestIdException`.
    pub fn is_invalid_pull_request_id_exception(&self) -> bool {
        matches!(self, Self::InvalidPullRequestIdException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidReplacementContentException`.
    pub fn is_invalid_replacement_content_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementContentException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidReplacementTypeException`.
    pub fn is_invalid_replacement_type_exception(&self) -> bool {
        matches!(self, Self::InvalidReplacementTypeException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::ManualMergeRequiredException`.
    pub fn is_manual_merge_required_exception(&self) -> bool {
        matches!(self, Self::ManualMergeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::MaximumConflictResolutionEntriesExceededException`.
    pub fn is_maximum_conflict_resolution_entries_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumConflictResolutionEntriesExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::MaximumFileContentToLoadExceededException`.
    pub fn is_maximum_file_content_to_load_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileContentToLoadExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::MaximumItemsToCompareExceededException`.
    pub fn is_maximum_items_to_compare_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumItemsToCompareExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::MultipleConflictResolutionEntriesException`.
    pub fn is_multiple_conflict_resolution_entries_exception(&self) -> bool {
        matches!(self, Self::MultipleConflictResolutionEntriesException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PullRequestAlreadyClosedException`.
    pub fn is_pull_request_already_closed_exception(&self) -> bool {
        matches!(self, Self::PullRequestAlreadyClosedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PullRequestApprovalRulesNotSatisfiedException`.
    pub fn is_pull_request_approval_rules_not_satisfied_exception(&self) -> bool {
        matches!(self, Self::PullRequestApprovalRulesNotSatisfiedException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PullRequestDoesNotExistException`.
    pub fn is_pull_request_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::PullRequestDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::PullRequestIdRequiredException`.
    pub fn is_pull_request_id_required_exception(&self) -> bool {
        matches!(self, Self::PullRequestIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::ReplacementContentRequiredException`.
    pub fn is_replacement_content_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementContentRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::ReplacementTypeRequiredException`.
    pub fn is_replacement_type_required_exception(&self) -> bool {
        matches!(self, Self::ReplacementTypeRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::RepositoryNotAssociatedWithPullRequestException`.
    pub fn is_repository_not_associated_with_pull_request_exception(&self) -> bool {
        matches!(self, Self::RepositoryNotAssociatedWithPullRequestException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::TipOfSourceReferenceIsDifferentException`.
    pub fn is_tip_of_source_reference_is_different_exception(&self) -> bool {
        matches!(self, Self::TipOfSourceReferenceIsDifferentException(_))
    }
    /// Returns `true` if the error kind is `MergePullRequestBySquashError::TipsDivergenceExceededException`.
    pub fn is_tips_divergence_exceeded_exception(&self) -> bool {
        matches!(self, Self::TipsDivergenceExceededException(_))
    }
}
impl ::std::error::Error for MergePullRequestBySquashError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::CommitMessageLengthExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::ConcurrentReferenceUpdateException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidCommitIdException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidConflictDetailLevelException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidConflictResolutionException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidConflictResolutionStrategyException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidEmailException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidFileModeException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidPathException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidPullRequestIdException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidReplacementContentException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidReplacementTypeException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::ManualMergeRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::MaximumConflictResolutionEntriesExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::MaximumFileContentToLoadExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::MaximumItemsToCompareExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::MultipleConflictResolutionEntriesException(_inner) => ::std::option::Option::Some(_inner),
            Self::NameLengthExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::PathRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::PullRequestAlreadyClosedException(_inner) => ::std::option::Option::Some(_inner),
            Self::PullRequestApprovalRulesNotSatisfiedException(_inner) => ::std::option::Option::Some(_inner),
            Self::PullRequestDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::PullRequestIdRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::ReplacementContentRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::ReplacementTypeRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryNotAssociatedWithPullRequestException(_inner) => ::std::option::Option::Some(_inner),
            Self::TipOfSourceReferenceIsDifferentException(_inner) => ::std::option::Option::Some(_inner),
            Self::TipsDivergenceExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(_inner),
        }
    }
}

pub use crate::operation::merge_pull_request_by_squash::_merge_pull_request_by_squash_output::MergePullRequestBySquashOutput;

pub use crate::operation::merge_pull_request_by_squash::_merge_pull_request_by_squash_input::MergePullRequestBySquashInput;

mod _merge_pull_request_by_squash_input;

mod _merge_pull_request_by_squash_output;

/// Builders
pub mod builders;
