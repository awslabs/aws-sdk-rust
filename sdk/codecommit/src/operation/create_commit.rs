// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.
/// Orchestration and serialization glue logic for `CreateCommit`.
#[derive(::std::clone::Clone, ::std::default::Default, ::std::fmt::Debug)]
#[non_exhaustive]
#[doc(hidden)]
pub struct CreateCommit;
impl CreateCommit {
    #[doc(hidden)]
    pub fn new() -> Self {
        Self
    }
    pub(crate) async fn orchestrate(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_commit::CreateCommitInput,
    ) -> ::std::result::Result<
        crate::operation::create_commit::CreateCommitOutput,
        ::aws_smithy_runtime_api::client::result::SdkError<
            crate::operation::create_commit::CreateCommitError,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let map_err = |err: ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >| {
            err.map_service_error(|err| {
                err.downcast::<crate::operation::create_commit::CreateCommitError>()
                    .expect("correct error type")
            })
        };
        let context = Self::orchestrate_with_stop_point(runtime_plugins, input, ::aws_smithy_runtime::client::orchestrator::StopPoint::None)
            .await
            .map_err(map_err)?;
        let output = context.finalize().map_err(map_err)?;
        ::std::result::Result::Ok(
            output
                .downcast::<crate::operation::create_commit::CreateCommitOutput>()
                .expect("correct output type"),
        )
    }

    pub(crate) async fn orchestrate_with_stop_point(
        runtime_plugins: &::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        input: crate::operation::create_commit::CreateCommitInput,
        stop_point: ::aws_smithy_runtime::client::orchestrator::StopPoint,
    ) -> ::std::result::Result<
        ::aws_smithy_runtime_api::client::interceptors::context::InterceptorContext,
        ::aws_smithy_runtime_api::client::result::SdkError<
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
            ::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
        >,
    > {
        let input = ::aws_smithy_runtime_api::client::interceptors::context::Input::erase(input);
        ::aws_smithy_runtime::client::orchestrator::invoke_with_stop_point("codecommit", "CreateCommit", input, runtime_plugins, stop_point).await
    }

    pub(crate) fn operation_runtime_plugins(
        client_runtime_plugins: ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins,
        client_config: &crate::config::Config,
        config_override: ::std::option::Option<crate::config::Builder>,
    ) -> ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugins {
        let mut runtime_plugins = client_runtime_plugins.with_operation_plugin(Self::new());
        runtime_plugins = runtime_plugins.with_client_plugin(crate::auth_plugin::DefaultAuthOptionsPlugin::new(vec![
            ::aws_runtime::auth::sigv4::SCHEME_ID,
        ]));
        if let ::std::option::Option::Some(config_override) = config_override {
            for plugin in config_override.runtime_plugins.iter().cloned() {
                runtime_plugins = runtime_plugins.with_operation_plugin(plugin);
            }
            runtime_plugins = runtime_plugins.with_operation_plugin(crate::config::ConfigOverrideRuntimePlugin::new(
                config_override,
                client_config.config.clone(),
                &client_config.runtime_components,
            ));
        }
        runtime_plugins
    }
}
impl ::aws_smithy_runtime_api::client::runtime_plugin::RuntimePlugin for CreateCommit {
    fn config(&self) -> ::std::option::Option<::aws_smithy_types::config_bag::FrozenLayer> {
        let mut cfg = ::aws_smithy_types::config_bag::Layer::new("CreateCommit");

        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedRequestSerializer::new(
            CreateCommitRequestSerializer,
        ));
        cfg.store_put(::aws_smithy_runtime_api::client::ser_de::SharedResponseDeserializer::new(
            CreateCommitResponseDeserializer,
        ));

        cfg.store_put(::aws_smithy_runtime_api::client::auth::AuthSchemeOptionResolverParams::new(
            ::aws_smithy_runtime_api::client::auth::static_resolver::StaticAuthSchemeOptionResolverParams::new(),
        ));

        cfg.store_put(::aws_smithy_http::operation::Metadata::new("CreateCommit", "codecommit"));
        let mut signing_options = ::aws_runtime::auth::SigningOptions::default();
        signing_options.double_uri_encode = true;
        signing_options.content_sha256_header = false;
        signing_options.normalize_uri_path = true;
        signing_options.payload_override = None;

        cfg.store_put(::aws_runtime::auth::SigV4OperationSigningConfig {
            signing_options,
            ..::std::default::Default::default()
        });

        ::std::option::Option::Some(cfg.freeze())
    }

    fn runtime_components(
        &self,
        _: &::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder,
    ) -> ::std::borrow::Cow<'_, ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder> {
        ::std::borrow::Cow::Owned(
            ::aws_smithy_runtime_api::client::runtime_components::RuntimeComponentsBuilder::new("CreateCommit")
                .with_interceptor(CreateCommitEndpointParamsInterceptor)
                .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::TransientErrorClassifier::<
                    crate::operation::create_commit::CreateCommitError,
                >::new())
                .with_retry_classifier(::aws_smithy_runtime::client::retries::classifiers::ModeledAsRetryableClassifier::<
                    crate::operation::create_commit::CreateCommitError,
                >::new())
                .with_retry_classifier(::aws_runtime::retries::classifiers::AwsErrorCodeClassifier::<
                    crate::operation::create_commit::CreateCommitError,
                >::new()),
        )
    }
}

#[derive(Debug)]
struct CreateCommitResponseDeserializer;
impl ::aws_smithy_runtime_api::client::ser_de::DeserializeResponse for CreateCommitResponseDeserializer {
    fn deserialize_nonstreaming(
        &self,
        response: &::aws_smithy_runtime_api::client::orchestrator::HttpResponse,
    ) -> ::aws_smithy_runtime_api::client::interceptors::context::OutputOrError {
        let (success, status) = (response.status().is_success(), response.status().as_u16());
        let headers = response.headers();
        let body = response.body().bytes().expect("body loaded");
        #[allow(unused_mut)]
        let mut force_error = false;
        ::tracing::debug!(request_id = ?::aws_http::request_id::RequestId::request_id(response));
        let parse_result = if !success && status != 200 || force_error {
            crate::protocol_serde::shape_create_commit::de_create_commit_http_error(status, headers, body)
        } else {
            crate::protocol_serde::shape_create_commit::de_create_commit_http_response(status, headers, body)
        };
        crate::protocol_serde::type_erase_result(parse_result)
    }
}
#[derive(Debug)]
struct CreateCommitRequestSerializer;
impl ::aws_smithy_runtime_api::client::ser_de::SerializeRequest for CreateCommitRequestSerializer {
    #[allow(unused_mut, clippy::let_and_return, clippy::needless_borrow, clippy::useless_conversion)]
    fn serialize_input(
        &self,
        input: ::aws_smithy_runtime_api::client::interceptors::context::Input,
        _cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<::aws_smithy_runtime_api::client::orchestrator::HttpRequest, ::aws_smithy_runtime_api::box_error::BoxError> {
        let input = input
            .downcast::<crate::operation::create_commit::CreateCommitInput>()
            .expect("correct type");
        let _header_serialization_settings = _cfg
            .load::<crate::serialization_settings::HeaderSerializationSettings>()
            .cloned()
            .unwrap_or_default();
        let mut request_builder = {
            fn uri_base(
                _input: &crate::operation::create_commit::CreateCommitInput,
                output: &mut ::std::string::String,
            ) -> ::std::result::Result<(), ::aws_smithy_types::error::operation::BuildError> {
                use ::std::fmt::Write as _;
                ::std::write!(output, "/").expect("formatting should succeed");
                ::std::result::Result::Ok(())
            }
            #[allow(clippy::unnecessary_wraps)]
            fn update_http_builder(
                input: &crate::operation::create_commit::CreateCommitInput,
                builder: ::http::request::Builder,
            ) -> ::std::result::Result<::http::request::Builder, ::aws_smithy_types::error::operation::BuildError> {
                let mut uri = ::std::string::String::new();
                uri_base(input, &mut uri)?;
                ::std::result::Result::Ok(builder.method("POST").uri(uri))
            }
            let mut builder = update_http_builder(&input, ::http::request::Builder::new())?;
            builder = _header_serialization_settings.set_default_header(builder, ::http::header::CONTENT_TYPE, "application/x-amz-json-1.1");
            builder = _header_serialization_settings.set_default_header(
                builder,
                ::http::header::HeaderName::from_static("x-amz-target"),
                "CodeCommit_20150413.CreateCommit",
            );
            builder
        };
        let body = ::aws_smithy_types::body::SdkBody::from(crate::protocol_serde::shape_create_commit::ser_create_commit_input(&input)?);
        if let Some(content_length) = body.content_length() {
            let content_length = content_length.to_string();
            request_builder = _header_serialization_settings.set_default_header(request_builder, ::http::header::CONTENT_LENGTH, &content_length);
        }
        ::std::result::Result::Ok(request_builder.body(body).expect("valid request").try_into().unwrap())
    }
}
#[derive(Debug)]
struct CreateCommitEndpointParamsInterceptor;

impl ::aws_smithy_runtime_api::client::interceptors::Intercept for CreateCommitEndpointParamsInterceptor {
    fn name(&self) -> &'static str {
        "CreateCommitEndpointParamsInterceptor"
    }

    fn read_before_execution(
        &self,
        context: &::aws_smithy_runtime_api::client::interceptors::context::BeforeSerializationInterceptorContextRef<
            '_,
            ::aws_smithy_runtime_api::client::interceptors::context::Input,
            ::aws_smithy_runtime_api::client::interceptors::context::Output,
            ::aws_smithy_runtime_api::client::interceptors::context::Error,
        >,
        cfg: &mut ::aws_smithy_types::config_bag::ConfigBag,
    ) -> ::std::result::Result<(), ::aws_smithy_runtime_api::box_error::BoxError> {
        let _input = context
            .input()
            .downcast_ref::<CreateCommitInput>()
            .ok_or("failed to downcast to CreateCommitInput")?;

        let params = crate::config::endpoint::Params::builder()
            .set_region(cfg.load::<::aws_types::region::Region>().map(|r| r.as_ref().to_owned()))
            .set_use_dual_stack(cfg.load::<::aws_types::endpoint_config::UseDualStack>().map(|ty| ty.0))
            .set_use_fips(cfg.load::<::aws_types::endpoint_config::UseFips>().map(|ty| ty.0))
            .set_endpoint(cfg.load::<::aws_types::endpoint_config::EndpointUrl>().map(|ty| ty.0.clone()))
            .build()
            .map_err(|err| {
                ::aws_smithy_runtime_api::client::interceptors::error::ContextAttachedError::new("endpoint params could not be built", err)
            })?;
        cfg.interceptor_state()
            .store_put(::aws_smithy_runtime_api::client::endpoint::EndpointResolverParams::new(params));
        ::std::result::Result::Ok(())
    }
}

/// Do not use this.
///
/// Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now).
#[deprecated(
    note = "Operation `*Error/*ErrorKind` types were combined into a single `*Error` enum. The `.kind` field on `*Error` no longer exists and isn't needed anymore (you can just match on the error directly since it's an enum now)."
)]
pub type CreateCommitErrorKind = CreateCommitError;
/// Error type for the `CreateCommitError` operation.
#[non_exhaustive]
#[derive(::std::fmt::Debug)]
pub enum CreateCommitError {
    /// <p>The specified branch does not exist.</p>
    BranchDoesNotExistException(crate::types::error::BranchDoesNotExistException),
    /// <p>The specified branch name is not valid because it is a tag name. Enter the name of a branch in the repository. For a list of valid branch names, use <code>ListBranches</code>.</p>
    BranchNameIsTagNameException(crate::types::error::BranchNameIsTagNameException),
    /// <p>A branch name is required, but was not specified.</p>
    BranchNameRequiredException(crate::types::error::BranchNameRequiredException),
    /// <p>The commit message is too long. Provide a shorter string. </p>
    CommitMessageLengthExceededException(crate::types::error::CommitMessageLengthExceededException),
    /// <p>A file cannot be added to the repository because the specified path name has the same name as a file that already exists in this repository. Either provide a different name for the file, or specify a different path for the file.</p>
    DirectoryNameConflictsWithFileNameException(crate::types::error::DirectoryNameConflictsWithFileNameException),
    /// <p>An encryption integrity check failed.</p>
    EncryptionIntegrityChecksFailedException(crate::types::error::EncryptionIntegrityChecksFailedException),
    /// <p>An encryption key could not be accessed.</p>
    EncryptionKeyAccessDeniedException(crate::types::error::EncryptionKeyAccessDeniedException),
    /// <p>The encryption key is disabled.</p>
    EncryptionKeyDisabledException(crate::types::error::EncryptionKeyDisabledException),
    /// <p>No encryption key was found.</p>
    EncryptionKeyNotFoundException(crate::types::error::EncryptionKeyNotFoundException),
    /// <p>The encryption key is not available.</p>
    EncryptionKeyUnavailableException(crate::types::error::EncryptionKeyUnavailableException),
    /// <p>The commit cannot be created because both a source file and file content have been specified for the same file. You cannot provide both. Either specify a source file or provide the file content directly.</p>
    FileContentAndSourceFileSpecifiedException(crate::types::error::FileContentAndSourceFileSpecifiedException),
    /// <p>The file cannot be added because it is too large. The maximum file size is 6 MB, and the combined file content change size is 7 MB. Consider making these changes using a Git client.</p>
    FileContentSizeLimitExceededException(crate::types::error::FileContentSizeLimitExceededException),
    /// <p>The specified file does not exist. Verify that you have used the correct file name, full path, and extension.</p>
    FileDoesNotExistException(crate::types::error::FileDoesNotExistException),
    /// <p>The commit cannot be created because no files have been specified as added, updated, or changed (PutFile or DeleteFile) for the commit.</p>
    FileEntryRequiredException(crate::types::error::FileEntryRequiredException),
    /// <p>The commit cannot be created because no file mode has been specified. A file mode is required to update mode permissions for a file.</p>
    FileModeRequiredException(crate::types::error::FileModeRequiredException),
    /// <p>A file cannot be added to the repository because the specified file name has the same name as a directory in this repository. Either provide another name for the file, or add the file in a directory that does not match the file name.</p>
    FileNameConflictsWithDirectoryNameException(crate::types::error::FileNameConflictsWithDirectoryNameException),
    /// <p>The commit cannot be created because a specified file path points to a submodule. Verify that the destination files have valid file paths that do not point to a submodule.</p>
    FilePathConflictsWithSubmodulePathException(crate::types::error::FilePathConflictsWithSubmodulePathException),
    /// <p>The commit cannot be created because at least one of the overall changes in the commit results in a folder whose contents exceed the limit of 6 MB. Either reduce the number and size of your changes, or split the changes across multiple folders.</p>
    FolderContentSizeLimitExceededException(crate::types::error::FolderContentSizeLimitExceededException),
    /// <p>The specified reference name is not valid.</p>
    InvalidBranchNameException(crate::types::error::InvalidBranchNameException),
    /// <p>The specified deletion parameter is not valid.</p>
    InvalidDeletionParameterException(crate::types::error::InvalidDeletionParameterException),
    /// <p>The specified email address either contains one or more characters that are not allowed, or it exceeds the maximum number of characters allowed for an email address.</p>
    InvalidEmailException(crate::types::error::InvalidEmailException),
    /// <p>The specified file mode permission is not valid. For a list of valid file mode permissions, see <code>PutFile</code>. </p>
    InvalidFileModeException(crate::types::error::InvalidFileModeException),
    /// <p>The parent commit ID is not valid. The commit ID cannot be empty, and must match the head commit ID for the branch of the repository where you want to add or update a file.</p>
    InvalidParentCommitIdException(crate::types::error::InvalidParentCommitIdException),
    /// <p>The specified path is not valid.</p>
    InvalidPathException(crate::types::error::InvalidPathException),
    /// <p>A specified repository name is not valid.</p> <note>
    /// <p>This exception occurs only when a specified repository name is not valid. Other exceptions occur when a required repository parameter is missing, or when a specified repository does not exist.</p>
    /// </note>
    InvalidRepositoryNameException(crate::types::error::InvalidRepositoryNameException),
    /// <p>The number of specified files to change as part of this commit exceeds the maximum number of files that can be changed in a single commit. Consider using a Git client for these changes.</p>
    MaximumFileEntriesExceededException(crate::types::error::MaximumFileEntriesExceededException),
    /// <p>The user name is not valid because it has exceeded the character limit for author names. </p>
    NameLengthExceededException(crate::types::error::NameLengthExceededException),
    /// <p>The commit cannot be created because no changes will be made to the repository as a result of this commit. A commit must contain at least one change.</p>
    NoChangeException(crate::types::error::NoChangeException),
    /// <p>The parent commit ID is not valid because it does not exist. The specified parent commit ID does not exist in the specified branch of the repository.</p>
    ParentCommitDoesNotExistException(crate::types::error::ParentCommitDoesNotExistException),
    /// <p>The file could not be added because the provided parent commit ID is not the current tip of the specified branch. To view the full commit ID of the current head of the branch, use <code>GetBranch</code>.</p>
    ParentCommitIdOutdatedException(crate::types::error::ParentCommitIdOutdatedException),
    /// <p>A parent commit ID is required. To view the full commit ID of a branch in a repository, use <code>GetBranch</code> or a Git command (for example, git pull or git log).</p>
    ParentCommitIdRequiredException(crate::types::error::ParentCommitIdRequiredException),
    /// <p>The folderPath for a location cannot be null.</p>
    PathRequiredException(crate::types::error::PathRequiredException),
    /// <p>The commit cannot be created because one or more files specified in the commit reference both a file and a folder.</p>
    PutFileEntryConflictException(crate::types::error::PutFileEntryConflictException),
    /// <p>The specified repository does not exist.</p>
    RepositoryDoesNotExistException(crate::types::error::RepositoryDoesNotExistException),
    /// <p>A repository name is required, but was not specified.</p>
    RepositoryNameRequiredException(crate::types::error::RepositoryNameRequiredException),
    /// <p>The commit cannot be created because one of the changes specifies copying or moving a .gitkeep file.</p>
    RestrictedSourceFileException(crate::types::error::RestrictedSourceFileException),
    /// <p>The commit cannot be created because one or more changes in this commit duplicate actions in the same file path. For example, you cannot make the same delete request to the same file in the same file path twice, or make a delete request and a move request to the same file as part of the same commit.</p>
    SamePathRequestException(crate::types::error::SamePathRequestException),
    /// <p>The commit cannot be created because no source files or file content have been specified for the commit.</p>
    SourceFileOrContentRequiredException(crate::types::error::SourceFileOrContentRequiredException),
    /// An unexpected error occurred (e.g., invalid JSON returned by the service or an unknown error code).
    Unhandled(::aws_smithy_types::error::Unhandled),
}
impl ::aws_smithy_runtime_api::client::result::CreateUnhandledError for CreateCommitError {
    fn create_unhandled_error(
        source: ::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>,
        meta: ::std::option::Option<::aws_smithy_types::error::ErrorMetadata>,
    ) -> Self {
        Self::Unhandled({
            let mut builder = ::aws_smithy_types::error::Unhandled::builder().source(source);
            builder.set_meta(meta);
            builder.build()
        })
    }
}
impl ::std::fmt::Display for CreateCommitError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::BranchDoesNotExistException(_inner) => _inner.fmt(f),
            Self::BranchNameIsTagNameException(_inner) => _inner.fmt(f),
            Self::BranchNameRequiredException(_inner) => _inner.fmt(f),
            Self::CommitMessageLengthExceededException(_inner) => _inner.fmt(f),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => _inner.fmt(f),
            Self::EncryptionIntegrityChecksFailedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyAccessDeniedException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyDisabledException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyNotFoundException(_inner) => _inner.fmt(f),
            Self::EncryptionKeyUnavailableException(_inner) => _inner.fmt(f),
            Self::FileContentAndSourceFileSpecifiedException(_inner) => _inner.fmt(f),
            Self::FileContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::FileDoesNotExistException(_inner) => _inner.fmt(f),
            Self::FileEntryRequiredException(_inner) => _inner.fmt(f),
            Self::FileModeRequiredException(_inner) => _inner.fmt(f),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => _inner.fmt(f),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => _inner.fmt(f),
            Self::FolderContentSizeLimitExceededException(_inner) => _inner.fmt(f),
            Self::InvalidBranchNameException(_inner) => _inner.fmt(f),
            Self::InvalidDeletionParameterException(_inner) => _inner.fmt(f),
            Self::InvalidEmailException(_inner) => _inner.fmt(f),
            Self::InvalidFileModeException(_inner) => _inner.fmt(f),
            Self::InvalidParentCommitIdException(_inner) => _inner.fmt(f),
            Self::InvalidPathException(_inner) => _inner.fmt(f),
            Self::InvalidRepositoryNameException(_inner) => _inner.fmt(f),
            Self::MaximumFileEntriesExceededException(_inner) => _inner.fmt(f),
            Self::NameLengthExceededException(_inner) => _inner.fmt(f),
            Self::NoChangeException(_inner) => _inner.fmt(f),
            Self::ParentCommitDoesNotExistException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdOutdatedException(_inner) => _inner.fmt(f),
            Self::ParentCommitIdRequiredException(_inner) => _inner.fmt(f),
            Self::PathRequiredException(_inner) => _inner.fmt(f),
            Self::PutFileEntryConflictException(_inner) => _inner.fmt(f),
            Self::RepositoryDoesNotExistException(_inner) => _inner.fmt(f),
            Self::RepositoryNameRequiredException(_inner) => _inner.fmt(f),
            Self::RestrictedSourceFileException(_inner) => _inner.fmt(f),
            Self::SamePathRequestException(_inner) => _inner.fmt(f),
            Self::SourceFileOrContentRequiredException(_inner) => _inner.fmt(f),
            Self::Unhandled(_inner) => _inner.fmt(f),
        }
    }
}
impl ::aws_smithy_types::error::metadata::ProvideErrorMetadata for CreateCommitError {
    fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        match self {
            Self::BranchDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::BranchNameIsTagNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::BranchNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::CommitMessageLengthExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyDisabledException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileContentAndSourceFileSpecifiedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileEntryRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileModeRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidBranchNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidDeletionParameterException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidEmailException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidFileModeException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidParentCommitIdException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidPathException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::InvalidRepositoryNameException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::MaximumFileEntriesExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::NameLengthExceededException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::NoChangeException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ParentCommitDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ParentCommitIdOutdatedException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::ParentCommitIdRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::PathRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::PutFileEntryConflictException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryDoesNotExistException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RepositoryNameRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::RestrictedSourceFileException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::SamePathRequestException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::SourceFileOrContentRequiredException(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
            Self::Unhandled(_inner) => ::aws_smithy_types::error::metadata::ProvideErrorMetadata::meta(_inner),
        }
    }
}
impl ::aws_http::request_id::RequestId for crate::operation::create_commit::CreateCommitError {
    fn request_id(&self) -> Option<&str> {
        self.meta().request_id()
    }
}
impl ::aws_smithy_types::retry::ProvideErrorKind for CreateCommitError {
    fn code(&self) -> ::std::option::Option<&str> {
        ::aws_smithy_types::error::metadata::ProvideErrorMetadata::code(self)
    }
    fn retryable_error_kind(&self) -> ::std::option::Option<::aws_smithy_types::retry::ErrorKind> {
        ::std::option::Option::None
    }
}
impl CreateCommitError {
    /// Creates the `CreateCommitError::Unhandled` variant from any error type.
    pub fn unhandled(
        err: impl ::std::convert::Into<::std::boxed::Box<dyn ::std::error::Error + ::std::marker::Send + ::std::marker::Sync + 'static>>,
    ) -> Self {
        Self::Unhandled(::aws_smithy_types::error::Unhandled::builder().source(err).build())
    }

    /// Creates the `CreateCommitError::Unhandled` variant from a `::aws_smithy_types::error::ErrorMetadata`.
    pub fn generic(err: ::aws_smithy_types::error::ErrorMetadata) -> Self {
        Self::Unhandled(::aws_smithy_types::error::Unhandled::builder().source(err.clone()).meta(err).build())
    }
    ///
    /// Returns error metadata, which includes the error code, message,
    /// request ID, and potentially additional information.
    ///
    pub fn meta(&self) -> &::aws_smithy_types::error::ErrorMetadata {
        use ::aws_smithy_types::error::metadata::ProvideErrorMetadata;
        match self {
            Self::BranchDoesNotExistException(e) => e.meta(),
            Self::BranchNameIsTagNameException(e) => e.meta(),
            Self::BranchNameRequiredException(e) => e.meta(),
            Self::CommitMessageLengthExceededException(e) => e.meta(),
            Self::DirectoryNameConflictsWithFileNameException(e) => e.meta(),
            Self::EncryptionIntegrityChecksFailedException(e) => e.meta(),
            Self::EncryptionKeyAccessDeniedException(e) => e.meta(),
            Self::EncryptionKeyDisabledException(e) => e.meta(),
            Self::EncryptionKeyNotFoundException(e) => e.meta(),
            Self::EncryptionKeyUnavailableException(e) => e.meta(),
            Self::FileContentAndSourceFileSpecifiedException(e) => e.meta(),
            Self::FileContentSizeLimitExceededException(e) => e.meta(),
            Self::FileDoesNotExistException(e) => e.meta(),
            Self::FileEntryRequiredException(e) => e.meta(),
            Self::FileModeRequiredException(e) => e.meta(),
            Self::FileNameConflictsWithDirectoryNameException(e) => e.meta(),
            Self::FilePathConflictsWithSubmodulePathException(e) => e.meta(),
            Self::FolderContentSizeLimitExceededException(e) => e.meta(),
            Self::InvalidBranchNameException(e) => e.meta(),
            Self::InvalidDeletionParameterException(e) => e.meta(),
            Self::InvalidEmailException(e) => e.meta(),
            Self::InvalidFileModeException(e) => e.meta(),
            Self::InvalidParentCommitIdException(e) => e.meta(),
            Self::InvalidPathException(e) => e.meta(),
            Self::InvalidRepositoryNameException(e) => e.meta(),
            Self::MaximumFileEntriesExceededException(e) => e.meta(),
            Self::NameLengthExceededException(e) => e.meta(),
            Self::NoChangeException(e) => e.meta(),
            Self::ParentCommitDoesNotExistException(e) => e.meta(),
            Self::ParentCommitIdOutdatedException(e) => e.meta(),
            Self::ParentCommitIdRequiredException(e) => e.meta(),
            Self::PathRequiredException(e) => e.meta(),
            Self::PutFileEntryConflictException(e) => e.meta(),
            Self::RepositoryDoesNotExistException(e) => e.meta(),
            Self::RepositoryNameRequiredException(e) => e.meta(),
            Self::RestrictedSourceFileException(e) => e.meta(),
            Self::SamePathRequestException(e) => e.meta(),
            Self::SourceFileOrContentRequiredException(e) => e.meta(),
            Self::Unhandled(e) => e.meta(),
        }
    }
    /// Returns `true` if the error kind is `CreateCommitError::BranchDoesNotExistException`.
    pub fn is_branch_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::BranchDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::BranchNameIsTagNameException`.
    pub fn is_branch_name_is_tag_name_exception(&self) -> bool {
        matches!(self, Self::BranchNameIsTagNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::BranchNameRequiredException`.
    pub fn is_branch_name_required_exception(&self) -> bool {
        matches!(self, Self::BranchNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::CommitMessageLengthExceededException`.
    pub fn is_commit_message_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::CommitMessageLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::DirectoryNameConflictsWithFileNameException`.
    pub fn is_directory_name_conflicts_with_file_name_exception(&self) -> bool {
        matches!(self, Self::DirectoryNameConflictsWithFileNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionIntegrityChecksFailedException`.
    pub fn is_encryption_integrity_checks_failed_exception(&self) -> bool {
        matches!(self, Self::EncryptionIntegrityChecksFailedException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionKeyAccessDeniedException`.
    pub fn is_encryption_key_access_denied_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyAccessDeniedException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionKeyDisabledException`.
    pub fn is_encryption_key_disabled_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyDisabledException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionKeyNotFoundException`.
    pub fn is_encryption_key_not_found_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyNotFoundException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::EncryptionKeyUnavailableException`.
    pub fn is_encryption_key_unavailable_exception(&self) -> bool {
        matches!(self, Self::EncryptionKeyUnavailableException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileContentAndSourceFileSpecifiedException`.
    pub fn is_file_content_and_source_file_specified_exception(&self) -> bool {
        matches!(self, Self::FileContentAndSourceFileSpecifiedException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileContentSizeLimitExceededException`.
    pub fn is_file_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FileContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileDoesNotExistException`.
    pub fn is_file_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::FileDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileEntryRequiredException`.
    pub fn is_file_entry_required_exception(&self) -> bool {
        matches!(self, Self::FileEntryRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileModeRequiredException`.
    pub fn is_file_mode_required_exception(&self) -> bool {
        matches!(self, Self::FileModeRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FileNameConflictsWithDirectoryNameException`.
    pub fn is_file_name_conflicts_with_directory_name_exception(&self) -> bool {
        matches!(self, Self::FileNameConflictsWithDirectoryNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FilePathConflictsWithSubmodulePathException`.
    pub fn is_file_path_conflicts_with_submodule_path_exception(&self) -> bool {
        matches!(self, Self::FilePathConflictsWithSubmodulePathException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::FolderContentSizeLimitExceededException`.
    pub fn is_folder_content_size_limit_exceeded_exception(&self) -> bool {
        matches!(self, Self::FolderContentSizeLimitExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidBranchNameException`.
    pub fn is_invalid_branch_name_exception(&self) -> bool {
        matches!(self, Self::InvalidBranchNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidDeletionParameterException`.
    pub fn is_invalid_deletion_parameter_exception(&self) -> bool {
        matches!(self, Self::InvalidDeletionParameterException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidEmailException`.
    pub fn is_invalid_email_exception(&self) -> bool {
        matches!(self, Self::InvalidEmailException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidFileModeException`.
    pub fn is_invalid_file_mode_exception(&self) -> bool {
        matches!(self, Self::InvalidFileModeException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidParentCommitIdException`.
    pub fn is_invalid_parent_commit_id_exception(&self) -> bool {
        matches!(self, Self::InvalidParentCommitIdException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidPathException`.
    pub fn is_invalid_path_exception(&self) -> bool {
        matches!(self, Self::InvalidPathException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::InvalidRepositoryNameException`.
    pub fn is_invalid_repository_name_exception(&self) -> bool {
        matches!(self, Self::InvalidRepositoryNameException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::MaximumFileEntriesExceededException`.
    pub fn is_maximum_file_entries_exceeded_exception(&self) -> bool {
        matches!(self, Self::MaximumFileEntriesExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::NameLengthExceededException`.
    pub fn is_name_length_exceeded_exception(&self) -> bool {
        matches!(self, Self::NameLengthExceededException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::NoChangeException`.
    pub fn is_no_change_exception(&self) -> bool {
        matches!(self, Self::NoChangeException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::ParentCommitDoesNotExistException`.
    pub fn is_parent_commit_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::ParentCommitDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::ParentCommitIdOutdatedException`.
    pub fn is_parent_commit_id_outdated_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdOutdatedException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::ParentCommitIdRequiredException`.
    pub fn is_parent_commit_id_required_exception(&self) -> bool {
        matches!(self, Self::ParentCommitIdRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::PathRequiredException`.
    pub fn is_path_required_exception(&self) -> bool {
        matches!(self, Self::PathRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::PutFileEntryConflictException`.
    pub fn is_put_file_entry_conflict_exception(&self) -> bool {
        matches!(self, Self::PutFileEntryConflictException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::RepositoryDoesNotExistException`.
    pub fn is_repository_does_not_exist_exception(&self) -> bool {
        matches!(self, Self::RepositoryDoesNotExistException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::RepositoryNameRequiredException`.
    pub fn is_repository_name_required_exception(&self) -> bool {
        matches!(self, Self::RepositoryNameRequiredException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::RestrictedSourceFileException`.
    pub fn is_restricted_source_file_exception(&self) -> bool {
        matches!(self, Self::RestrictedSourceFileException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::SamePathRequestException`.
    pub fn is_same_path_request_exception(&self) -> bool {
        matches!(self, Self::SamePathRequestException(_))
    }
    /// Returns `true` if the error kind is `CreateCommitError::SourceFileOrContentRequiredException`.
    pub fn is_source_file_or_content_required_exception(&self) -> bool {
        matches!(self, Self::SourceFileOrContentRequiredException(_))
    }
}
impl ::std::error::Error for CreateCommitError {
    fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            Self::BranchDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::BranchNameIsTagNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::BranchNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::CommitMessageLengthExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::DirectoryNameConflictsWithFileNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionIntegrityChecksFailedException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyAccessDeniedException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyDisabledException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyNotFoundException(_inner) => ::std::option::Option::Some(_inner),
            Self::EncryptionKeyUnavailableException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileContentAndSourceFileSpecifiedException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileContentSizeLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileEntryRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileModeRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::FileNameConflictsWithDirectoryNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::FilePathConflictsWithSubmodulePathException(_inner) => ::std::option::Option::Some(_inner),
            Self::FolderContentSizeLimitExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidBranchNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidDeletionParameterException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidEmailException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidFileModeException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidParentCommitIdException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidPathException(_inner) => ::std::option::Option::Some(_inner),
            Self::InvalidRepositoryNameException(_inner) => ::std::option::Option::Some(_inner),
            Self::MaximumFileEntriesExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::NameLengthExceededException(_inner) => ::std::option::Option::Some(_inner),
            Self::NoChangeException(_inner) => ::std::option::Option::Some(_inner),
            Self::ParentCommitDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::ParentCommitIdOutdatedException(_inner) => ::std::option::Option::Some(_inner),
            Self::ParentCommitIdRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::PathRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::PutFileEntryConflictException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryDoesNotExistException(_inner) => ::std::option::Option::Some(_inner),
            Self::RepositoryNameRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::RestrictedSourceFileException(_inner) => ::std::option::Option::Some(_inner),
            Self::SamePathRequestException(_inner) => ::std::option::Option::Some(_inner),
            Self::SourceFileOrContentRequiredException(_inner) => ::std::option::Option::Some(_inner),
            Self::Unhandled(_inner) => ::std::option::Option::Some(_inner),
        }
    }
}

pub use crate::operation::create_commit::_create_commit_output::CreateCommitOutput;

pub use crate::operation::create_commit::_create_commit_input::CreateCommitInput;

mod _create_commit_input;

mod _create_commit_output;

/// Builders
pub mod builders;
