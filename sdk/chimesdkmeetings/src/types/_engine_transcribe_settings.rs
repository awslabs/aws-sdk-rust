// Code generated by software.amazon.smithy.rust.codegen.smithy-rs. DO NOT EDIT.

/// <p>Settings specific for Amazon Transcribe as the live transcription engine.</p>
/// <p>If you specify an invalid combination of parameters, a <code>TranscriptFailed</code> event will be sent with the contents of the <code>BadRequestException</code> generated by Amazon Transcribe. For more information on each parameter and which combinations are valid, refer to the <a href="https://docs.aws.amazon.com/transcribe/latest/APIReference/API_streaming_StartStreamTranscription.html">StartStreamTranscription</a> API in the <i>Amazon Transcribe Developer Guide</i>.</p>
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::fmt::Debug)]
pub struct EngineTranscribeSettings {
    /// <p>Specify the language code that represents the language spoken.</p>
    /// <p>If you're unsure of the language spoken in your audio, consider using <code>IdentifyLanguage</code> to enable automatic language identification.</p>
    pub language_code: ::std::option::Option<crate::types::TranscribeLanguageCode>,
    /// <p>Specify how you want your vocabulary filter applied to your transcript.</p>
    /// <p>To replace words with <code>***</code>, choose <code>mask</code>.</p>
    /// <p>To delete words, choose <code>remove</code>.</p>
    /// <p>To flag words without changing them, choose <code>tag</code>.</p>
    pub vocabulary_filter_method: ::std::option::Option<crate::types::TranscribeVocabularyFilterMethod>,
    /// <p>Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more vocabulary filters with your transcription, use the <code>VocabularyFilterNames</code> parameter instead.</p>
    pub vocabulary_filter_name: ::std::option::Option<::std::string::String>,
    /// <p>Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more custom vocabularies with your transcription, use the <code>VocabularyNames</code> parameter instead.</p>
    pub vocabulary_name: ::std::option::Option<::std::string::String>,
    /// <p>The Amazon Web Services Region in which to use Amazon Transcribe.</p>
    /// <p>If you don't specify a Region, then the <a href="https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html">MediaRegion</a> of the meeting is used. However, if Amazon Transcribe is not available in the <code>MediaRegion</code>, then a <code>TranscriptFailed</code> event is sent.</p>
    /// <p>Use <code>auto</code> to use Amazon Transcribe in a Region near the meeting’s <code>MediaRegion</code>. For more information, refer to <a href="https://docs.aws.amazon.com/chime-sdk/latest/dg/transcription-options.html#choose-region">Choosing a transcription Region</a> in the <i>Amazon Chime SDK Developer Guide</i>.</p>
    pub region: ::std::option::Option<crate::types::TranscribeRegion>,
    /// <p>Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.</p>
    pub enable_partial_results_stabilization: bool,
    /// <p>Specify the level of stability to use when you enable partial results stabilization (<code>EnablePartialResultsStabilization</code>).</p>
    /// <p>Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.</p>
    pub partial_results_stability: ::std::option::Option<crate::types::TranscribePartialResultsStability>,
    /// <p>Labels all personally identifiable information (PII) identified in your transcript. If you don't include <code>PiiEntityTypes</code>, all PII is identified.</p><note>
    /// <p>You can’t set <code>ContentIdentificationType</code> and <code>ContentRedactionType</code>.</p>
    /// </note>
    pub content_identification_type: ::std::option::Option<crate::types::TranscribeContentIdentificationType>,
    /// <p>Content redaction is performed at the segment level. If you don't include <code>PiiEntityTypes</code>, all PII is redacted.</p><note>
    /// <p>You can’t set <code>ContentRedactionType</code> and <code>ContentIdentificationType</code>.</p>
    /// </note>
    pub content_redaction_type: ::std::option::Option<crate::types::TranscribeContentRedactionType>,
    /// <p>Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select <code>ALL</code>.</p>
    /// <p>Values must be comma-separated and can include: <code>ADDRESS</code>, <code>BANK_ACCOUNT_NUMBER</code>, <code>BANK_ROUTING</code>, <code>CREDIT_DEBIT_CVV</code>, <code>CREDIT_DEBIT_EXPIRY</code> <code>CREDIT_DEBIT_NUMBER</code>, <code>EMAIL</code>,<code>NAME</code>, <code>PHONE</code>, <code>PIN</code>, <code>SSN</code>, or <code>ALL</code>.</p>
    /// <p>Note that if you include <code>PiiEntityTypes</code>, you must also include <code>ContentIdentificationType</code> or <code>ContentRedactionType</code>.</p>
    /// <p>If you include <code>ContentRedactionType</code> or <code>ContentIdentificationType</code>, but do not include PiiEntityTypes, all PII is redacted or identified.</p>
    pub pii_entity_types: ::std::option::Option<::std::string::String>,
    /// <p>Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive.</p>
    /// <p>The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.</p>
    pub language_model_name: ::std::option::Option<::std::string::String>,
    /// <p>Enables automatic language identification for your transcription.</p>
    /// <p>If you include <code>IdentifyLanguage</code>, you can optionally use <code>LanguageOptions</code> to include a list of language codes that you think may be present in your audio stream. Including language options can improve transcription accuracy.</p>
    /// <p>You can also use <code>PreferredLanguage</code> to include a preferred language. Doing so can help Amazon Transcribe identify the language faster.</p>
    /// <p>You must include either <code>LanguageCode</code> or <code>IdentifyLanguage</code>.</p>
    /// <p>Language identification can't be combined with custom language models or redaction.</p>
    pub identify_language: bool,
    /// <p>Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages are present, do not include this parameter.</p>
    /// <p>Including language options can improve the accuracy of language identification.</p>
    /// <p>If you include <code>LanguageOptions</code>, you must also include <code>IdentifyLanguage</code>.</p><important>
    /// <p>You can only include one language dialect per language. For example, you cannot include <code>en-US</code> and <code>en-AU</code>.</p>
    /// </important>
    pub language_options: ::std::option::Option<::std::string::String>,
    /// <p>Specify a preferred language from the subset of languages codes you specified in <code>LanguageOptions</code>.</p>
    /// <p>You can only use this parameter if you include <code>IdentifyLanguage</code> and <code>LanguageOptions</code>.</p>
    pub preferred_language: ::std::option::Option<crate::types::TranscribeLanguageCode>,
    /// <p>Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you don't include <code>IdentifyLanguage</code> and want to use a custom vocabulary with your transcription, use the <code>VocabularyName</code> parameter instead.</p>
    pub vocabulary_names: ::std::option::Option<::std::string::String>,
    /// <p>Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you're <i>not</i> including <code>IdentifyLanguage</code> and want to use a custom vocabulary filter with your transcription, use the <code>VocabularyFilterName</code> parameter instead.</p>
    pub vocabulary_filter_names: ::std::option::Option<::std::string::String>,
}
impl EngineTranscribeSettings {
    /// <p>Specify the language code that represents the language spoken.</p>
    /// <p>If you're unsure of the language spoken in your audio, consider using <code>IdentifyLanguage</code> to enable automatic language identification.</p>
    pub fn language_code(&self) -> ::std::option::Option<&crate::types::TranscribeLanguageCode> {
        self.language_code.as_ref()
    }
    /// <p>Specify how you want your vocabulary filter applied to your transcript.</p>
    /// <p>To replace words with <code>***</code>, choose <code>mask</code>.</p>
    /// <p>To delete words, choose <code>remove</code>.</p>
    /// <p>To flag words without changing them, choose <code>tag</code>.</p>
    pub fn vocabulary_filter_method(&self) -> ::std::option::Option<&crate::types::TranscribeVocabularyFilterMethod> {
        self.vocabulary_filter_method.as_ref()
    }
    /// <p>Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more vocabulary filters with your transcription, use the <code>VocabularyFilterNames</code> parameter instead.</p>
    pub fn vocabulary_filter_name(&self) -> ::std::option::Option<&str> {
        self.vocabulary_filter_name.as_deref()
    }
    /// <p>Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more custom vocabularies with your transcription, use the <code>VocabularyNames</code> parameter instead.</p>
    pub fn vocabulary_name(&self) -> ::std::option::Option<&str> {
        self.vocabulary_name.as_deref()
    }
    /// <p>The Amazon Web Services Region in which to use Amazon Transcribe.</p>
    /// <p>If you don't specify a Region, then the <a href="https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html">MediaRegion</a> of the meeting is used. However, if Amazon Transcribe is not available in the <code>MediaRegion</code>, then a <code>TranscriptFailed</code> event is sent.</p>
    /// <p>Use <code>auto</code> to use Amazon Transcribe in a Region near the meeting’s <code>MediaRegion</code>. For more information, refer to <a href="https://docs.aws.amazon.com/chime-sdk/latest/dg/transcription-options.html#choose-region">Choosing a transcription Region</a> in the <i>Amazon Chime SDK Developer Guide</i>.</p>
    pub fn region(&self) -> ::std::option::Option<&crate::types::TranscribeRegion> {
        self.region.as_ref()
    }
    /// <p>Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.</p>
    pub fn enable_partial_results_stabilization(&self) -> bool {
        self.enable_partial_results_stabilization
    }
    /// <p>Specify the level of stability to use when you enable partial results stabilization (<code>EnablePartialResultsStabilization</code>).</p>
    /// <p>Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.</p>
    pub fn partial_results_stability(&self) -> ::std::option::Option<&crate::types::TranscribePartialResultsStability> {
        self.partial_results_stability.as_ref()
    }
    /// <p>Labels all personally identifiable information (PII) identified in your transcript. If you don't include <code>PiiEntityTypes</code>, all PII is identified.</p><note>
    /// <p>You can’t set <code>ContentIdentificationType</code> and <code>ContentRedactionType</code>.</p>
    /// </note>
    pub fn content_identification_type(&self) -> ::std::option::Option<&crate::types::TranscribeContentIdentificationType> {
        self.content_identification_type.as_ref()
    }
    /// <p>Content redaction is performed at the segment level. If you don't include <code>PiiEntityTypes</code>, all PII is redacted.</p><note>
    /// <p>You can’t set <code>ContentRedactionType</code> and <code>ContentIdentificationType</code>.</p>
    /// </note>
    pub fn content_redaction_type(&self) -> ::std::option::Option<&crate::types::TranscribeContentRedactionType> {
        self.content_redaction_type.as_ref()
    }
    /// <p>Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select <code>ALL</code>.</p>
    /// <p>Values must be comma-separated and can include: <code>ADDRESS</code>, <code>BANK_ACCOUNT_NUMBER</code>, <code>BANK_ROUTING</code>, <code>CREDIT_DEBIT_CVV</code>, <code>CREDIT_DEBIT_EXPIRY</code> <code>CREDIT_DEBIT_NUMBER</code>, <code>EMAIL</code>,<code>NAME</code>, <code>PHONE</code>, <code>PIN</code>, <code>SSN</code>, or <code>ALL</code>.</p>
    /// <p>Note that if you include <code>PiiEntityTypes</code>, you must also include <code>ContentIdentificationType</code> or <code>ContentRedactionType</code>.</p>
    /// <p>If you include <code>ContentRedactionType</code> or <code>ContentIdentificationType</code>, but do not include PiiEntityTypes, all PII is redacted or identified.</p>
    pub fn pii_entity_types(&self) -> ::std::option::Option<&str> {
        self.pii_entity_types.as_deref()
    }
    /// <p>Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive.</p>
    /// <p>The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.</p>
    pub fn language_model_name(&self) -> ::std::option::Option<&str> {
        self.language_model_name.as_deref()
    }
    /// <p>Enables automatic language identification for your transcription.</p>
    /// <p>If you include <code>IdentifyLanguage</code>, you can optionally use <code>LanguageOptions</code> to include a list of language codes that you think may be present in your audio stream. Including language options can improve transcription accuracy.</p>
    /// <p>You can also use <code>PreferredLanguage</code> to include a preferred language. Doing so can help Amazon Transcribe identify the language faster.</p>
    /// <p>You must include either <code>LanguageCode</code> or <code>IdentifyLanguage</code>.</p>
    /// <p>Language identification can't be combined with custom language models or redaction.</p>
    pub fn identify_language(&self) -> bool {
        self.identify_language
    }
    /// <p>Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages are present, do not include this parameter.</p>
    /// <p>Including language options can improve the accuracy of language identification.</p>
    /// <p>If you include <code>LanguageOptions</code>, you must also include <code>IdentifyLanguage</code>.</p><important>
    /// <p>You can only include one language dialect per language. For example, you cannot include <code>en-US</code> and <code>en-AU</code>.</p>
    /// </important>
    pub fn language_options(&self) -> ::std::option::Option<&str> {
        self.language_options.as_deref()
    }
    /// <p>Specify a preferred language from the subset of languages codes you specified in <code>LanguageOptions</code>.</p>
    /// <p>You can only use this parameter if you include <code>IdentifyLanguage</code> and <code>LanguageOptions</code>.</p>
    pub fn preferred_language(&self) -> ::std::option::Option<&crate::types::TranscribeLanguageCode> {
        self.preferred_language.as_ref()
    }
    /// <p>Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you don't include <code>IdentifyLanguage</code> and want to use a custom vocabulary with your transcription, use the <code>VocabularyName</code> parameter instead.</p>
    pub fn vocabulary_names(&self) -> ::std::option::Option<&str> {
        self.vocabulary_names.as_deref()
    }
    /// <p>Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you're <i>not</i> including <code>IdentifyLanguage</code> and want to use a custom vocabulary filter with your transcription, use the <code>VocabularyFilterName</code> parameter instead.</p>
    pub fn vocabulary_filter_names(&self) -> ::std::option::Option<&str> {
        self.vocabulary_filter_names.as_deref()
    }
}
impl EngineTranscribeSettings {
    /// Creates a new builder-style object to manufacture [`EngineTranscribeSettings`](crate::types::EngineTranscribeSettings).
    pub fn builder() -> crate::types::builders::EngineTranscribeSettingsBuilder {
        crate::types::builders::EngineTranscribeSettingsBuilder::default()
    }
}

/// A builder for [`EngineTranscribeSettings`](crate::types::EngineTranscribeSettings).
#[non_exhaustive]
#[derive(::std::clone::Clone, ::std::cmp::PartialEq, ::std::default::Default, ::std::fmt::Debug)]
pub struct EngineTranscribeSettingsBuilder {
    pub(crate) language_code: ::std::option::Option<crate::types::TranscribeLanguageCode>,
    pub(crate) vocabulary_filter_method: ::std::option::Option<crate::types::TranscribeVocabularyFilterMethod>,
    pub(crate) vocabulary_filter_name: ::std::option::Option<::std::string::String>,
    pub(crate) vocabulary_name: ::std::option::Option<::std::string::String>,
    pub(crate) region: ::std::option::Option<crate::types::TranscribeRegion>,
    pub(crate) enable_partial_results_stabilization: ::std::option::Option<bool>,
    pub(crate) partial_results_stability: ::std::option::Option<crate::types::TranscribePartialResultsStability>,
    pub(crate) content_identification_type: ::std::option::Option<crate::types::TranscribeContentIdentificationType>,
    pub(crate) content_redaction_type: ::std::option::Option<crate::types::TranscribeContentRedactionType>,
    pub(crate) pii_entity_types: ::std::option::Option<::std::string::String>,
    pub(crate) language_model_name: ::std::option::Option<::std::string::String>,
    pub(crate) identify_language: ::std::option::Option<bool>,
    pub(crate) language_options: ::std::option::Option<::std::string::String>,
    pub(crate) preferred_language: ::std::option::Option<crate::types::TranscribeLanguageCode>,
    pub(crate) vocabulary_names: ::std::option::Option<::std::string::String>,
    pub(crate) vocabulary_filter_names: ::std::option::Option<::std::string::String>,
}
impl EngineTranscribeSettingsBuilder {
    /// <p>Specify the language code that represents the language spoken.</p>
    /// <p>If you're unsure of the language spoken in your audio, consider using <code>IdentifyLanguage</code> to enable automatic language identification.</p>
    pub fn language_code(mut self, input: crate::types::TranscribeLanguageCode) -> Self {
        self.language_code = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specify the language code that represents the language spoken.</p>
    /// <p>If you're unsure of the language spoken in your audio, consider using <code>IdentifyLanguage</code> to enable automatic language identification.</p>
    pub fn set_language_code(mut self, input: ::std::option::Option<crate::types::TranscribeLanguageCode>) -> Self {
        self.language_code = input;
        self
    }
    /// <p>Specify the language code that represents the language spoken.</p>
    /// <p>If you're unsure of the language spoken in your audio, consider using <code>IdentifyLanguage</code> to enable automatic language identification.</p>
    pub fn get_language_code(&self) -> &::std::option::Option<crate::types::TranscribeLanguageCode> {
        &self.language_code
    }
    /// <p>Specify how you want your vocabulary filter applied to your transcript.</p>
    /// <p>To replace words with <code>***</code>, choose <code>mask</code>.</p>
    /// <p>To delete words, choose <code>remove</code>.</p>
    /// <p>To flag words without changing them, choose <code>tag</code>.</p>
    pub fn vocabulary_filter_method(mut self, input: crate::types::TranscribeVocabularyFilterMethod) -> Self {
        self.vocabulary_filter_method = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specify how you want your vocabulary filter applied to your transcript.</p>
    /// <p>To replace words with <code>***</code>, choose <code>mask</code>.</p>
    /// <p>To delete words, choose <code>remove</code>.</p>
    /// <p>To flag words without changing them, choose <code>tag</code>.</p>
    pub fn set_vocabulary_filter_method(mut self, input: ::std::option::Option<crate::types::TranscribeVocabularyFilterMethod>) -> Self {
        self.vocabulary_filter_method = input;
        self
    }
    /// <p>Specify how you want your vocabulary filter applied to your transcript.</p>
    /// <p>To replace words with <code>***</code>, choose <code>mask</code>.</p>
    /// <p>To delete words, choose <code>remove</code>.</p>
    /// <p>To flag words without changing them, choose <code>tag</code>.</p>
    pub fn get_vocabulary_filter_method(&self) -> &::std::option::Option<crate::types::TranscribeVocabularyFilterMethod> {
        &self.vocabulary_filter_method
    }
    /// <p>Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more vocabulary filters with your transcription, use the <code>VocabularyFilterNames</code> parameter instead.</p>
    pub fn vocabulary_filter_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vocabulary_filter_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more vocabulary filters with your transcription, use the <code>VocabularyFilterNames</code> parameter instead.</p>
    pub fn set_vocabulary_filter_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vocabulary_filter_name = input;
        self
    }
    /// <p>Specify the name of the custom vocabulary filter that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more vocabulary filters with your transcription, use the <code>VocabularyFilterNames</code> parameter instead.</p>
    pub fn get_vocabulary_filter_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.vocabulary_filter_name
    }
    /// <p>Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more custom vocabularies with your transcription, use the <code>VocabularyNames</code> parameter instead.</p>
    pub fn vocabulary_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vocabulary_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more custom vocabularies with your transcription, use the <code>VocabularyNames</code> parameter instead.</p>
    pub fn set_vocabulary_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vocabulary_name = input;
        self
    }
    /// <p>Specify the name of the custom vocabulary that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you include <code>IdentifyLanguage</code> and want to use one or more custom vocabularies with your transcription, use the <code>VocabularyNames</code> parameter instead.</p>
    pub fn get_vocabulary_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.vocabulary_name
    }
    /// <p>The Amazon Web Services Region in which to use Amazon Transcribe.</p>
    /// <p>If you don't specify a Region, then the <a href="https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html">MediaRegion</a> of the meeting is used. However, if Amazon Transcribe is not available in the <code>MediaRegion</code>, then a <code>TranscriptFailed</code> event is sent.</p>
    /// <p>Use <code>auto</code> to use Amazon Transcribe in a Region near the meeting’s <code>MediaRegion</code>. For more information, refer to <a href="https://docs.aws.amazon.com/chime-sdk/latest/dg/transcription-options.html#choose-region">Choosing a transcription Region</a> in the <i>Amazon Chime SDK Developer Guide</i>.</p>
    pub fn region(mut self, input: crate::types::TranscribeRegion) -> Self {
        self.region = ::std::option::Option::Some(input);
        self
    }
    /// <p>The Amazon Web Services Region in which to use Amazon Transcribe.</p>
    /// <p>If you don't specify a Region, then the <a href="https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html">MediaRegion</a> of the meeting is used. However, if Amazon Transcribe is not available in the <code>MediaRegion</code>, then a <code>TranscriptFailed</code> event is sent.</p>
    /// <p>Use <code>auto</code> to use Amazon Transcribe in a Region near the meeting’s <code>MediaRegion</code>. For more information, refer to <a href="https://docs.aws.amazon.com/chime-sdk/latest/dg/transcription-options.html#choose-region">Choosing a transcription Region</a> in the <i>Amazon Chime SDK Developer Guide</i>.</p>
    pub fn set_region(mut self, input: ::std::option::Option<crate::types::TranscribeRegion>) -> Self {
        self.region = input;
        self
    }
    /// <p>The Amazon Web Services Region in which to use Amazon Transcribe.</p>
    /// <p>If you don't specify a Region, then the <a href="https://docs.aws.amazon.com/chime-sdk/latest/APIReference/API_meeting-chime_CreateMeeting.html">MediaRegion</a> of the meeting is used. However, if Amazon Transcribe is not available in the <code>MediaRegion</code>, then a <code>TranscriptFailed</code> event is sent.</p>
    /// <p>Use <code>auto</code> to use Amazon Transcribe in a Region near the meeting’s <code>MediaRegion</code>. For more information, refer to <a href="https://docs.aws.amazon.com/chime-sdk/latest/dg/transcription-options.html#choose-region">Choosing a transcription Region</a> in the <i>Amazon Chime SDK Developer Guide</i>.</p>
    pub fn get_region(&self) -> &::std::option::Option<crate::types::TranscribeRegion> {
        &self.region
    }
    /// <p>Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.</p>
    pub fn enable_partial_results_stabilization(mut self, input: bool) -> Self {
        self.enable_partial_results_stabilization = ::std::option::Option::Some(input);
        self
    }
    /// <p>Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.</p>
    pub fn set_enable_partial_results_stabilization(mut self, input: ::std::option::Option<bool>) -> Self {
        self.enable_partial_results_stabilization = input;
        self
    }
    /// <p>Enables partial result stabilization for your transcription. Partial result stabilization can reduce latency in your output, but may impact accuracy.</p>
    pub fn get_enable_partial_results_stabilization(&self) -> &::std::option::Option<bool> {
        &self.enable_partial_results_stabilization
    }
    /// <p>Specify the level of stability to use when you enable partial results stabilization (<code>EnablePartialResultsStabilization</code>).</p>
    /// <p>Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.</p>
    pub fn partial_results_stability(mut self, input: crate::types::TranscribePartialResultsStability) -> Self {
        self.partial_results_stability = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specify the level of stability to use when you enable partial results stabilization (<code>EnablePartialResultsStabilization</code>).</p>
    /// <p>Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.</p>
    pub fn set_partial_results_stability(mut self, input: ::std::option::Option<crate::types::TranscribePartialResultsStability>) -> Self {
        self.partial_results_stability = input;
        self
    }
    /// <p>Specify the level of stability to use when you enable partial results stabilization (<code>EnablePartialResultsStabilization</code>).</p>
    /// <p>Low stability provides the highest accuracy. High stability transcribes faster, but with slightly lower accuracy.</p>
    pub fn get_partial_results_stability(&self) -> &::std::option::Option<crate::types::TranscribePartialResultsStability> {
        &self.partial_results_stability
    }
    /// <p>Labels all personally identifiable information (PII) identified in your transcript. If you don't include <code>PiiEntityTypes</code>, all PII is identified.</p><note>
    /// <p>You can’t set <code>ContentIdentificationType</code> and <code>ContentRedactionType</code>.</p>
    /// </note>
    pub fn content_identification_type(mut self, input: crate::types::TranscribeContentIdentificationType) -> Self {
        self.content_identification_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Labels all personally identifiable information (PII) identified in your transcript. If you don't include <code>PiiEntityTypes</code>, all PII is identified.</p><note>
    /// <p>You can’t set <code>ContentIdentificationType</code> and <code>ContentRedactionType</code>.</p>
    /// </note>
    pub fn set_content_identification_type(mut self, input: ::std::option::Option<crate::types::TranscribeContentIdentificationType>) -> Self {
        self.content_identification_type = input;
        self
    }
    /// <p>Labels all personally identifiable information (PII) identified in your transcript. If you don't include <code>PiiEntityTypes</code>, all PII is identified.</p><note>
    /// <p>You can’t set <code>ContentIdentificationType</code> and <code>ContentRedactionType</code>.</p>
    /// </note>
    pub fn get_content_identification_type(&self) -> &::std::option::Option<crate::types::TranscribeContentIdentificationType> {
        &self.content_identification_type
    }
    /// <p>Content redaction is performed at the segment level. If you don't include <code>PiiEntityTypes</code>, all PII is redacted.</p><note>
    /// <p>You can’t set <code>ContentRedactionType</code> and <code>ContentIdentificationType</code>.</p>
    /// </note>
    pub fn content_redaction_type(mut self, input: crate::types::TranscribeContentRedactionType) -> Self {
        self.content_redaction_type = ::std::option::Option::Some(input);
        self
    }
    /// <p>Content redaction is performed at the segment level. If you don't include <code>PiiEntityTypes</code>, all PII is redacted.</p><note>
    /// <p>You can’t set <code>ContentRedactionType</code> and <code>ContentIdentificationType</code>.</p>
    /// </note>
    pub fn set_content_redaction_type(mut self, input: ::std::option::Option<crate::types::TranscribeContentRedactionType>) -> Self {
        self.content_redaction_type = input;
        self
    }
    /// <p>Content redaction is performed at the segment level. If you don't include <code>PiiEntityTypes</code>, all PII is redacted.</p><note>
    /// <p>You can’t set <code>ContentRedactionType</code> and <code>ContentIdentificationType</code>.</p>
    /// </note>
    pub fn get_content_redaction_type(&self) -> &::std::option::Option<crate::types::TranscribeContentRedactionType> {
        &self.content_redaction_type
    }
    /// <p>Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select <code>ALL</code>.</p>
    /// <p>Values must be comma-separated and can include: <code>ADDRESS</code>, <code>BANK_ACCOUNT_NUMBER</code>, <code>BANK_ROUTING</code>, <code>CREDIT_DEBIT_CVV</code>, <code>CREDIT_DEBIT_EXPIRY</code> <code>CREDIT_DEBIT_NUMBER</code>, <code>EMAIL</code>,<code>NAME</code>, <code>PHONE</code>, <code>PIN</code>, <code>SSN</code>, or <code>ALL</code>.</p>
    /// <p>Note that if you include <code>PiiEntityTypes</code>, you must also include <code>ContentIdentificationType</code> or <code>ContentRedactionType</code>.</p>
    /// <p>If you include <code>ContentRedactionType</code> or <code>ContentIdentificationType</code>, but do not include PiiEntityTypes, all PII is redacted or identified.</p>
    pub fn pii_entity_types(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.pii_entity_types = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select <code>ALL</code>.</p>
    /// <p>Values must be comma-separated and can include: <code>ADDRESS</code>, <code>BANK_ACCOUNT_NUMBER</code>, <code>BANK_ROUTING</code>, <code>CREDIT_DEBIT_CVV</code>, <code>CREDIT_DEBIT_EXPIRY</code> <code>CREDIT_DEBIT_NUMBER</code>, <code>EMAIL</code>,<code>NAME</code>, <code>PHONE</code>, <code>PIN</code>, <code>SSN</code>, or <code>ALL</code>.</p>
    /// <p>Note that if you include <code>PiiEntityTypes</code>, you must also include <code>ContentIdentificationType</code> or <code>ContentRedactionType</code>.</p>
    /// <p>If you include <code>ContentRedactionType</code> or <code>ContentIdentificationType</code>, but do not include PiiEntityTypes, all PII is redacted or identified.</p>
    pub fn set_pii_entity_types(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.pii_entity_types = input;
        self
    }
    /// <p>Specify which types of personally identifiable information (PII) you want to redact in your transcript. You can include as many types as you'd like, or you can select <code>ALL</code>.</p>
    /// <p>Values must be comma-separated and can include: <code>ADDRESS</code>, <code>BANK_ACCOUNT_NUMBER</code>, <code>BANK_ROUTING</code>, <code>CREDIT_DEBIT_CVV</code>, <code>CREDIT_DEBIT_EXPIRY</code> <code>CREDIT_DEBIT_NUMBER</code>, <code>EMAIL</code>,<code>NAME</code>, <code>PHONE</code>, <code>PIN</code>, <code>SSN</code>, or <code>ALL</code>.</p>
    /// <p>Note that if you include <code>PiiEntityTypes</code>, you must also include <code>ContentIdentificationType</code> or <code>ContentRedactionType</code>.</p>
    /// <p>If you include <code>ContentRedactionType</code> or <code>ContentIdentificationType</code>, but do not include PiiEntityTypes, all PII is redacted or identified.</p>
    pub fn get_pii_entity_types(&self) -> &::std::option::Option<::std::string::String> {
        &self.pii_entity_types
    }
    /// <p>Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive.</p>
    /// <p>The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.</p>
    pub fn language_model_name(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.language_model_name = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive.</p>
    /// <p>The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.</p>
    pub fn set_language_model_name(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.language_model_name = input;
        self
    }
    /// <p>Specify the name of the custom language model that you want to use when processing your transcription. Note that language model names are case sensitive.</p>
    /// <p>The language of the specified language model must match the language code. If the languages don't match, the custom language model isn't applied. There are no errors or warnings associated with a language mismatch.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the custom language model must be available in Amazon Transcribe in each Region.</p>
    pub fn get_language_model_name(&self) -> &::std::option::Option<::std::string::String> {
        &self.language_model_name
    }
    /// <p>Enables automatic language identification for your transcription.</p>
    /// <p>If you include <code>IdentifyLanguage</code>, you can optionally use <code>LanguageOptions</code> to include a list of language codes that you think may be present in your audio stream. Including language options can improve transcription accuracy.</p>
    /// <p>You can also use <code>PreferredLanguage</code> to include a preferred language. Doing so can help Amazon Transcribe identify the language faster.</p>
    /// <p>You must include either <code>LanguageCode</code> or <code>IdentifyLanguage</code>.</p>
    /// <p>Language identification can't be combined with custom language models or redaction.</p>
    pub fn identify_language(mut self, input: bool) -> Self {
        self.identify_language = ::std::option::Option::Some(input);
        self
    }
    /// <p>Enables automatic language identification for your transcription.</p>
    /// <p>If you include <code>IdentifyLanguage</code>, you can optionally use <code>LanguageOptions</code> to include a list of language codes that you think may be present in your audio stream. Including language options can improve transcription accuracy.</p>
    /// <p>You can also use <code>PreferredLanguage</code> to include a preferred language. Doing so can help Amazon Transcribe identify the language faster.</p>
    /// <p>You must include either <code>LanguageCode</code> or <code>IdentifyLanguage</code>.</p>
    /// <p>Language identification can't be combined with custom language models or redaction.</p>
    pub fn set_identify_language(mut self, input: ::std::option::Option<bool>) -> Self {
        self.identify_language = input;
        self
    }
    /// <p>Enables automatic language identification for your transcription.</p>
    /// <p>If you include <code>IdentifyLanguage</code>, you can optionally use <code>LanguageOptions</code> to include a list of language codes that you think may be present in your audio stream. Including language options can improve transcription accuracy.</p>
    /// <p>You can also use <code>PreferredLanguage</code> to include a preferred language. Doing so can help Amazon Transcribe identify the language faster.</p>
    /// <p>You must include either <code>LanguageCode</code> or <code>IdentifyLanguage</code>.</p>
    /// <p>Language identification can't be combined with custom language models or redaction.</p>
    pub fn get_identify_language(&self) -> &::std::option::Option<bool> {
        &self.identify_language
    }
    /// <p>Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages are present, do not include this parameter.</p>
    /// <p>Including language options can improve the accuracy of language identification.</p>
    /// <p>If you include <code>LanguageOptions</code>, you must also include <code>IdentifyLanguage</code>.</p><important>
    /// <p>You can only include one language dialect per language. For example, you cannot include <code>en-US</code> and <code>en-AU</code>.</p>
    /// </important>
    pub fn language_options(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.language_options = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages are present, do not include this parameter.</p>
    /// <p>Including language options can improve the accuracy of language identification.</p>
    /// <p>If you include <code>LanguageOptions</code>, you must also include <code>IdentifyLanguage</code>.</p><important>
    /// <p>You can only include one language dialect per language. For example, you cannot include <code>en-US</code> and <code>en-AU</code>.</p>
    /// </important>
    pub fn set_language_options(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.language_options = input;
        self
    }
    /// <p>Specify two or more language codes that represent the languages you think may be present in your media; including more than five is not recommended. If you're unsure what languages are present, do not include this parameter.</p>
    /// <p>Including language options can improve the accuracy of language identification.</p>
    /// <p>If you include <code>LanguageOptions</code>, you must also include <code>IdentifyLanguage</code>.</p><important>
    /// <p>You can only include one language dialect per language. For example, you cannot include <code>en-US</code> and <code>en-AU</code>.</p>
    /// </important>
    pub fn get_language_options(&self) -> &::std::option::Option<::std::string::String> {
        &self.language_options
    }
    /// <p>Specify a preferred language from the subset of languages codes you specified in <code>LanguageOptions</code>.</p>
    /// <p>You can only use this parameter if you include <code>IdentifyLanguage</code> and <code>LanguageOptions</code>.</p>
    pub fn preferred_language(mut self, input: crate::types::TranscribeLanguageCode) -> Self {
        self.preferred_language = ::std::option::Option::Some(input);
        self
    }
    /// <p>Specify a preferred language from the subset of languages codes you specified in <code>LanguageOptions</code>.</p>
    /// <p>You can only use this parameter if you include <code>IdentifyLanguage</code> and <code>LanguageOptions</code>.</p>
    pub fn set_preferred_language(mut self, input: ::std::option::Option<crate::types::TranscribeLanguageCode>) -> Self {
        self.preferred_language = input;
        self
    }
    /// <p>Specify a preferred language from the subset of languages codes you specified in <code>LanguageOptions</code>.</p>
    /// <p>You can only use this parameter if you include <code>IdentifyLanguage</code> and <code>LanguageOptions</code>.</p>
    pub fn get_preferred_language(&self) -> &::std::option::Option<crate::types::TranscribeLanguageCode> {
        &self.preferred_language
    }
    /// <p>Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you don't include <code>IdentifyLanguage</code> and want to use a custom vocabulary with your transcription, use the <code>VocabularyName</code> parameter instead.</p>
    pub fn vocabulary_names(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vocabulary_names = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you don't include <code>IdentifyLanguage</code> and want to use a custom vocabulary with your transcription, use the <code>VocabularyName</code> parameter instead.</p>
    pub fn set_vocabulary_names(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vocabulary_names = input;
        self
    }
    /// <p>Specify the names of the custom vocabularies that you want to use when processing your transcription. Note that vocabulary names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you don't include <code>IdentifyLanguage</code> and want to use a custom vocabulary with your transcription, use the <code>VocabularyName</code> parameter instead.</p>
    pub fn get_vocabulary_names(&self) -> &::std::option::Option<::std::string::String> {
        &self.vocabulary_names
    }
    /// <p>Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you're <i>not</i> including <code>IdentifyLanguage</code> and want to use a custom vocabulary filter with your transcription, use the <code>VocabularyFilterName</code> parameter instead.</p>
    pub fn vocabulary_filter_names(mut self, input: impl ::std::convert::Into<::std::string::String>) -> Self {
        self.vocabulary_filter_names = ::std::option::Option::Some(input.into());
        self
    }
    /// <p>Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you're <i>not</i> including <code>IdentifyLanguage</code> and want to use a custom vocabulary filter with your transcription, use the <code>VocabularyFilterName</code> parameter instead.</p>
    pub fn set_vocabulary_filter_names(mut self, input: ::std::option::Option<::std::string::String>) -> Self {
        self.vocabulary_filter_names = input;
        self
    }
    /// <p>Specify the names of the custom vocabulary filters that you want to use when processing your transcription. Note that vocabulary filter names are case sensitive.</p>
    /// <p>If you use Amazon Transcribe in multiple Regions, the vocabulary filter must be available in Amazon Transcribe in each Region.</p>
    /// <p>If you're <i>not</i> including <code>IdentifyLanguage</code> and want to use a custom vocabulary filter with your transcription, use the <code>VocabularyFilterName</code> parameter instead.</p>
    pub fn get_vocabulary_filter_names(&self) -> &::std::option::Option<::std::string::String> {
        &self.vocabulary_filter_names
    }
    /// Consumes the builder and constructs a [`EngineTranscribeSettings`](crate::types::EngineTranscribeSettings).
    pub fn build(self) -> crate::types::EngineTranscribeSettings {
        crate::types::EngineTranscribeSettings {
            language_code: self.language_code,
            vocabulary_filter_method: self.vocabulary_filter_method,
            vocabulary_filter_name: self.vocabulary_filter_name,
            vocabulary_name: self.vocabulary_name,
            region: self.region,
            enable_partial_results_stabilization: self.enable_partial_results_stabilization.unwrap_or_default(),
            partial_results_stability: self.partial_results_stability,
            content_identification_type: self.content_identification_type,
            content_redaction_type: self.content_redaction_type,
            pii_entity_types: self.pii_entity_types,
            language_model_name: self.language_model_name,
            identify_language: self.identify_language.unwrap_or_default(),
            language_options: self.language_options,
            preferred_language: self.preferred_language,
            vocabulary_names: self.vocabulary_names,
            vocabulary_filter_names: self.vocabulary_filter_names,
        }
    }
}
